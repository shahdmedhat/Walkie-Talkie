/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./demo/demo-1.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./demo/demo-1.ts":
/*!************************!*\
  !*** ./demo/demo-1.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

    "use strict";

    Object.defineProperty(exports, "__esModule", { value: true });
    // tslint:disable: no-console
    var web_1 = __webpack_require__(/*! ../src/platform/web */ "./src/platform/web/index.ts");
    var demo_utils_1 = __webpack_require__(/*! ./demo-utils */ "./demo/demo-utils.ts");
    var serverSpan = demo_utils_1.getSpan("server");
    var targetSpan = demo_utils_1.getSpan("target");
    var connectButton = demo_utils_1.getButton("connect");
    var callButton = demo_utils_1.getButton("call");
    var hangupButton = demo_utils_1.getButton("hangup");
    var disconnectButton = demo_utils_1.getButton("disconnect");
    var audioElement = demo_utils_1.getAudio("remoteAudio");
    var keypad = demo_utils_1.getButtons("keypad");
    var dtmfSpan = demo_utils_1.getSpan("dtmf");
    var holdCheckbox = demo_utils_1.getInput("hold");
    var muteCheckbox = demo_utils_1.getInput("mute");
    // WebSocket Server URL
    var webSocketServer = "wss://edge.sip.onsip.com";
    serverSpan.innerHTML = webSocketServer;
    // Destination URI
    var target = "sip:welcome@onsip.com";
    targetSpan.innerHTML = target;
    // Name for demo user
    var displayName = "SIP.js Demo";
    // SimpleUser delegate
    var simpleUserDelegate = {
        onCallCreated: function () {
            console.log("[" + displayName + "] Call created");
            callButton.disabled = true;
            hangupButton.disabled = false;
            keypadDisabled(true);
            holdCheckboxDisabled(true);
            muteCheckboxDisabled(true);
        },
        onCallAnswered: function () {
            console.log("[" + displayName + "] Call answered");
            keypadDisabled(false);
            holdCheckboxDisabled(false);
            muteCheckboxDisabled(false);
        },
        onCallHangup: function () {
            console.log("[" + displayName + "] Call hangup");
            callButton.disabled = false;
            hangupButton.disabled = true;
            keypadDisabled(true);
            holdCheckboxDisabled(true);
            muteCheckboxDisabled(true);
        },
        onCallHold: function (held) {
            console.log("[" + displayName + "] Call hold " + held);
            holdCheckbox.checked = held;
        }
    };
    // SimpleUser options
    var simpleUserOptions = {
        delegate: simpleUserDelegate,
        media: {
            remote: {
                audio: audioElement
            }
        },
        userAgentOptions: {
            displayName: displayName
        }
    };
    // SimpleUser construction
    var simpleUser = new web_1.SimpleUser(webSocketServer, simpleUserOptions);
    // Add click listener to connect button
    connectButton.addEventListener("click", function () {
        connectButton.disabled = true;
        disconnectButton.disabled = true;
        callButton.disabled = true;
        hangupButton.disabled = true;
        simpleUser.connect()
            .then(function () {
            connectButton.disabled = true;
            disconnectButton.disabled = false;
            callButton.disabled = false;
            hangupButton.disabled = true;
        })
            .catch(function (error) {
            connectButton.disabled = false;
            console.error("[" + simpleUser.id + "] failed to connect");
            console.error(error);
            alert("Failed to connect.\n" + error);
        });
    });
    // Add click listener to call button
    callButton.addEventListener("click", function () {
        callButton.disabled = true;
        hangupButton.disabled = true;
        simpleUser.call(target)
            .catch(function (error) {
            console.error("[" + simpleUser.id + "] failed to place call");
            console.error(error);
            alert("Failed to place call.\n" + error);
        });
    });
    // Add click listener to hangup button
    hangupButton.addEventListener("click", function () {
        callButton.disabled = true;
        hangupButton.disabled = true;
        simpleUser.hangup()
            .catch(function (error) {
            console.error("[" + simpleUser.id + "] failed to hangup call");
            console.error(error);
            alert("Failed to hangup call.\n" + error);
        });
    });
    // Add click listener to disconnect button
    disconnectButton.addEventListener("click", function () {
        connectButton.disabled = true;
        disconnectButton.disabled = true;
        callButton.disabled = true;
        hangupButton.disabled = true;
        simpleUser.disconnect()
            .then(function () {
            connectButton.disabled = false;
            disconnectButton.disabled = true;
            callButton.disabled = true;
            hangupButton.disabled = true;
        })
            .catch(function (error) {
            console.error("[" + simpleUser.id + "] failed to disconnect");
            console.error(error);
            alert("Failed to disconnect.\n" + error);
        });
    });
    // Add click listeners to keypad buttons
    keypad.forEach(function (button) {
        button.addEventListener("click", function () {
            var tone = button.textContent;
            if (tone) {
                simpleUser.sendDTMF(tone)
                    .then(function () {
                    dtmfSpan.innerHTML += tone;
                });
            }
        });
    });
    // Keypad helper function
    var keypadDisabled = function (disabled) {
        keypad.forEach(function (button) { return button.disabled = disabled; });
        dtmfSpan.innerHTML = "";
    };
    // Add change listener to hold checkbox
    holdCheckbox.addEventListener("change", function () {
        if (holdCheckbox.checked) {
            // Checkbox is checked..
            simpleUser.hold()
                .catch(function (error) {
                holdCheckbox.checked = false;
                console.error("[" + simpleUser.id + "] failed to hold call");
                console.error(error);
                alert("Failed to hold call.\n" + error);
            });
        }
        else {
            // Checkbox is not checked..
            simpleUser.unhold()
                .catch(function (error) {
                holdCheckbox.checked = true;
                console.error("[" + simpleUser.id + "] failed to unhold call");
                console.error(error);
                alert("Failed to unhold call.\n" + error);
            });
        }
    });
    // Hold helper function
    var holdCheckboxDisabled = function (disabled) {
        holdCheckbox.checked = false;
        holdCheckbox.disabled = disabled;
    };
    // Add change listener to mute checkbox
    muteCheckbox.addEventListener("change", function () {
        if (muteCheckbox.checked) {
            // Checkbox is checked..
            simpleUser.mute();
            if (!simpleUser.isMuted) {
                muteCheckbox.checked = false;
                console.error("[" + simpleUser.id + "] failed to mute call");
                alert("Failed to mute call.\n");
            }
        }
        else {
            // Checkbox is not checked..
            simpleUser.unmute();
            if (!simpleUser.isMuted) {
                muteCheckbox.checked = true;
                console.error("[" + simpleUser.id + "] failed to unmute call");
                alert("Failed to unmute call.\n");
            }
        }
    });
    // Mute helper function
    var muteCheckboxDisabled = function (disabled) {
        muteCheckbox.checked = false;
        muteCheckbox.disabled = disabled;
    };
    // Enable the connect button
    connectButton.disabled = false;
    
    
    /***/ }),
    
    /***/ "./demo/demo-utils.ts":
    /*!****************************!*\
      !*** ./demo/demo-utils.ts ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    function getAudio(id) {
        var el = document.getElementById(id);
        if (!(el instanceof HTMLAudioElement)) {
            throw new Error("Element \"" + id + "\" not found or not an audio element.");
        }
        return el;
    }
    exports.getAudio = getAudio;
    function getButton(id) {
        var el = document.getElementById(id);
        if (!(el instanceof HTMLButtonElement)) {
            throw new Error("Element \"" + id + "\" not found or not a button element.");
        }
        return el;
    }
    exports.getButton = getButton;
    function getButtons(id) {
        var els = document.getElementsByClassName(id);
        if (!els.length) {
            throw new Error("Elements \"" + id + "\" not found.");
        }
        var buttons = [];
        // tslint:disable-next-line:prefer-for-of
        for (var i = 0; i < els.length; i++) {
            var el = els[i];
            if (!(el instanceof HTMLButtonElement)) {
                throw new Error("Element " + i + " of \"" + id + "\" not a button element.");
            }
            buttons.push(el);
        }
        return buttons;
    }
    exports.getButtons = getButtons;
    function getInput(id) {
        var el = document.getElementById(id);
        if (!(el instanceof HTMLInputElement)) {
            throw new Error("Element \"" + id + "\" not found or not an input element.");
        }
        return el;
    }
    exports.getInput = getInput;
    function getSpan(id) {
        var el = document.getElementById(id);
        if (!(el instanceof HTMLSpanElement)) {
            throw new Error("Element \"" + id + "\" not found or not a span element.");
        }
        return el;
    }
    exports.getSpan = getSpan;
    function getVideo(id) {
        var el = document.getElementById(id);
        if (!(el instanceof HTMLVideoElement)) {
            throw new Error("Element \"" + id + "\" not found or not a video element.");
        }
        return el;
    }
    exports.getVideo = getVideo;
    
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/core.js":
    /*!****************************************!*\
      !*** ./node_modules/crypto-js/core.js ***!
      \****************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory();
        }
        else {}
    }(this, function () {
    
        /**
         * CryptoJS core components.
         */
        var CryptoJS = CryptoJS || (function (Math, undefined) {
            /*
             * Local polyfil of Object.create
             */
            var create = Object.create || (function () {
                function F() {};
    
                return function (obj) {
                    var subtype;
    
                    F.prototype = obj;
    
                    subtype = new F();
    
                    F.prototype = null;
    
                    return subtype;
                };
            }())
    
            /**
             * CryptoJS namespace.
             */
            var C = {};
    
            /**
             * Library namespace.
             */
            var C_lib = C.lib = {};
    
            /**
             * Base object for prototypal inheritance.
             */
            var Base = C_lib.Base = (function () {
    
    
                return {
                    /**
                     * Creates a new object that inherits from this object.
                     *
                     * @param {Object} overrides Properties to copy into the new object.
                     *
                     * @return {Object} The new object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var MyType = CryptoJS.lib.Base.extend({
                     *         field: 'value',
                     *
                     *         method: function () {
                     *         }
                     *     });
                     */
                    extend: function (overrides) {
                        // Spawn
                        var subtype = create(this);
    
                        // Augment
                        if (overrides) {
                            subtype.mixIn(overrides);
                        }
    
                        // Create default initializer
                        if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                            subtype.init = function () {
                                subtype.$super.init.apply(this, arguments);
                            };
                        }
    
                        // Initializer's prototype is the subtype object
                        subtype.init.prototype = subtype;
    
                        // Reference supertype
                        subtype.$super = this;
    
                        return subtype;
                    },
    
                    /**
                     * Extends this object and runs the init method.
                     * Arguments to create() will be passed to init().
                     *
                     * @return {Object} The new object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var instance = MyType.create();
                     */
                    create: function () {
                        var instance = this.extend();
                        instance.init.apply(instance, arguments);
    
                        return instance;
                    },
    
                    /**
                     * Initializes a newly created object.
                     * Override this method to add some logic when your objects are created.
                     *
                     * @example
                     *
                     *     var MyType = CryptoJS.lib.Base.extend({
                     *         init: function () {
                     *             // ...
                     *         }
                     *     });
                     */
                    init: function () {
                    },
    
                    /**
                     * Copies properties into this object.
                     *
                     * @param {Object} properties The properties to mix in.
                     *
                     * @example
                     *
                     *     MyType.mixIn({
                     *         field: 'value'
                     *     });
                     */
                    mixIn: function (properties) {
                        for (var propertyName in properties) {
                            if (properties.hasOwnProperty(propertyName)) {
                                this[propertyName] = properties[propertyName];
                            }
                        }
    
                        // IE won't copy toString using the loop above
                        if (properties.hasOwnProperty('toString')) {
                            this.toString = properties.toString;
                        }
                    },
    
                    /**
                     * Creates a copy of this object.
                     *
                     * @return {Object} The clone.
                     *
                     * @example
                     *
                     *     var clone = instance.clone();
                     */
                    clone: function () {
                        return this.init.prototype.extend(this);
                    }
                };
            }());
    
            /**
             * An array of 32-bit words.
             *
             * @property {Array} words The array of 32-bit words.
             * @property {number} sigBytes The number of significant bytes in this word array.
             */
            var WordArray = C_lib.WordArray = Base.extend({
                /**
                 * Initializes a newly created word array.
                 *
                 * @param {Array} words (Optional) An array of 32-bit words.
                 * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.create();
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
                 */
                init: function (words, sigBytes) {
                    words = this.words = words || [];
    
                    if (sigBytes != undefined) {
                        this.sigBytes = sigBytes;
                    } else {
                        this.sigBytes = words.length * 4;
                    }
                },
    
                /**
                 * Converts this word array to a string.
                 *
                 * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
                 *
                 * @return {string} The stringified word array.
                 *
                 * @example
                 *
                 *     var string = wordArray + '';
                 *     var string = wordArray.toString();
                 *     var string = wordArray.toString(CryptoJS.enc.Utf8);
                 */
                toString: function (encoder) {
                    return (encoder || Hex).stringify(this);
                },
    
                /**
                 * Concatenates a word array to this word array.
                 *
                 * @param {WordArray} wordArray The word array to append.
                 *
                 * @return {WordArray} This word array.
                 *
                 * @example
                 *
                 *     wordArray1.concat(wordArray2);
                 */
                concat: function (wordArray) {
                    // Shortcuts
                    var thisWords = this.words;
                    var thatWords = wordArray.words;
                    var thisSigBytes = this.sigBytes;
                    var thatSigBytes = wordArray.sigBytes;
    
                    // Clamp excess bits
                    this.clamp();
    
                    // Concat
                    if (thisSigBytes % 4) {
                        // Copy one byte at a time
                        for (var i = 0; i < thatSigBytes; i++) {
                            var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                            thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                        }
                    } else {
                        // Copy one word at a time
                        for (var i = 0; i < thatSigBytes; i += 4) {
                            thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                        }
                    }
                    this.sigBytes += thatSigBytes;
    
                    // Chainable
                    return this;
                },
    
                /**
                 * Removes insignificant bits.
                 *
                 * @example
                 *
                 *     wordArray.clamp();
                 */
                clamp: function () {
                    // Shortcuts
                    var words = this.words;
                    var sigBytes = this.sigBytes;
    
                    // Clamp
                    words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
                    words.length = Math.ceil(sigBytes / 4);
                },
    
                /**
                 * Creates a copy of this word array.
                 *
                 * @return {WordArray} The clone.
                 *
                 * @example
                 *
                 *     var clone = wordArray.clone();
                 */
                clone: function () {
                    var clone = Base.clone.call(this);
                    clone.words = this.words.slice(0);
    
                    return clone;
                },
    
                /**
                 * Creates a word array filled with random bytes.
                 *
                 * @param {number} nBytes The number of random bytes to generate.
                 *
                 * @return {WordArray} The random word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.random(16);
                 */
                random: function (nBytes) {
                    var words = [];
    
                    var r = (function (m_w) {
                        var m_w = m_w;
                        var m_z = 0x3ade68b1;
                        var mask = 0xffffffff;
    
                        return function () {
                            m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
                            m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
                            var result = ((m_z << 0x10) + m_w) & mask;
                            result /= 0x100000000;
                            result += 0.5;
                            return result * (Math.random() > .5 ? 1 : -1);
                        }
                    });
    
                    for (var i = 0, rcache; i < nBytes; i += 4) {
                        var _r = r((rcache || Math.random()) * 0x100000000);
    
                        rcache = _r() * 0x3ade67b7;
                        words.push((_r() * 0x100000000) | 0);
                    }
    
                    return new WordArray.init(words, nBytes);
                }
            });
    
            /**
             * Encoder namespace.
             */
            var C_enc = C.enc = {};
    
            /**
             * Hex encoding strategy.
             */
            var Hex = C_enc.Hex = {
                /**
                 * Converts a word array to a hex string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The hex string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
    
                    // Convert
                    var hexChars = [];
                    for (var i = 0; i < sigBytes; i++) {
                        var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                        hexChars.push((bite >>> 4).toString(16));
                        hexChars.push((bite & 0x0f).toString(16));
                    }
    
                    return hexChars.join('');
                },
    
                /**
                 * Converts a hex string to a word array.
                 *
                 * @param {string} hexStr The hex string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
                 */
                parse: function (hexStr) {
                    // Shortcut
                    var hexStrLength = hexStr.length;
    
                    // Convert
                    var words = [];
                    for (var i = 0; i < hexStrLength; i += 2) {
                        words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
                    }
    
                    return new WordArray.init(words, hexStrLength / 2);
                }
            };
    
            /**
             * Latin1 encoding strategy.
             */
            var Latin1 = C_enc.Latin1 = {
                /**
                 * Converts a word array to a Latin1 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The Latin1 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;
    
                    // Convert
                    var latin1Chars = [];
                    for (var i = 0; i < sigBytes; i++) {
                        var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                        latin1Chars.push(String.fromCharCode(bite));
                    }
    
                    return latin1Chars.join('');
                },
    
                /**
                 * Converts a Latin1 string to a word array.
                 *
                 * @param {string} latin1Str The Latin1 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
                 */
                parse: function (latin1Str) {
                    // Shortcut
                    var latin1StrLength = latin1Str.length;
    
                    // Convert
                    var words = [];
                    for (var i = 0; i < latin1StrLength; i++) {
                        words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
                    }
    
                    return new WordArray.init(words, latin1StrLength);
                }
            };
    
            /**
             * UTF-8 encoding strategy.
             */
            var Utf8 = C_enc.Utf8 = {
                /**
                 * Converts a word array to a UTF-8 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The UTF-8 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    try {
                        return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                    } catch (e) {
                        throw new Error('Malformed UTF-8 data');
                    }
                },
    
                /**
                 * Converts a UTF-8 string to a word array.
                 *
                 * @param {string} utf8Str The UTF-8 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
                 */
                parse: function (utf8Str) {
                    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                }
            };
    
            /**
             * Abstract buffered block algorithm template.
             *
             * The property blockSize must be implemented in a concrete subtype.
             *
             * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
             */
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                /**
                 * Resets this block algorithm's data buffer to its initial state.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm.reset();
                 */
                reset: function () {
                    // Initial values
                    this._data = new WordArray.init();
                    this._nDataBytes = 0;
                },
    
                /**
                 * Adds new data to this block algorithm's buffer.
                 *
                 * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm._append('data');
                 *     bufferedBlockAlgorithm._append(wordArray);
                 */
                _append: function (data) {
                    // Convert string to WordArray, else assume WordArray already
                    if (typeof data == 'string') {
                        data = Utf8.parse(data);
                    }
    
                    // Append
                    this._data.concat(data);
                    this._nDataBytes += data.sigBytes;
                },
    
                /**
                 * Processes available data blocks.
                 *
                 * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
                 *
                 * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
                 *
                 * @return {WordArray} The processed data.
                 *
                 * @example
                 *
                 *     var processedData = bufferedBlockAlgorithm._process();
                 *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
                 */
                _process: function (doFlush) {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
                    var dataSigBytes = data.sigBytes;
                    var blockSize = this.blockSize;
                    var blockSizeBytes = blockSize * 4;
    
                    // Count blocks ready
                    var nBlocksReady = dataSigBytes / blockSizeBytes;
                    if (doFlush) {
                        // Round up to include partial blocks
                        nBlocksReady = Math.ceil(nBlocksReady);
                    } else {
                        // Round down to include only full blocks,
                        // less the number of blocks that must remain in the buffer
                        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                    }
    
                    // Count words ready
                    var nWordsReady = nBlocksReady * blockSize;
    
                    // Count bytes ready
                    var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
    
                    // Process blocks
                    if (nWordsReady) {
                        for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                            // Perform concrete-algorithm logic
                            this._doProcessBlock(dataWords, offset);
                        }
    
                        // Remove processed words
                        var processedWords = dataWords.splice(0, nWordsReady);
                        data.sigBytes -= nBytesReady;
                    }
    
                    // Return processed words
                    return new WordArray.init(processedWords, nBytesReady);
                },
    
                /**
                 * Creates a copy of this object.
                 *
                 * @return {Object} The clone.
                 *
                 * @example
                 *
                 *     var clone = bufferedBlockAlgorithm.clone();
                 */
                clone: function () {
                    var clone = Base.clone.call(this);
                    clone._data = this._data.clone();
    
                    return clone;
                },
    
                _minBufferSize: 0
            });
    
            /**
             * Abstract hasher template.
             *
             * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
             */
            var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
                /**
                 * Configuration options.
                 */
                cfg: Base.extend(),
    
                /**
                 * Initializes a newly created hasher.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
                 *
                 * @example
                 *
                 *     var hasher = CryptoJS.algo.SHA256.create();
                 */
                init: function (cfg) {
                    // Apply config defaults
                    this.cfg = this.cfg.extend(cfg);
    
                    // Set initial values
                    this.reset();
                },
    
                /**
                 * Resets this hasher to its initial state.
                 *
                 * @example
                 *
                 *     hasher.reset();
                 */
                reset: function () {
                    // Reset data buffer
                    BufferedBlockAlgorithm.reset.call(this);
    
                    // Perform concrete-hasher logic
                    this._doReset();
                },
    
                /**
                 * Updates this hasher with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {Hasher} This hasher.
                 *
                 * @example
                 *
                 *     hasher.update('message');
                 *     hasher.update(wordArray);
                 */
                update: function (messageUpdate) {
                    // Append
                    this._append(messageUpdate);
    
                    // Update the hash
                    this._process();
    
                    // Chainable
                    return this;
                },
    
                /**
                 * Finalizes the hash computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The hash.
                 *
                 * @example
                 *
                 *     var hash = hasher.finalize();
                 *     var hash = hasher.finalize('message');
                 *     var hash = hasher.finalize(wordArray);
                 */
                finalize: function (messageUpdate) {
                    // Final message update
                    if (messageUpdate) {
                        this._append(messageUpdate);
                    }
    
                    // Perform concrete-hasher logic
                    var hash = this._doFinalize();
    
                    return hash;
                },
    
                blockSize: 512/32,
    
                /**
                 * Creates a shortcut function to a hasher's object interface.
                 *
                 * @param {Hasher} hasher The hasher to create a helper for.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
                 */
                _createHelper: function (hasher) {
                    return function (message, cfg) {
                        return new hasher.init(cfg).finalize(message);
                    };
                },
    
                /**
                 * Creates a shortcut function to the HMAC's object interface.
                 *
                 * @param {Hasher} hasher The hasher to use in this HMAC helper.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
                 */
                _createHmacHelper: function (hasher) {
                    return function (message, key) {
                        return new C_algo.HMAC.init(hasher, key).finalize(message);
                    };
                }
            });
    
            /**
             * Algorithm namespace.
             */
            var C_algo = C.algo = {};
    
            return C;
        }(Math));
    
    
        return CryptoJS;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/crypto-js/md5.js":
    /*!***************************************!*\
      !*** ./node_modules/crypto-js/md5.js ***!
      \***************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    ;(function (root, factory) {
        if (true) {
            // CommonJS
            module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
        }
        else {}
    }(this, function (CryptoJS) {
    
        (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;
    
            // Constants table
            var T = [];
    
            // Compute constants
            (function () {
                for (var i = 0; i < 64; i++) {
                    T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
                }
            }());
    
            /**
             * MD5 hash algorithm.
             */
            var MD5 = C_algo.MD5 = Hasher.extend({
                _doReset: function () {
                    this._hash = new WordArray.init([
                        0x67452301, 0xefcdab89,
                        0x98badcfe, 0x10325476
                    ]);
                },
    
                _doProcessBlock: function (M, offset) {
                    // Swap endian
                    for (var i = 0; i < 16; i++) {
                        // Shortcuts
                        var offset_i = offset + i;
                        var M_offset_i = M[offset_i];
    
                        M[offset_i] = (
                            (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                            (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                        );
                    }
    
                    // Shortcuts
                    var H = this._hash.words;
    
                    var M_offset_0  = M[offset + 0];
                    var M_offset_1  = M[offset + 1];
                    var M_offset_2  = M[offset + 2];
                    var M_offset_3  = M[offset + 3];
                    var M_offset_4  = M[offset + 4];
                    var M_offset_5  = M[offset + 5];
                    var M_offset_6  = M[offset + 6];
                    var M_offset_7  = M[offset + 7];
                    var M_offset_8  = M[offset + 8];
                    var M_offset_9  = M[offset + 9];
                    var M_offset_10 = M[offset + 10];
                    var M_offset_11 = M[offset + 11];
                    var M_offset_12 = M[offset + 12];
                    var M_offset_13 = M[offset + 13];
                    var M_offset_14 = M[offset + 14];
                    var M_offset_15 = M[offset + 15];
    
                    // Working varialbes
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
    
                    // Computation
                    a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
                    d = FF(d, a, b, c, M_offset_1,  12, T[1]);
                    c = FF(c, d, a, b, M_offset_2,  17, T[2]);
                    b = FF(b, c, d, a, M_offset_3,  22, T[3]);
                    a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
                    d = FF(d, a, b, c, M_offset_5,  12, T[5]);
                    c = FF(c, d, a, b, M_offset_6,  17, T[6]);
                    b = FF(b, c, d, a, M_offset_7,  22, T[7]);
                    a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
                    d = FF(d, a, b, c, M_offset_9,  12, T[9]);
                    c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                    b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                    a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
                    d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                    c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                    b = FF(b, c, d, a, M_offset_15, 22, T[15]);
    
                    a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
                    d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
                    c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                    b = GG(b, c, d, a, M_offset_0,  20, T[19]);
                    a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
                    d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
                    c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                    b = GG(b, c, d, a, M_offset_4,  20, T[23]);
                    a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
                    d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
                    c = GG(c, d, a, b, M_offset_3,  14, T[26]);
                    b = GG(b, c, d, a, M_offset_8,  20, T[27]);
                    a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
                    d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
                    c = GG(c, d, a, b, M_offset_7,  14, T[30]);
                    b = GG(b, c, d, a, M_offset_12, 20, T[31]);
    
                    a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
                    d = HH(d, a, b, c, M_offset_8,  11, T[33]);
                    c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                    b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                    a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
                    d = HH(d, a, b, c, M_offset_4,  11, T[37]);
                    c = HH(c, d, a, b, M_offset_7,  16, T[38]);
                    b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                    a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
                    d = HH(d, a, b, c, M_offset_0,  11, T[41]);
                    c = HH(c, d, a, b, M_offset_3,  16, T[42]);
                    b = HH(b, c, d, a, M_offset_6,  23, T[43]);
                    a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
                    d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                    c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                    b = HH(b, c, d, a, M_offset_2,  23, T[47]);
    
                    a = II(a, b, c, d, M_offset_0,  6,  T[48]);
                    d = II(d, a, b, c, M_offset_7,  10, T[49]);
                    c = II(c, d, a, b, M_offset_14, 15, T[50]);
                    b = II(b, c, d, a, M_offset_5,  21, T[51]);
                    a = II(a, b, c, d, M_offset_12, 6,  T[52]);
                    d = II(d, a, b, c, M_offset_3,  10, T[53]);
                    c = II(c, d, a, b, M_offset_10, 15, T[54]);
                    b = II(b, c, d, a, M_offset_1,  21, T[55]);
                    a = II(a, b, c, d, M_offset_8,  6,  T[56]);
                    d = II(d, a, b, c, M_offset_15, 10, T[57]);
                    c = II(c, d, a, b, M_offset_6,  15, T[58]);
                    b = II(b, c, d, a, M_offset_13, 21, T[59]);
                    a = II(a, b, c, d, M_offset_4,  6,  T[60]);
                    d = II(d, a, b, c, M_offset_11, 10, T[61]);
                    c = II(c, d, a, b, M_offset_2,  15, T[62]);
                    b = II(b, c, d, a, M_offset_9,  21, T[63]);
    
                    // Intermediate hash value
                    H[0] = (H[0] + a) | 0;
                    H[1] = (H[1] + b) | 0;
                    H[2] = (H[2] + c) | 0;
                    H[3] = (H[3] + d) | 0;
                },
    
                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
    
                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;
    
                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
    
                    var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
                    var nBitsTotalL = nBitsTotal;
                    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                        (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                        (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
                    );
                    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                        (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                        (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
                    );
    
                    data.sigBytes = (dataWords.length + 1) * 4;
    
                    // Hash final blocks
                    this._process();
    
                    // Shortcuts
                    var hash = this._hash;
                    var H = hash.words;
    
                    // Swap endian
                    for (var i = 0; i < 4; i++) {
                        // Shortcut
                        var H_i = H[i];
    
                        H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                               (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
                    }
    
                    // Return final computed hash
                    return hash;
                },
    
                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();
    
                    return clone;
                }
            });
    
            function FF(a, b, c, d, x, s, t) {
                var n = a + ((b & c) | (~b & d)) + x + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
    
            function GG(a, b, c, d, x, s, t) {
                var n = a + ((b & d) | (c & ~d)) + x + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
    
            function HH(a, b, c, d, x, s, t) {
                var n = a + (b ^ c ^ d) + x + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
    
            function II(a, b, c, d, x, s, t) {
                var n = a + (c ^ (b | ~d)) + x + t;
                return ((n << s) | (n >>> (32 - s))) + b;
            }
    
            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.MD5('message');
             *     var hash = CryptoJS.MD5(wordArray);
             */
            C.MD5 = Hasher._createHelper(MD5);
    
            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacMD5(message, key);
             */
            C.HmacMD5 = Hasher._createHmacHelper(MD5);
        }(Math));
    
    
        return CryptoJS.MD5;
    
    }));
    
    /***/ }),
    
    /***/ "./node_modules/events/events.js":
    /*!***************************************!*\
      !*** ./node_modules/events/events.js ***!
      \***************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    
    var R = typeof Reflect === 'object' ? Reflect : null
    var ReflectApply = R && typeof R.apply === 'function'
      ? R.apply
      : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      }
    
    var ReflectOwnKeys
    if (R && typeof R.ownKeys === 'function') {
      ReflectOwnKeys = R.ownKeys
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target)
          .concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    
    var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
      return value !== value;
    }
    
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    
    // Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;
    
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = undefined;
    
    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    var defaultMaxListeners = 10;
    
    Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        }
        defaultMaxListeners = arg;
      }
    });
    
    EventEmitter.init = function() {
    
      if (this._events === undefined ||
          this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }
    
      this._maxListeners = this._maxListeners || undefined;
    };
    
    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
      }
      this._maxListeners = n;
      return this;
    };
    
    function $getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = (type === 'error');
    
      var events = this._events;
      if (events !== undefined)
        doError = (doError && events.error === undefined);
      else if (!doError)
        return false;
    
      // If there is no 'error' event listener then throw.
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          // Note: The comments on the `throw` lines are intentional, they show
          // up in Node's output if this results in an unhandled exception.
          throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
      }
    
      var handler = events[type];
    
      if (handler === undefined)
        return false;
    
      if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
    
      return true;
    };
    
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
    
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    
      events = target._events;
      if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
          target.emit('newListener', type,
                      listener.listener ? listener.listener : listener);
    
          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }
    
      if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] =
            prepend ? [listener, existing] : [existing, listener];
          // If we've already got an array, just append.
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
    
        // Check for listener leak
        m = $getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          // No error code for this since it is a Warning
          // eslint-disable-next-line no-restricted-syntax
          var w = new Error('Possible EventEmitter memory leak detected. ' +
                              existing.length + ' ' + String(type) + ' listeners ' +
                              'added. Use emitter.setMaxListeners() to ' +
                              'increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
    
      return target;
    }
    
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    
    EventEmitter.prototype.prependListener =
        function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };
    
    function onceWrapper() {
      var args = [];
      for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        ReflectApply(this.listener, this.target, args);
      }
    }
    
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    
    EventEmitter.prototype.prependOnceListener =
        function prependOnceListener(type, listener) {
          if (typeof listener !== 'function') {
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
          }
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };
    
    // Emits a 'removeListener' event if and only if the listener was removed.
    EventEmitter.prototype.removeListener =
        function removeListener(type, listener) {
          var list, events, position, i, originalListener;
    
          if (typeof listener !== 'function') {
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
          }
    
          events = this._events;
          if (events === undefined)
            return this;
    
          list = events[type];
          if (list === undefined)
            return this;
    
          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = Object.create(null);
            else {
              delete events[type];
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener);
            }
          } else if (typeof list !== 'function') {
            position = -1;
    
            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }
    
            if (position < 0)
              return this;
    
            if (position === 0)
              list.shift();
            else {
              spliceOne(list, position);
            }
    
            if (list.length === 1)
              events[type] = list[0];
    
            if (events.removeListener !== undefined)
              this.emit('removeListener', type, originalListener || listener);
          }
    
          return this;
        };
    
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    
    EventEmitter.prototype.removeAllListeners =
        function removeAllListeners(type) {
          var listeners, events, i;
    
          events = this._events;
          if (events === undefined)
            return this;
    
          // not listening for removeListener, no need to emit
          if (events.removeListener === undefined) {
            if (arguments.length === 0) {
              this._events = Object.create(null);
              this._eventsCount = 0;
            } else if (events[type] !== undefined) {
              if (--this._eventsCount === 0)
                this._events = Object.create(null);
              else
                delete events[type];
            }
            return this;
          }
    
          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = Object.create(null);
            this._eventsCount = 0;
            return this;
          }
    
          listeners = events[type];
    
          if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
          } else if (listeners !== undefined) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }
    
          return this;
        };
    
    function _listeners(target, type, unwrap) {
      var events = target._events;
    
      if (events === undefined)
        return [];
    
      var evlistener = events[type];
      if (evlistener === undefined)
        return [];
    
      if (typeof evlistener === 'function')
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    
      return unwrap ?
        unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
    
      if (events !== undefined) {
        var evlistener = events[type];
    
        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener !== undefined) {
          return evlistener.length;
        }
      }
    
      return 0;
    }
    
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/tslib/tslib.es6.js":
    /*!*****************************************!*\
      !*** ./node_modules/tslib/tslib.es6.js ***!
      \*****************************************/
    /*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
    /***/ (function(module, __webpack_exports__, __webpack_require__) {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    
    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        }
        return __assign.apply(this, arguments);
    }
    
    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }
    
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }
    
    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    
    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }
    
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };
    
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }
    
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    
    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }
    
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };
    
    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }
    
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    
    
    /***/ }),
    
    /***/ "./src/api/byer.ts":
    /*!*************************!*\
      !*** ./src/api/byer.ts ***!
      \*************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var invitation_1 = __webpack_require__(/*! ./invitation */ "./src/api/invitation.ts");
    var inviter_1 = __webpack_require__(/*! ./inviter */ "./src/api/inviter.ts");
    var session_state_1 = __webpack_require__(/*! ./session-state */ "./src/api/session-state.ts");
    /**
     * A byer ends a {@link Session} (outgoing BYE).
     * @remarks
     * Sends an outgoing in dialog BYE request.
     * @public
     */
    var Byer = /** @class */ (function () {
        /**
         * Constructs a new instance of the `Byer` class.
         * @param session - The session the BYE will be sent from. See {@link Session} for details.
         * @param options - An options bucket. See {@link ByerOptions} for details.
         */
        function Byer(session, options) {
            this.logger = session.userAgent.getLogger("sip.Byer");
            this._session = session;
        }
        Object.defineProperty(Byer.prototype, "session", {
            /** The byer session. */
            get: function () {
                return this._session;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sends the BYE request.
         * @param options - {@link ByerByeOptions} options bucket.
         */
        Byer.prototype.bye = function (options) {
            if (options === void 0) { options = {}; }
            var message = "Byer.bye() may only be called if established session.";
            switch (this.session.state) {
                case session_state_1.SessionState.Initial:
                    if (this.session instanceof inviter_1.Inviter) {
                        message += " However Inviter.invite() has not yet been called.";
                        message += " Perhaps you should have called Inviter.cancel()?";
                    }
                    else if (this.session instanceof invitation_1.Invitation) {
                        message += " However Invitation.accept() has not yet been called.";
                        message += " Perhaps you should have called Invitation.reject()?";
                    }
                    break;
                case session_state_1.SessionState.Establishing:
                    if (this.session instanceof inviter_1.Inviter) {
                        message += " However a dialog does not yet exist.";
                        message += " Perhaps you should have called Inviter.cancel()?";
                    }
                    else if (this.session instanceof invitation_1.Invitation) {
                        message += " However Invitation.accept() has not yet been called (or not yet resolved).";
                        message += " Perhaps you should have called Invitation.reject()?";
                    }
                    break;
                case session_state_1.SessionState.Established:
                    return this.session._bye(options.requestDelegate, options.requestOptions);
                case session_state_1.SessionState.Terminating:
                    message += " However this session is already terminating.";
                    if (this.session instanceof inviter_1.Inviter) {
                        message += " Perhaps you have already called Inviter.cancel()?";
                    }
                    else if (this.session instanceof invitation_1.Invitation) {
                        message += " Perhaps you have already called Byer.bye()?";
                    }
                    break;
                case session_state_1.SessionState.Terminated:
                    message += " However this session is already terminated.";
                    break;
                default:
                    throw new Error("Unknown state");
            }
            this.logger.error(message);
            return Promise.reject(new Error("Invalid session state " + this.session.state));
        };
        return Byer;
    }());
    exports.Byer = Byer;
    
    
    /***/ }),
    
    /***/ "./src/api/emitter.ts":
    /*!****************************!*\
      !*** ./src/api/emitter.ts ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Creates an {@link Emitter}.
     * @param eventEmitter - An event emitter.
     * @param eventName - Event name.
     * @internal
     */
    function _makeEmitter(eventEmitter, eventName) {
        if (eventName === void 0) { eventName = "event"; }
        return {
            addListener: function (listener, options) {
                if (options === void 0) { options = {}; }
                if (options.once) {
                    eventEmitter.once(eventName, listener);
                }
                else {
                    eventEmitter.addListener(eventName, listener);
                }
            },
            removeListener: function (listener) {
                eventEmitter.removeListener(eventName, listener);
            },
            on: function (listener) {
                eventEmitter.on(eventName, listener);
            },
            off: function (listener) {
                eventEmitter.removeListener(eventName, listener);
            },
            once: function (listener) {
                eventEmitter.once(eventName, listener);
            }
        };
    }
    exports._makeEmitter = _makeEmitter;
    
    
    /***/ }),
    
    /***/ "./src/api/exceptions/content-type-unsupported.ts":
    /*!********************************************************!*\
      !*** ./src/api/exceptions/content-type-unsupported.ts ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var core_1 = __webpack_require__(/*! ../../core */ "./src/core/index.ts");
    /**
     * An exception indicating an unsupported content type prevented execution.
     * @public
     */
    var ContentTypeUnsupportedError = /** @class */ (function (_super) {
        tslib_1.__extends(ContentTypeUnsupportedError, _super);
        function ContentTypeUnsupportedError(message) {
            return _super.call(this, message ? message : "Unsupported content type.") || this;
        }
        return ContentTypeUnsupportedError;
    }(core_1.Exception));
    exports.ContentTypeUnsupportedError = ContentTypeUnsupportedError;
    
    
    /***/ }),
    
    /***/ "./src/api/exceptions/index.ts":
    /*!*************************************!*\
      !*** ./src/api/exceptions/index.ts ***!
      \*************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./content-type-unsupported */ "./src/api/exceptions/content-type-unsupported.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./request-pending */ "./src/api/exceptions/request-pending.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./session-description-handler */ "./src/api/exceptions/session-description-handler.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./session-terminated */ "./src/api/exceptions/session-terminated.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./state-transition */ "./src/api/exceptions/state-transition.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/api/exceptions/request-pending.ts":
    /*!***********************************************!*\
      !*** ./src/api/exceptions/request-pending.ts ***!
      \***********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var core_1 = __webpack_require__(/*! ../../core */ "./src/core/index.ts");
    /**
     * An exception indicating an outstanding prior request prevented execution.
     * @public
     */
    var RequestPendingError = /** @class */ (function (_super) {
        tslib_1.__extends(RequestPendingError, _super);
        /** @internal */
        function RequestPendingError(message) {
            return _super.call(this, message ? message : "Request pending.") || this;
        }
        return RequestPendingError;
    }(core_1.Exception));
    exports.RequestPendingError = RequestPendingError;
    
    
    /***/ }),
    
    /***/ "./src/api/exceptions/session-description-handler.ts":
    /*!***********************************************************!*\
      !*** ./src/api/exceptions/session-description-handler.ts ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var core_1 = __webpack_require__(/*! ../../core */ "./src/core/index.ts");
    /**
     * An exception indicating a session description handler error occured.
     * @public
     */
    var SessionDescriptionHandlerError = /** @class */ (function (_super) {
        tslib_1.__extends(SessionDescriptionHandlerError, _super);
        function SessionDescriptionHandlerError(message) {
            return _super.call(this, message ? message : "Unspecified session description handler error.") || this;
        }
        return SessionDescriptionHandlerError;
    }(core_1.Exception));
    exports.SessionDescriptionHandlerError = SessionDescriptionHandlerError;
    
    
    /***/ }),
    
    /***/ "./src/api/exceptions/session-terminated.ts":
    /*!**************************************************!*\
      !*** ./src/api/exceptions/session-terminated.ts ***!
      \**************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var core_1 = __webpack_require__(/*! ../../core */ "./src/core/index.ts");
    /**
     * An exception indicating the session terminated before the action completed.
     * @public
     */
    var SessionTerminatedError = /** @class */ (function (_super) {
        tslib_1.__extends(SessionTerminatedError, _super);
        function SessionTerminatedError() {
            return _super.call(this, "The session has terminated.") || this;
        }
        return SessionTerminatedError;
    }(core_1.Exception));
    exports.SessionTerminatedError = SessionTerminatedError;
    
    
    /***/ }),
    
    /***/ "./src/api/exceptions/state-transition.ts":
    /*!************************************************!*\
      !*** ./src/api/exceptions/state-transition.ts ***!
      \************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var core_1 = __webpack_require__(/*! ../../core */ "./src/core/index.ts");
    /**
     * An exception indicating an invalid state transition error occured.
     * @public
     */
    var StateTransitionError = /** @class */ (function (_super) {
        tslib_1.__extends(StateTransitionError, _super);
        function StateTransitionError(message) {
            return _super.call(this, message ? message : "An error occurred during state transition.") || this;
        }
        return StateTransitionError;
    }(core_1.Exception));
    exports.StateTransitionError = StateTransitionError;
    
    
    /***/ }),
    
    /***/ "./src/api/index.ts":
    /*!**************************!*\
      !*** ./src/api/index.ts ***!
      \**************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    /**
     * A simple yet powerful API which takes care of SIP signaling and WebRTC media sessions for you.
     * @packageDocumentation
     */
    tslib_1.__exportStar(__webpack_require__(/*! ./exceptions */ "./src/api/exceptions/index.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./byer */ "./src/api/byer.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./emitter */ "./src/api/emitter.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./info */ "./src/api/info.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./infoer */ "./src/api/infoer.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./invitation */ "./src/api/invitation.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./inviter */ "./src/api/inviter.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./message */ "./src/api/message.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./messager */ "./src/api/messager.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./notification */ "./src/api/notification.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./publisher-state */ "./src/api/publisher-state.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./publisher */ "./src/api/publisher.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./referral */ "./src/api/referral.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./referrer */ "./src/api/referrer.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./registerer-state */ "./src/api/registerer-state.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./registerer */ "./src/api/registerer.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./session-state */ "./src/api/session-state.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./session */ "./src/api/session.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./subscriber */ "./src/api/subscriber.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./subscription-state */ "./src/api/subscription-state.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./subscription */ "./src/api/subscription.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./transport-state */ "./src/api/transport-state.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-options */ "./src/api/user-agent-options.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-state */ "./src/api/user-agent-state.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./user-agent */ "./src/api/user-agent.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/api/info.ts":
    /*!*************************!*\
      !*** ./src/api/info.ts ***!
      \*************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An exchange of information (incoming INFO).
     * @public
     */
    var Info = /** @class */ (function () {
        /** @internal */
        function Info(incomingInfoRequest) {
            this.incomingInfoRequest = incomingInfoRequest;
        }
        Object.defineProperty(Info.prototype, "request", {
            /** Incoming MESSAGE request message. */
            get: function () {
                return this.incomingInfoRequest.message;
            },
            enumerable: true,
            configurable: true
        });
        /** Accept the request. */
        Info.prototype.accept = function (options) {
            this.incomingInfoRequest.accept(options);
            return Promise.resolve();
        };
        /** Reject the request. */
        Info.prototype.reject = function (options) {
            this.incomingInfoRequest.reject(options);
            return Promise.resolve();
        };
        return Info;
    }());
    exports.Info = Info;
    
    
    /***/ }),
    
    /***/ "./src/api/infoer.ts":
    /*!***************************!*\
      !*** ./src/api/infoer.ts ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var session_state_1 = __webpack_require__(/*! ./session-state */ "./src/api/session-state.ts");
    /**
     * An Infoer sends {@link Info} (outgoing INFO).
     * @remarks
     * Sends an outgoing in dialog INFO request.
     * @public
     */
    var Infoer = /** @class */ (function () {
        /**
         * Constructs a new instance of the `Infoer` class.
         * @param session - The session the INFO will be sent from. See {@link Session} for details.
         * @param options - An options bucket.
         */
        function Infoer(session, options) {
            this.logger = session.userAgent.getLogger("sip.Infoer");
            this._session = session;
        }
        Object.defineProperty(Infoer.prototype, "session", {
            /** The Infoer session. */
            get: function () {
                return this._session;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sends the INFO request.
         * @param options - {@link InfoerInfoOptions} options bucket.
         */
        Infoer.prototype.info = function (options) {
            if (options === void 0) { options = {}; }
            // guard session state
            if (this.session.state !== session_state_1.SessionState.Established) {
                var message = "Infoer.info() may only be called if established session.";
                this.logger.error(message);
                return Promise.reject(new Error("Invalid session state " + this.session.state));
            }
            return this.session._info(options.requestDelegate, options.requestOptions);
        };
        return Infoer;
    }());
    exports.Infoer = Infoer;
    
    
    /***/ }),
    
    /***/ "./src/api/invitation.ts":
    /*!*******************************!*\
      !*** ./src/api/invitation.ts ***!
      \*******************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var core_1 = __webpack_require__(/*! ../core */ "./src/core/index.ts");
    var utils_1 = __webpack_require__(/*! ../core/messages/utils */ "./src/core/messages/utils.ts");
    var exceptions_1 = __webpack_require__(/*! ./exceptions */ "./src/api/exceptions/index.ts");
    var session_1 = __webpack_require__(/*! ./session */ "./src/api/session.ts");
    var session_state_1 = __webpack_require__(/*! ./session-state */ "./src/api/session-state.ts");
    var user_agent_options_1 = __webpack_require__(/*! ./user-agent-options */ "./src/api/user-agent-options.ts");
    /**
     * An invitation is an offer to establish a {@link Session} (incoming INVITE).
     * @public
     */
    var Invitation = /** @class */ (function (_super) {
        tslib_1.__extends(Invitation, _super);
        /** @internal */
        function Invitation(userAgent, incomingInviteRequest) {
            var _this = _super.call(this, userAgent) || this;
            _this.incomingInviteRequest = incomingInviteRequest;
            /** True if dispose() has been called. */
            _this.disposed = false;
            /** INVITE will be rejected if not accepted within a certain period time. */
            _this.expiresTimer = undefined;
            /** True if this Session has been Terminated due to a CANCEL request. */
            _this.isCanceled = false;
            /** Are reliable provisional responses required or supported. */
            _this.rel100 = "none";
            /** The current RSeq header value. */
            _this.rseq = Math.floor(Math.random() * 10000);
            /** INVITE will be rejected if final response not sent in a certain period time. */
            _this.userNoAnswerTimer = undefined;
            /** True if waiting for a PRACK before sending a 200 Ok. */
            _this.waitingForPrack = false;
            _this.logger = userAgent.getLogger("sip.Invitation");
            var incomingRequestMessage = _this.incomingInviteRequest.message;
            // Set 100rel if necessary
            var requireHeader = incomingRequestMessage.getHeader("require");
            if (requireHeader && requireHeader.toLowerCase().indexOf("100rel") >= 0) {
                _this.rel100 = "required";
            }
            var supportedHeader = incomingRequestMessage.getHeader("supported");
            if (supportedHeader && supportedHeader.toLowerCase().indexOf("100rel") >= 0) {
                _this.rel100 = "supported";
            }
            // Set the toTag on the incoming request message to the toTag which
            // will be used in the response to the incoming request!!!
            // FIXME: HACK: This is a hack to port an existing behavior.
            // The behavior being ported appears to be a hack itself,
            // so this is a hack to port a hack. At least one test spec
            // relies on it (which is yet another hack).
            incomingRequestMessage.toTag = incomingInviteRequest.toTag;
            if (typeof incomingRequestMessage.toTag !== "string") {
                throw new TypeError("toTag should have been a string.");
            }
            // The following mapping values are RECOMMENDED:
            // ...
            // 19 no answer from the user              480 Temporarily unavailable
            // https://tools.ietf.org/html/rfc3398#section-7.2.4.1
            _this.userNoAnswerTimer = setTimeout(function () {
                incomingInviteRequest.reject({ statusCode: 480 });
                _this.stateTransition(session_state_1.SessionState.Terminated);
            }, _this.userAgent.configuration.noAnswerTimeout ? _this.userAgent.configuration.noAnswerTimeout * 1000 : 60000);
            // 1. If the request is an INVITE that contains an Expires header
            // field, the UAS core sets a timer for the number of seconds
            // indicated in the header field value.  When the timer fires, the
            // invitation is considered to be expired.  If the invitation
            // expires before the UAS has generated a final response, a 487
            // (Request Terminated) response SHOULD be generated.
            // https://tools.ietf.org/html/rfc3261#section-13.3.1
            if (incomingRequestMessage.hasHeader("expires")) {
                var expires = Number(incomingRequestMessage.getHeader("expires") || 0) * 1000;
                _this.expiresTimer = setTimeout(function () {
                    if (_this.state === session_state_1.SessionState.Initial) {
                        incomingInviteRequest.reject({ statusCode: 487 });
                        _this.stateTransition(session_state_1.SessionState.Terminated);
                    }
                }, expires);
            }
            // Session parent properties
            var assertedIdentity = _this.request.getHeader("P-Asserted-Identity");
            if (assertedIdentity) {
                _this._assertedIdentity = core_1.Grammar.nameAddrHeaderParse(assertedIdentity);
            }
            _this._contact = _this.userAgent.contact.toString();
            var contentDisposition = incomingRequestMessage.parseHeader("Content-Disposition");
            if (contentDisposition && contentDisposition.type === "render") {
                _this._renderbody = incomingRequestMessage.body;
                _this._rendertype = incomingRequestMessage.getHeader("Content-Type");
            }
            // Identifier
            _this._id = incomingRequestMessage.callId + incomingRequestMessage.fromTag;
            // Add to the user agent's session collection.
            _this.userAgent._sessions[_this._id] = _this;
            return _this;
        }
        /**
         * Destructor.
         */
        Invitation.prototype.dispose = function () {
            var _this = this;
            // Only run through this once. It can and does get called multiple times
            // depending on the what the sessions state is when first called.
            // For example, if called when "establishing" it will be called again
            // at least once when the session transitions to "terminated".
            // Regardless, running through this more than once is pointless.
            if (this.disposed) {
                return Promise.resolve();
            }
            this.disposed = true;
            // Clear timers
            if (this.expiresTimer) {
                clearTimeout(this.expiresTimer);
                this.expiresTimer = undefined;
            }
            if (this.userNoAnswerTimer) {
                clearTimeout(this.userNoAnswerTimer);
                this.userNoAnswerTimer = undefined;
            }
            // If accept() is still waiting for a PRACK, make sure it rejects
            this.prackNeverArrived();
            // If the final response for the initial INVITE not yet been sent, reject it
            switch (this.state) {
                case session_state_1.SessionState.Initial:
                    return this.reject().then(function () { return _super.prototype.dispose.call(_this); });
                case session_state_1.SessionState.Establishing:
                    return this.reject().then(function () { return _super.prototype.dispose.call(_this); });
                case session_state_1.SessionState.Established:
                    return _super.prototype.dispose.call(this);
                case session_state_1.SessionState.Terminating:
                    return _super.prototype.dispose.call(this);
                case session_state_1.SessionState.Terminated:
                    return _super.prototype.dispose.call(this);
                default:
                    throw new Error("Unknown state.");
            }
        };
        Object.defineProperty(Invitation.prototype, "autoSendAnInitialProvisionalResponse", {
            /**
             * If true, a first provisional response after the 100 Trying
             * will be sent automatically. This is false it the UAC required
             * reliable provisional responses (100rel in Require header),
             * otherwise it is true. The provisional is sent by calling
             * `progress()` without any options.
             *
             * FIXME: TODO: It seems reasonable that the ISC user should
             * be able to optionally disable this behavior. As the provisional
             * is sent prior to the "invite" event being emitted, it's a known
             * issue that the ISC user cannot register listeners or do any other
             * setup prior to the call to `progress()`. As an example why this is
             * an issue, setting `ua.configuration.rel100` to REQUIRED will result
             * in an attempt by `progress()` to send a 183 with SDP produced by
             * calling `getDescription()` on a session description handler, but
             * the ISC user cannot perform any potentially required session description
             * handler initialization (thus preventing the utilization of setting
             * `ua.configuration.rel100` to REQUIRED). That begs the question of
             * why this behavior is disabled when the UAC requires 100rel but not
             * when the UAS requires 100rel? But ignoring that, it's just one example
             * of a class of cases where the ISC user needs to do something prior
             * to the first call to `progress()` and is unable to do so.
             * @internal
             */
            get: function () {
                return this.rel100 === "required" ? false : true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Invitation.prototype, "body", {
            /**
             * Initial incoming INVITE request message body.
             */
            get: function () {
                return this.incomingInviteRequest.message.body;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Invitation.prototype, "localIdentity", {
            /**
             * The identity of the local user.
             */
            get: function () {
                return this.request.to;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Invitation.prototype, "remoteIdentity", {
            /**
             * The identity of the remote user.
             */
            get: function () {
                return this.request.from;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Invitation.prototype, "request", {
            /**
             * Initial incoming INVITE request message.
             */
            get: function () {
                return this.incomingInviteRequest.message;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Accept the invitation.
         *
         * @remarks
         * Accept the incoming INVITE request to start a Session.
         * Replies to the INVITE request with a 200 Ok response.
         * Resolves once the response sent, otherwise rejects.
         *
         * This method may reject for a variety of reasons including
         * the receipt of a CANCEL request before `accept` is able
         * to construct a response.
         * @param options - Options bucket.
         */
        Invitation.prototype.accept = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            this.logger.log("Invitation.accept");
            // validate state
            if (this.state !== session_state_1.SessionState.Initial) {
                var error = new Error("Invalid session state " + this.state);
                this.logger.error(error.message);
                return Promise.reject(error);
            }
            // transition state
            this.stateTransition(session_state_1.SessionState.Establishing);
            return this.sendAccept(options)
                .then(function (_a) {
                var message = _a.message, session = _a.session;
                session.delegate = {
                    onAck: function (ackRequest) { return _this.onAckRequest(ackRequest); },
                    onAckTimeout: function () { return _this.onAckTimeout(); },
                    onBye: function (byeRequest) { return _this.onByeRequest(byeRequest); },
                    onInfo: function (infoRequest) { return _this.onInfoRequest(infoRequest); },
                    onInvite: function (inviteRequest) { return _this.onInviteRequest(inviteRequest); },
                    onNotify: function (notifyRequest) { return _this.onNotifyRequest(notifyRequest); },
                    onPrack: function (prackRequest) { return _this.onPrackRequest(prackRequest); },
                    onRefer: function (referRequest) { return _this.onReferRequest(referRequest); }
                };
                _this._dialog = session;
                _this.stateTransition(session_state_1.SessionState.Established);
                // TODO: Reconsider this "automagic" send of a BYE to replacee behavior.
                // This behavior has been ported forward from legacy versions.
                if (_this._replacee) {
                    _this._replacee._bye();
                }
            })
                .catch(function (error) { return _this.handleResponseError(error); });
        };
        /**
         * Indicate progress processing the invitation.
         *
         * @remarks
         * Report progress to the the caller.
         * Replies to the INVITE request with a 1xx provisional response.
         * Resolves once the response sent, otherwise rejects.
         * @param options - Options bucket.
         */
        Invitation.prototype.progress = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            this.logger.log("Invitation.progress");
            // validate state
            if (this.state !== session_state_1.SessionState.Initial) {
                var error = new Error("Invalid session state " + this.state);
                this.logger.error(error.message);
                return Promise.reject(error);
            }
            // Ported
            var statusCode = options.statusCode || 180;
            if (statusCode < 100 || statusCode > 199) {
                throw new TypeError("Invalid statusCode: " + statusCode);
            }
            // After the first reliable provisional response for a request has been
            // acknowledged, the UAS MAY send additional reliable provisional
            // responses.  The UAS MUST NOT send a second reliable provisional
            // response until the first is acknowledged.  After the first, it is
            // RECOMMENDED that the UAS not send an additional reliable provisional
            // response until the previous is acknowledged.  The first reliable
            // provisional response receives special treatment because it conveys
            // the initial sequence number.  If additional reliable provisional
            // responses were sent before the first was acknowledged, the UAS could
            // not be certain these were received in order.
            // https://tools.ietf.org/html/rfc3262#section-3
            if (this.waitingForPrack) {
                this.logger.warn("Unexpected call for progress while waiting for prack, ignoring");
                return Promise.resolve();
            }
            // Trying provisional response
            if (options.statusCode === 100) {
                return this.sendProgressTrying()
                    .then(function (response) { return; })
                    .catch(function (error) { return _this.handleResponseError(error); });
            }
            // Standard provisional response
            if (!(this.rel100 === "required") &&
                !(this.rel100 === "supported" && options.rel100) &&
                !(this.rel100 === "supported" &&
                    this.userAgent.configuration.sipExtension100rel === user_agent_options_1.SIPExtension.Required)) {
                return this.sendProgress(options)
                    .then(function (response) { return; })
                    .catch(function (error) { return _this.handleResponseError(error); });
            }
            // Reliable provisional response
            return this.sendProgressReliableWaitForPrack(options)
                .then(function (response) { return; })
                .catch(function (error) { return _this.handleResponseError(error); });
        };
        /**
         * Reject the invitation.
         *
         * @remarks
         * Replies to the INVITE request with a 4xx, 5xx, or 6xx final response.
         * Resolves once the response sent, otherwise rejects.
         *
         * The expectation is that this method is used to reject an INVITE request.
         * That is indeed the case - a call to `progress` followed by `reject` is
         * a typical way to "decline" an incoming INVITE request. However it may
         * also be called after calling `accept` (but only before it completes)
         * which will reject the call and cause `accept` to reject.
         * @param options - Options bucket.
         */
        Invitation.prototype.reject = function (options) {
            if (options === void 0) { options = {}; }
            this.logger.log("Invitation.reject");
            // validate state
            if (this.state !== session_state_1.SessionState.Initial &&
                this.state !== session_state_1.SessionState.Establishing) {
                var error = new Error("Invalid session state " + this.state);
                this.logger.error(error.message);
                return Promise.reject(error);
            }
            var statusCode = options.statusCode || 480;
            var reasonPhrase = options.reasonPhrase ? options.reasonPhrase : utils_1.getReasonPhrase(statusCode);
            var extraHeaders = options.extraHeaders || [];
            if (statusCode < 300 || statusCode > 699) {
                throw new TypeError("Invalid statusCode: " + statusCode);
            }
            var body = options.body ? core_1.fromBodyLegacy(options.body) : undefined;
            // FIXME: Need to redirect to someplace
            var response = statusCode < 400 ?
                this.incomingInviteRequest.redirect([], { statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body }) :
                this.incomingInviteRequest.reject({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
            this.stateTransition(session_state_1.SessionState.Terminated);
            return Promise.resolve();
        };
        /**
         * Handle CANCEL request.
         *
         * @param message - CANCEL message.
         * @internal
         */
        Invitation.prototype._onCancel = function (message) {
            this.logger.log("Invitation._onCancel");
            // validate state
            if (this.state !== session_state_1.SessionState.Initial &&
                this.state !== session_state_1.SessionState.Establishing) {
                this.logger.error("CANCEL received while in state " + this.state + ", dropping request");
                return;
            }
            // flag canceled
            this.isCanceled = true;
            // reject INVITE with 487 status code
            this.incomingInviteRequest.reject({ statusCode: 487 });
            this.stateTransition(session_state_1.SessionState.Terminated);
        };
        /**
         * Helper function to handle offer/answer in a PRACK.
         */
        Invitation.prototype.handlePrackOfferAnswer = function (request, options) {
            if (!this.dialog) {
                throw new Error("Dialog undefined.");
            }
            // If the PRACK doesn't have an offer/answer, nothing to be done.
            var body = core_1.getBody(request.message);
            if (!body || body.contentDisposition !== "session") {
                return Promise.resolve(undefined);
            }
            // If the UAC receives a reliable provisional response with an offer
            // (this would occur if the UAC sent an INVITE without an offer, in
            // which case the first reliable provisional response will contain the
            // offer), it MUST generate an answer in the PRACK.  If the UAC receives
            // a reliable provisional response with an answer, it MAY generate an
            // additional offer in the PRACK.  If the UAS receives a PRACK with an
            // offer, it MUST place the answer in the 2xx to the PRACK.
            // https://tools.ietf.org/html/rfc3262#section-5
            switch (this.dialog.signalingState) {
                case core_1.SignalingState.Initial:
                    // State should never be reached as first reliable provisional response must have answer/offer.
                    throw new Error("Invalid signaling state " + this.dialog.signalingState + ".");
                case core_1.SignalingState.Stable:
                    // Receved answer.
                    return this.setAnswer(body, options).then(function () { return undefined; });
                case core_1.SignalingState.HaveLocalOffer:
                    // State should never be reached as local offer would be answered by this PRACK
                    throw new Error("Invalid signaling state " + this.dialog.signalingState + ".");
                case core_1.SignalingState.HaveRemoteOffer:
                    // Received offer, generate answer.
                    return this.setOfferAndGetAnswer(body, options);
                case core_1.SignalingState.Closed:
                    throw new Error("Invalid signaling state " + this.dialog.signalingState + ".");
                default:
                    throw new Error("Invalid signaling state " + this.dialog.signalingState + ".");
            }
        };
        /**
         * A handler for errors which occur while attempting to send 1xx and 2xx responses.
         * In all cases, an attempt is made to reject the request if it is still outstanding.
         * And while there are a variety of things which can go wrong and we log something here
         * for all errors, there are a handful of common exceptions we pay some extra attention to.
         * @param error - The error which occurred.
         */
        Invitation.prototype.handleResponseError = function (error) {
            var statusCode = 480; // "Temporarily Unavailable"
            // Log Error message
            if (error instanceof Error) {
                this.logger.error(error.message);
            }
            else {
                // We don't actually know what a session description handler implementation might throw our way,
                // and more generally as a last resort catch all, just assume we are getting an "any" and log it.
                this.logger.error(error);
            }
            // Log Exception message
            if (error instanceof exceptions_1.ContentTypeUnsupportedError) {
                this.logger.error("A session description handler occurred while sending response (content type unsupported");
                statusCode = 415; // "Unsupported Media Type"
            }
            else if (error instanceof exceptions_1.SessionDescriptionHandlerError) {
                this.logger.error("A session description handler occurred while sending response");
            }
            else if (error instanceof exceptions_1.SessionTerminatedError) {
                this.logger.error("Session ended before response could be formulated and sent (while waiting for PRACK)");
            }
            else if (error instanceof core_1.TransactionStateError) {
                this.logger.error("Session changed state before response could be formulated and sent");
            }
            // Reject if still in "initial" or "establishing" state.
            if (this.state === session_state_1.SessionState.Initial || this.state === session_state_1.SessionState.Establishing) {
                try {
                    this.incomingInviteRequest.reject({ statusCode: statusCode });
                    this.stateTransition(session_state_1.SessionState.Terminated);
                }
                catch (e) {
                    this.logger.error("An error occurred attempting to reject the request while handling another error");
                    throw e; // This is not a good place to be...
                }
            }
            // FIXME: TODO:
            // Here we are squelching the throwing of errors due to an race condition.
            // We have an internal race between calling `accept()` and handling an incoming
            // CANCEL request. As there is no good way currently to delegate the handling of
            // these race errors to the caller of `accept()`, we are squelching the throwing
            // of ALL errors when/if they occur after receiving a CANCEL to catch the ONE we know
            // is a "normal" exceptional condition. While this is a completely reasonable approach,
            // the decision should be left up to the library user. Furthermore, as we are eating
            // ALL errors in this case, we are potentially (likely) hiding "real" errors which occur.
            //
            // Only rethrow error if the session has not been canceled.
            if (this.isCanceled) {
                this.logger.warn("An error occurred while attempting to formulate and send a response to an incoming INVITE." +
                    " However a CANCEL was received and processed while doing so which can (and often does) result" +
                    " in errors occurring as the session terminates in the meantime. Said error is being ignored.");
                return;
            }
            throw error;
        };
        /**
         * Callback for when ACK for a 2xx response is never received.
         * @param session - Session the ACK never arrived for.
         */
        Invitation.prototype.onAckTimeout = function () {
            this.logger.log("Invitation.onAckTimeout");
            if (!this.dialog) {
                throw new Error("Dialog undefined.");
            }
            this.logger.log("No ACK received for an extended period of time, terminating session");
            this.dialog.bye();
            this.stateTransition(session_state_1.SessionState.Terminated);
        };
        /**
         * A version of `accept` which resolves a session when the 200 Ok response is sent.
         * @param options - Options bucket.
         */
        Invitation.prototype.sendAccept = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            // The UAS MAY send a final response to the initial request before
            // having received PRACKs for all unacknowledged reliable provisional
            // responses, unless the final response is 2xx and any of the
            // unacknowledged reliable provisional responses contained a session
            // description.  In that case, it MUST NOT send a final response until
            // those provisional responses are acknowledged.  If the UAS does send a
            // final response when reliable responses are still unacknowledged, it
            // SHOULD NOT continue to retransmit the unacknowledged reliable
            // provisional responses, but it MUST be prepared to process PRACK
            // requests for those outstanding responses.  A UAS MUST NOT send new
            // reliable provisional responses (as opposed to retransmissions of
            // unacknowledged ones) after sending a final response to a request.
            // https://tools.ietf.org/html/rfc3262#section-3
            if (this.waitingForPrack) {
                return this.waitForArrivalOfPrack()
                    .then(function () { return clearTimeout(_this.userNoAnswerTimer); }) // Ported
                    .then(function () { return _this.generateResponseOfferAnswer(_this.incomingInviteRequest, options); })
                    .then(function (body) { return _this.incomingInviteRequest.accept({ statusCode: 200, body: body }); });
            }
            clearTimeout(this.userNoAnswerTimer); // Ported
            return this.generateResponseOfferAnswer(this.incomingInviteRequest, options)
                .then(function (body) { return _this.incomingInviteRequest.accept({ statusCode: 200, body: body }); });
        };
        /**
         * A version of `progress` which resolves when the provisional response is sent.
         * @param options - Options bucket.
         */
        Invitation.prototype.sendProgress = function (options) {
            if (options === void 0) { options = {}; }
            var statusCode = options.statusCode || 180;
            var reasonPhrase = options.reasonPhrase;
            var extraHeaders = (options.extraHeaders || []).slice();
            var body = options.body ? core_1.fromBodyLegacy(options.body) : undefined;
            // The 183 (Session Progress) response is used to convey information
            // about the progress of the call that is not otherwise classified.  The
            // Reason-Phrase, header fields, or message body MAY be used to convey
            // more details about the call progress.
            // https://tools.ietf.org/html/rfc3261#section-21.1.5
            // It is the de facto industry standard to utilize 183 with SDP to provide "early media".
            // While it is unlikely someone would want to send a 183 without SDP, so it should be an option.
            if (statusCode === 183 && !body) {
                return this.sendProgressWithSDP(options);
            }
            try {
                var progressResponse = this.incomingInviteRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
                this._dialog = progressResponse.session;
                return Promise.resolve(progressResponse);
            }
            catch (error) {
                return Promise.reject(error);
            }
        };
        /**
         * A version of `progress` which resolves when the provisional response with sdp is sent.
         * @param options - Options bucket.
         */
        Invitation.prototype.sendProgressWithSDP = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var statusCode = options.statusCode || 183;
            var reasonPhrase = options.reasonPhrase;
            var extraHeaders = (options.extraHeaders || []).slice();
            // Get an offer/answer and send a reply.
            return this.generateResponseOfferAnswer(this.incomingInviteRequest, options)
                .then(function (body) { return _this.incomingInviteRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body }); })
                .then(function (progressResponse) {
                _this._dialog = progressResponse.session;
                return progressResponse;
            });
        };
        /**
         * A version of `progress` which resolves when the reliable provisional response is sent.
         * @param options - Options bucket.
         */
        Invitation.prototype.sendProgressReliable = function (options) {
            if (options === void 0) { options = {}; }
            options.extraHeaders = (options.extraHeaders || []).slice();
            options.extraHeaders.push("Require: 100rel");
            options.extraHeaders.push("RSeq: " + Math.floor(Math.random() * 10000));
            return this.sendProgressWithSDP(options);
        };
        /**
         * A version of `progress` which resolves when the reliable provisional response is acknowledged.
         * @param options - Options bucket.
         */
        Invitation.prototype.sendProgressReliableWaitForPrack = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var statusCode = options.statusCode || 183;
            var reasonPhrase = options.reasonPhrase;
            var extraHeaders = (options.extraHeaders || []).slice();
            extraHeaders.push("Require: 100rel");
            extraHeaders.push("RSeq: " + this.rseq++);
            var body;
            return new Promise(function (resolve, reject) {
                _this.waitingForPrack = true;
                _this.generateResponseOfferAnswer(_this.incomingInviteRequest, options)
                    .then(function (offerAnswer) {
                    body = offerAnswer;
                    return _this.incomingInviteRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
                })
                    .then(function (progressResponse) {
                    _this._dialog = progressResponse.session;
                    var prackRequest;
                    var prackResponse;
                    progressResponse.session.delegate = {
                        onPrack: function (request) {
                            prackRequest = request;
                            clearTimeout(prackWaitTimeoutTimer);
                            clearTimeout(rel1xxRetransmissionTimer);
                            if (!_this.waitingForPrack) {
                                return;
                            }
                            _this.waitingForPrack = false;
                            _this.handlePrackOfferAnswer(prackRequest, options)
                                .then(function (prackResponseBody) {
                                try {
                                    prackResponse = prackRequest.accept({ statusCode: 200, body: prackResponseBody });
                                    _this.prackArrived();
                                    resolve({ prackRequest: prackRequest, prackResponse: prackResponse, progressResponse: progressResponse });
                                }
                                catch (error) {
                                    reject(error);
                                }
                            })
                                .catch(function (error) { return reject(error); });
                        }
                    };
                    // https://tools.ietf.org/html/rfc3262#section-3
                    var prackWaitTimeout = function () {
                        if (!_this.waitingForPrack) {
                            return;
                        }
                        _this.waitingForPrack = false;
                        _this.logger.warn("No PRACK received, rejecting INVITE.");
                        clearTimeout(rel1xxRetransmissionTimer);
                        _this.reject({ statusCode: 504 })
                            .then(function () { return reject(new exceptions_1.SessionTerminatedError()); })
                            .catch(function (error) { return reject(error); });
                    };
                    var prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, core_1.Timers.T1 * 64);
                    // https://tools.ietf.org/html/rfc3262#section-3
                    var rel1xxRetransmission = function () {
                        try {
                            _this.incomingInviteRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
                        }
                        catch (error) {
                            _this.waitingForPrack = false;
                            reject(error);
                            return;
                        }
                        rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout *= 2);
                    };
                    var timeout = core_1.Timers.T1;
                    var rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout);
                })
                    .catch(function (error) {
                    _this.waitingForPrack = false;
                    reject(error);
                });
            });
        };
        /**
         * A version of `progress` which resolves when a 100 Trying provisional response is sent.
         */
        Invitation.prototype.sendProgressTrying = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                try {
                    var progressResponse = _this.incomingInviteRequest.trying();
                    return Promise.resolve(progressResponse);
                }
                catch (error) {
                    return Promise.reject(error);
                }
            });
        };
        /**
         * When attempting to accept the INVITE, an invitation waits
         * for any outstanding PRACK to arrive before sending the 200 Ok.
         * It will be waiting on this Promise to resolve which lets it know
         * the PRACK has arrived and it may proceed to send the 200 Ok.
         */
        Invitation.prototype.waitForArrivalOfPrack = function () {
            var _this = this;
            if (this.waitingForPrackPromise) {
                throw new Error("Already waiting for PRACK");
            }
            this.waitingForPrackPromise = new Promise(function (resolve, reject) {
                _this.waitingForPrackResolve = resolve;
                _this.waitingForPrackReject = reject;
            });
            return this.waitingForPrackPromise;
        };
        /**
         * Here we are resolving the promise which in turn will cause
         * the accept to proceed (it may still fail for other reasons, but...).
         */
        Invitation.prototype.prackArrived = function () {
            if (this.waitingForPrackResolve) {
                this.waitingForPrackResolve();
            }
            this.waitingForPrackPromise = undefined;
            this.waitingForPrackResolve = undefined;
            this.waitingForPrackReject = undefined;
        };
        /**
         * Here we are rejecting the promise which in turn will cause
         * the accept to fail and the session to transition to "terminated".
         */
        Invitation.prototype.prackNeverArrived = function () {
            if (this.waitingForPrackReject) {
                this.waitingForPrackReject(new exceptions_1.SessionTerminatedError());
            }
            this.waitingForPrackPromise = undefined;
            this.waitingForPrackResolve = undefined;
            this.waitingForPrackReject = undefined;
        };
        return Invitation;
    }(session_1.Session));
    exports.Invitation = Invitation;
    
    
    /***/ }),
    
    /***/ "./src/api/inviter.ts":
    /*!****************************!*\
      !*** ./src/api/inviter.ts ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var core_1 = __webpack_require__(/*! ../core */ "./src/core/index.ts");
    var utils_1 = __webpack_require__(/*! ../core/messages/utils */ "./src/core/messages/utils.ts");
    var session_1 = __webpack_require__(/*! ./session */ "./src/api/session.ts");
    var session_state_1 = __webpack_require__(/*! ./session-state */ "./src/api/session-state.ts");
    var user_agent_options_1 = __webpack_require__(/*! ./user-agent-options */ "./src/api/user-agent-options.ts");
    /**
     * An inviter offers to establish a {@link Session} (outgoing INVITE).
     * @public
     */
    var Inviter = /** @class */ (function (_super) {
        tslib_1.__extends(Inviter, _super);
        /**
         * Constructs a new instance of the `Inviter` class.
         * @param userAgent - User agent. See {@link UserAgent} for details.
         * @param targetURI - Request URI identifying the target of the message.
         * @param options - Options bucket. See {@link InviterOptions} for details.
         */
        function Inviter(userAgent, targetURI, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, userAgent, options) || this;
            /** True if dispose() has been called. */
            _this.disposed = false;
            /** True if early media use is enabled. */
            _this.earlyMedia = false;
            /** The early media session description handlers. */
            _this.earlyMediaSessionDescriptionHandlers = new Map();
            /** True if cancel() was called. */
            _this.isCanceled = false;
            /** True if initial INVITE without SDP. */
            _this.inviteWithoutSdp = false;
            _this.logger = userAgent.getLogger("sip.Inviter");
            // Early media
            _this.earlyMedia = options.earlyMedia !== undefined ? options.earlyMedia : _this.earlyMedia;
            // From tag
            _this.fromTag = utils_1.newTag();
            // Invite without SDP
            _this.inviteWithoutSdp = options.inviteWithoutSdp !== undefined ? options.inviteWithoutSdp : _this.inviteWithoutSdp;
            // Inviter options (could do better copying these options)
            var inviterOptions = tslib_1.__assign({}, options);
            inviterOptions.params = tslib_1.__assign({}, options.params);
            // Anonymous call
            var anonymous = options.anonymous || false;
            // Contact
            var contact = userAgent.contact.toString({
                anonymous: anonymous,
                // Do not add ;ob in initial forming dialog requests if the
                // registration over the current connection got a GRUU URI.
                outbound: anonymous ? !userAgent.contact.tempGruu : !userAgent.contact.pubGruu
            });
            // FIXME: TODO: We should not be parsing URIs here as if it fails we have to throw an exception
            // which is not something we want our constructor to do. URIs should be passed in as params.
            // URIs
            if (anonymous && userAgent.configuration.uri) {
                inviterOptions.params.fromDisplayName = "Anonymous";
                inviterOptions.params.fromUri = "sip:anonymous@anonymous.invalid";
            }
            var fromURI = userAgent.userAgentCore.configuration.aor;
            if (inviterOptions.params.fromUri) {
                fromURI =
                    (typeof inviterOptions.params.fromUri === "string") ?
                        core_1.Grammar.URIParse(inviterOptions.params.fromUri) :
                        inviterOptions.params.fromUri;
            }
            if (!fromURI) {
                throw new TypeError("Invalid from URI: " + inviterOptions.params.fromUri);
            }
            var toURI = targetURI;
            if (inviterOptions.params.toUri) {
                toURI =
                    (typeof inviterOptions.params.toUri === "string") ?
                        core_1.Grammar.URIParse(inviterOptions.params.toUri) :
                        inviterOptions.params.toUri;
            }
            if (!toURI) {
                throw new TypeError("Invalid to URI: " + inviterOptions.params.toUri);
            }
            // Params
            var messageOptions = tslib_1.__assign({}, inviterOptions.params);
            messageOptions.fromTag = _this.fromTag;
            // Extra headers
            var extraHeaders = (inviterOptions.extraHeaders || []).slice();
            if (anonymous && userAgent.configuration.uri) {
                extraHeaders.push("P-Preferred-Identity: " + userAgent.configuration.uri.toString());
                extraHeaders.push("Privacy: id");
            }
            extraHeaders.push("Contact: " + contact);
            extraHeaders.push("Allow: " + [
                "ACK",
                "CANCEL",
                "INVITE",
                "MESSAGE",
                "BYE",
                "OPTIONS",
                "INFO",
                "NOTIFY",
                "REFER"
            ].toString());
            if (userAgent.configuration.sipExtension100rel === user_agent_options_1.SIPExtension.Required) {
                extraHeaders.push("Require: 100rel");
            }
            if (userAgent.configuration.sipExtensionReplaces === user_agent_options_1.SIPExtension.Required) {
                extraHeaders.push("Require: replaces");
            }
            inviterOptions.extraHeaders = extraHeaders;
            // Body
            var body = undefined;
            // Make initial outgoing request message
            _this.outgoingRequestMessage = userAgent.userAgentCore.makeOutgoingRequestMessage(core_1.C.INVITE, targetURI, fromURI, toURI, messageOptions, extraHeaders, body);
            // Session parent properties
            _this._contact = contact;
            _this._referralInviterOptions = inviterOptions;
            _this._renderbody = options.renderbody;
            _this._rendertype = options.rendertype;
            _this._sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
            _this._sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
            // Identifier
            _this._id = _this.outgoingRequestMessage.callId + _this.fromTag;
            // Add to the user agent's session collection.
            _this.userAgent._sessions[_this._id] = _this;
            return _this;
        }
        /**
         * Destructor.
         */
        Inviter.prototype.dispose = function () {
            var _this = this;
            // Only run through this once. It can and does get called multiple times
            // depending on the what the sessions state is when first called.
            // For example, if called when "establishing" it will be called again
            // at least once when the session transitions to "terminated".
            // Regardless, running through this more than once is pointless.
            if (this.disposed) {
                return Promise.resolve();
            }
            this.disposed = true;
            // Dispose of early dialog media
            this.disposeEarlyMedia();
            // If the final response for the initial INVITE not yet been received, cancel it
            switch (this.state) {
                case session_state_1.SessionState.Initial:
                    return this.cancel().then(function () { return _super.prototype.dispose.call(_this); });
                case session_state_1.SessionState.Establishing:
                    return this.cancel().then(function () { return _super.prototype.dispose.call(_this); });
                case session_state_1.SessionState.Established:
                    return _super.prototype.dispose.call(this);
                case session_state_1.SessionState.Terminating:
                    return _super.prototype.dispose.call(this);
                case session_state_1.SessionState.Terminated:
                    return _super.prototype.dispose.call(this);
                default:
                    throw new Error("Unknown state.");
            }
        };
        Object.defineProperty(Inviter.prototype, "body", {
            /**
             * Initial outgoing INVITE request message body.
             */
            get: function () {
                return this.outgoingRequestMessage.body;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Inviter.prototype, "localIdentity", {
            /**
             * The identity of the local user.
             */
            get: function () {
                return this.outgoingRequestMessage.from;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Inviter.prototype, "remoteIdentity", {
            /**
             * The identity of the remote user.
             */
            get: function () {
                return this.outgoingRequestMessage.to;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Inviter.prototype, "request", {
            /**
             * Initial outgoing INVITE request message.
             */
            get: function () {
                return this.outgoingRequestMessage;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Cancels the INVITE request.
         *
         * @remarks
         * Sends a CANCEL request.
         * Resolves once the response sent, otherwise rejects.
         *
         * After sending a CANCEL request the expectation is that a 487 final response
         * will be received for the INVITE. However a 200 final response to the INVITE
         * may nonetheless arrive (it's a race between the CANCEL reaching the UAS before
         * the UAS sends a 200) in which case an ACK & BYE will be sent. The net effect
         * is that this method will terminate the session regardless of the race.
         * @param options - Options bucket.
         */
        Inviter.prototype.cancel = function (options) {
            if (options === void 0) { options = {}; }
            this.logger.log("Inviter.cancel");
            // validate state
            if (this.state !== session_state_1.SessionState.Initial && this.state !== session_state_1.SessionState.Establishing) {
                var error = new Error("Invalid session state " + this.state);
                this.logger.error(error.message);
                return Promise.reject(error);
            }
            // flag canceled
            this.isCanceled = true;
            // transition state
            this.stateTransition(session_state_1.SessionState.Terminating);
            // helper function
            function getCancelReason(code, reason) {
                if (code && code < 200 || code > 699) {
                    throw new TypeError("Invalid statusCode: " + code);
                }
                else if (code) {
                    var cause = code;
                    var text = utils_1.getReasonPhrase(code) || reason;
                    return "SIP;cause=" + cause + ';text="' + text + '"';
                }
            }
            if (this.outgoingInviteRequest) {
                // the CANCEL may not be respected by peer(s), so don't transition to terminated
                var cancelReason = void 0;
                if (options.statusCode && options.reasonPhrase) {
                    cancelReason = getCancelReason(options.statusCode, options.reasonPhrase);
                }
                this.outgoingInviteRequest.cancel(cancelReason, options);
            }
            else {
                this.logger.warn("Canceled session before INVITE was sent");
                this.stateTransition(session_state_1.SessionState.Terminated);
            }
            return Promise.resolve();
        };
        /**
         * Sends the INVITE request.
         *
         * @remarks
         * TLDR...
         *  1) Only one offer/answer exchange permitted during initial INVITE.
         *  2) No "early media" if the initial offer is in an INVITE (default behavior).
         *  3) If "early media" and the initial offer is in an INVITE, no INVITE forking.
         *
         * 1) Only one offer/answer exchange permitted during initial INVITE.
         *
         * Our implementation replaces the following bullet point...
         *
         * o  After having sent or received an answer to the first offer, the
         *    UAC MAY generate subsequent offers in requests based on rules
         *    specified for that method, but only if it has received answers
         *    to any previous offers, and has not sent any offers to which it
         *    hasn't gotten an answer.
         * https://tools.ietf.org/html/rfc3261#section-13.2.1
         *
         * ...with...
         *
         * o  After having sent or received an answer to the first offer, the
         *    UAC MUST NOT generate subsequent offers in requests based on rules
         *    specified for that method.
         *
         * ...which in combination with this bullet point...
         *
         * o  Once the UAS has sent or received an answer to the initial
         *    offer, it MUST NOT generate subsequent offers in any responses
         *    to the initial INVITE.  This means that a UAS based on this
         *    specification alone can never generate subsequent offers until
         *    completion of the initial transaction.
         * https://tools.ietf.org/html/rfc3261#section-13.2.1
         *
         * ...ensures that EXACTLY ONE offer/answer exchange will occur
         * during an initial out of dialog INVITE request made by our UAC.
         *
         *
         * 2) No "early media" if the initial offer is in an INVITE (default behavior).
         *
         * While our implementation adheres to the following bullet point...
         *
         * o  If the initial offer is in an INVITE, the answer MUST be in a
         *    reliable non-failure message from UAS back to UAC which is
         *    correlated to that INVITE.  For this specification, that is
         *    only the final 2xx response to that INVITE.  That same exact
         *    answer MAY also be placed in any provisional responses sent
         *    prior to the answer.  The UAC MUST treat the first session
         *    description it receives as the answer, and MUST ignore any
         *    session descriptions in subsequent responses to the initial
         *    INVITE.
         * https://tools.ietf.org/html/rfc3261#section-13.2.1
         *
         * We have made the following implementation decision with regard to early media...
         *
         * o  If the initial offer is in the INVITE, the answer from the
         *    UAS back to the UAC will establish a media session only
         *    only after the final 2xx response to that INVITE is received.
         *
         * The reason for this decision is rooted in a restriction currently
         * inherent in WebRTC. Specifically, while a SIP INVITE request with an
         * initial offer may fork resulting in more than one provisional answer,
         * there is currently no easy/good way to to "fork" an offer generated
         * by a peer connection. In particular, a WebRTC offer currently may only
         * be matched with one answer and we have no good way to know which
         * "provisional answer" is going to be the "final answer". So we have
         * decided to punt and not create any "early media" sessions in this case.
         *
         * The upshot is that if you want "early media", you must not put the
         * initial offer in the INVITE. Instead, force the UAS to provide the
         * initial offer by sending an INVITE without an offer. In the WebRTC
         * case this allows us to create a unique peer connection with a unique
         * answer for every provisional offer with "early media" on all of them.
         *
         *
         * 3) If "early media" and the initial offer is in an INVITE, no INVITE forking.
         *
         * The default behavior may be altered and "early media" utilized if the
         * initial offer is in the an INVITE by setting the `earlyMedia` options.
         * However in that case the INVITE request MUST NOT fork. This allows for
         * "early media" in environments where the forking behavior of the SIP
         * servers being utilized is configured to disallow forking.
         */
        Inviter.prototype.invite = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            this.logger.log("Inviter.invite");
            // validate state
            if (this.state !== session_state_1.SessionState.Initial) {
                // re-invite
                return _super.prototype.invite.call(this, options);
            }
            // just send an INVITE with no sdp...
            if (options.withoutSdp || this.inviteWithoutSdp) {
                if (this._renderbody && this._rendertype) {
                    this.outgoingRequestMessage.body = { contentType: this._rendertype, body: this._renderbody };
                }
                // transition state
                this.stateTransition(session_state_1.SessionState.Establishing);
                return Promise.resolve(this.sendInvite(options));
            }
            // get an offer and send it in an INVITE
            var offerOptions = {
                sessionDescriptionHandlerOptions: this._sessionDescriptionHandlerOptions,
                sessionDescriptionHandlerModifiers: this._sessionDescriptionHandlerModifiers
            };
            return this.getOffer(offerOptions)
                .then(function (body) {
                _this.outgoingRequestMessage.body = { body: body.content, contentType: body.contentType };
                // transition state
                _this.stateTransition(session_state_1.SessionState.Establishing);
                return _this.sendInvite(options);
            })
                .catch(function (error) {
                _this.logger.log(error.message);
                _this.stateTransition(session_state_1.SessionState.Terminated);
                throw error;
            });
        };
        /**
         * 13.2.1 Creating the Initial INVITE
         *
         * Since the initial INVITE represents a request outside of a dialog,
         * its construction follows the procedures of Section 8.1.1.  Additional
         * processing is required for the specific case of INVITE.
         *
         * An Allow header field (Section 20.5) SHOULD be present in the INVITE.
         * It indicates what methods can be invoked within a dialog, on the UA
         * sending the INVITE, for the duration of the dialog.  For example, a
         * UA capable of receiving INFO requests within a dialog [34] SHOULD
         * include an Allow header field listing the INFO method.
         *
         * A Supported header field (Section 20.37) SHOULD be present in the
         * INVITE.  It enumerates all the extensions understood by the UAC.
         *
         * An Accept (Section 20.1) header field MAY be present in the INVITE.
         * It indicates which Content-Types are acceptable to the UA, in both
         * the response received by it, and in any subsequent requests sent to
         * it within dialogs established by the INVITE.  The Accept header field
         * is especially useful for indicating support of various session
         * description formats.
         *
         * The UAC MAY add an Expires header field (Section 20.19) to limit the
         * validity of the invitation.  If the time indicated in the Expires
         * header field is reached and no final answer for the INVITE has been
         * received, the UAC core SHOULD generate a CANCEL request for the
         * INVITE, as per Section 9.
         *
         * A UAC MAY also find it useful to add, among others, Subject (Section
         * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)
         * header fields.  They all contain information related to the INVITE.
         *
         * The UAC MAY choose to add a message body to the INVITE.  Section
         * 8.1.1.10 deals with how to construct the header fields -- Content-
         * Type among others -- needed to describe the message body.
         *
         * https://tools.ietf.org/html/rfc3261#section-13.2.1
         */
        Inviter.prototype.sendInvite = function (options) {
            //    There are special rules for message bodies that contain a session
            //    description - their corresponding Content-Disposition is "session".
            //    SIP uses an offer/answer model where one UA sends a session
            //    description, called the offer, which contains a proposed description
            //    of the session.  The offer indicates the desired communications means
            //    (audio, video, games), parameters of those means (such as codec
            //    types) and addresses for receiving media from the answerer.  The
            //    other UA responds with another session description, called the
            //    answer, which indicates which communications means are accepted, the
            //    parameters that apply to those means, and addresses for receiving
            //    media from the offerer. An offer/answer exchange is within the
            //    context of a dialog, so that if a SIP INVITE results in multiple
            //    dialogs, each is a separate offer/answer exchange.  The offer/answer
            //    model defines restrictions on when offers and answers can be made
            //    (for example, you cannot make a new offer while one is in progress).
            //    This results in restrictions on where the offers and answers can
            //    appear in SIP messages.  In this specification, offers and answers
            //    can only appear in INVITE requests and responses, and ACK.  The usage
            //    of offers and answers is further restricted.  For the initial INVITE
            //    transaction, the rules are:
            //
            //       o  The initial offer MUST be in either an INVITE or, if not there,
            //          in the first reliable non-failure message from the UAS back to
            //          the UAC.  In this specification, that is the final 2xx
            //          response.
            //
            //       o  If the initial offer is in an INVITE, the answer MUST be in a
            //          reliable non-failure message from UAS back to UAC which is
            //          correlated to that INVITE.  For this specification, that is
            //          only the final 2xx response to that INVITE.  That same exact
            //          answer MAY also be placed in any provisional responses sent
            //          prior to the answer.  The UAC MUST treat the first session
            //          description it receives as the answer, and MUST ignore any
            //          session descriptions in subsequent responses to the initial
            //          INVITE.
            //
            //       o  If the initial offer is in the first reliable non-failure
            //          message from the UAS back to UAC, the answer MUST be in the
            //          acknowledgement for that message (in this specification, ACK
            //          for a 2xx response).
            //
            //       o  After having sent or received an answer to the first offer, the
            //          UAC MAY generate subsequent offers in requests based on rules
            //          specified for that method, but only if it has received answers
            //          to any previous offers, and has not sent any offers to which it
            //          hasn't gotten an answer.
            //
            //       o  Once the UAS has sent or received an answer to the initial
            //          offer, it MUST NOT generate subsequent offers in any responses
            //          to the initial INVITE.  This means that a UAS based on this
            //          specification alone can never generate subsequent offers until
            //          completion of the initial transaction.
            //
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            var _this = this;
            if (options === void 0) { options = {}; }
            // 5 The Offer/Answer Model and PRACK
            //
            //    RFC 3261 describes guidelines for the sets of messages in which
            //    offers and answers [3] can appear.  Based on those guidelines, this
            //    extension provides additional opportunities for offer/answer
            //    exchanges.
            //    If the INVITE contained an offer, the UAS MAY generate an answer in a
            //    reliable provisional response (assuming these are supported by the
            //    UAC).  That results in the establishment of the session before
            //    completion of the call.  Similarly, if a reliable provisional
            //    response is the first reliable message sent back to the UAC, and the
            //    INVITE did not contain an offer, one MUST appear in that reliable
            //    provisional response.
            //    If the UAC receives a reliable provisional response with an offer
            //    (this would occur if the UAC sent an INVITE without an offer, in
            //    which case the first reliable provisional response will contain the
            //    offer), it MUST generate an answer in the PRACK.  If the UAC receives
            //    a reliable provisional response with an answer, it MAY generate an
            //    additional offer in the PRACK.  If the UAS receives a PRACK with an
            //    offer, it MUST place the answer in the 2xx to the PRACK.
            //    Once an answer has been sent or received, the UA SHOULD establish the
            //    session based on the parameters of the offer and answer, even if the
            //    original INVITE itself has not been responded to.
            //    If the UAS had placed a session description in any reliable
            //    provisional response that is unacknowledged when the INVITE is
            //    accepted, the UAS MUST delay sending the 2xx until the provisional
            //    response is acknowledged.  Otherwise, the reliability of the 1xx
            //    cannot be guaranteed, and reliability is needed for proper operation
            //    of the offer/answer exchange.
            //    All user agents that support this extension MUST support all
            //    offer/answer exchanges that are possible based on the rules in
            //    Section 13.2 of RFC 3261, based on the existence of INVITE and PRACK
            //    as requests, and 2xx and reliable 1xx as non-failure reliable
            //    responses.
            //
            // https://tools.ietf.org/html/rfc3262#section-5
            ////
            // The Offer/Answer Model Implementation
            //
            // The offer/answer model is straight forward, but one MUST READ the specifications...
            //
            // 13.2.1 Creating the Initial INVITE (paragraph 8 in particular)
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            //
            // 5 The Offer/Answer Model and PRACK
            // https://tools.ietf.org/html/rfc3262#section-5
            //
            // Session Initiation Protocol (SIP) Usage of the Offer/Answer Model
            // https://tools.ietf.org/html/rfc6337
            ////
            ////
            // TODO: The Offer/Answer Model Implementation
            //
            // Currently if `earlyMedia` is enabled and the INVITE request forks,
            // the session is terminated if the early dialog does not match the
            // confirmed dialog. This restriction make sense in a WebRTC environment,
            // but there are other environments where this restriction does not hold.
            //
            // So while we currently cannot make the offer in INVITE+forking+webrtc
            // case work, we propose doing the following...
            //
            // OPTION 1
            // - add a `earlyMediaForking` option and
            // - require SDH.setDescription() to be callable multiple times.
            //
            // OPTION 2
            // 1) modify SDH Factory to provide an initial offer without giving us the SDH, and then...
            // 2) stick that offer in the initial INVITE, and when 183 with initial answer is received...
            // 3) ask SDH Factory if it supports "earlyRemoteAnswer"
            //   a) if true, ask SDH Factory to createSDH(localOffer).then((sdh) => sdh.setDescription(remoteAnswer)
            //   b) if false, defer getting a SDH until 2xx response is received
            //
            // Our supplied WebRTC SDH will default to behavior 3b which works in forking environment (without)
            // early media if initial offer is in the INVITE). We will, however, provide an "inviteWillNotFork"
            // option which if set to "true" will have our supplied WebRTC SDH behave in the 3a manner.
            // That will result in
            //  - early media working with initial offer in the INVITE, and...
            //  - if the INVITE forks, the session terminating with an ERROR that reads like
            //    "You set 'inviteWillNotFork' to true but the INVITE forked. You can't eat your cake, and have it too."
            //  - furthermore, we accept that users will report that error to us as "bug" regardless
            //
            // So, SDH Factory is going to end up with a new interface along the lines of...
            //
            // interface SessionDescriptionHandlerFactory {
            //   makeLocalOffer(): Promise<ContentTypeAndBody>;
            //   makeSessionDescriptionHandler(
            //     initialOffer: ContentTypeAndBody, offerType: "local" | "remote"
            //   ): Promise<SessionDescriptionHandler>;
            //   supportsEarlyRemoteAnswer: boolean;
            //   supportsContentType(contentType: string): boolean;
            //   getDescription(description: ContentTypeAndBody): Promise<ContentTypeAndBody>
            //   setDescription(description: ContentTypeAndBody): Promise<void>
            // }
            ////
            // Send the INVITE request.
            this.outgoingInviteRequest = this.userAgent.userAgentCore.invite(this.outgoingRequestMessage, {
                onAccept: function (inviteResponse) {
                    // Our transaction layer is "non-standard" in that it will only
                    // pass us a 2xx response once per branch, so there is no need to
                    // worry about dealing with 2xx retransmissions. However, we can
                    // and do still get 2xx responses for multiple branches (when an
                    // INVITE is forked) which may create multiple confirmed dialogs.
                    // Herein we are acking and sending a bye to any confirmed dialogs
                    // which arrive beyond the first one. This is the desired behavior
                    // for most applications (but certainly not all).
                    // If we already received a confirmed dialog, ack & bye this additional confirmed session.
                    if (_this.dialog) {
                        _this.logger.log("Additional confirmed dialog, sending ACK and BYE");
                        _this.ackAndBye(inviteResponse);
                        // We do NOT transition state in this case (this is an "extra" dialog)
                        return;
                    }
                    // If the user requested cancellation, ack & bye this session.
                    if (_this.isCanceled) {
                        _this.logger.log("Canceled session accepted, sending ACK and BYE");
                        _this.ackAndBye(inviteResponse);
                        _this.stateTransition(session_state_1.SessionState.Terminated);
                        return;
                    }
                    _this.notifyReferer(inviteResponse);
                    _this.onAccept(inviteResponse)
                        .then(function () {
                        _this.disposeEarlyMedia();
                    })
                        .catch(function (error) {
                        _this.disposeEarlyMedia();
                    })
                        .then(function () {
                        if (options.requestDelegate && options.requestDelegate.onAccept) {
                            options.requestDelegate.onAccept(inviteResponse);
                        }
                    });
                },
                onProgress: function (inviteResponse) {
                    // If the user requested cancellation, ignore response.
                    if (_this.isCanceled) {
                        return;
                    }
                    _this.notifyReferer(inviteResponse);
                    _this.onProgress(inviteResponse)
                        .catch(function (error) {
                        _this.disposeEarlyMedia();
                    })
                        .then(function () {
                        if (options.requestDelegate && options.requestDelegate.onProgress) {
                            options.requestDelegate.onProgress(inviteResponse);
                        }
                    });
                },
                onRedirect: function (inviteResponse) {
                    _this.notifyReferer(inviteResponse);
                    _this.onRedirect(inviteResponse);
                    if (options.requestDelegate && options.requestDelegate.onRedirect) {
                        options.requestDelegate.onRedirect(inviteResponse);
                    }
                },
                onReject: function (inviteResponse) {
                    _this.notifyReferer(inviteResponse);
                    _this.onReject(inviteResponse);
                    if (options.requestDelegate && options.requestDelegate.onReject) {
                        options.requestDelegate.onReject(inviteResponse);
                    }
                },
                onTrying: function (inviteResponse) {
                    _this.notifyReferer(inviteResponse);
                    _this.onTrying(inviteResponse);
                    if (options.requestDelegate && options.requestDelegate.onTrying) {
                        options.requestDelegate.onTrying(inviteResponse);
                    }
                }
            });
            return this.outgoingInviteRequest;
        };
        Inviter.prototype.disposeEarlyMedia = function () {
            this.earlyMediaSessionDescriptionHandlers.forEach(function (sessionDescriptionHandler) {
                sessionDescriptionHandler.close();
            });
            this.earlyMediaSessionDescriptionHandlers.clear();
        };
        Inviter.prototype.notifyReferer = function (response) {
            var _this = this;
            if (!this._referred) {
                return;
            }
            if (!(this._referred instanceof session_1.Session)) {
                throw new Error("Referred session not instance of session");
            }
            if (!this._referred.dialog) {
                return;
            }
            if (!response.message.statusCode) {
                throw new Error("Status code undefined.");
            }
            if (!response.message.reasonPhrase) {
                throw new Error("Reason phrase undefined.");
            }
            var statusCode = response.message.statusCode;
            var reasonPhrase = response.message.reasonPhrase;
            var body = ("SIP/2.0 " + statusCode + " " + reasonPhrase).trim();
            var outgoingNotifyRequest = this._referred.dialog.notify(undefined, {
                extraHeaders: [
                    "Event: refer",
                    "Subscription-State: terminated",
                ],
                body: {
                    contentDisposition: "render",
                    contentType: "message/sipfrag",
                    content: body
                }
            });
            // The implicit subscription created by a REFER is the same as a
            // subscription created with a SUBSCRIBE request.  The agent issuing the
            // REFER can terminate this subscription prematurely by unsubscribing
            // using the mechanisms described in [2].  Terminating a subscription,
            // either by explicitly unsubscribing or rejecting NOTIFY, is not an
            // indication that the referenced request should be withdrawn or
            // abandoned.
            // https://tools.ietf.org/html/rfc3515#section-2.4.4
            // FIXME: TODO: This should be done in a subscribe dialog to satisfy the above.
            // If the notify is rejected, stop sending NOTIFY requests.
            outgoingNotifyRequest.delegate = {
                onReject: function () {
                    _this._referred = undefined;
                }
            };
        };
        /**
         * Handle final response to initial INVITE.
         * @param inviteResponse - 2xx response.
         */
        Inviter.prototype.onAccept = function (inviteResponse) {
            var _this = this;
            this.logger.log("Inviter.onAccept");
            // validate state
            if (this.state !== session_state_1.SessionState.Establishing) {
                this.logger.error("Accept received while in state " + this.state + ", dropping response");
                return Promise.reject(new Error("Invalid session state " + this.state));
            }
            var response = inviteResponse.message;
            var session = inviteResponse.session;
            // Ported behavior.
            if (response.hasHeader("P-Asserted-Identity")) {
                this._assertedIdentity = core_1.Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
            }
            // We have a confirmed dialog.
            session.delegate = {
                onAck: function (ackRequest) { return _this.onAckRequest(ackRequest); },
                onBye: function (byeRequest) { return _this.onByeRequest(byeRequest); },
                onInfo: function (infoRequest) { return _this.onInfoRequest(infoRequest); },
                onInvite: function (inviteRequest) { return _this.onInviteRequest(inviteRequest); },
                onNotify: function (notifyRequest) { return _this.onNotifyRequest(notifyRequest); },
                onPrack: function (prackRequest) { return _this.onPrackRequest(prackRequest); },
                onRefer: function (referRequest) { return _this.onReferRequest(referRequest); }
            };
            this._dialog = session;
            var sdhOptions = this._sessionDescriptionHandlerOptions;
            var sdhModifiers = this._sessionDescriptionHandlerModifiers;
            switch (session.signalingState) {
                case core_1.SignalingState.Initial:
                    // INVITE without offer, so MUST have offer at this point, so invalid state.
                    this.logger.error("Received 2xx response to INVITE without a session description");
                    this.ackAndBye(inviteResponse, 400, "Missing session description");
                    this.stateTransition(session_state_1.SessionState.Terminated);
                    return Promise.reject(new Error("Bad Media Description"));
                case core_1.SignalingState.HaveLocalOffer:
                    // INVITE with offer, so MUST have answer at this point, so invalid state.
                    this.logger.error("Received 2xx response to INVITE without a session description");
                    this.ackAndBye(inviteResponse, 400, "Missing session description");
                    this.stateTransition(session_state_1.SessionState.Terminated);
                    return Promise.reject(new Error("Bad Media Description"));
                case core_1.SignalingState.HaveRemoteOffer: {
                    // INVITE without offer, received offer in 2xx, so MUST send answer in ACK.
                    if (!this._dialog.offer) {
                        throw new Error("Session offer undefined in signaling state " + this._dialog.signalingState + ".");
                    }
                    var options = {
                        sessionDescriptionHandlerOptions: sdhOptions,
                        sessionDescriptionHandlerModifiers: sdhModifiers
                    };
                    return this.setOfferAndGetAnswer(this._dialog.offer, options)
                        .then(function (body) {
                        var ackRequest = inviteResponse.ack({ body: body });
                        _this.stateTransition(session_state_1.SessionState.Established);
                    })
                        .catch(function (error) {
                        _this.ackAndBye(inviteResponse, 488, "Invalid session description");
                        _this.stateTransition(session_state_1.SessionState.Terminated);
                        throw error;
                    });
                }
                case core_1.SignalingState.Stable: {
                    // If INVITE without offer and we have already completed the initial exchange.
                    if (this.earlyMediaSessionDescriptionHandlers.size > 0) {
                        var sdh = this.earlyMediaSessionDescriptionHandlers.get(session.id);
                        if (!sdh) {
                            throw new Error("Session description handler undefined.");
                        }
                        this.setSessionDescriptionHandler(sdh);
                        this.earlyMediaSessionDescriptionHandlers.delete(session.id);
                        var ackRequest = inviteResponse.ack();
                        this.stateTransition(session_state_1.SessionState.Established);
                        return Promise.resolve();
                    }
                    // If INVITE with offer and we used an "early" answer in a provisional response for media
                    if (this.earlyMediaDialog) {
                        // If early media dialog doesn't match confirmed dialog, we must unfortunately fail.
                        // This limitation stems from how WebRTC currently implements its offer/answer model.
                        // There are details elsewhere, but in short a WebRTC offer cannot be forked.
                        if (this.earlyMediaDialog !== session) {
                            if (this.earlyMedia) {
                                var message = "You have set the 'earlyMedia' option to 'true' which requires that your INVITE requests " +
                                    "do not fork and yet this INVITE request did in fact fork. Consequentially and not surprisingly " +
                                    "the end point which accepted the INVITE (confirmed dialog) does not match the end point with " +
                                    "which early media has been setup (early dialog) and thus this session is unable to proceed. " +
                                    "In accordance with the SIP specifications, the SIP servers your end point is connected to " +
                                    "determine if an INVITE forks and the forking behavior of those servers cannot be controlled " +
                                    "by this library. If you wish to use early media with this library you must configure those " +
                                    "servers accordingly. Alternatively you may set the 'earlyMedia' to 'false' which will allow " +
                                    "this library to function with any INVITE requests which do fork.";
                                this.logger.error(message);
                            }
                            var error = new Error("Early media dialog does not equal confirmed dialog, terminating session");
                            this.logger.error(error.message);
                            this.ackAndBye(inviteResponse, 488, "Not Acceptable Here");
                            this.stateTransition(session_state_1.SessionState.Terminated);
                            return Promise.reject(error);
                        }
                        // Otherwise we are good to go.
                        var ackRequest = inviteResponse.ack();
                        this.stateTransition(session_state_1.SessionState.Established);
                        return Promise.resolve();
                    }
                    // If INVITE with offer and we have been waiting till now to apply the answer.
                    var answer = session.answer;
                    if (!answer) {
                        throw new Error("Answer is undefined.");
                    }
                    var options = {
                        sessionDescriptionHandlerOptions: sdhOptions,
                        sessionDescriptionHandlerModifiers: sdhModifiers
                    };
                    return this.setAnswer(answer, options)
                        .then(function () {
                        // This session has completed an initial offer/answer exchange...
                        var ackOptions;
                        if (_this._renderbody && _this._rendertype) {
                            ackOptions = {
                                body: { contentDisposition: "render", contentType: _this._rendertype, content: _this._renderbody }
                            };
                        }
                        var ackRequest = inviteResponse.ack(ackOptions);
                        _this.stateTransition(session_state_1.SessionState.Established);
                    })
                        .catch(function (error) {
                        _this.logger.error(error.message);
                        _this.ackAndBye(inviteResponse, 488, "Not Acceptable Here");
                        _this.stateTransition(session_state_1.SessionState.Terminated);
                        throw error;
                    });
                }
                case core_1.SignalingState.Closed:
                    // Dialog has terminated.
                    return Promise.reject(new Error("Terminated."));
                default:
                    throw new Error("Unknown session signaling state.");
            }
        };
        /**
         * Handle provisional response to initial INVITE.
         * @param inviteResponse - 1xx response.
         */
        Inviter.prototype.onProgress = function (inviteResponse) {
            var _this = this;
            this.logger.log("Inviter.onProgress");
            // validate state
            if (this.state !== session_state_1.SessionState.Establishing) {
                this.logger.error("Progress received while in state " + this.state + ", dropping response");
                return Promise.reject(new Error("Invalid session state " + this.state));
            }
            if (!this.outgoingInviteRequest) {
                throw new Error("Outgoing INVITE request undefined.");
            }
            var response = inviteResponse.message;
            var session = inviteResponse.session;
            // Ported - Set assertedIdentity.
            if (response.hasHeader("P-Asserted-Identity")) {
                this._assertedIdentity = core_1.Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
            }
            // If a provisional response is received for an initial request, and
            // that response contains a Require header field containing the option
            // tag 100rel, the response is to be sent reliably.  If the response is
            // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be
            // ignored, and the procedures below MUST NOT be used.
            // https://tools.ietf.org/html/rfc3262#section-4
            var requireHeader = response.getHeader("require");
            var rseqHeader = response.getHeader("rseq");
            var rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : undefined;
            var responseReliable = !!rseq;
            var extraHeaders = [];
            if (responseReliable) {
                extraHeaders.push("RAck: " + response.getHeader("rseq") + " " + response.getHeader("cseq"));
            }
            var sdhOptions = this._sessionDescriptionHandlerOptions;
            var sdhModifiers = this._sessionDescriptionHandlerModifiers;
            switch (session.signalingState) {
                case core_1.SignalingState.Initial:
                    // INVITE without offer and session still has no offer (and no answer).
                    if (responseReliable) {
                        // Similarly, if a reliable provisional
                        // response is the first reliable message sent back to the UAC, and the
                        // INVITE did not contain an offer, one MUST appear in that reliable
                        // provisional response.
                        // https://tools.ietf.org/html/rfc3262#section-5
                        this.logger.warn("First reliable provisional response received MUST contain an offer when INVITE does not contain an offer.");
                        // FIXME: Known popular UA's currently end up here...
                        inviteResponse.prack({ extraHeaders: extraHeaders });
                    }
                    return Promise.resolve();
                case core_1.SignalingState.HaveLocalOffer:
                    // INVITE with offer and session only has that initial local offer.
                    if (responseReliable) {
                        inviteResponse.prack({ extraHeaders: extraHeaders });
                    }
                    return Promise.resolve();
                case core_1.SignalingState.HaveRemoteOffer:
                    if (!responseReliable) {
                        // The initial offer MUST be in either an INVITE or, if not there,
                        // in the first reliable non-failure message from the UAS back to
                        // the UAC.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.1
                        // According to Section 13.2.1 of [RFC3261], 'The first reliable
                        // non-failure message' must have an offer if there is no offer in the
                        // INVITE request.  This means that the User Agent (UA) that receives
                        // the INVITE request without an offer must include an offer in the
                        // first reliable response with 100rel extension.  If no reliable
                        // provisional response has been sent, the User Agent Server (UAS) must
                        // include an offer when sending 2xx response.
                        // https://tools.ietf.org/html/rfc6337#section-2.2
                        this.logger.warn("Non-reliable provisional response MUST NOT contain an initial offer, discarding response.");
                        return Promise.resolve();
                    }
                    // If the initial offer is in the first reliable non-failure
                    // message from the UAS back to UAC, the answer MUST be in the
                    // acknowledgement for that message
                    var sdh_1 = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions || {});
                    this.earlyMediaSessionDescriptionHandlers.set(session.id, sdh_1);
                    return sdh_1
                        .setDescription(response.body, sdhOptions, sdhModifiers)
                        .then(function () { return sdh_1.getDescription(sdhOptions, sdhModifiers); })
                        .then(function (description) {
                        var body = {
                            contentDisposition: "session", contentType: description.contentType, content: description.body
                        };
                        inviteResponse.prack({ extraHeaders: extraHeaders, body: body });
                    })
                        .catch(function (error) {
                        _this.stateTransition(session_state_1.SessionState.Terminated);
                        throw error;
                    });
                case core_1.SignalingState.Stable:
                    // This session has completed an initial offer/answer exchange, so...
                    // - INVITE with SDP and this provisional response MAY be reliable
                    // - INVITE without SDP and this provisional response MAY be reliable
                    if (responseReliable) {
                        inviteResponse.prack({ extraHeaders: extraHeaders });
                    }
                    if (this.earlyMedia && !this.earlyMediaDialog) {
                        this.earlyMediaDialog = session;
                        var answer = session.answer;
                        if (!answer) {
                            throw new Error("Answer is undefined.");
                        }
                        var options = {
                            sessionDescriptionHandlerOptions: sdhOptions,
                            sessionDescriptionHandlerModifiers: sdhModifiers
                        };
                        return this.setAnswer(answer, options)
                            .catch(function (error) {
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                            throw error;
                        });
                    }
                    return Promise.resolve();
                case core_1.SignalingState.Closed:
                    // Dialog has terminated.
                    return Promise.reject(new Error("Terminated."));
                default:
                    throw new Error("Unknown session signaling state.");
            }
        };
        /**
         * Handle final response to initial INVITE.
         * @param inviteResponse - 3xx response.
         */
        Inviter.prototype.onRedirect = function (inviteResponse) {
            this.logger.log("Inviter.onRedirect");
            // validate state
            if (this.state !== session_state_1.SessionState.Establishing &&
                this.state !== session_state_1.SessionState.Terminating) {
                this.logger.error("Redirect received while in state " + this.state + ", dropping response");
                return;
            }
            // transition state
            this.stateTransition(session_state_1.SessionState.Terminated);
        };
        /**
         * Handle final response to initial INVITE.
         * @param inviteResponse - 4xx, 5xx, or 6xx response.
         */
        Inviter.prototype.onReject = function (inviteResponse) {
            this.logger.log("Inviter.onReject");
            // validate state
            if (this.state !== session_state_1.SessionState.Establishing &&
                this.state !== session_state_1.SessionState.Terminating) {
                this.logger.error("Reject received while in state " + this.state + ", dropping response");
                return;
            }
            // transition state
            this.stateTransition(session_state_1.SessionState.Terminated);
        };
        /**
         * Handle final response to initial INVITE.
         * @param inviteResponse - 100 response.
         */
        Inviter.prototype.onTrying = function (inviteResponse) {
            this.logger.log("Inviter.onTrying");
            // validate state
            if (this.state !== session_state_1.SessionState.Establishing) {
                this.logger.error("Trying received while in state " + this.state + ", dropping response");
                return;
            }
        };
        return Inviter;
    }(session_1.Session));
    exports.Inviter = Inviter;
    
    
    /***/ }),
    
    /***/ "./src/api/message.ts":
    /*!****************************!*\
      !*** ./src/api/message.ts ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A received message (incoming MESSAGE).
     * @public
     */
    var Message = /** @class */ (function () {
        /** @internal */
        function Message(incomingMessageRequest) {
            this.incomingMessageRequest = incomingMessageRequest;
        }
        Object.defineProperty(Message.prototype, "request", {
            /** Incoming MESSAGE request message. */
            get: function () {
                return this.incomingMessageRequest.message;
            },
            enumerable: true,
            configurable: true
        });
        /** Accept the request. */
        Message.prototype.accept = function (options) {
            this.incomingMessageRequest.accept(options);
            return Promise.resolve();
        };
        /** Reject the request. */
        Message.prototype.reject = function (options) {
            this.incomingMessageRequest.reject(options);
            return Promise.resolve();
        };
        return Message;
    }());
    exports.Message = Message;
    
    
    /***/ }),
    
    /***/ "./src/api/messager.ts":
    /*!*****************************!*\
      !*** ./src/api/messager.ts ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var core_1 = __webpack_require__(/*! ../core */ "./src/core/index.ts");
    /**
     * A messager sends a {@link Message} (outgoing MESSAGE).
     * @public
     */
    var Messager = /** @class */ (function () {
        /**
         * Constructs a new instance of the `Messager` class.
         * @param userAgent - User agent. See {@link UserAgent} for details.
         * @param targetURI - Request URI identifying the target of the message.
         * @param content - Content for the body of the message.
         * @param contentType - Content type of the body of the message.
         * @param options - Options bucket. See {@link MessagerOptions} for details.
         */
        function Messager(userAgent, targetURI, content, contentType, options) {
            if (contentType === void 0) { contentType = "text/plain"; }
            if (options === void 0) { options = {}; }
            // Logger
            this.logger = userAgent.getLogger("sip.Messager");
            // Default options params
            options.params = options.params || {};
            // URIs
            var fromURI = userAgent.userAgentCore.configuration.aor;
            if (options.params.fromUri) {
                fromURI =
                    (typeof options.params.fromUri === "string") ?
                        core_1.Grammar.URIParse(options.params.fromUri) :
                        options.params.fromUri;
            }
            if (!fromURI) {
                throw new TypeError("Invalid from URI: " + options.params.fromUri);
            }
            var toURI = targetURI;
            if (options.params.toUri) {
                toURI =
                    (typeof options.params.toUri === "string") ?
                        core_1.Grammar.URIParse(options.params.toUri) :
                        options.params.toUri;
            }
            if (!toURI) {
                throw new TypeError("Invalid to URI: " + options.params.toUri);
            }
            // Message params
            var params = options.params ? tslib_1.__assign({}, options.params) : {};
            // Extra headers
            var extraHeaders = (options.extraHeaders || []).slice();
            // Body
            var contentDisposition = "render";
            var body = {
                contentDisposition: contentDisposition,
                contentType: contentType,
                content: content
            };
            // Build the request
            this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(core_1.C.MESSAGE, targetURI, fromURI, toURI, params, extraHeaders, body);
            // User agent
            this.userAgent = userAgent;
        }
        /**
         * Send the message.
         */
        Messager.prototype.message = function (options) {
            if (options === void 0) { options = {}; }
            this.userAgent.userAgentCore.request(this.request, options.requestDelegate);
            return Promise.resolve();
        };
        return Messager;
    }());
    exports.Messager = Messager;
    
    
    /***/ }),
    
    /***/ "./src/api/notification.ts":
    /*!*********************************!*\
      !*** ./src/api/notification.ts ***!
      \*********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A notification of an event (incoming NOTIFY).
     * @public
     */
    var Notification = /** @class */ (function () {
        /** @internal */
        function Notification(incomingNotifyRequest) {
            this.incomingNotifyRequest = incomingNotifyRequest;
        }
        Object.defineProperty(Notification.prototype, "request", {
            /** Incoming NOTIFY request message. */
            get: function () {
                return this.incomingNotifyRequest.message;
            },
            enumerable: true,
            configurable: true
        });
        /** Accept the request. */
        Notification.prototype.accept = function (options) {
            this.incomingNotifyRequest.accept(options);
            return Promise.resolve();
        };
        /** Reject the request. */
        Notification.prototype.reject = function (options) {
            this.incomingNotifyRequest.reject(options);
            return Promise.resolve();
        };
        return Notification;
    }());
    exports.Notification = Notification;
    
    
    /***/ }),
    
    /***/ "./src/api/publisher-state.ts":
    /*!************************************!*\
      !*** ./src/api/publisher-state.ts ***!
      \************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * {@link Publisher} state.
     * @remarks
     * The {@link Publisher} behaves in a deterministic manner according to the following
     * Finite State Machine (FSM).
     * ```txt
     *                  __________________________________________
     *                 |  __________________________              |
     * Publisher       | |                          v             v
     * Constructed -> Initial -> Published -> Unpublished -> Terminated
     *                              |   ^____________|             ^
     *                              |______________________________|
     * ```
     * @public
     */
    var PublisherState;
    (function (PublisherState) {
        PublisherState["Initial"] = "Initial";
        PublisherState["Published"] = "Published";
        PublisherState["Unpublished"] = "Unpublished";
        PublisherState["Terminated"] = "Terminated";
    })(PublisherState = exports.PublisherState || (exports.PublisherState = {}));
    
    
    /***/ }),
    
    /***/ "./src/api/publisher.ts":
    /*!******************************!*\
      !*** ./src/api/publisher.ts ***!
      \******************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
    var core_1 = __webpack_require__(/*! ../core */ "./src/core/index.ts");
    var utils_1 = __webpack_require__(/*! ../core/messages/utils */ "./src/core/messages/utils.ts");
    var emitter_1 = __webpack_require__(/*! ./emitter */ "./src/api/emitter.ts");
    var publisher_state_1 = __webpack_require__(/*! ./publisher-state */ "./src/api/publisher-state.ts");
    /**
     * A publisher publishes a publication (outgoing PUBLISH).
     * @public
     */
    var Publisher = /** @class */ (function (_super) {
        tslib_1.__extends(Publisher, _super);
        /**
         * Constructs a new instance of the `Publisher` class.
         *
         * @param userAgent - User agent. See {@link UserAgent} for details.
         * @param targetURI - Request URI identifying the target of the message.
         * @param eventType - The event type identifying the published document.
         * @param options - Options bucket. See {@link PublisherOptions} for details.
         */
        function Publisher(userAgent, targetURI, eventType, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this.disposed = false;
            /** The publication state. */
            _this._state = publisher_state_1.PublisherState.Initial;
            /** Emits when the registration state changes. */
            _this._stateEventEmitter = new events_1.EventEmitter();
            _this.userAgent = userAgent;
            options.extraHeaders = (options.extraHeaders || []).slice();
            options.contentType = (options.contentType || "text/plain");
            if (typeof options.expires !== "number" || (options.expires % 1) !== 0) {
                options.expires = 3600;
            }
            else {
                options.expires = Number(options.expires);
            }
            if (typeof (options.unpublishOnClose) !== "boolean") {
                options.unpublishOnClose = true;
            }
            _this.target = targetURI;
            _this.event = eventType;
            _this.options = options;
            _this.pubRequestExpires = _this.options.expires;
            _this.logger = userAgent.getLogger("sip.Publisher");
            var params = options.params || {};
            var fromURI = params.fromUri ? params.fromUri : userAgent.userAgentCore.configuration.aor;
            var toURI = params.toUri ? params.toUri : targetURI;
            var body;
            if (options.body && options.contentType) {
                var contentDisposition = "render";
                var contentType = options.contentType;
                var content = options.body;
                body = {
                    contentDisposition: contentDisposition,
                    contentType: contentType,
                    content: content,
                };
            }
            var extraHeaders = (options.extraHeaders || []).slice();
            // Build the request
            _this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(core_1.C.PUBLISH, targetURI, fromURI, toURI, params, extraHeaders, body);
            // Identifier
            _this.id = _this.target.toString() + ":" + _this.event;
            // Add to the user agent's publisher collection.
            _this.userAgent._publishers[_this.id] = _this;
            return _this;
        }
        /**
         * Destructor.
         */
        Publisher.prototype.dispose = function () {
            if (this.disposed) {
                return Promise.resolve();
            }
            this.disposed = true;
            this.logger.log("Publisher " + this.id + " in state " + this.state + " is being disposed");
            // Remove from the user agent's publisher collection
            delete this.userAgent._publishers[this.id];
            // Send unpublish, if requested
            if (this.options.unpublishOnClose && this.state === publisher_state_1.PublisherState.Published) {
                return this.unpublish();
            }
            if (this.publishRefreshTimer) {
                clearTimeout(this.publishRefreshTimer);
                this.publishRefreshTimer = undefined;
            }
            this.pubRequestBody = undefined;
            this.pubRequestExpires = 0;
            this.pubRequestEtag = undefined;
            return Promise.resolve();
        };
        Object.defineProperty(Publisher.prototype, "state", {
            /** The publication state. */
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Publisher.prototype, "stateChange", {
            /** Emits when the publisher state changes. */
            get: function () {
                return emitter_1._makeEmitter(this._stateEventEmitter);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Publish.
         * @param content - Body to publish
         */
        Publisher.prototype.publish = function (content, options) {
            if (options === void 0) { options = {}; }
            // Clean up before the run
            if (this.publishRefreshTimer) {
                clearTimeout(this.publishRefreshTimer);
                this.publishRefreshTimer = undefined;
            }
            // is Initial or Modify request
            this.options.body = content;
            this.pubRequestBody = this.options.body;
            if (this.pubRequestExpires === 0) {
                // This is Initial request after unpublish
                this.pubRequestExpires = this.options.expires;
                this.pubRequestEtag = undefined;
            }
            this.sendPublishRequest();
            return Promise.resolve();
        };
        /**
         * Unpublish.
         */
        Publisher.prototype.unpublish = function (options) {
            if (options === void 0) { options = {}; }
            // Clean up before the run
            if (this.publishRefreshTimer) {
                clearTimeout(this.publishRefreshTimer);
                this.publishRefreshTimer = undefined;
            }
            this.pubRequestBody = undefined;
            this.pubRequestExpires = 0;
            if (this.pubRequestEtag !== undefined) {
                this.sendPublishRequest();
            }
            return Promise.resolve();
        };
        /** @internal */
        Publisher.prototype.receiveResponse = function (response) {
            var _this = this;
            var statusCode = response.statusCode || 0;
            var cause = utils_1.getReasonPhrase(statusCode);
            switch (true) {
                case /^1[0-9]{2}$/.test(statusCode.toString()):
                    this.emit("progress", response, cause);
                    break;
                case /^2[0-9]{2}$/.test(statusCode.toString()):
                    // Set SIP-Etag
                    if (response.hasHeader("SIP-ETag")) {
                        this.pubRequestEtag = response.getHeader("SIP-ETag");
                    }
                    else {
                        this.logger.warn("SIP-ETag header missing in a 200-class response to PUBLISH");
                    }
                    // Update Expire
                    if (response.hasHeader("Expires")) {
                        var expires = Number(response.getHeader("Expires"));
                        if (typeof expires === "number" && expires >= 0 && expires <= this.pubRequestExpires) {
                            this.pubRequestExpires = expires;
                        }
                        else {
                            this.logger.warn("Bad Expires header in a 200-class response to PUBLISH");
                        }
                    }
                    else {
                        this.logger.warn("Expires header missing in a 200-class response to PUBLISH");
                    }
                    if (this.pubRequestExpires !== 0) {
                        // Schedule refresh
                        this.publishRefreshTimer = setTimeout(function () { return _this.refreshRequest(); }, this.pubRequestExpires * 900);
                        this.stateTransition(publisher_state_1.PublisherState.Published);
                    }
                    else {
                        this.stateTransition(publisher_state_1.PublisherState.Unpublished);
                    }
                    break;
                case /^412$/.test(statusCode.toString()):
                    // 412 code means no matching ETag - possibly the PUBLISH expired
                    // Resubmit as new request, if the current request is not a "remove"
                    if (this.pubRequestEtag !== undefined && this.pubRequestExpires !== 0) {
                        this.logger.warn("412 response to PUBLISH, recovering");
                        this.pubRequestEtag = undefined;
                        this.emit("progress", response, cause);
                        this.publish(this.options.body);
                    }
                    else {
                        this.logger.warn("412 response to PUBLISH, recovery failed");
                        this.pubRequestExpires = 0;
                        this.stateTransition(publisher_state_1.PublisherState.Unpublished);
                        this.stateTransition(publisher_state_1.PublisherState.Terminated);
                    }
                    break;
                case /^423$/.test(statusCode.toString()):
                    // 423 code means we need to adjust the Expires interval up
                    if (this.pubRequestExpires !== 0 && response.hasHeader("Min-Expires")) {
                        var minExpires = Number(response.getHeader("Min-Expires"));
                        if (typeof minExpires === "number" || minExpires > this.pubRequestExpires) {
                            this.logger.warn("423 code in response to PUBLISH, adjusting the Expires value and trying to recover");
                            this.pubRequestExpires = minExpires;
                            this.emit("progress", response, cause);
                            this.publish(this.options.body);
                        }
                        else {
                            this.logger.warn("Bad 423 response Min-Expires header received for PUBLISH");
                            this.pubRequestExpires = 0;
                            this.stateTransition(publisher_state_1.PublisherState.Unpublished);
                            this.stateTransition(publisher_state_1.PublisherState.Terminated);
                        }
                    }
                    else {
                        this.logger.warn("423 response to PUBLISH, recovery failed");
                        this.pubRequestExpires = 0;
                        this.stateTransition(publisher_state_1.PublisherState.Unpublished);
                        this.stateTransition(publisher_state_1.PublisherState.Terminated);
                    }
                    break;
                default:
                    this.pubRequestExpires = 0;
                    this.stateTransition(publisher_state_1.PublisherState.Unpublished);
                    this.stateTransition(publisher_state_1.PublisherState.Terminated);
                    break;
            }
            // Do the cleanup
            if (this.pubRequestExpires === 0) {
                if (this.publishRefreshTimer) {
                    clearTimeout(this.publishRefreshTimer);
                    this.publishRefreshTimer = undefined;
                }
                this.pubRequestBody = undefined;
                this.pubRequestEtag = undefined;
            }
        };
        /** @internal */
        Publisher.prototype.send = function () {
            var _this = this;
            return this.userAgent.userAgentCore.publish(this.request, {
                onAccept: function (response) { return _this.receiveResponse(response.message); },
                onProgress: function (response) { return _this.receiveResponse(response.message); },
                onRedirect: function (response) { return _this.receiveResponse(response.message); },
                onReject: function (response) { return _this.receiveResponse(response.message); },
                onTrying: function (response) { return _this.receiveResponse(response.message); }
            });
        };
        Publisher.prototype.refreshRequest = function () {
            // Clean up before the run
            if (this.publishRefreshTimer) {
                clearTimeout(this.publishRefreshTimer);
                this.publishRefreshTimer = undefined;
            }
            // This is Refresh request
            this.pubRequestBody = undefined;
            if (this.pubRequestEtag === undefined) {
                throw new Error("Etag undefined");
            }
            if (this.pubRequestExpires === 0) {
                throw new Error("Expires zero");
            }
            this.sendPublishRequest();
        };
        Publisher.prototype.sendPublishRequest = function () {
            var reqOptions = Object.create(this.options || Object.prototype);
            reqOptions.extraHeaders = (this.options.extraHeaders || []).slice();
            reqOptions.extraHeaders.push("Event: " + this.event);
            reqOptions.extraHeaders.push("Expires: " + this.pubRequestExpires);
            if (this.pubRequestEtag !== undefined) {
                reqOptions.extraHeaders.push("SIP-If-Match: " + this.pubRequestEtag);
            }
            var ruri = this.target;
            var params = this.options.params || {};
            var bodyAndContentType;
            if (this.pubRequestBody !== undefined) {
                bodyAndContentType = {
                    body: this.pubRequestBody,
                    contentType: this.options.contentType
                };
            }
            var body;
            if (bodyAndContentType) {
                body = core_1.fromBodyLegacy(bodyAndContentType);
            }
            this.request = this.userAgent.userAgentCore.makeOutgoingRequestMessage(core_1.C.PUBLISH, ruri, params.fromUri ? params.fromUri : this.userAgent.userAgentCore.configuration.aor, params.toUri ? params.toUri : this.target, params, reqOptions.extraHeaders, body);
            return this.send();
        };
        /**
         * Transition publication state.
         */
        Publisher.prototype.stateTransition = function (newState) {
            var _this = this;
            var invalidTransition = function () {
                throw new Error("Invalid state transition from " + _this._state + " to " + newState);
            };
            // Validate transition
            switch (this._state) {
                case publisher_state_1.PublisherState.Initial:
                    if (newState !== publisher_state_1.PublisherState.Published &&
                        newState !== publisher_state_1.PublisherState.Unpublished &&
                        newState !== publisher_state_1.PublisherState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case publisher_state_1.PublisherState.Published:
                    if (newState !== publisher_state_1.PublisherState.Unpublished &&
                        newState !== publisher_state_1.PublisherState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case publisher_state_1.PublisherState.Unpublished:
                    if (newState !== publisher_state_1.PublisherState.Published &&
                        newState !== publisher_state_1.PublisherState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case publisher_state_1.PublisherState.Terminated:
                    invalidTransition();
                    break;
                default:
                    throw new Error("Unrecognized state.");
            }
            // Transition
            this._state = newState;
            this.logger.log("Publication transitioned to state " + this._state);
            this._stateEventEmitter.emit("event", this._state);
            // Dispose
            if (newState === publisher_state_1.PublisherState.Terminated) {
                this.dispose();
            }
        };
        return Publisher;
    }(events_1.EventEmitter));
    exports.Publisher = Publisher;
    
    
    /***/ }),
    
    /***/ "./src/api/referral.ts":
    /*!*****************************!*\
      !*** ./src/api/referral.ts ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = __webpack_require__(/*! ../core */ "./src/core/index.ts");
    /**
     * A request to establish a {@link Session} elsewhere (incoming REFER).
     * @public
     */
    var Referral = /** @class */ (function () {
        /** @internal */
        function Referral(incomingReferRequest, session) {
            this.incomingReferRequest = incomingReferRequest;
            this.session = session;
        }
        Object.defineProperty(Referral.prototype, "referTo", {
            get: function () {
                var referTo = this.incomingReferRequest.message.parseHeader("refer-to");
                if (!(referTo instanceof core_1.NameAddrHeader)) {
                    throw new Error("Failed to parse Refer-To header.");
                }
                return referTo;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Referral.prototype, "referredBy", {
            get: function () {
                return this.incomingReferRequest.message.getHeader("referred-by");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Referral.prototype, "replaces", {
            get: function () {
                return this.referTo.uri.getHeader("replaces");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Referral.prototype, "request", {
            /** Incoming REFER request message. */
            get: function () {
                return this.incomingReferRequest.message;
            },
            enumerable: true,
            configurable: true
        });
        /** Accept the request. */
        Referral.prototype.accept = function (options) {
            if (options === void 0) { options = { statusCode: 202 }; }
            this.incomingReferRequest.accept(options);
            return Promise.resolve();
        };
        /** Reject the request. */
        Referral.prototype.reject = function (options) {
            this.incomingReferRequest.reject(options);
            return Promise.resolve();
        };
        /**
         * Creates an inviter which may be used to send an out of dialog INVITE request.
         *
         * @remarks
         * This a helper method to create an Inviter which will execute the referral
         * of the `Session` which was referred. The appropriate headers are set and
         * the referred `Session` is linked to the new `Session`. Note that only a
         * single instance of the `Inviter` will be created and returned (if called
         * more than once a reference to the same `Inviter` will be returned every time).
         *
         * @param options - Options bucket.
         * @param modifiers - Session description handler modifiers.
         */
        Referral.prototype.makeInviter = function (options) {
            if (this.inviter) {
                return this.inviter;
            }
            var targetURI = this.referTo.uri.clone();
            targetURI.clearHeaders();
            options = options || {};
            var extraHeaders = (options.extraHeaders || []).slice();
            var replaces = this.replaces;
            if (replaces) {
                // decodeURIComponent is a holdover from 2c086eb4. Not sure that it is actually necessary
                extraHeaders.push("Replaces: " + decodeURIComponent(replaces));
            }
            var referredBy = this.referredBy;
            if (referredBy) {
                extraHeaders.push("Referred-By: " + referredBy);
            }
            options.extraHeaders = extraHeaders;
            this.inviter = this.session.userAgent._makeInviter(targetURI, options);
            this.inviter._referred = this.session;
            this.session._referral = this.inviter;
            return this.inviter;
        };
        return Referral;
    }());
    exports.Referral = Referral;
    
    
    /***/ }),
    
    /***/ "./src/api/referrer.ts":
    /*!*****************************!*\
      !*** ./src/api/referrer.ts ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = __webpack_require__(/*! ../core */ "./src/core/index.ts");
    var session_state_1 = __webpack_require__(/*! ./session-state */ "./src/api/session-state.ts");
    /**
     * A referrer sends a {@link Referral} (outgoing REFER).
     * @remarks
     * Sends an outgoing in dialog REFER request.
     * @public
     */
    var Referrer = /** @class */ (function () {
        /**
         * Constructs a new instance of the `Referrer` class.
         * @param session - The session the REFER will be sent from. See {@link Session} for details.
         * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.
         * @param options - An options bucket. See {@link ReferrerOptions} for details.
         */
        function Referrer(session, referTo, options) {
            this.logger = session.userAgent.getLogger("sip.Referrer");
            this._session = session;
            this._referTo = referTo;
        }
        Object.defineProperty(Referrer.prototype, "session", {
            /** The referrer session. */
            get: function () {
                return this._session;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sends the REFER request.
         * @param options - An options bucket.
         */
        Referrer.prototype.refer = function (options) {
            if (options === void 0) { options = {}; }
            // guard session state
            if (this.session.state !== session_state_1.SessionState.Established) {
                var message = "Referrer.refer() may only be called if established session.";
                this.logger.error(message);
                return Promise.reject(new Error("Invalid session state " + this.session.state));
            }
            var requestDelegate = options.requestDelegate;
            var requestOptions = options.requestOptions || {};
            var extraHeaders = this.extraHeaders(this.referToString(this._referTo));
            requestOptions.extraHeaders = requestOptions.extraHeaders || [];
            requestOptions.extraHeaders = requestOptions.extraHeaders.concat(extraHeaders);
            return this.session.refer(this, requestDelegate, requestOptions);
        };
        Referrer.prototype.extraHeaders = function (referTo) {
            var extraHeaders = [];
            extraHeaders.push("Referred-By: <" + this._session.userAgent.configuration.uri + ">");
            extraHeaders.push("Contact: " + this._session._contact);
            extraHeaders.push("Allow: " + [
                "ACK",
                "CANCEL",
                "INVITE",
                "MESSAGE",
                "BYE",
                "OPTIONS",
                "INFO",
                "NOTIFY",
                "REFER"
            ].toString());
            extraHeaders.push("Refer-To: " + referTo);
            return extraHeaders;
        };
        Referrer.prototype.referToString = function (target) {
            var referTo;
            if (target instanceof core_1.URI) {
                // REFER without Replaces (Blind Transfer)
                referTo = target.toString();
            }
            else {
                // REFER with Replaces (Attended Transfer)
                if (!target.dialog) {
                    throw new Error("Dialog undefined.");
                }
                var displayName = target.remoteIdentity.friendlyName;
                var remoteTarget = target.dialog.remoteTarget.toString();
                var callId = target.dialog.callId;
                var remoteTag = target.dialog.remoteTag;
                var localTag = target.dialog.localTag;
                var replaces = encodeURIComponent(callId + ";to-tag=" + remoteTag + ";from-tag=" + localTag);
                referTo = "\"" + displayName + "\" <" + remoteTarget + "?Replaces=" + replaces + ">";
            }
            return referTo;
        };
        return Referrer;
    }());
    exports.Referrer = Referrer;
    
    
    /***/ }),
    
    /***/ "./src/api/registerer-state.ts":
    /*!*************************************!*\
      !*** ./src/api/registerer-state.ts ***!
      \*************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * {@link Registerer} state.
     * @remarks
     * The {@link Registerer} behaves in a deterministic manner according to the following
     * Finite State Machine (FSM).
     * ```txt
     *                   __________________________________________
     *                  |  __________________________              |
     * Registerer       | |                          v             v
     * Constructed -> Initial -> Registered -> Unregistered -> Terminated
     *                              |   ^____________|             ^
     *                              |______________________________|
     * ```
     * @public
     */
    var RegistererState;
    (function (RegistererState) {
        RegistererState["Initial"] = "Initial";
        RegistererState["Registered"] = "Registered";
        RegistererState["Unregistered"] = "Unregistered";
        RegistererState["Terminated"] = "Terminated";
    })(RegistererState = exports.RegistererState || (exports.RegistererState = {}));
    
    
    /***/ }),
    
    /***/ "./src/api/registerer.ts":
    /*!*******************************!*\
      !*** ./src/api/registerer.ts ***!
      \*******************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
    var core_1 = __webpack_require__(/*! ../core */ "./src/core/index.ts");
    var emitter_1 = __webpack_require__(/*! ./emitter */ "./src/api/emitter.ts");
    var exceptions_1 = __webpack_require__(/*! ./exceptions */ "./src/api/exceptions/index.ts");
    var registerer_state_1 = __webpack_require__(/*! ./registerer-state */ "./src/api/registerer-state.ts");
    /**
     * A registerer registers a contact for an address of record (outgoing REGISTER).
     * @public
     */
    var Registerer = /** @class */ (function () {
        /**
         * Constructs a new instance of the `Registerer` class.
         * @param userAgent - User agent. See {@link UserAgent} for details.
         * @param options - Options bucket. See {@link RegistererOptions} for details.
         */
        function Registerer(userAgent, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            this.disposed = false;
            /** The contacts returned from the most recent accepted REGISTER request. */
            this._contacts = [];
            /** The registration state. */
            this._state = registerer_state_1.RegistererState.Initial;
            /** Emits when the registration state changes. */
            this._stateEventEmitter = new events_1.EventEmitter();
            /** True is waiting for final response to outstanding REGISTER request. */
            this._waiting = false;
            /** Emits when waiting changes. */
            this._waitingEventEmitter = new events_1.EventEmitter();
            // Set user agent
            this.userAgent = userAgent;
            // Default registrar is domain portion of user agent uri
            var defaultUserAgentRegistrar = userAgent.configuration.uri.clone();
            defaultUserAgentRegistrar.user = undefined;
            // Initialize configuration
            this.options = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, Registerer.defaultOptions), { registrar: defaultUserAgentRegistrar }), Registerer.stripUndefinedProperties(options));
            // Make sure we are not using references to array options
            this.options.extraContactHeaderParams = (this.options.extraContactHeaderParams || []).slice();
            this.options.extraHeaders = (this.options.extraHeaders || []).slice();
            // Make sure we are not using references to registrar uri
            if (!this.options.registrar) {
                throw new Error("Registrar undefined.");
            }
            this.options.registrar = this.options.registrar.clone();
            // Set instanceId and regId conditional defaults and validate
            if (this.options.regId && !this.options.instanceId) {
                this.options.instanceId = Registerer.newUUID();
            }
            else if (!this.options.regId && this.options.instanceId) {
                this.options.regId = 1;
            }
            if (this.options.instanceId && core_1.Grammar.parse(this.options.instanceId, "uuid") === -1) {
                throw new Error("Invalid instanceId.");
            }
            if (this.options.regId && this.options.regId < 0) {
                throw new Error("Invalid regId.");
            }
            var registrar = this.options.registrar;
            var fromURI = (this.options.params && this.options.params.fromUri) || userAgent.userAgentCore.configuration.aor;
            var toURI = (this.options.params && this.options.params.toUri) || userAgent.configuration.uri;
            var params = this.options.params || {};
            var extraHeaders = (options.extraHeaders || []).slice();
            // Build the request
            this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(core_1.C.REGISTER, registrar, fromURI, toURI, params, extraHeaders, undefined);
            // Registration expires
            this.expires = this.options.expires || Registerer.defaultOptions.expires;
            if (this.expires < 0) {
                throw new Error("Invalid expires.");
            }
            // initialize logger
            this.logger = userAgent.getLogger("sip.Registerer");
            if (this.options.logConfiguration) {
                this.logger.log("Configuration:");
                Object.keys(this.options).forEach(function (key) {
                    var value = _this.options[key];
                    switch (key) {
                        case "registrar":
                            _this.logger.log(" " + key + ": " + value);
                            break;
                        default:
                            _this.logger.log(" " + key + ": " + JSON.stringify(value));
                    }
                });
            }
            // Identifier
            this.id = this.request.callId + this.request.from.parameters.tag;
            // Add to the user agent's session collection.
            this.userAgent._registerers[this.id] = this;
        }
        // http://stackoverflow.com/users/109538/broofa
        Registerer.newUUID = function () {
            var UUID = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
                var r = Math.floor(Math.random() * 16);
                var v = c === "x" ? r : (r % 4 + 8);
                return v.toString(16);
            });
            return UUID;
        };
        /**
         * Strip properties with undefined values from options.
         * This is a work around while waiting for missing vs undefined to be addressed (or not)...
         * https://github.com/Microsoft/TypeScript/issues/13195
         * @param options - Options to reduce
         */
        Registerer.stripUndefinedProperties = function (options) {
            return Object.keys(options).reduce(function (object, key) {
                if (options[key] !== undefined) {
                    object[key] = options[key];
                }
                return object;
            }, {});
        };
        Object.defineProperty(Registerer.prototype, "contacts", {
            /** The registered contacts. */
            get: function () {
                return this._contacts.slice();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Registerer.prototype, "state", {
            /** The registration state. */
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Registerer.prototype, "stateChange", {
            /** Emits when the registerer state changes. */
            get: function () {
                return emitter_1._makeEmitter(this._stateEventEmitter);
            },
            enumerable: true,
            configurable: true
        });
        /** Destructor. */
        Registerer.prototype.dispose = function () {
            var _this = this;
            if (this.disposed) {
                return Promise.resolve();
            }
            this.disposed = true;
            this.logger.log("Registerer " + this.id + " in state " + this.state + " is being disposed");
            // Remove from the user agent's registerer collection
            delete this.userAgent._registerers[this.id];
            // If registered, unregisters and resolves after final response received.
            return new Promise(function (resolve, reject) {
                var doClose = function () {
                    // If we are registered, unregister and resolve after our state changes
                    if (!_this.waiting && _this._state === registerer_state_1.RegistererState.Registered) {
                        _this.stateChange.addListener(function () {
                            _this.terminated();
                            resolve();
                        }, { once: true });
                        _this.unregister();
                        return;
                    }
                    // Otherwise just resolve
                    _this.terminated();
                    resolve();
                };
                // If we are waiting for an outstanding request, wait for it to finish and then try closing.
                // Otherwise just try closing.
                if (_this.waiting) {
                    _this.waitingChange.addListener(function () { return doClose(); }, { once: true });
                }
                else {
                    doClose();
                }
            });
        };
        /**
         * Sends the REGISTER request.
         * @remarks
         * If successful, sends re-REGISTER requests prior to registration expiration until `unsubscribe()` is called.
         * Rejects with `RequestPendingError` if a REGISTER request is already in progress.
         */
        Registerer.prototype.register = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            // UAs MUST NOT send a new registration (that is, containing new Contact
            // header field values, as opposed to a retransmission) until they have
            // received a final response from the registrar for the previous one or
            // the previous REGISTER request has timed out.
            // https://tools.ietf.org/html/rfc3261#section-10.2
            if (this.waiting) {
                var error = new exceptions_1.RequestPendingError("REGISTER request already in progress, waiting for final response");
                return Promise.reject(error);
            }
            // Options
            if (options.requestOptions) {
                this.options = tslib_1.__assign(tslib_1.__assign({}, this.options), options.requestOptions);
            }
            // Extra headers
            var extraHeaders = (this.options.extraHeaders || []).slice();
            extraHeaders.push("Contact: " + this.generateContactHeader(this.expires));
            // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
            extraHeaders.push("Allow: " + [
                "ACK",
                "CANCEL",
                "INVITE",
                "MESSAGE",
                "BYE",
                "OPTIONS",
                "INFO",
                "NOTIFY",
                "REFER"
            ].toString());
            // Call-ID: All registrations from a UAC SHOULD use the same Call-ID
            // header field value for registrations sent to a particular
            // registrar.
            //
            // CSeq: The CSeq value guarantees proper ordering of REGISTER
            // requests.  A UA MUST increment the CSeq value by one for each
            // REGISTER request with the same Call-ID.
            // https://tools.ietf.org/html/rfc3261#section-10.2
            this.request.cseq++;
            this.request.setHeader("cseq", this.request.cseq + " REGISTER");
            this.request.extraHeaders = extraHeaders;
            this.waitingToggle(true);
            var outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {
                onAccept: function (response) {
                    var expires;
                    // FIXME: This does NOT appear to be to spec and should be removed.
                    // I haven't found anywhere that an Expires header may be used in a response.
                    if (response.message.hasHeader("expires")) {
                        expires = Number(response.message.getHeader("expires"));
                    }
                    // 8. The registrar returns a 200 (OK) response.  The response MUST
                    // contain Contact header field values enumerating all current
                    // bindings.  Each Contact value MUST feature an "expires"
                    // parameter indicating its expiration interval chosen by the
                    // registrar.  The response SHOULD include a Date header field.
                    // https://tools.ietf.org/html/rfc3261#section-10.3
                    _this._contacts = response.message.getHeaders("contact");
                    var contacts = _this._contacts.length;
                    if (!contacts) {
                        _this.logger.error("No Contact header in response to REGISTER, dropping response.");
                        _this.unregistered();
                        return;
                    }
                    // The 200 (OK) response from the registrar contains a list of Contact
                    // fields enumerating all current bindings.  The UA compares each
                    // contact address to see if it created the contact address, using
                    // comparison rules in Section 19.1.4.  If so, it updates the expiration
                    // time interval according to the expires parameter or, if absent, the
                    // Expires field value.  The UA then issues a REGISTER request for each
                    // of its bindings before the expiration interval has elapsed.
                    // https://tools.ietf.org/html/rfc3261#section-10.2.4
                    var contact;
                    while (contacts--) {
                        contact = response.message.parseHeader("contact", contacts);
                        if (contact.uri.user === _this.userAgent.contact.uri.user) {
                            expires = contact.getParam("expires");
                            break;
                        }
                        else {
                            contact = undefined;
                        }
                    }
                    // There must be a matching contact.
                    if (contact === undefined) {
                        _this.logger.error("No Contact header pointing to us, dropping response");
                        _this.unregistered();
                        _this.waitingToggle(false);
                        return;
                    }
                    // The contact must have an expires.
                    if (expires === undefined) {
                        _this.logger.error("Contact pointing to us is missing expires parameter, dropping response");
                        _this.unregistered();
                        _this.waitingToggle(false);
                        return;
                    }
                    // Save gruu values
                    if (contact.hasParam("temp-gruu")) {
                        _this.userAgent.contact.tempGruu = core_1.Grammar.URIParse(contact.getParam("temp-gruu").replace(/"/g, ""));
                    }
                    if (contact.hasParam("pub-gruu")) {
                        _this.userAgent.contact.pubGruu = core_1.Grammar.URIParse(contact.getParam("pub-gruu").replace(/"/g, ""));
                    }
                    _this.registered(expires);
                    if (options.requestDelegate && options.requestDelegate.onAccept) {
                        options.requestDelegate.onAccept(response);
                    }
                    _this.waitingToggle(false);
                },
                onProgress: function (response) {
                    if (options.requestDelegate && options.requestDelegate.onProgress) {
                        options.requestDelegate.onProgress(response);
                    }
                },
                onRedirect: function (response) {
                    _this.logger.error("Redirect received. Not supported.");
                    _this.unregistered();
                    if (options.requestDelegate && options.requestDelegate.onRedirect) {
                        options.requestDelegate.onRedirect(response);
                    }
                    _this.waitingToggle(false);
                },
                onReject: function (response) {
                    if (response.message.statusCode === 423) {
                        // If a UA receives a 423 (Interval Too Brief) response, it MAY retry
                        // the registration after making the expiration interval of all contact
                        // addresses in the REGISTER request equal to or greater than the
                        // expiration interval within the Min-Expires header field of the 423
                        // (Interval Too Brief) response.
                        // https://tools.ietf.org/html/rfc3261#section-10.2.8
                        //
                        // The registrar MAY choose an expiration less than the requested
                        // expiration interval.  If and only if the requested expiration
                        // interval is greater than zero AND smaller than one hour AND
                        // less than a registrar-configured minimum, the registrar MAY
                        // reject the registration with a response of 423 (Interval Too
                        // Brief).  This response MUST contain a Min-Expires header field
                        // that states the minimum expiration interval the registrar is
                        // willing to honor.  It then skips the remaining steps.
                        // https://tools.ietf.org/html/rfc3261#section-10.3
                        if (!response.message.hasHeader("min-expires")) {
                            // This response MUST contain a Min-Expires header field
                            _this.logger.error("423 response received for REGISTER without Min-Expires, dropping response");
                            _this.unregistered();
                            _this.waitingToggle(false);
                            return;
                        }
                        // Increase our registration interval to the suggested minimum
                        _this.expires = Number(response.message.getHeader("min-expires"));
                        // Attempt the registration again immediately
                        _this.waitingToggle(false);
                        _this.register();
                        return;
                    }
                    _this.logger.warn("Failed to register, status code " + response.message.statusCode);
                    _this.unregistered();
                    if (options.requestDelegate && options.requestDelegate.onReject) {
                        options.requestDelegate.onReject(response);
                    }
                    _this.waitingToggle(false);
                },
                onTrying: function (response) {
                    if (options.requestDelegate && options.requestDelegate.onTrying) {
                        options.requestDelegate.onTrying(response);
                    }
                }
            });
            return Promise.resolve(outgoingRegisterRequest);
        };
        /**
         * Sends the REGISTER request with expires equal to zero.
         * Rejects with `RequestPendingError` if a REGISTER request is already in progress.
         */
        Registerer.prototype.unregister = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            // UAs MUST NOT send a new registration (that is, containing new Contact
            // header field values, as opposed to a retransmission) until they have
            // received a final response from the registrar for the previous one or
            // the previous REGISTER request has timed out.
            // https://tools.ietf.org/html/rfc3261#section-10.2
            if (this.waiting) {
                var error = new exceptions_1.RequestPendingError("REGISTER request already in progress, waiting for final response");
                return Promise.reject(error);
            }
            if (this._state !== registerer_state_1.RegistererState.Registered && !options.all) {
                this.logger.warn("Not currently registered, but sending an unregister anyway.");
            }
            // Extra headers
            var extraHeaders = (options.requestOptions && options.requestOptions.extraHeaders || []).slice();
            this.request.extraHeaders = extraHeaders;
            // Registrations are soft state and expire unless refreshed, but can
            // also be explicitly removed.  A client can attempt to influence the
            // expiration interval selected by the registrar as described in Section
            // 10.2.1.  A UA requests the immediate removal of a binding by
            // specifying an expiration interval of "0" for that contact address in
            // a REGISTER request.  UAs SHOULD support this mechanism so that
            // bindings can be removed before their expiration interval has passed.
            //
            // The REGISTER-specific Contact header field value of "*" applies to
            // all registrations, but it MUST NOT be used unless the Expires header
            // field is present with a value of "0".
            // https://tools.ietf.org/html/rfc3261#section-10.2.2
            if (options.all) {
                extraHeaders.push("Contact: *");
                extraHeaders.push("Expires: 0");
            }
            else {
                extraHeaders.push("Contact: " + this.generateContactHeader(0));
            }
            // Call-ID: All registrations from a UAC SHOULD use the same Call-ID
            // header field value for registrations sent to a particular
            // registrar.
            //
            // CSeq: The CSeq value guarantees proper ordering of REGISTER
            // requests.  A UA MUST increment the CSeq value by one for each
            // REGISTER request with the same Call-ID.
            // https://tools.ietf.org/html/rfc3261#section-10.2
            this.request.cseq++;
            this.request.setHeader("cseq", this.request.cseq + " REGISTER");
            // Pre-emptive clear the registration timer to avoid a race condition where
            // this timer fires while waiting for a final response to the unsubscribe.
            if (this.registrationTimer !== undefined) {
                clearTimeout(this.registrationTimer);
                this.registrationTimer = undefined;
            }
            this.waitingToggle(true);
            var outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {
                onAccept: function (response) {
                    _this._contacts = response.message.getHeaders("contact"); // Update contacts
                    _this.unregistered();
                    if (options.requestDelegate && options.requestDelegate.onAccept) {
                        options.requestDelegate.onAccept(response);
                    }
                    _this.waitingToggle(false);
                },
                onProgress: function (response) {
                    if (options.requestDelegate && options.requestDelegate.onProgress) {
                        options.requestDelegate.onProgress(response);
                    }
                },
                onRedirect: function (response) {
                    _this.logger.error("Unregister redirected. Not currently supported.");
                    _this.unregistered();
                    if (options.requestDelegate && options.requestDelegate.onRedirect) {
                        options.requestDelegate.onRedirect(response);
                    }
                    _this.waitingToggle(false);
                },
                onReject: function (response) {
                    _this.logger.error("Unregister rejected with status code " + response.message.statusCode);
                    _this.unregistered();
                    if (options.requestDelegate && options.requestDelegate.onReject) {
                        options.requestDelegate.onReject(response);
                    }
                    _this.waitingToggle(false);
                },
                onTrying: function (response) {
                    if (options.requestDelegate && options.requestDelegate.onTrying) {
                        options.requestDelegate.onTrying(response);
                    }
                }
            });
            return Promise.resolve(outgoingRegisterRequest);
        };
        /**
         * Clear registration timers.
         */
        Registerer.prototype.clearTimers = function () {
            if (this.registrationTimer !== undefined) {
                clearTimeout(this.registrationTimer);
                this.registrationTimer = undefined;
            }
            if (this.registrationExpiredTimer !== undefined) {
                clearTimeout(this.registrationExpiredTimer);
                this.registrationExpiredTimer = undefined;
            }
        };
        /**
         * Generate Contact Header
         */
        Registerer.prototype.generateContactHeader = function (expires) {
            var contact = this.userAgent.contact.toString();
            if (this.options.regId && this.options.instanceId) {
                contact += ";reg-id=" + this.options.regId;
                contact += ';+sip.instance="<urn:uuid:' + this.options.instanceId + '>"';
            }
            if (this.options.extraContactHeaderParams) {
                this.options.extraContactHeaderParams.forEach(function (header) {
                    contact += ";" + header;
                });
            }
            contact += ";expires=" + expires;
            return contact;
        };
        /**
         * Helper function, called when registered.
         */
        Registerer.prototype.registered = function (expires) {
            var _this = this;
            this.clearTimers();
            // Re-Register before the expiration interval has elapsed.
            // For that, decrease the expires value. ie: 3 seconds
            this.registrationTimer = setTimeout(function () {
                _this.registrationTimer = undefined;
                _this.register();
            }, (expires * 1000) - 3000);
            // We are unregistered if the registration expires.
            this.registrationExpiredTimer = setTimeout(function () {
                _this.logger.warn("Registration expired");
                _this.unregistered();
            }, expires * 1000);
            if (this._state !== registerer_state_1.RegistererState.Registered) {
                this.stateTransition(registerer_state_1.RegistererState.Registered);
            }
        };
        /**
         * Helper function, called when unregistered.
         */
        Registerer.prototype.unregistered = function () {
            this.clearTimers();
            if (this._state !== registerer_state_1.RegistererState.Unregistered) {
                this.stateTransition(registerer_state_1.RegistererState.Unregistered);
            }
        };
        /**
         * Helper function, called when terminated.
         */
        Registerer.prototype.terminated = function () {
            this.clearTimers();
            if (this._state !== registerer_state_1.RegistererState.Terminated) {
                this.stateTransition(registerer_state_1.RegistererState.Terminated);
            }
        };
        /**
         * Transition registration state.
         */
        Registerer.prototype.stateTransition = function (newState) {
            var _this = this;
            var invalidTransition = function () {
                throw new Error("Invalid state transition from " + _this._state + " to " + newState);
            };
            // Validate transition
            switch (this._state) {
                case registerer_state_1.RegistererState.Initial:
                    if (newState !== registerer_state_1.RegistererState.Registered &&
                        newState !== registerer_state_1.RegistererState.Unregistered &&
                        newState !== registerer_state_1.RegistererState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case registerer_state_1.RegistererState.Registered:
                    if (newState !== registerer_state_1.RegistererState.Unregistered &&
                        newState !== registerer_state_1.RegistererState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case registerer_state_1.RegistererState.Unregistered:
                    if (newState !== registerer_state_1.RegistererState.Registered &&
                        newState !== registerer_state_1.RegistererState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case registerer_state_1.RegistererState.Terminated:
                    invalidTransition();
                    break;
                default:
                    throw new Error("Unrecognized state.");
            }
            // Transition
            this._state = newState;
            this.logger.log("Registration transitioned to state " + this._state);
            this._stateEventEmitter.emit("event", this._state);
            // Dispose
            if (newState === registerer_state_1.RegistererState.Terminated) {
                this.dispose();
            }
        };
        Object.defineProperty(Registerer.prototype, "waiting", {
            /** True if the registerer is currently waiting for final response to a REGISTER request. */
            get: function () {
                return this._waiting;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Registerer.prototype, "waitingChange", {
            /** Emits when the registerer waiting state changes. */
            get: function () {
                return emitter_1._makeEmitter(this._waitingEventEmitter);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Toggle waiting.
         */
        Registerer.prototype.waitingToggle = function (waiting) {
            if (this._waiting === waiting) {
                throw new Error("Invalid waiting transition from " + this._waiting + " to " + waiting);
            }
            this._waiting = waiting;
            this.logger.log("Waiting toggled to " + this._waiting);
            this._waitingEventEmitter.emit("event", this._waiting);
        };
        /** Default registerer options. */
        Registerer.defaultOptions = {
            expires: 600,
            extraContactHeaderParams: [],
            extraHeaders: [],
            logConfiguration: true,
            instanceId: "",
            params: {},
            regId: 0,
            registrar: new core_1.URI("sip", "anonymous", "anonymous.invalid")
        };
        return Registerer;
    }());
    exports.Registerer = Registerer;
    
    
    /***/ }),
    
    /***/ "./src/api/session-state.ts":
    /*!**********************************!*\
      !*** ./src/api/session-state.ts ***!
      \**********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * {@link Session} state.
     *
     * @remarks
     * The {@link Session} behaves in a deterministic manner according to the following
     * Finite State Machine (FSM).
     * ```txt
     *                   ___________________________________________________________
     *                  |  ____________________________________________             |
     *                  | |            ____________________________    |            |
     * Session          | |           |                            v   v            v
     * Constructed -> Initial -> Establishing -> Established -> Terminating -> Terminated
     *                                |               |___________________________^   ^
     *                                |_______________________________________________|
     * ```
     * @public
     */
    var SessionState;
    (function (SessionState) {
        /**
         * If `Inviter`, INVITE not sent yet.
         * If `Invitation`, received INVITE (but no final response sent yet).
         */
        SessionState["Initial"] = "Initial";
        /**
         * If `Inviter`, sent INVITE and waiting for a final response.
         * If `Invitation`, received INVITE and attempting to send 200 final response (but has not sent it yet).
         */
        SessionState["Establishing"] = "Establishing";
        /**
         * If `Inviter`, sent INVITE and received 200 final response and sent ACK.
         * If `Invitation`, received INVITE and sent 200 final response.
         */
        SessionState["Established"] = "Established";
        /**
         * If `Inviter`, sent INVITE, sent CANCEL and now waiting for 487 final response to ACK (or 200 to ACK & BYE).
         * If `Invitation`, received INVITE, sent 200 final response and now waiting on ACK and upon receipt will attempt BYE
         * (as the protocol specification requires, before sending a BYE we must receive the ACK - so we are waiting).
         */
        SessionState["Terminating"] = "Terminating";
        /**
         * If `Inviter`, sent INVITE and received non-200 final response (or sent/received BYE after receiving 200).
         * If `Invitation`, received INVITE and sent non-200 final response (or sent/received BYE after sending 200).
         */
        SessionState["Terminated"] = "Terminated";
    })(SessionState = exports.SessionState || (exports.SessionState = {}));
    
    
    /***/ }),
    
    /***/ "./src/api/session.ts":
    /*!****************************!*\
      !*** ./src/api/session.ts ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
    var core_1 = __webpack_require__(/*! ../core */ "./src/core/index.ts");
    var utils_1 = __webpack_require__(/*! ../core/messages/utils */ "./src/core/messages/utils.ts");
    var allowed_methods_1 = __webpack_require__(/*! ../core/user-agent-core/allowed-methods */ "./src/core/user-agent-core/allowed-methods.ts");
    var emitter_1 = __webpack_require__(/*! ./emitter */ "./src/api/emitter.ts");
    var exceptions_1 = __webpack_require__(/*! ./exceptions */ "./src/api/exceptions/index.ts");
    var info_1 = __webpack_require__(/*! ./info */ "./src/api/info.ts");
    var notification_1 = __webpack_require__(/*! ./notification */ "./src/api/notification.ts");
    var referral_1 = __webpack_require__(/*! ./referral */ "./src/api/referral.ts");
    var session_state_1 = __webpack_require__(/*! ./session-state */ "./src/api/session-state.ts");
    /**
     * A session provides real time communication between one or more participants.
     *
     * @remarks
     * The transport behaves in a deterministic manner according to the
     * the state defined in {@link SessionState}.
     * @public
     */
    var Session = /** @class */ (function () {
        /**
         * Constructor.
         * @param userAgent - User agent. See {@link UserAgent} for details.
         * @internal
         */
        function Session(userAgent, options) {
            if (options === void 0) { options = {}; }
            /** True if there is a re-INVITE request outstanding. */
            this.pendingReinvite = false;
            /** Session state. */
            this._state = session_state_1.SessionState.Initial;
            /** Session state emitter. */
            this._stateEventEmitter = new events_1.EventEmitter();
            this.delegate = options.delegate;
            this._userAgent = userAgent;
        }
        /**
         * Destructor.
         */
        Session.prototype.dispose = function () {
            var _this = this;
            this.logger.log("Session " + this.id + " in state " + this._state + " is being disposed");
            // Remove from the user agent's session collection
            delete this.userAgent._sessions[this.id];
            // Dispose of dialog media
            if (this._sessionDescriptionHandler) {
                this._sessionDescriptionHandler.close();
                // TODO: The SDH needs to remain defined as it will be called after it is closed in cases
                // where an answer/offer arrives while the session is being torn down. There are a variety
                // of circumstances where this can happen - sending a BYE during a re-INVITE for example.
                // The code is currently written such that it lazily makes a new SDH when it needs one
                // and one is not yet defined. Thus if we undefined it here, it will currently make a
                // new one which is out of sync and then never gets cleaned up.
                //
                // The downside of leaving it defined are that calls this closed SDH will continue to be
                // made (think setDescription) and those should/will fail. These failures are handled, but
                // it would be nice to have it all coded up in a way where having an undefined SDH where
                // one is expected throws an error.
                //
                // this._sessionDescriptionHandler = undefined;
            }
            switch (this.state) {
                case session_state_1.SessionState.Initial:
                    break; // the Inviter/Invitation sub class dispose method handles this case
                case session_state_1.SessionState.Establishing:
                    break; // the Inviter/Invitation sub class dispose method handles this case
                case session_state_1.SessionState.Established:
                    return new Promise(function (resolve, reject) {
                        _this._bye({
                            onAccept: function () { return resolve(); },
                            onRedirect: function () { return resolve(); },
                            onReject: function () { return resolve(); }
                        });
                    });
                case session_state_1.SessionState.Terminating:
                    break; // nothing to be done
                case session_state_1.SessionState.Terminated:
                    break; // nothing to be done
                default:
                    throw new Error("Unknown state.");
            }
            return Promise.resolve();
        };
        Object.defineProperty(Session.prototype, "assertedIdentity", {
            /**
             * The asserted identity of the remote user.
             */
            get: function () {
                return this._assertedIdentity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Session.prototype, "dialog", {
            /**
             * The confirmed session dialog.
             */
            get: function () {
                return this._dialog;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Session.prototype, "id", {
            /**
             * A unique identifier for this session.
             */
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Session.prototype, "replacee", {
            /**
             * The session being replace by this one.
             */
            get: function () {
                return this._replacee;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Session.prototype, "sessionDescriptionHandler", {
            /**
             * Session description handler.
             * @remarks
             * If `this` is an instance of `Invitation`,
             * `sessionDescriptionHandler` will be defined when the session state changes to "established".
             * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,
             * `sessionDescriptionHandler` will be defined when the session state changes to "establishing".
             * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,
             * `sessionDescriptionHandler` will be defined when the session state changes to "established".
             * Otherwise `undefined`.
             */
            get: function () {
                return this._sessionDescriptionHandler;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Session.prototype, "sessionDescriptionHandlerFactory", {
            /**
             * Session description handler factory.
             */
            get: function () {
                return this.userAgent.configuration.sessionDescriptionHandlerFactory;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Session.prototype, "state", {
            /**
             * Session state.
             */
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Session.prototype, "stateChange", {
            /**
             * Session state change emitter.
             */
            get: function () {
                return emitter_1._makeEmitter(this._stateEventEmitter);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Session.prototype, "userAgent", {
            /**
             * The user agent.
             */
            get: function () {
                return this._userAgent;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Renegotiate the session. Sends a re-INVITE.
         * @param options - Options bucket.
         */
        Session.prototype.invite = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            this.logger.log("Session.invite");
            if (this.state !== session_state_1.SessionState.Established) {
                return Promise.reject(new Error("Invalid session state " + this.state));
            }
            if (this.pendingReinvite) {
                return Promise.reject(new exceptions_1.RequestPendingError("Reinvite in progress. Please wait until complete, then try again."));
            }
            this.pendingReinvite = true;
            var delegate = {
                onAccept: function (response) {
                    // A re-INVITE transaction has an offer/answer [RFC3264] exchange
                    // associated with it.  The UAC (User Agent Client) generating a given
                    // re-INVITE can act as the offerer or as the answerer.  A UAC willing
                    // to act as the offerer includes an offer in the re-INVITE.  The UAS
                    // (User Agent Server) then provides an answer in a response to the
                    // re-INVITE.  A UAC willing to act as answerer does not include an
                    // offer in the re-INVITE.  The UAS then provides an offer in a response
                    // to the re-INVITE becoming, thus, the offerer.
                    // https://tools.ietf.org/html/rfc6141#section-1
                    var body = core_1.getBody(response.message);
                    if (!body) {
                        // No way to recover, so terminate session and mark as failed.
                        _this.logger.error("Received 2xx response to re-INVITE without a session description");
                        _this.ackAndBye(response, 400, "Missing session description");
                        _this.stateTransition(session_state_1.SessionState.Terminated);
                        _this.pendingReinvite = false;
                        return;
                    }
                    if (options.withoutSdp) {
                        // INVITE without SDP - set remote offer and send an answer in the ACK
                        // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
                        //        This behavior was ported from legacy code and the issue punted down the road.
                        var answerOptions = {
                            sessionDescriptionHandlerOptions: options.sessionDescriptionHandlerOptions,
                            sessionDescriptionHandlerModifiers: options.sessionDescriptionHandlerModifiers
                        };
                        _this.setOfferAndGetAnswer(body, answerOptions)
                            .then(function (answerBody) {
                            response.ack({ body: answerBody });
                        })
                            .catch(function (error) {
                            // No way to recover, so terminate session and mark as failed.
                            _this.logger.error("Failed to handle offer in 2xx response to re-INVITE");
                            _this.logger.error(error.message);
                            if (_this.state === session_state_1.SessionState.Terminated) {
                                // A BYE should not be sent if already terminated.
                                // For example, a BYE may be sent/received while re-INVITE is outstanding.
                                response.ack();
                            }
                            else {
                                _this.ackAndBye(response, 488, "Bad Media Description");
                                _this.stateTransition(session_state_1.SessionState.Terminated);
                            }
                        })
                            .then(function () {
                            _this.pendingReinvite = false;
                            if (options.requestDelegate && options.requestDelegate.onAccept) {
                                options.requestDelegate.onAccept(response);
                            }
                        });
                    }
                    else {
                        // INVITE with SDP - set remote answer and send an ACK
                        // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
                        //        This behavior was ported from legacy code and the issue punted down the road.
                        var answerOptions = {
                            sessionDescriptionHandlerOptions: _this._sessionDescriptionHandlerOptions,
                            sessionDescriptionHandlerModifiers: _this._sessionDescriptionHandlerModifiers
                        };
                        _this.setAnswer(body, answerOptions)
                            .then(function () {
                            response.ack();
                        })
                            .catch(function (error) {
                            // No way to recover, so terminate session and mark as failed.
                            _this.logger.error("Failed to handle answer in 2xx response to re-INVITE");
                            _this.logger.error(error.message);
                            // A BYE should only be sent if session is not already terminated.
                            // For example, a BYE may be sent/received while re-INVITE is outstanding.
                            // The ACK needs to be sent regardless as it was not handled by the transaction.
                            if (_this.state !== session_state_1.SessionState.Terminated) {
                                _this.ackAndBye(response, 488, "Bad Media Description");
                                _this.stateTransition(session_state_1.SessionState.Terminated);
                            }
                            else {
                                response.ack();
                            }
                        })
                            .then(function () {
                            _this.pendingReinvite = false;
                            if (options.requestDelegate && options.requestDelegate.onAccept) {
                                options.requestDelegate.onAccept(response);
                            }
                        });
                    }
                },
                onProgress: function (response) {
                    return;
                },
                onRedirect: function (response) {
                    return;
                },
                onReject: function (response) {
                    _this.logger.warn("Received a non-2xx response to re-INVITE");
                    _this.pendingReinvite = false;
                    if (options.withoutSdp) {
                        if (options.requestDelegate && options.requestDelegate.onReject) {
                            options.requestDelegate.onReject(response);
                        }
                    }
                    else {
                        _this.rollbackOffer()
                            .catch(function (error) {
                            // No way to recover, so terminate session and mark as failed.
                            _this.logger.error("Failed to rollback offer on non-2xx response to re-INVITE");
                            _this.logger.error(error.message);
                            // A BYE should only be sent if session is not already terminated.
                            // For example, a BYE may be sent/received while re-INVITE is outstanding.
                            // Note that the ACK was already sent by the transaction, so just need to send BYE.
                            if (_this.state !== session_state_1.SessionState.Terminated) {
                                if (!_this.dialog) {
                                    throw new Error("Dialog undefined.");
                                }
                                var extraHeaders = [];
                                extraHeaders.push("Reason: " + _this.getReasonHeaderValue(500, "Internal Server Error"));
                                _this.dialog.bye(undefined, { extraHeaders: extraHeaders });
                                _this.stateTransition(session_state_1.SessionState.Terminated);
                            }
                        })
                            .then(function () {
                            if (options.requestDelegate && options.requestDelegate.onReject) {
                                options.requestDelegate.onReject(response);
                            }
                        });
                    }
                },
                onTrying: function (response) {
                    return;
                }
            };
            var requestOptions = options.requestOptions || {};
            requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();
            requestOptions.extraHeaders.push("Allow: " + allowed_methods_1.AllowedMethods.toString());
            requestOptions.extraHeaders.push("Contact: " + this._contact);
            // Just send an INVITE with no sdp...
            if (options.withoutSdp) {
                if (!this.dialog) {
                    this.pendingReinvite = false;
                    throw new Error("Dialog undefined.");
                }
                return Promise.resolve(this.dialog.invite(delegate, requestOptions));
            }
            // Get an offer and send it in an INVITE
            // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
            //        This behavior was ported from legacy code and the issue punted down the road.
            var offerOptions = {
                sessionDescriptionHandlerOptions: options.sessionDescriptionHandlerOptions,
                sessionDescriptionHandlerModifiers: options.sessionDescriptionHandlerModifiers
            };
            return this.getOffer(offerOptions)
                .then(function (offerBody) {
                if (!_this.dialog) {
                    _this.pendingReinvite = false;
                    throw new Error("Dialog undefined.");
                }
                requestOptions.body = offerBody;
                return _this.dialog.invite(delegate, requestOptions);
            })
                .catch(function (error) {
                _this.logger.error(error.message);
                _this.logger.error("Failed to send re-INVITE");
                _this.pendingReinvite = false;
                throw error;
            });
        };
        /**
         * Send REFER.
         * @param referrer - Referrer.
         * @param delegate - Request delegate.
         * @param options - Request options bucket.
         * @internal
         */
        Session.prototype.refer = function (referrer, delegate, options) {
            // Using core session dialog
            if (!this.dialog) {
                return Promise.reject(new Error("Session dialog undefined."));
            }
            // If the session has a referrer, it will receive any in-dialog NOTIFY requests.
            this._referrer = referrer;
            return Promise.resolve(this.dialog.refer(delegate, options));
        };
        /**
         * Send BYE.
         * @param delegate - Request delegate.
         * @param options - Request options bucket.
         * @internal
         */
        Session.prototype._bye = function (delegate, options) {
            var _this = this;
            // Using core session dialog
            if (!this.dialog) {
                return Promise.reject(new Error("Session dialog undefined."));
            }
            var dialog = this.dialog;
            // The caller's UA MAY send a BYE for either confirmed or early dialogs,
            // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT
            // send a BYE on early dialogs. However, the callee's UA MUST NOT send a
            // BYE on a confirmed dialog until it has received an ACK for its 2xx
            // response or until the server transaction times out.
            // https://tools.ietf.org/html/rfc3261#section-15
            switch (dialog.sessionState) {
                case core_1.SessionState.Initial:
                    throw new Error("Invalid dialog state " + dialog.sessionState);
                case core_1.SessionState.Early: // Implementation choice - not sending BYE for early dialogs.
                    throw new Error("Invalid dialog state " + dialog.sessionState);
                case core_1.SessionState.AckWait: { // This state only occurs if we are the callee.
                    this.stateTransition(session_state_1.SessionState.Terminating); // We're terminating
                    return new Promise(function (resolve, reject) {
                        dialog.delegate = {
                            // When ACK shows up, say BYE.
                            onAck: function () {
                                var request = dialog.bye(delegate, options);
                                _this.stateTransition(session_state_1.SessionState.Terminated);
                                resolve(request);
                            },
                            // Or the server transaction times out before the ACK arrives.
                            onAckTimeout: function () {
                                var request = dialog.bye(delegate, options);
                                _this.stateTransition(session_state_1.SessionState.Terminated);
                                resolve(request);
                            }
                        };
                    });
                }
                case core_1.SessionState.Confirmed: {
                    var request = dialog.bye(delegate, options);
                    this.stateTransition(session_state_1.SessionState.Terminated);
                    return Promise.resolve(request);
                }
                case core_1.SessionState.Terminated:
                    throw new Error("Invalid dialog state " + dialog.sessionState);
                default:
                    throw new Error("Unrecognized state.");
            }
        };
        /**
         * Send INFO.
         * @param delegate - Request delegate.
         * @param options - Request options bucket.
         * @internal
         */
        Session.prototype._info = function (delegate, options) {
            // Using core session dialog
            if (!this.dialog) {
                return Promise.reject(new Error("Session dialog undefined."));
            }
            return Promise.resolve(this.dialog.info(delegate, options));
        };
        /**
         * Send ACK and then BYE. There are unrecoverable errors which can occur
         * while handling dialog forming and in-dialog INVITE responses and when
         * they occur we ACK the response and send a BYE.
         * Note that the BYE is sent in the dialog associated with the response
         * which is not necessarily `this.dialog`. And, accordingly, the
         * session state is not transitioned to terminated and session is not closed.
         * @param inviteResponse - The response causing the error.
         * @param statusCode - Status code for he reason phrase.
         * @param reasonPhrase - Reason phrase for the BYE.
         * @internal
         */
        Session.prototype.ackAndBye = function (response, statusCode, reasonPhrase) {
            response.ack();
            var extraHeaders = [];
            if (statusCode) {
                extraHeaders.push("Reason: " + this.getReasonHeaderValue(statusCode, reasonPhrase));
            }
            // Using the dialog session associate with the response (which might not be this.dialog)
            response.session.bye(undefined, { extraHeaders: extraHeaders });
        };
        /**
         * Handle in dialog ACK request.
         * @internal
         */
        Session.prototype.onAckRequest = function (request) {
            var _this = this;
            this.logger.log("Session.onAckRequest");
            if (this.state !== session_state_1.SessionState.Established && this.state !== session_state_1.SessionState.Terminating) {
                this.logger.error("ACK received while in state " + this.state + ", dropping request");
                return;
            }
            var dialog = this.dialog;
            if (!dialog) {
                throw new Error("Dialog undefined.");
            }
            switch (dialog.signalingState) {
                case core_1.SignalingState.Initial: {
                    // State should never be reached as first reliable response must have answer/offer.
                    // So we must have never has sent an offer.
                    this.logger.error("Invalid signaling state " + dialog.signalingState + ".");
                    var extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                    dialog.bye(undefined, { extraHeaders: extraHeaders });
                    this.stateTransition(session_state_1.SessionState.Terminated);
                    return;
                }
                case core_1.SignalingState.Stable: {
                    // State we should be in.
                    // Either the ACK has the answer that got us here, or we were in this state prior to the ACK.
                    var body = core_1.getBody(request.message);
                    // If the ACK doesn't have an answer, nothing to be done.
                    if (!body) {
                        return;
                    }
                    if (body.contentDisposition === "render") {
                        this._renderbody = body.content;
                        this._rendertype = body.contentType;
                        return;
                    }
                    if (body.contentDisposition !== "session") {
                        return;
                    }
                    // Received answer in ACK.
                    var options = {
                        sessionDescriptionHandlerOptions: this._sessionDescriptionHandlerOptions,
                        sessionDescriptionHandlerModifiers: this._sessionDescriptionHandlerModifiers
                    };
                    this.setAnswer(body, options)
                        .catch(function (error) {
                        _this.logger.error(error.message);
                        var extraHeaders = ["Reason: " + _this.getReasonHeaderValue(488, "Bad Media Description")];
                        dialog.bye(undefined, { extraHeaders: extraHeaders });
                        _this.stateTransition(session_state_1.SessionState.Terminated);
                    });
                    return;
                }
                case core_1.SignalingState.HaveLocalOffer: {
                    // State should never be reached as local offer would be answered by this ACK.
                    // So we must have received an ACK without an answer.
                    this.logger.error("Invalid signaling state " + dialog.signalingState + ".");
                    var extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                    dialog.bye(undefined, { extraHeaders: extraHeaders });
                    this.stateTransition(session_state_1.SessionState.Terminated);
                    return;
                }
                case core_1.SignalingState.HaveRemoteOffer: {
                    // State should never be reached as remote offer would be answered in first reliable response.
                    // So we must have never has sent an answer.
                    this.logger.error("Invalid signaling state " + dialog.signalingState + ".");
                    var extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                    dialog.bye(undefined, { extraHeaders: extraHeaders });
                    this.stateTransition(session_state_1.SessionState.Terminated);
                    return;
                }
                case core_1.SignalingState.Closed:
                    throw new Error("Invalid signaling state " + dialog.signalingState + ".");
                default:
                    throw new Error("Invalid signaling state " + dialog.signalingState + ".");
            }
        };
        /**
         * Handle in dialog BYE request.
         * @internal
         */
        Session.prototype.onByeRequest = function (request) {
            this.logger.log("Session.onByeRequest");
            if (this.state !== session_state_1.SessionState.Established) {
                this.logger.error("BYE received while in state " + this.state + ", dropping request");
                return;
            }
            request.accept();
            this.stateTransition(session_state_1.SessionState.Terminated);
        };
        /**
         * Handle in dialog INFO request.
         * @internal
         */
        Session.prototype.onInfoRequest = function (request) {
            this.logger.log("Session.onInfoRequest");
            if (this.state !== session_state_1.SessionState.Established) {
                this.logger.error("INFO received while in state " + this.state + ", dropping request");
                return;
            }
            if (this.delegate && this.delegate.onInfo) {
                var info = new info_1.Info(request);
                this.delegate.onInfo(info);
            }
            else {
                request.accept();
            }
        };
        /**
         * Handle in dialog INVITE request.
         * @internal
         */
        Session.prototype.onInviteRequest = function (request) {
            var _this = this;
            this.logger.log("Session.onInviteRequest");
            if (this.state !== session_state_1.SessionState.Established) {
                this.logger.error("INVITE received while in state " + this.state + ", dropping request");
                return;
            }
            // TODO: would be nice to have core track and set the Contact header,
            // but currently the session which is setting it is holding onto it.
            var extraHeaders = ["Contact: " + this._contact];
            // Handle P-Asserted-Identity
            if (request.message.hasHeader("P-Asserted-Identity")) {
                var header = request.message.getHeader("P-Asserted-Identity");
                if (!header) {
                    throw new Error("Header undefined.");
                }
                this._assertedIdentity = core_1.Grammar.nameAddrHeaderParse(header);
            }
            // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
            //        This behavior was ported from legacy code and the issue punted down the road.
            var options = {
                sessionDescriptionHandlerOptions: this._sessionDescriptionHandlerOptions,
                sessionDescriptionHandlerModifiers: this._sessionDescriptionHandlerModifiers
            };
            this.generateResponseOfferAnswerInDialog(options)
                .then(function (body) {
                var outgoingResponse = request.accept({ statusCode: 200, extraHeaders: extraHeaders, body: body });
                if (_this.delegate && _this.delegate.onInvite) {
                    _this.delegate.onInvite(request.message, outgoingResponse.message, 200);
                }
            })
                .catch(function (error) {
                _this.logger.error(error.message);
                _this.logger.error("Failed to handle to re-INVITE request");
                if (!_this.dialog) {
                    throw new Error("Dialog undefined.");
                }
                _this.logger.error(_this.dialog.signalingState);
                // If we don't have a local/remote offer...
                if (_this.dialog.signalingState === core_1.SignalingState.Stable) {
                    var outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here
                    if (_this.delegate && _this.delegate.onInvite) {
                        _this.delegate.onInvite(request.message, outgoingResponse.message, 488);
                    }
                    return;
                }
                // Otherwise rollback
                _this.rollbackOffer()
                    .then(function () {
                    var outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here
                    if (_this.delegate && _this.delegate.onInvite) {
                        _this.delegate.onInvite(request.message, outgoingResponse.message, 488);
                    }
                })
                    .catch(function (errorRollback) {
                    // No way to recover, so terminate session and mark as failed.
                    _this.logger.error(errorRollback.message);
                    _this.logger.error("Failed to rollback offer on re-INVITE request");
                    var outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here
                    // A BYE should only be sent if session is not already terminated.
                    // For example, a BYE may be sent/received while re-INVITE is outstanding.
                    // Note that the ACK was already sent by the transaction, so just need to send BYE.
                    if (_this.state !== session_state_1.SessionState.Terminated) {
                        if (!_this.dialog) {
                            throw new Error("Dialog undefined.");
                        }
                        var extraHeadersBye = [];
                        extraHeadersBye.push("Reason: " + _this.getReasonHeaderValue(500, "Internal Server Error"));
                        _this.dialog.bye(undefined, { extraHeaders: extraHeaders });
                        _this.stateTransition(session_state_1.SessionState.Terminated);
                    }
                    if (_this.delegate && _this.delegate.onInvite) {
                        _this.delegate.onInvite(request.message, outgoingResponse.message, 488);
                    }
                });
            });
        };
        /**
         * Handle in dialog NOTIFY request.
         * @internal
         */
        Session.prototype.onNotifyRequest = function (request) {
            this.logger.log("Session.onNotifyRequest");
            if (this.state !== session_state_1.SessionState.Established) {
                this.logger.error("NOTIFY received while in state " + this.state + ", dropping request");
                return;
            }
            // If this a NOTIFY associated with the progress of a REFER,
            // look to delegate handling to the associated Referrer.
            if (this._referrer && this._referrer.delegate && this._referrer.delegate.onNotify) {
                var notification = new notification_1.Notification(request);
                this._referrer.delegate.onNotify(notification);
                return;
            }
            // Otherwise accept the NOTIFY.
            if (this.delegate && this.delegate.onNotify) {
                var notification = new notification_1.Notification(request);
                this.delegate.onNotify(notification);
            }
            else {
                request.accept();
            }
        };
        /**
         * Handle in dialog PRACK request.
         * @internal
         */
        Session.prototype.onPrackRequest = function (request) {
            this.logger.log("Session.onPrackRequest");
            if (this.state !== session_state_1.SessionState.Established) {
                this.logger.error("PRACK received while in state " + this.state + ", dropping request");
                return;
            }
            throw new Error("Unimplemented.");
        };
        /**
         * Handle in dialog REFER request.
         * @internal
         */
        Session.prototype.onReferRequest = function (request) {
            var _this = this;
            this.logger.log("Session.onReferRequest");
            if (this.state !== session_state_1.SessionState.Established) {
                this.logger.error("REFER received while in state " + this.state + ", dropping request");
                return;
            }
            // REFER is a SIP request and is constructed as defined in [1].  A REFER
            // request MUST contain exactly one Refer-To header field value.
            // https://tools.ietf.org/html/rfc3515#section-2.4.1
            if (!request.message.hasHeader("refer-to")) {
                this.logger.warn("Invalid REFER packet. A refer-to header is required. Rejecting.");
                request.reject();
                return;
            }
            var referral = new referral_1.Referral(request, this);
            if (this.delegate && this.delegate.onRefer) {
                this.delegate.onRefer(referral);
            }
            else {
                this.logger.log("No delegate available to handle REFER, automatically accepting and following.");
                referral
                    .accept()
                    .then(function () { return referral
                    .makeInviter(_this._referralInviterOptions)
                    .invite(); })
                    .catch(function (error) {
                    // FIXME: logging and eating error...
                    _this.logger.error(error.message);
                });
            }
        };
        /**
         * Generate an offer or answer for a response to an INVITE request.
         * If a remote offer was provided in the request, set the remote
         * description and get a local answer. If a remote offer was not
         * provided, generates a local offer.
         * @internal
         */
        Session.prototype.generateResponseOfferAnswer = function (request, options) {
            if (this.dialog) {
                return this.generateResponseOfferAnswerInDialog(options);
            }
            var body = core_1.getBody(request.message);
            if (!body || body.contentDisposition !== "session") {
                return this.getOffer(options);
            }
            else {
                return this.setOfferAndGetAnswer(body, options);
            }
        };
        /**
         * Generate an offer or answer for a response to an INVITE request
         * when a dialog (early or otherwise) has already been established.
         * This method may NOT be called if a dialog has yet to be established.
         * @internal
         */
        Session.prototype.generateResponseOfferAnswerInDialog = function (options) {
            if (!this.dialog) {
                throw new Error("Dialog undefined.");
            }
            switch (this.dialog.signalingState) {
                case core_1.SignalingState.Initial:
                    return this.getOffer(options);
                case core_1.SignalingState.HaveLocalOffer:
                    // o  Once the UAS has sent or received an answer to the initial
                    // offer, it MUST NOT generate subsequent offers in any responses
                    // to the initial INVITE.  This means that a UAS based on this
                    // specification alone can never generate subsequent offers until
                    // completion of the initial transaction.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    return Promise.resolve(undefined);
                case core_1.SignalingState.HaveRemoteOffer:
                    if (!this.dialog.offer) {
                        throw new Error("Session offer undefined in signaling state " + this.dialog.signalingState + ".");
                    }
                    return this.setOfferAndGetAnswer(this.dialog.offer, options);
                case core_1.SignalingState.Stable:
                    // o  Once the UAS has sent or received an answer to the initial
                    // offer, it MUST NOT generate subsequent offers in any responses
                    // to the initial INVITE.  This means that a UAS based on this
                    // specification alone can never generate subsequent offers until
                    // completion of the initial transaction.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    if (this.state !== session_state_1.SessionState.Established) {
                        return Promise.resolve(undefined);
                    }
                    // In dialog INVITE without offer, get an offer for the response.
                    return this.getOffer(options);
                case core_1.SignalingState.Closed:
                    throw new Error("Invalid signaling state " + this.dialog.signalingState + ".");
                default:
                    throw new Error("Invalid signaling state " + this.dialog.signalingState + ".");
            }
        };
        /**
         * Get local offer.
         * @internal
         */
        Session.prototype.getOffer = function (options) {
            var _this = this;
            var sdh = this.setupSessionDescriptionHandler();
            var sdhOptions = options.sessionDescriptionHandlerOptions;
            var sdhModifiers = options.sessionDescriptionHandlerModifiers;
            // This is intentionally written very defensively. Don't trust SDH to behave.
            try {
                return sdh.getDescription(sdhOptions, sdhModifiers)
                    .then(function (bodyAndContentType) { return core_1.fromBodyLegacy(bodyAndContentType); })
                    .catch(function (error) {
                    _this.logger.error("Session.getOffer: SDH getDescription rejected...");
                    var e = error instanceof Error ? error : new Error(error);
                    _this.logger.error(e.message);
                    throw e;
                });
            }
            catch (error) { // don't trust SDH to throw an Error
                this.logger.error("Session.getOffer: SDH getDescription threw...");
                var e = error instanceof Error ? error : new Error(error);
                this.logger.error(e.message);
                return Promise.reject(e);
            }
        };
        /**
         * Rollback local/remote offer.
         * @internal
         */
        Session.prototype.rollbackOffer = function () {
            var _this = this;
            var sdh = this.setupSessionDescriptionHandler();
            if (!sdh.rollbackDescription) {
                return Promise.resolve();
            }
            // This is intentionally written very defensively. Don't trust SDH to behave.
            try {
                return sdh.rollbackDescription()
                    .catch(function (error) {
                    _this.logger.error("Session.rollbackOffer: SDH rollbackDescription rejected...");
                    var e = error instanceof Error ? error : new Error(error);
                    _this.logger.error(e.message);
                    throw e;
                });
            }
            catch (error) { // don't trust SDH to throw an Error
                this.logger.error("Session.rollbackOffer: SDH rollbackDescription threw...");
                var e = error instanceof Error ? error : new Error(error);
                this.logger.error(e.message);
                return Promise.reject(e);
            }
        };
        /**
         * Set remote answer.
         * @internal
         */
        Session.prototype.setAnswer = function (answer, options) {
            var _this = this;
            var sdh = this.setupSessionDescriptionHandler();
            var sdhOptions = options.sessionDescriptionHandlerOptions;
            var sdhModifiers = options.sessionDescriptionHandlerModifiers;
            // This is intentionally written very defensively. Don't trust SDH to behave.
            try {
                if (!sdh.hasDescription(answer.contentType)) {
                    return Promise.reject(new exceptions_1.ContentTypeUnsupportedError());
                }
            }
            catch (error) {
                this.logger.error("Session.setAnswer: SDH hasDescription threw...");
                var e = error instanceof Error ? error : new Error(error);
                this.logger.error(e.message);
                return Promise.reject(e);
            }
            try {
                return sdh.setDescription(answer.content, sdhOptions, sdhModifiers)
                    .catch(function (error) {
                    _this.logger.error("Session.setAnswer: SDH setDescription rejected...");
                    var e = error instanceof Error ? error : new Error(error);
                    _this.logger.error(e.message);
                    throw e;
                });
            }
            catch (error) { // don't trust SDH to throw an Error
                this.logger.error("Session.setAnswer: SDH setDescription threw...");
                var e = error instanceof Error ? error : new Error(error);
                this.logger.error(e.message);
                return Promise.reject(e);
            }
        };
        /**
         * Set remote offer and get local answer.
         * @internal
         */
        Session.prototype.setOfferAndGetAnswer = function (offer, options) {
            var _this = this;
            var sdh = this.setupSessionDescriptionHandler();
            var sdhOptions = options.sessionDescriptionHandlerOptions;
            var sdhModifiers = options.sessionDescriptionHandlerModifiers;
            // This is intentionally written very defensively. Don't trust SDH to behave.
            try {
                if (!sdh.hasDescription(offer.contentType)) {
                    return Promise.reject(new exceptions_1.ContentTypeUnsupportedError());
                }
            }
            catch (error) {
                this.logger.error("Session.setOfferAndGetAnswer: SDH hasDescription threw...");
                var e = error instanceof Error ? error : new Error(error);
                this.logger.error(e.message);
                return Promise.reject(e);
            }
            try {
                return sdh.setDescription(offer.content, sdhOptions, sdhModifiers)
                    .then(function () { return sdh.getDescription(sdhOptions, sdhModifiers); })
                    .then(function (bodyAndContentType) { return core_1.fromBodyLegacy(bodyAndContentType); })
                    .catch(function (error) {
                    _this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...");
                    var e = error instanceof Error ? error : new Error(error);
                    _this.logger.error(e.message);
                    throw e;
                });
            }
            catch (error) { // don't trust SDH to throw an Error
                this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...");
                var e = error instanceof Error ? error : new Error(error);
                this.logger.error(e.message);
                return Promise.reject(e);
            }
        };
        /**
         * SDH for confirmed dialog.
         * @internal
         */
        Session.prototype.setSessionDescriptionHandler = function (sdh) {
            if (this._sessionDescriptionHandler) {
                throw new Error("Session description handler defined.");
            }
            this._sessionDescriptionHandler = sdh;
        };
        /**
         * SDH for confirmed dialog.
         * @internal
         */
        Session.prototype.setupSessionDescriptionHandler = function () {
            if (this._sessionDescriptionHandler) {
                return this._sessionDescriptionHandler;
            }
            this._sessionDescriptionHandler =
                this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);
            return this._sessionDescriptionHandler;
        };
        /**
         * Transition session state.
         * @internal
         */
        Session.prototype.stateTransition = function (newState) {
            var _this = this;
            var invalidTransition = function () {
                throw new Error("Invalid state transition from " + _this._state + " to " + newState);
            };
            // Validate transition
            switch (this._state) {
                case session_state_1.SessionState.Initial:
                    if (newState !== session_state_1.SessionState.Establishing &&
                        newState !== session_state_1.SessionState.Established &&
                        newState !== session_state_1.SessionState.Terminating &&
                        newState !== session_state_1.SessionState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case session_state_1.SessionState.Establishing:
                    if (newState !== session_state_1.SessionState.Established &&
                        newState !== session_state_1.SessionState.Terminating &&
                        newState !== session_state_1.SessionState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case session_state_1.SessionState.Established:
                    if (newState !== session_state_1.SessionState.Terminating &&
                        newState !== session_state_1.SessionState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case session_state_1.SessionState.Terminating:
                    if (newState !== session_state_1.SessionState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case session_state_1.SessionState.Terminated:
                    invalidTransition();
                    break;
                default:
                    throw new Error("Unrecognized state.");
            }
            // Transition
            this._state = newState;
            this.logger.log("Session " + this.id + " transitioned to state " + this._state);
            this._stateEventEmitter.emit("event", this._state);
            // Dispose
            if (newState === session_state_1.SessionState.Terminated) {
                this.dispose();
            }
        };
        Session.prototype.getReasonHeaderValue = function (code, reason) {
            var cause = code;
            var text = utils_1.getReasonPhrase(code);
            if (!text && reason) {
                text = reason;
            }
            return "SIP;cause=" + cause + ';text="' + text + '"';
        };
        return Session;
    }());
    exports.Session = Session;
    
    
    /***/ }),
    
    /***/ "./src/api/subscriber.ts":
    /*!*******************************!*\
      !*** ./src/api/subscriber.ts ***!
      \*******************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var core_1 = __webpack_require__(/*! ../core */ "./src/core/index.ts");
    var allowed_methods_1 = __webpack_require__(/*! ../core/user-agent-core/allowed-methods */ "./src/core/user-agent-core/allowed-methods.ts");
    var notification_1 = __webpack_require__(/*! ./notification */ "./src/api/notification.ts");
    var subscription_1 = __webpack_require__(/*! ./subscription */ "./src/api/subscription.ts");
    var subscription_state_1 = __webpack_require__(/*! ./subscription-state */ "./src/api/subscription-state.ts");
    /**
     * A subscriber establishes a {@link Subscription} (outgoing SUBSCRIBE).
     *
     * @remarks
     * This is (more or less) an implementation of a "subscriber" as
     * defined in RFC 6665 "SIP-Specific Event Notifications".
     * https://tools.ietf.org/html/rfc6665
     *
     * @example
     * ```ts
     * // Create a new subscriber.
     * const targetURI = new URI("sip", "alice", "example.com");
     * const eventType = "example-name"; // https://www.iana.org/assignments/sip-events/sip-events.xhtml
     * const subscriber = new Subscriber(userAgent, targetURI, eventType);
     *
     * // Add delegate to handle event notifications.
     * subscriber.delegate = {
     *   onNotify: (notification: Notification) => {
     *     // handle notification here
     *   }
     * };
     *
     * // Monitor subscription state changes.
     * subscriber.stateChange.addListener((newState: SubscriptionState) => {
     *   if (newState === SubscriptionState.Terminated) {
     *     // handle state change here
     *   }
     * });
     *
     * // Attempt to establish the subscription
     * subscriber.subscribe();
     *
     * // Sometime later when done with subscription
     * subscriber.unsubscribe();
     * ```
     *
     * @public
     */
    var Subscriber = /** @class */ (function (_super) {
        tslib_1.__extends(Subscriber, _super);
        /**
         * Constructor.
         * @param userAgent - User agent. See {@link UserAgent} for details.
         * @param targetURI - The request URI identifying the subscribed event.
         * @param eventType - The event type identifying the subscribed event.
         * @param options - Options bucket. See {@link SubscriberOptions} for details.
         */
        function Subscriber(userAgent, targetURI, eventType, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, userAgent, options) || this;
            _this.body = undefined;
            _this.logger = userAgent.getLogger("sip.Subscriber");
            if (options.body) {
                _this.body = {
                    body: options.body,
                    contentType: options.contentType ? options.contentType : "application/sdp"
                };
            }
            _this.targetURI = targetURI;
            // Subscription event
            _this.event = eventType;
            // Subscription expires
            if (options.expires === undefined) {
                _this.expires = 3600;
            }
            else if (typeof options.expires !== "number") { // pre-typescript type guard
                _this.logger.warn("Option \"expires\" must be a number. Using default of 3600.");
                _this.expires = 3600;
            }
            else {
                _this.expires = options.expires;
            }
            // Subscription extra headers
            _this.extraHeaders = (options.extraHeaders || []).slice();
            // Subscription context.
            _this.subscriberRequest = _this.initSubscriberRequest();
            _this.outgoingRequestMessage = _this.subscriberRequest.message;
            // Add to UserAgent's collection
            _this.id = _this.outgoingRequestMessage.callId + _this.outgoingRequestMessage.from.parameters.tag + _this.event;
            _this._userAgent._subscriptions[_this.id] = _this;
            return _this;
        }
        /**
         * Destructor.
         * @internal
         */
        Subscriber.prototype.dispose = function () {
            var _this = this;
            if (this.disposed) {
                return Promise.resolve();
            }
            this.logger.log("Subscription " + this.id + " in state " + this.state + " is being disposed");
            // Remove from the user agent's subscription collection
            delete this._userAgent._subscriptions[this.id];
            // Clear timers
            if (this.retryAfterTimer) {
                clearTimeout(this.retryAfterTimer);
                this.retryAfterTimer = undefined;
            }
            // Dispose subscriber request
            this.subscriberRequest.dispose();
            // Make sure to dispose of our parent, then unsubscribe the
            // subscription dialog (if need be) and resolve when it has terminated.
            return _super.prototype.dispose.call(this)
                .then(function () {
                // If we have never subscribed there is nothing to wait on.
                // If we are already transitioned to terminated there is no need to unsubscribe again.
                if (_this.state !== subscription_state_1.SubscriptionState.Subscribed) {
                    return;
                }
                if (!_this._dialog) {
                    throw new Error("Dialog undefined.");
                }
                if (_this._dialog.subscriptionState === core_1.SubscriptionState.Pending ||
                    _this._dialog.subscriptionState === core_1.SubscriptionState.Active) {
                    var dialog_1 = _this._dialog;
                    return new Promise(function (resolve, reject) {
                        dialog_1.delegate = {
                            onTerminated: function () { return resolve(); }
                        };
                        dialog_1.unsubscribe();
                    });
                }
            });
        };
        /**
         * Subscribe to event notifications.
         *
         * @remarks
         * Send an initial SUBSCRIBE request if no subscription as been established.
         * Sends a re-SUBSCRIBE request if the subscription is "active".
         */
        Subscriber.prototype.subscribe = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            switch (this.subscriberRequest.state) {
                case core_1.SubscriptionState.Initial:
                    // we can end up here when retrying so only state transition if in SubscriptionState.Initial state
                    if (this.state === subscription_state_1.SubscriptionState.Initial) {
                        this.stateTransition(subscription_state_1.SubscriptionState.NotifyWait);
                    }
                    this.subscriberRequest.subscribe().then(function (result) {
                        if (result.success) {
                            if (result.success.subscription) {
                                _this._dialog = result.success.subscription;
                                _this._dialog.delegate = {
                                    onNotify: function (request) { return _this.onNotify(request); },
                                    onRefresh: function (request) { return _this.onRefresh(request); },
                                    onTerminated: function () { return _this.stateTransition(subscription_state_1.SubscriptionState.Terminated); }
                                };
                            }
                            _this.onNotify(result.success.request);
                        }
                        else if (result.failure) {
                            _this.unsubscribe();
                        }
                    });
                    break;
                case core_1.SubscriptionState.NotifyWait:
                    break;
                case core_1.SubscriptionState.Pending:
                    break;
                case core_1.SubscriptionState.Active:
                    if (this._dialog) {
                        var request = this._dialog.refresh();
                        request.delegate = {
                            onAccept: (function (response) { return _this.onAccepted(response); }),
                            onRedirect: (function (response) { return _this.unsubscribe(); }),
                            onReject: (function (response) { return _this.unsubscribe(); }),
                        };
                    }
                    break;
                case core_1.SubscriptionState.Terminated:
                    break;
                default:
                    break;
            }
            return Promise.resolve();
        };
        /**
         * {@inheritDoc Subscription.unsubscribe}
         */
        Subscriber.prototype.unsubscribe = function (options) {
            if (options === void 0) { options = {}; }
            if (this.disposed) {
                return Promise.resolve();
            }
            switch (this.subscriberRequest.state) {
                case core_1.SubscriptionState.Initial:
                    break;
                case core_1.SubscriptionState.NotifyWait:
                    break;
                case core_1.SubscriptionState.Pending:
                    if (this._dialog) {
                        this._dialog.unsubscribe();
                        // responses intentionally ignored
                    }
                    break;
                case core_1.SubscriptionState.Active:
                    if (this._dialog) {
                        this._dialog.unsubscribe();
                        // responses intentionally ignored
                    }
                    break;
                case core_1.SubscriptionState.Terminated:
                    break;
                default:
                    throw new Error("Unknown state.");
            }
            this.stateTransition(subscription_state_1.SubscriptionState.Terminated);
            return Promise.resolve();
        };
        /**
         * Sends a re-SUBSCRIBE request if the subscription is "active".
         * @deprecated Use `subscribe` instead.
         * @internal
         */
        Subscriber.prototype._refresh = function () {
            if (this.subscriberRequest.state === core_1.SubscriptionState.Active) {
                return this.subscribe();
            }
            return Promise.resolve();
        };
        /** @internal */
        Subscriber.prototype.onAccepted = function (response) {
            // NOTE: If you think you should do something with this response,
            // please make sure you understand what it is you are doing and why.
            // Per the RFC, the first NOTIFY is all that actually matters.
        };
        /** @internal */
        Subscriber.prototype.onNotify = function (request) {
            var _this = this;
            // If we've set state to done, no further processing should take place
            // and we are only interested in cleaning up after the appropriate NOTIFY.
            if (this.disposed) {
                request.accept();
                return;
            }
            // State transition if needed.
            if (this.state !== subscription_state_1.SubscriptionState.Subscribed) {
                this.stateTransition(subscription_state_1.SubscriptionState.Subscribed);
            }
            // Delegate notification.
            if (this.delegate && this.delegate.onNotify) {
                var notification = new notification_1.Notification(request);
                this.delegate.onNotify(notification);
            }
            else {
                request.accept();
            }
            //  If the "Subscription-State" value is SubscriptionState.Terminated, the subscriber
            //  MUST consider the subscription terminated.  The "expires" parameter
            //  has no semantics for SubscriptionState.Terminated -- notifiers SHOULD NOT include an
            //  "expires" parameter on a "Subscription-State" header field with a
            //  value of SubscriptionState.Terminated, and subscribers MUST ignore any such
            //  parameter, if present.  If a reason code is present, the client
            //  should behave as described below.  If no reason code or an unknown
            //  reason code is present, the client MAY attempt to re-subscribe at any
            //  time (unless a "retry-after" parameter is present, in which case the
            //  client SHOULD NOT attempt re-subscription until after the number of
            //  seconds specified by the "retry-after" parameter).  The reason codes
            //  defined by this document are:
            // https://tools.ietf.org/html/rfc6665#section-4.1.3
            var subscriptionState = request.message.parseHeader("Subscription-State");
            if (subscriptionState && subscriptionState.state) {
                switch (subscriptionState.state) {
                    case "terminated":
                        if (subscriptionState.reason) {
                            this.logger.log("Terminated subscription with reason " + subscriptionState.reason);
                            switch (subscriptionState.reason) {
                                case "deactivated":
                                case "timeout":
                                    this.initSubscriberRequest();
                                    this.subscribe();
                                    return;
                                case "probation":
                                case "giveup":
                                    this.initSubscriberRequest();
                                    if (subscriptionState.params && subscriptionState.params["retry-after"]) {
                                        this.retryAfterTimer = setTimeout(function () { return _this.subscribe(); }, subscriptionState.params["retry-after"]);
                                    }
                                    else {
                                        this.subscribe();
                                    }
                                    return;
                                case "rejected":
                                case "noresource":
                                case "invariant":
                                    break;
                            }
                        }
                        this.unsubscribe();
                        break;
                    default:
                        break;
                }
            }
        };
        /** @internal */
        Subscriber.prototype.onRefresh = function (request) {
            var _this = this;
            request.delegate = {
                onAccept: function (response) { return _this.onAccepted(response); }
            };
        };
        Subscriber.prototype.initSubscriberRequest = function () {
            var _this = this;
            var options = {
                extraHeaders: this.extraHeaders,
                body: this.body ? core_1.fromBodyLegacy(this.body) : undefined
            };
            this.subscriberRequest = new SubscriberRequest(this._userAgent.userAgentCore, this.targetURI, this.event, this.expires, options);
            this.subscriberRequest.delegate = {
                onAccept: (function (response) { return _this.onAccepted(response); })
            };
            return this.subscriberRequest;
        };
        return Subscriber;
    }(subscription_1.Subscription));
    exports.Subscriber = Subscriber;
    // tslint:disable-next-line:max-classes-per-file
    var SubscriberRequest = /** @class */ (function () {
        function SubscriberRequest(core, target, event, expires, options, delegate) {
            this.core = core;
            this.target = target;
            this.event = event;
            this.expires = expires;
            this.subscribed = false;
            this.logger = core.loggerFactory.getLogger("sip.Subscriber");
            this.delegate = delegate;
            var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
            var extraHeaders = (options && options.extraHeaders || []).slice();
            extraHeaders.push(allowHeader);
            extraHeaders.push("Event: " + this.event);
            extraHeaders.push("Expires: " + this.expires);
            extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
            var body = options && options.body;
            this.message = core.makeOutgoingRequestMessage(core_1.C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, extraHeaders, body);
        }
        /** Destructor. */
        SubscriberRequest.prototype.dispose = function () {
            if (this.request) {
                this.request.waitNotifyStop();
                this.request.dispose();
                this.request = undefined;
            }
        };
        Object.defineProperty(SubscriberRequest.prototype, "state", {
            /** Subscription state. */
            get: function () {
                if (this.subscription) {
                    return this.subscription.subscriptionState;
                }
                else if (this.subscribed) {
                    return core_1.SubscriptionState.NotifyWait;
                }
                else {
                    return core_1.SubscriptionState.Initial;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Establish subscription.
         * @param options Options bucket.
         */
        SubscriberRequest.prototype.subscribe = function () {
            var _this = this;
            if (this.subscribed) {
                return Promise.reject(new Error("Not in initial state. Did you call subscribe more than once?"));
            }
            this.subscribed = true;
            return new Promise(function (resolve, reject) {
                if (!_this.message) {
                    throw new Error("Message undefined.");
                }
                _this.request = _this.core.subscribe(_this.message, {
                    // This SUBSCRIBE request will be confirmed with a final response.
                    // 200-class responses indicate that the subscription has been accepted
                    // and that a NOTIFY request will be sent immediately.
                    // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                    onAccept: function (response) {
                        if (_this.delegate && _this.delegate.onAccept) {
                            _this.delegate.onAccept(response);
                        }
                    },
                    // Due to the potential for out-of-order messages, packet loss, and
                    // forking, the subscriber MUST be prepared to receive NOTIFY requests
                    // before the SUBSCRIBE transaction has completed.
                    // https://tools.ietf.org/html/rfc6665#section-4.1.2.4
                    onNotify: function (requestWithSubscription) {
                        _this.subscription = requestWithSubscription.subscription;
                        if (_this.subscription) {
                            _this.subscription.autoRefresh = true;
                        }
                        resolve({ success: requestWithSubscription });
                    },
                    // If this Timer N expires prior to the receipt of a NOTIFY request,
                    // the subscriber considers the subscription failed, and cleans up
                    // any state associated with the subscription attempt.
                    // https://tools.ietf.org/html/rfc6665#section-4.1.2.4
                    onNotifyTimeout: function () {
                        resolve({ failure: {} });
                    },
                    // This SUBSCRIBE request will be confirmed with a final response.
                    // Non-200-class final responses indicate that no subscription or new
                    // dialog usage has been created, and no subsequent NOTIFY request will
                    // be sent.
                    // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                    onRedirect: function (response) {
                        resolve({ failure: { response: response } });
                    },
                    // This SUBSCRIBE request will be confirmed with a final response.
                    // Non-200-class final responses indicate that no subscription or new
                    // dialog usage has been created, and no subsequent NOTIFY request will
                    // be sent.
                    // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                    onReject: function (response) {
                        resolve({ failure: { response: response } });
                    }
                });
            });
        };
        return SubscriberRequest;
    }());
    
    
    /***/ }),
    
    /***/ "./src/api/subscription-state.ts":
    /*!***************************************!*\
      !*** ./src/api/subscription-state.ts ***!
      \***************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * {@link Subscription} state.
     * @remarks
     * The {@link Subscription} behaves in a deterministic manner according to the following
     * Finite State Machine (FSM).
     * ```txt
     *                    _______________________________________
     * Subscription      |                                       v
     * Constructed -> Initial -> NotifyWait -> Subscribed -> Terminated
     *                              |____________________________^
     * ```
     * @public
     */
    var SubscriptionState;
    (function (SubscriptionState) {
        SubscriptionState["Initial"] = "Initial";
        SubscriptionState["NotifyWait"] = "NotifyWait";
        SubscriptionState["Subscribed"] = "Subscribed";
        SubscriptionState["Terminated"] = "Terminated";
    })(SubscriptionState = exports.SubscriptionState || (exports.SubscriptionState = {}));
    
    
    /***/ }),
    
    /***/ "./src/api/subscription.ts":
    /*!*********************************!*\
      !*** ./src/api/subscription.ts ***!
      \*********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
    var emitter_1 = __webpack_require__(/*! ./emitter */ "./src/api/emitter.ts");
    var subscription_state_1 = __webpack_require__(/*! ./subscription-state */ "./src/api/subscription-state.ts");
    /**
     * A subscription provides {@link Notification} of events.
     *
     * @remarks
     * See {@link Subscriber} for details on establishing a subscription.
     *
     * @public
     */
    var Subscription = /** @class */ (function () {
        /**
         * Constructor.
         * @param userAgent - User agent. See {@link UserAgent} for details.
         * @internal
         */
        function Subscription(userAgent, options) {
            if (options === void 0) { options = {}; }
            this._disposed = false;
            this._state = subscription_state_1.SubscriptionState.Initial;
            this._stateEventEmitter = new events_1.EventEmitter();
            this._logger = userAgent.getLogger("sip.Subscription");
            this._userAgent = userAgent;
            this.delegate = options.delegate;
        }
        /**
         * Destructor.
         */
        Subscription.prototype.dispose = function () {
            if (this._disposed) {
                return Promise.resolve();
            }
            this._disposed = true;
            this._stateEventEmitter.removeAllListeners();
            return Promise.resolve();
        };
        Object.defineProperty(Subscription.prototype, "dialog", {
            /**
             * The subscribed subscription dialog.
             */
            get: function () {
                return this._dialog;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Subscription.prototype, "disposed", {
            /**
             * True if disposed.
             * @internal
             */
            get: function () {
                return this._disposed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Subscription.prototype, "state", {
            /**
             * Subscription state. See {@link SubscriptionState} for details.
             */
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Subscription.prototype, "stateChange", {
            /**
             * Emits when the subscription `state` property changes.
             */
            get: function () {
                return emitter_1._makeEmitter(this._stateEventEmitter);
            },
            enumerable: true,
            configurable: true
        });
        /** @internal */
        Subscription.prototype.stateTransition = function (newState) {
            var _this = this;
            var invalidTransition = function () {
                throw new Error("Invalid state transition from " + _this._state + " to " + newState);
            };
            // Validate transition
            switch (this._state) {
                case subscription_state_1.SubscriptionState.Initial:
                    if (newState !== subscription_state_1.SubscriptionState.NotifyWait && newState !== subscription_state_1.SubscriptionState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case subscription_state_1.SubscriptionState.NotifyWait:
                    if (newState !== subscription_state_1.SubscriptionState.Subscribed && newState !== subscription_state_1.SubscriptionState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case subscription_state_1.SubscriptionState.Subscribed:
                    if (newState !== subscription_state_1.SubscriptionState.Terminated) {
                        invalidTransition();
                    }
                    break;
                case subscription_state_1.SubscriptionState.Terminated:
                    invalidTransition();
                    break;
                default:
                    throw new Error("Unrecognized state.");
            }
            // Guard against duplicate transition
            if (this._state === newState) {
                return;
            }
            // Transition
            this._state = newState;
            this._logger.log("Subscription " + (this._dialog ? this._dialog.id : undefined) + " transitioned to " + this._state);
            this._stateEventEmitter.emit("event", this._state);
            // Dispose
            if (newState === subscription_state_1.SubscriptionState.Terminated) {
                this.dispose();
            }
        };
        return Subscription;
    }());
    exports.Subscription = Subscription;
    
    
    /***/ }),
    
    /***/ "./src/api/transport-state.ts":
    /*!************************************!*\
      !*** ./src/api/transport-state.ts ***!
      \************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * {@link Transport} state.
     *
     * @remarks
     * The {@link Transport} behaves in a deterministic manner according to the following
     * Finite State Machine (FSM).
     * ```txt
     *                    ______________________________
     *                   |    ____________              |
     * Transport         v   v            |             |
     * Constructed -> Disconnected -> Connecting -> Connected -> Disconnecting
     *                     ^            ^    |_____________________^  |  |
     *                     |            |_____________________________|  |
     *                     |_____________________________________________|
     * ```
     * @public
     */
    var TransportState;
    (function (TransportState) {
        /**
         * The `connect()` method was called.
         */
        TransportState["Connecting"] = "Connecting";
        /**
         * The `connect()` method resolved.
         */
        TransportState["Connected"] = "Connected";
        /**
         * The `disconnect()` method was called.
         */
        TransportState["Disconnecting"] = "Disconnecting";
        /**
         * The `connect()` method was rejected, or
         * the `disconnect()` method completed, or
         * network connectivity was lost.
         */
        TransportState["Disconnected"] = "Disconnected";
    })(TransportState = exports.TransportState || (exports.TransportState = {}));
    
    
    /***/ }),
    
    /***/ "./src/api/user-agent-options.ts":
    /*!***************************************!*\
      !*** ./src/api/user-agent-options.ts ***!
      \***************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * SIP extension support level.
     * @public
     */
    var SIPExtension;
    (function (SIPExtension) {
        SIPExtension["Required"] = "Required";
        SIPExtension["Supported"] = "Supported";
        SIPExtension["Unsupported"] = "Unsupported";
    })(SIPExtension = exports.SIPExtension || (exports.SIPExtension = {}));
    /**
     * SIP Option Tags
     * @remarks
     * http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
     * @public
     */
    exports.UserAgentRegisteredOptionTags = {
        "100rel": true,
        "199": true,
        "answermode": true,
        "early-session": true,
        "eventlist": true,
        "explicitsub": true,
        "from-change": true,
        "geolocation-http": true,
        "geolocation-sip": true,
        "gin": true,
        "gruu": true,
        "histinfo": true,
        "ice": true,
        "join": true,
        "multiple-refer": true,
        "norefersub": true,
        "nosub": true,
        "outbound": true,
        "path": true,
        "policy": true,
        "precondition": true,
        "pref": true,
        "privacy": true,
        "recipient-list-invite": true,
        "recipient-list-message": true,
        "recipient-list-subscribe": true,
        "replaces": true,
        "resource-priority": true,
        "sdp-anat": true,
        "sec-agree": true,
        "tdialog": true,
        "timer": true,
        "uui": true // RFC 7433
    };
    
    
    /***/ }),
    
    /***/ "./src/api/user-agent-state.ts":
    /*!*************************************!*\
      !*** ./src/api/user-agent-state.ts ***!
      \*************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * {@link UserAgent} state.
     * @remarks
     * Valid state transitions:
     * ```
     * 1. "Started" --> "Stopped"
     * 2. "Stopped" --> "Started"
     * ```
     * @public
     */
    var UserAgentState;
    (function (UserAgentState) {
        UserAgentState["Started"] = "Started";
        UserAgentState["Stopped"] = "Stopped";
    })(UserAgentState = exports.UserAgentState || (exports.UserAgentState = {}));
    
    
    /***/ }),
    
    /***/ "./src/api/user-agent.ts":
    /*!*******************************!*\
      !*** ./src/api/user-agent.ts ***!
      \*******************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
    var core_1 = __webpack_require__(/*! ../core */ "./src/core/index.ts");
    var utils_1 = __webpack_require__(/*! ../core/messages/utils */ "./src/core/messages/utils.ts");
    var session_description_handler_1 = __webpack_require__(/*! ../platform/web/session-description-handler */ "./src/platform/web/session-description-handler.ts");
    var transport_1 = __webpack_require__(/*! ../platform/web/transport */ "./src/platform/web/transport.ts");
    var version_1 = __webpack_require__(/*! ../version */ "./src/version.ts");
    var emitter_1 = __webpack_require__(/*! ./emitter */ "./src/api/emitter.ts");
    var invitation_1 = __webpack_require__(/*! ./invitation */ "./src/api/invitation.ts");
    var inviter_1 = __webpack_require__(/*! ./inviter */ "./src/api/inviter.ts");
    var message_1 = __webpack_require__(/*! ./message */ "./src/api/message.ts");
    var notification_1 = __webpack_require__(/*! ./notification */ "./src/api/notification.ts");
    var user_agent_options_1 = __webpack_require__(/*! ./user-agent-options */ "./src/api/user-agent-options.ts");
    var user_agent_state_1 = __webpack_require__(/*! ./user-agent-state */ "./src/api/user-agent-state.ts");
    /**
     * A user agent sends and receives requests using a `Transport`.
     *
     * @remarks
     * A user agent (UA) is associated with a user via the user's SIP address of record (AOR)
     * and acts on behalf of that user to send and receive SIP requests. The user agent can
     * register to receive incoming requests, as well as create and send outbound messages.
     * The user agent also maintains the Transport over which its signaling travels.
     *
     * @public
     */
    var UserAgent = /** @class */ (function () {
        /**
         * Constructs a new instance of the `UserAgent` class.
         * @param options - Options bucket. See {@link UserAgentOptions} for details.
         */
        function UserAgent(options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            /** @internal */
            this._publishers = {};
            /** @internal */
            this._registerers = {};
            /** @internal */
            this._sessions = {};
            /** @internal */
            this._subscriptions = {};
            this._state = user_agent_state_1.UserAgentState.Stopped;
            this._stateEventEmitter = new events_1.EventEmitter();
            this._stateInitial = true;
            /** LoggerFactory. */
            this.loggerFactory = new core_1.LoggerFactory();
            /** Unload listener. */
            this.unloadListener = (function () { _this.stop(); });
            // initialize delegate
            this.delegate = options.delegate;
            // initialize configuration
            this.options = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, UserAgent.defaultOptions), { sipjsId: utils_1.createRandomToken(5) }), { uri: new core_1.URI("sip", "anonymous." + utils_1.createRandomToken(6), "anonymous.invalid") }), { viaHost: utils_1.createRandomToken(12) + ".invalid" }), UserAgent.stripUndefinedProperties(options));
            // viaHost is hack
            if (this.options.hackIpInContact) {
                if (typeof this.options.hackIpInContact === "boolean" && this.options.hackIpInContact) {
                    var from = 1;
                    var to = 254;
                    var octet = Math.floor(Math.random() * (to - from + 1) + from);
                    // random Test-Net IP (http://tools.ietf.org/html/rfc5735)
                    this.options.viaHost = "192.0.2." + octet;
                }
                else if (this.options.hackIpInContact) {
                    this.options.viaHost = this.options.hackIpInContact;
                }
            }
            // initialize logger & logger factory
            this.logger = this.loggerFactory.getLogger("sip.UserAgent");
            this.loggerFactory.builtinEnabled = this.options.logBuiltinEnabled;
            this.loggerFactory.connector = this.options.logConnector;
            switch (this.options.logLevel) {
                case "error":
                    this.loggerFactory.level = core_1.Levels.error;
                    break;
                case "warn":
                    this.loggerFactory.level = core_1.Levels.warn;
                    break;
                case "log":
                    this.loggerFactory.level = core_1.Levels.log;
                    break;
                case "debug":
                    this.loggerFactory.level = core_1.Levels.debug;
                    break;
                default:
                    break;
            }
            if (this.options.logConfiguration) {
                this.logger.log("Configuration:");
                Object.keys(this.options).forEach(function (key) {
                    var value = _this.options[key];
                    switch (key) {
                        case "uri":
                        case "sessionDescriptionHandlerFactory":
                            _this.logger.log(" " + key + ": " + value);
                            break;
                        case "authorizationPassword":
                            _this.logger.log(" " + key + ": " + "NOT SHOWN");
                            break;
                        case "transportConstructor":
                            _this.logger.log(" " + key + ": " + value.name);
                            break;
                        default:
                            _this.logger.log(" " + key + ": " + JSON.stringify(value));
                    }
                });
            }
            // guard deprecated transport options (remove this in version 16.x)
            if (this.options.transportOptions) {
                var optionsDeprecated = this.options.transportOptions;
                var maxReconnectionAttemptsDeprecated = optionsDeprecated.maxReconnectionAttempts;
                var reconnectionTimeoutDeprecated = optionsDeprecated.reconnectionTimeout;
                if (maxReconnectionAttemptsDeprecated !== undefined) {
                    var deprecatedMessage = "The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. " +
                        "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";
                    this.logger.warn(deprecatedMessage);
                }
                if (reconnectionTimeoutDeprecated !== undefined) {
                    var deprecatedMessage = "The transport option \"reconnectionTimeout\" as has apparently been specified and has been deprecated. " +
                        "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";
                    this.logger.warn(deprecatedMessage);
                }
                // hack
                if (options.reconnectionDelay === undefined && reconnectionTimeoutDeprecated !== undefined) {
                    this.options.reconnectionDelay = reconnectionTimeoutDeprecated;
                }
                if (options.reconnectionAttempts === undefined && maxReconnectionAttemptsDeprecated !== undefined) {
                    this.options.reconnectionAttempts = maxReconnectionAttemptsDeprecated;
                }
            }
            // guard deprecated user agent options (remove this in version 16.x)
            if (options.reconnectionDelay !== undefined) {
                var deprecatedMessage = "The user agent option \"reconnectionDelay\" as has apparently been specified and has been deprecated. " +
                    "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";
                this.logger.warn(deprecatedMessage);
            }
            if (options.reconnectionAttempts !== undefined) {
                var deprecatedMessage = "The user agent option \"reconnectionAttempts\" as has apparently been specified and has been deprecated. " +
                    "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";
                this.logger.warn(deprecatedMessage);
            }
            // Initialize Transport
            this._transport = new this.options.transportConstructor(this.getLogger("sip.Transport"), this.options.transportOptions);
            this.initTransportCallbacks();
            // Initialize Contact
            this._contact = this.initContact();
            // Initialize UserAgentCore
            this._userAgentCore = this.initCore();
            if (this.options.autoStart) {
                this.start();
            }
        }
        /**
         * Create a URI instance from a string.
         * @param uri - The string to parse.
         *
         * @example
         * ```ts
         * const uri = UserAgent.makeURI("sip:edgar@example.com");
         * ```
         */
        UserAgent.makeURI = function (uri) {
            return core_1.Grammar.URIParse(uri);
        };
        /**
         * Strip properties with undefined values from options.
         * This is a work around while waiting for missing vs undefined to be addressed (or not)...
         * https://github.com/Microsoft/TypeScript/issues/13195
         * @param options - Options to reduce
         */
        UserAgent.stripUndefinedProperties = function (options) {
            return Object.keys(options).reduce(function (object, key) {
                if (options[key] !== undefined) {
                    object[key] = options[key];
                }
                return object;
            }, {});
        };
        Object.defineProperty(UserAgent.prototype, "configuration", {
            /**
             * User agent configuration.
             */
            get: function () {
                return this.options;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgent.prototype, "contact", {
            /**
             * User agent contact.
             */
            get: function () {
                return this._contact;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgent.prototype, "state", {
            /**
             * User agent state.
             */
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgent.prototype, "stateChange", {
            /**
             * User agent state change emitter.
             */
            get: function () {
                return emitter_1._makeEmitter(this._stateEventEmitter);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgent.prototype, "transport", {
            /**
             * User agent transport.
             */
            get: function () {
                return this._transport;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgent.prototype, "userAgentCore", {
            /**
             * User agent core.
             */
            get: function () {
                return this._userAgentCore;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * The logger.
         */
        UserAgent.prototype.getLogger = function (category, label) {
            return this.loggerFactory.getLogger(category, label);
        };
        /**
         * The logger factory.
         */
        UserAgent.prototype.getLoggerFactory = function () {
            return this.loggerFactory;
        };
        /**
         * True if transport is connected.
         */
        UserAgent.prototype.isConnected = function () {
            return this.transport.isConnected();
        };
        /**
         * Reconnect the transport.
         */
        UserAgent.prototype.reconnect = function () {
            var _this = this;
            if (this.state === user_agent_state_1.UserAgentState.Stopped) {
                return Promise.reject(new Error("User agent stopped."));
            }
            // Make sure we don't call synchronously
            return Promise.resolve().then(function () { return _this.transport.connect(); });
        };
        /**
         * Start the user agent.
         *
         * @remarks
         * Resolves if transport connects, otherwise rejects.
         *
         * @example
         * ```ts
         * userAgent.start()
         *   .then(() => {
         *     // userAgent.isConnected() === true
         *   })
         *   .catch((error: Error) => {
         *     // userAgent.isConnected() === false
         *   });
         * ```
         */
        UserAgent.prototype.start = function () {
            if (this.state === user_agent_state_1.UserAgentState.Started) {
                this.logger.warn("User agent already started");
                return Promise.resolve();
            }
            this.logger.log("Starting " + this.configuration.uri);
            // TODO: Make these properties only valid while in "Started" state.
            // This is hold over of earlier times. Other internal/external code
            // is depending on these properties existing after construction, so
            // we construct the first instance of them during construction. We
            // don't need to remake them the first time start() is called, so
            // we have this little stateInitial thing going on...
            if (!this._stateInitial) {
                this._stateInitial = false;
                // Initialize Transport
                this._transport = new this.options.transportConstructor(this.getLogger("sip.Transport"), this.options.transportOptions);
                this.initTransportCallbacks();
                // Initialize Contact
                this._contact = this.initContact();
                // Initialize UserAgentCore
                this._userAgentCore = this.initCore();
            }
            // Transition state
            this.transitionState(user_agent_state_1.UserAgentState.Started);
            // TODO: Review this as it is not clear it has any benefit and at worst causes additional load the server.
            // On unload it may be best to simply in most scenarios to do nothing. Furthermore and regardless, this
            // kind of behavior seems more appropriate to be managed by the consumer of the API than the API itself.
            // Should this perhaps be deprecated?
            //
            // Add window unload event listener
            if (this.options.autoStop) {
                // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps
                var googleChromePackagedApp = typeof chrome !== "undefined" && chrome.app && chrome.app.runtime ? true : false;
                if (typeof window !== "undefined" &&
                    typeof window.addEventListener === "function" &&
                    !googleChromePackagedApp) {
                    window.addEventListener("unload", this.unloadListener);
                }
            }
            return this.transport.connect();
        };
        /**
         * Stop the user agent.
         *
         * @remarks
         * Resolves when the user agent has completed a graceful shutdown.
         * ```txt
         * 1) Sessions terminate.
         * 2) Registerers unregister.
         * 3) Subscribers unsubscribe.
         * 4) Publishers unpublish.
         * 5) Transport disconnects.
         * 6) User Agent Core resets.
         * ```
         * NOTE: While this is a "graceful shutdown", it can also be very slow one if you
         * are waiting for the returned Promise to resolve. The disposal of the clients and
         * dialogs is done serially - waiting on one to finish before moving on to the next.
         * This can be slow if there are lot of subscriptions to unsubscribe for example.
         *
         * THE SLOW PACE IS INTENTIONAL!
         * While one could spin them all down in parallel, this could slam the remote server.
         * It is bad practice to denial of service attack (DoS attack) servers!!!
         * Moreover, production servers will automatically blacklist clients which send too
         * many requests in too short a period of time - dropping any additional requests.
         *
         * If a different approach to disposing is needed, one can implement whatever is
         * needed and execute that prior to calling `stop()`. Alternatively one may simply
         * not wait for the Promise returned by `stop()` to complete.
         */
        UserAgent.prototype.stop = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var googleChromePackagedApp, publishers, registerers, sessions, subscriptions, transport, userAgentCore, _loop_1, _a, _b, _i, id, _loop_2, _c, _d, _e, id, _loop_3, _f, _g, _h, id, _loop_4, _j, _k, _l, id;
                var _this = this;
                return tslib_1.__generator(this, function (_m) {
                    switch (_m.label) {
                        case 0:
                            if (this.state === user_agent_state_1.UserAgentState.Stopped) {
                                this.logger.warn("User agent already stopped");
                                return [2 /*return*/, Promise.resolve()];
                            }
                            this.logger.log("Stopping " + this.configuration.uri);
                            // Transition state
                            this.transitionState(user_agent_state_1.UserAgentState.Stopped);
                            // TODO: See comments with associated complimentary code in start(). Should this perhaps be deprecated?
                            // Remove window unload event listener
                            if (this.options.autoStop) {
                                googleChromePackagedApp = typeof chrome !== "undefined" && chrome.app && chrome.app.runtime ? true : false;
                                if (typeof window !== "undefined" &&
                                    window.removeEventListener &&
                                    !googleChromePackagedApp) {
                                    window.removeEventListener("unload", this.unloadListener);
                                }
                            }
                            publishers = tslib_1.__assign({}, this._publishers);
                            registerers = tslib_1.__assign({}, this._registerers);
                            sessions = tslib_1.__assign({}, this._sessions);
                            subscriptions = tslib_1.__assign({}, this._subscriptions);
                            transport = this.transport;
                            userAgentCore = this.userAgentCore;
                            //
                            // At this point we have completed the state transition and everything
                            // following will effectively run async and MUST NOT cause any issues
                            // if UserAgent.start() is called while the following code continues.
                            //
                            // TODO: Minor optimization.
                            // The disposal in all cases involves, in part, sending messages which
                            // is not worth doing if the transport is not connected as we know attempting
                            // to send messages will be futile. But none of these disposal methods check
                            // if that's is the case and it would be easy for them to do so at this point.
                            // Dispose of Registerers
                            this.logger.log("Dispose of registerers");
                            _loop_1 = function (id) {
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (!registerers[id]) return [3 /*break*/, 2];
                                            return [4 /*yield*/, registerers[id].dispose()
                                                    .catch(function (error) {
                                                    _this.logger.error(error.message);
                                                    delete _this._registerers[id];
                                                    throw error;
                                                })];
                                        case 1:
                                            _a.sent();
                                            _a.label = 2;
                                        case 2: return [2 /*return*/];
                                    }
                                });
                            };
                            _a = [];
                            for (_b in registerers)
                                _a.push(_b);
                            _i = 0;
                            _m.label = 1;
                        case 1:
                            if (!(_i < _a.length)) return [3 /*break*/, 4];
                            id = _a[_i];
                            return [5 /*yield**/, _loop_1(id)];
                        case 2:
                            _m.sent();
                            _m.label = 3;
                        case 3:
                            _i++;
                            return [3 /*break*/, 1];
                        case 4:
                            // Dispose of Sessions
                            this.logger.log("Dispose of sessions");
                            _loop_2 = function (id) {
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (!sessions[id]) return [3 /*break*/, 2];
                                            return [4 /*yield*/, sessions[id].dispose()
                                                    .catch(function (error) {
                                                    _this.logger.error(error.message);
                                                    delete _this._sessions[id];
                                                    throw error;
                                                })];
                                        case 1:
                                            _a.sent();
                                            _a.label = 2;
                                        case 2: return [2 /*return*/];
                                    }
                                });
                            };
                            _c = [];
                            for (_d in sessions)
                                _c.push(_d);
                            _e = 0;
                            _m.label = 5;
                        case 5:
                            if (!(_e < _c.length)) return [3 /*break*/, 8];
                            id = _c[_e];
                            return [5 /*yield**/, _loop_2(id)];
                        case 6:
                            _m.sent();
                            _m.label = 7;
                        case 7:
                            _e++;
                            return [3 /*break*/, 5];
                        case 8:
                            // Dispose of Subscriptions
                            this.logger.log("Dispose of subscriptions");
                            _loop_3 = function (id) {
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (!subscriptions[id]) return [3 /*break*/, 2];
                                            return [4 /*yield*/, subscriptions[id].dispose()
                                                    .catch(function (error) {
                                                    _this.logger.error(error.message);
                                                    delete _this._subscriptions[id];
                                                    throw error;
                                                })];
                                        case 1:
                                            _a.sent();
                                            _a.label = 2;
                                        case 2: return [2 /*return*/];
                                    }
                                });
                            };
                            _f = [];
                            for (_g in subscriptions)
                                _f.push(_g);
                            _h = 0;
                            _m.label = 9;
                        case 9:
                            if (!(_h < _f.length)) return [3 /*break*/, 12];
                            id = _f[_h];
                            return [5 /*yield**/, _loop_3(id)];
                        case 10:
                            _m.sent();
                            _m.label = 11;
                        case 11:
                            _h++;
                            return [3 /*break*/, 9];
                        case 12:
                            // Dispose of Publishers
                            this.logger.log("Dispose of publishers");
                            _loop_4 = function (id) {
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (!publishers[id]) return [3 /*break*/, 2];
                                            return [4 /*yield*/, publishers[id].dispose()
                                                    .catch(function (error) {
                                                    _this.logger.error(error.message);
                                                    delete _this._publishers[id];
                                                    throw error;
                                                })];
                                        case 1:
                                            _a.sent();
                                            _a.label = 2;
                                        case 2: return [2 /*return*/];
                                    }
                                });
                            };
                            _j = [];
                            for (_k in publishers)
                                _j.push(_k);
                            _l = 0;
                            _m.label = 13;
                        case 13:
                            if (!(_l < _j.length)) return [3 /*break*/, 16];
                            id = _j[_l];
                            return [5 /*yield**/, _loop_4(id)];
                        case 14:
                            _m.sent();
                            _m.label = 15;
                        case 15:
                            _l++;
                            return [3 /*break*/, 13];
                        case 16:
                            // Dispose of the transport (disconnecting)
                            this.logger.log("Dispose of transport");
                            return [4 /*yield*/, transport.dispose()
                                    .catch(function (error) {
                                    _this.logger.error(error.message);
                                    throw error;
                                })];
                        case 17:
                            _m.sent();
                            // Dispose of the user agent core (resetting)
                            this.logger.log("Dispose of core");
                            userAgentCore.dispose();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Used to avoid circular references.
         * @internal
         */
        UserAgent.prototype._makeInviter = function (targetURI, options) {
            return new inviter_1.Inviter(this, targetURI, options);
        };
        /**
         * Attempt reconnection up to `maxReconnectionAttempts` times.
         * @param reconnectionAttempt - Current attempt number.
         */
        UserAgent.prototype.attemptReconnection = function (reconnectionAttempt) {
            var _this = this;
            if (reconnectionAttempt === void 0) { reconnectionAttempt = 1; }
            var reconnectionAttempts = this.options.reconnectionAttempts;
            var reconnectionDelay = this.options.reconnectionDelay;
            if (reconnectionAttempt > reconnectionAttempts) {
                this.logger.log("Maximum reconnection attempts reached");
                return;
            }
            this.logger.log("Reconnection attempt " + reconnectionAttempt + " of " + reconnectionAttempts + " - trying");
            setTimeout(function () {
                _this.reconnect()
                    .then(function () {
                    _this.logger.log("Reconnection attempt " + reconnectionAttempt + " of " + reconnectionAttempts + " - succeeded");
                })
                    .catch(function (error) {
                    _this.logger.error(error.message);
                    _this.logger.log("Reconnection attempt " + reconnectionAttempt + " of " + reconnectionAttempts + " - failed");
                    _this.attemptReconnection(++reconnectionAttempt);
                });
            }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);
        };
        /**
         * Initialize contact.
         */
        UserAgent.prototype.initContact = function () {
            var _this = this;
            var contactName = utils_1.createRandomToken(8); // FIXME: should be configurable
            var contactTransport = this.options.hackWssInTransport ? "wss" : "ws"; // FIXME: clearly broken for non ws transports
            var contact = {
                pubGruu: undefined,
                tempGruu: undefined,
                uri: new core_1.URI("sip", contactName, this.options.viaHost, undefined, { transport: contactTransport }),
                toString: function (contactToStringOptions) {
                    if (contactToStringOptions === void 0) { contactToStringOptions = {}; }
                    var anonymous = contactToStringOptions.anonymous || false;
                    var outbound = contactToStringOptions.outbound || false;
                    var contactString = "<";
                    if (anonymous) {
                        contactString += _this.contact.tempGruu || "sip:anonymous@anonymous.invalid;transport=" + contactTransport;
                    }
                    else {
                        contactString += _this.contact.pubGruu || _this.contact.uri;
                    }
                    if (outbound) {
                        contactString += ";ob";
                    }
                    contactString += ">";
                    return contactString;
                }
            };
            return contact;
        };
        /**
         * Initialize user agent core.
         */
        UserAgent.prototype.initCore = function () {
            var _this = this;
            // supported options
            var supportedOptionTags = [];
            supportedOptionTags.push("outbound"); // TODO: is this really supported?
            if (this.options.sipExtension100rel === user_agent_options_1.SIPExtension.Supported) {
                supportedOptionTags.push("100rel");
            }
            if (this.options.sipExtensionReplaces === user_agent_options_1.SIPExtension.Supported) {
                supportedOptionTags.push("replaces");
            }
            if (this.options.sipExtensionExtraSupported) {
                supportedOptionTags.push.apply(supportedOptionTags, this.options.sipExtensionExtraSupported);
            }
            if (!this.options.hackAllowUnregisteredOptionTags) {
                supportedOptionTags = supportedOptionTags.filter(function (optionTag) { return user_agent_options_1.UserAgentRegisteredOptionTags[optionTag]; });
            }
            supportedOptionTags = Array.from(new Set(supportedOptionTags)); // array of unique values
            // FIXME: TODO: This was ported, but this is and was just plain broken.
            var supportedOptionTagsResponse = supportedOptionTags.slice();
            if (this.contact.pubGruu || this.contact.tempGruu) {
                supportedOptionTagsResponse.push("gruu");
            }
            // core configuration
            var userAgentCoreConfiguration = {
                aor: this.options.uri,
                contact: this.contact,
                displayName: this.options.displayName,
                loggerFactory: this.loggerFactory,
                hackViaTcp: this.options.hackViaTcp,
                routeSet: this.options.preloadedRouteSet,
                supportedOptionTags: supportedOptionTags,
                supportedOptionTagsResponse: supportedOptionTagsResponse,
                sipjsId: this.options.sipjsId,
                userAgentHeaderFieldValue: this.options.userAgentString,
                viaForceRport: this.options.forceRport,
                viaHost: this.options.viaHost,
                authenticationFactory: function () {
                    var username = _this.options.authorizationUsername ?
                        _this.options.authorizationUsername :
                        _this.options.uri.user; // if authorization username not provided, use uri user as username
                    var password = _this.options.authorizationPassword ?
                        _this.options.authorizationPassword :
                        undefined;
                    return new core_1.DigestAuthentication(_this.getLoggerFactory(), username, password);
                },
                transportAccessor: function () { return _this.transport; }
            };
            var userAgentCoreDelegate = {
                onInvite: function (incomingInviteRequest) {
                    var invitation = new invitation_1.Invitation(_this, incomingInviteRequest);
                    incomingInviteRequest.delegate = {
                        onCancel: function (cancel) {
                            invitation._onCancel(cancel);
                        },
                        onTransportError: function (error) {
                            // A server transaction MUST NOT discard transaction state based only on
                            // encountering a non-recoverable transport error when sending a
                            // response.  Instead, the associated INVITE server transaction state
                            // machine MUST remain in its current state.  (Timers will eventually
                            // cause it to transition to the "Terminated" state).
                            // https://tools.ietf.org/html/rfc6026#section-7.1
                            // As noted in the comment above, we are to leaving it to the transaction
                            // timers to eventually cause the transaction to sort itself out in the case
                            // of a transport failure in an invite server transaction. This delegate method
                            // is here simply here for completeness and to make it clear that it provides
                            // nothing more than informational hook into the core. That is, if you think
                            // you should be trying to deal with a transport error here, you are likely wrong.
                            _this.logger.error("A transport error has occurred while handling an incoming INVITE request.");
                        }
                    };
                    // FIXME: Ported - 100 Trying send should be configurable.
                    // Only required if TU will not respond in 200ms.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.1
                    incomingInviteRequest.trying();
                    // The Replaces header contains information used to match an existing
                    // SIP dialog (call-id, to-tag, and from-tag).  Upon receiving an INVITE
                    // with a Replaces header, the User Agent (UA) attempts to match this
                    // information with a confirmed or early dialog.
                    // https://tools.ietf.org/html/rfc3891#section-3
                    if (_this.options.sipExtensionReplaces !== user_agent_options_1.SIPExtension.Unsupported) {
                        var message = incomingInviteRequest.message;
                        var replaces = message.parseHeader("replaces");
                        if (replaces) {
                            var callId = replaces.call_id;
                            if (typeof callId !== "string") {
                                throw new Error("Type of call id is not string");
                            }
                            var toTag = replaces.replaces_to_tag;
                            if (typeof toTag !== "string") {
                                throw new Error("Type of to tag is not string");
                            }
                            var fromTag = replaces.replaces_from_tag;
                            if (typeof fromTag !== "string") {
                                throw new Error("type of from tag is not string");
                            }
                            var targetDialogId = callId + toTag + fromTag;
                            var targetDialog = _this.userAgentCore.dialogs.get(targetDialogId);
                            // If no match is found, the UAS rejects the INVITE and returns a 481
                            // Call/Transaction Does Not Exist response.  Likewise, if the Replaces
                            // header field matches a dialog which was not created with an INVITE,
                            // the UAS MUST reject the request with a 481 response.
                            // https://tools.ietf.org/html/rfc3891#section-3
                            if (!targetDialog) {
                                invitation.reject({ statusCode: 481 });
                                return;
                            }
                            // If the Replaces header field matches a confirmed dialog, it checks
                            // for the presence of the "early-only" flag in the Replaces header
                            // field.  (This flag allows the UAC to prevent a potentially
                            // undesirable race condition described in Section 7.1.) If the flag is
                            // present, the UA rejects the request with a 486 Busy response.
                            // https://tools.ietf.org/html/rfc3891#section-3
                            if (!targetDialog.early && replaces.early_only === true) {
                                invitation.reject({ statusCode: 486 });
                                return;
                            }
                            // Provide a handle on the session being replaced.
                            var targetSession = _this._sessions[callId + fromTag] || _this._sessions[callId + toTag] || undefined;
                            if (!targetSession) {
                                throw new Error("Session does not exist.");
                            }
                            invitation._replacee = targetSession;
                        }
                    }
                    // A common scenario occurs when the callee is currently not willing or
                    // able to take additional calls at this end system.  A 486 (Busy Here)
                    // SHOULD be returned in such a scenario.
                    // https://tools.ietf.org/html/rfc3261#section-13.3.1.3
                    if (!_this.delegate || !_this.delegate.onInvite) {
                        invitation.reject({ statusCode: 486 });
                        return;
                    }
                    // Delegate invitation handling.
                    if (!invitation.autoSendAnInitialProvisionalResponse) {
                        _this.delegate.onInvite(invitation);
                    }
                    else {
                        var onInvite_1 = _this.delegate.onInvite;
                        invitation.progress()
                            .then(function () { return onInvite_1(invitation); });
                    }
                },
                onMessage: function (incomingMessageRequest) {
                    if (_this.delegate && _this.delegate.onMessage) {
                        var message = new message_1.Message(incomingMessageRequest);
                        _this.delegate.onMessage(message);
                    }
                    else {
                        // Accept the MESSAGE request, but do nothing with it.
                        incomingMessageRequest.accept();
                    }
                },
                onNotify: function (incomingNotifyRequest) {
                    // NOTIFY requests are sent to inform subscribers of changes in state to
                    // which the subscriber has a subscription.  Subscriptions are created
                    // using the SUBSCRIBE method.  In legacy implementations, it is
                    // possible that other means of subscription creation have been used.
                    // However, this specification does not allow the creation of
                    // subscriptions except through SUBSCRIBE requests and (for backwards-
                    // compatibility) REFER requests [RFC3515].
                    // https://tools.ietf.org/html/rfc6665#section-3.2
                    if (_this.delegate && _this.delegate.onNotify) {
                        var notification = new notification_1.Notification(incomingNotifyRequest);
                        _this.delegate.onNotify(notification);
                    }
                    else {
                        // Per the above which obsoletes https://tools.ietf.org/html/rfc3265,
                        // the use of out of dialog NOTIFY is obsolete, but...
                        if (_this.options.allowLegacyNotifications) {
                            incomingNotifyRequest.accept(); // Accept the NOTIFY request, but do nothing with it.
                        }
                        else {
                            incomingNotifyRequest.reject({ statusCode: 481 });
                        }
                    }
                },
                onRefer: function (incomingReferRequest) {
                    _this.logger.log("Received an out of dialog refer");
                    if (!_this.options.allowOutOfDialogRefers) {
                        incomingReferRequest.reject({ statusCode: 405 });
                    }
                    _this.logger.log("Allow out of dialog refers is enabled on the UA");
                    // const referContext = new ReferServerContext(this, incomingReferRequest);
                    // if (this.listeners("outOfDialogReferRequested").length) {
                    //   this.emit("outOfDialogReferRequested", referContext);
                    // } else {
                    //   this.logger.log(
                    //     "No outOfDialogReferRequest listeners, automatically accepting and following the out of dialog refer"
                    //   );
                    //   referContext.accept({ followRefer: true });
                    // }
                    // if (this.delegate && this.delegate.onRefer) {
                    //   this.delegate.onRefer(incomingReferRequest);
                    // }
                },
                onRegister: function (incomingRegisterRequest) {
                    // TOOD: this.delegate.onRegister(...)
                    if (_this.delegate && _this.delegate.onRegisterRequest) {
                        _this.delegate.onRegisterRequest(incomingRegisterRequest);
                    }
                },
                onSubscribe: function (incomingSubscribeRequest) {
                    // TOOD: this.delegate.onSubscribe(...)
                    if (_this.delegate && _this.delegate.onSubscribeRequest) {
                        _this.delegate.onSubscribeRequest(incomingSubscribeRequest);
                    }
                }
            };
            return new core_1.UserAgentCore(userAgentCoreConfiguration, userAgentCoreDelegate);
        };
        UserAgent.prototype.initTransportCallbacks = function () {
            var _this = this;
            this.transport.onConnect = function () { return _this.onTransportConnect(); };
            this.transport.onDisconnect = function (error) { return _this.onTransportDisconnect(error); };
            this.transport.onMessage = function (message) { return _this.onTransportMessage(message); };
        };
        UserAgent.prototype.onTransportConnect = function () {
            if (this.state === user_agent_state_1.UserAgentState.Stopped) {
                return;
            }
            if (this.delegate && this.delegate.onConnect) {
                this.delegate.onConnect();
            }
        };
        UserAgent.prototype.onTransportDisconnect = function (error) {
            if (this.state === user_agent_state_1.UserAgentState.Stopped) {
                return;
            }
            if (this.delegate && this.delegate.onDisconnect) {
                this.delegate.onDisconnect(error);
            }
            // Only attempt to reconnect if network/server dropped the connection.
            if (error && this.options.reconnectionAttempts > 0) {
                this.attemptReconnection();
            }
        };
        UserAgent.prototype.onTransportMessage = function (messageString) {
            var _this = this;
            var message = core_1.Parser.parseMessage(messageString, this.getLogger("sip.Parser"));
            if (!message) {
                this.logger.warn("Failed to parse incoming message. Dropping.");
                return;
            }
            if (this.state === user_agent_state_1.UserAgentState.Stopped && message instanceof core_1.IncomingRequestMessage) {
                this.logger.warn("Received " + message.method + " request while stopped. Dropping.");
                return;
            }
            // A valid SIP request formulated by a UAC MUST, at a minimum, contain
            // the following header fields: To, From, CSeq, Call-ID, Max-Forwards,
            // and Via; all of these header fields are mandatory in all SIP
            // requests.
            // https://tools.ietf.org/html/rfc3261#section-8.1.1
            var hasMinimumHeaders = function () {
                var mandatoryHeaders = ["from", "to", "call_id", "cseq", "via"];
                for (var _i = 0, mandatoryHeaders_1 = mandatoryHeaders; _i < mandatoryHeaders_1.length; _i++) {
                    var header = mandatoryHeaders_1[_i];
                    if (!message.hasHeader(header)) {
                        _this.logger.warn("Missing mandatory header field : " + header + ".");
                        return false;
                    }
                }
                return true;
            };
            // Request Checks
            if (message instanceof core_1.IncomingRequestMessage) {
                // This is port of SanityCheck.minimumHeaders().
                if (!hasMinimumHeaders()) {
                    this.logger.warn("Request missing mandatory header field. Dropping.");
                    return;
                }
                // FIXME: This is non-standard and should be a configurable behavior (desirable regardless).
                // Custom SIP.js check to reject request from ourself (this instance of SIP.js).
                // This is port of SanityCheck.rfc3261_16_3_4().
                if (!message.toTag && message.callId.substr(0, 5) === this.options.sipjsId) {
                    this.userAgentCore.replyStateless(message, { statusCode: 482 });
                    return;
                }
                // FIXME: This should be Transport check before we get here (Section 18).
                // Custom SIP.js check to reject requests if body length wrong.
                // This is port of SanityCheck.rfc3261_18_3_request().
                var len = utils_1.str_utf8_length(message.body);
                var contentLength = message.getHeader("content-length");
                if (contentLength && len < Number(contentLength)) {
                    this.userAgentCore.replyStateless(message, { statusCode: 400 });
                    return;
                }
            }
            // Response Checks
            if (message instanceof core_1.IncomingResponseMessage) {
                // This is port of SanityCheck.minimumHeaders().
                if (!hasMinimumHeaders()) {
                    this.logger.warn("Response missing mandatory header field. Dropping.");
                    return;
                }
                // Custom SIP.js check to drop responses if multiple Via headers.
                // This is port of SanityCheck.rfc3261_8_1_3_3().
                if (message.getHeaders("via").length > 1) {
                    this.logger.warn("More than one Via header field present in the response. Dropping.");
                    return;
                }
                // FIXME: This should be Transport check before we get here (Section 18).
                // Custom SIP.js check to drop responses if bad Via header.
                // This is port of SanityCheck.rfc3261_18_1_2().
                if (message.via.host !== this.options.viaHost || message.via.port !== undefined) {
                    this.logger.warn("Via sent-by in the response does not match UA Via host value. Dropping.");
                    return;
                }
                // FIXME: This should be Transport check before we get here (Section 18).
                // Custom SIP.js check to reject requests if body length wrong.
                // This is port of SanityCheck.rfc3261_18_3_response().
                var len = utils_1.str_utf8_length(message.body);
                var contentLength = message.getHeader("content-length");
                if (contentLength && len < Number(contentLength)) {
                    this.logger.warn("Message body length is lower than the value in Content-Length header field. Dropping.");
                    return;
                }
            }
            // Handle Request
            if (message instanceof core_1.IncomingRequestMessage) {
                this.userAgentCore.receiveIncomingRequestFromTransport(message);
                return;
            }
            // Handle Response
            if (message instanceof core_1.IncomingResponseMessage) {
                this.userAgentCore.receiveIncomingResponseFromTransport(message);
                return;
            }
            throw new Error("Invalid message type.");
        };
        /**
         * Transition state.
         */
        UserAgent.prototype.transitionState = function (newState, error) {
            var _this = this;
            var invalidTransition = function () {
                throw new Error("Invalid state transition from " + _this._state + " to " + newState);
            };
            // Validate state transition
            switch (this._state) {
                case user_agent_state_1.UserAgentState.Started:
                    if (newState !== user_agent_state_1.UserAgentState.Stopped) {
                        invalidTransition();
                    }
                    break;
                case user_agent_state_1.UserAgentState.Stopped:
                    if (newState !== user_agent_state_1.UserAgentState.Started) {
                        invalidTransition();
                    }
                    break;
                default:
                    throw new Error("Unknown state.");
            }
            // Update state
            this.logger.log("Transitioned from " + this._state + " to " + newState);
            this._state = newState;
            this._stateEventEmitter.emit("event", this._state);
        };
        /** Default user agent options. */
        UserAgent.defaultOptions = {
            allowLegacyNotifications: false,
            allowOutOfDialogRefers: false,
            authorizationPassword: "",
            authorizationUsername: "",
            autoStart: false,
            autoStop: true,
            delegate: {},
            displayName: "",
            forceRport: false,
            hackAllowUnregisteredOptionTags: false,
            hackIpInContact: false,
            hackViaTcp: false,
            hackWssInTransport: false,
            logBuiltinEnabled: true,
            logConfiguration: true,
            logConnector: function () { },
            logLevel: "log",
            noAnswerTimeout: 60,
            preloadedRouteSet: [],
            reconnectionAttempts: 0,
            reconnectionDelay: 4,
            sessionDescriptionHandlerFactory: session_description_handler_1.SessionDescriptionHandler.defaultFactory,
            sessionDescriptionHandlerFactoryOptions: {},
            sipExtension100rel: user_agent_options_1.SIPExtension.Unsupported,
            sipExtensionReplaces: user_agent_options_1.SIPExtension.Unsupported,
            sipExtensionExtraSupported: [],
            sipjsId: "",
            transportConstructor: transport_1.Transport,
            transportOptions: {},
            uri: new core_1.URI("sip", "anonymous", "anonymous.invalid"),
            userAgentString: "SIP.js/" + version_1.LIBRARY_VERSION,
            viaHost: ""
        };
        return UserAgent;
    }());
    exports.UserAgent = UserAgent;
    
    
    /***/ }),
    
    /***/ "./src/core/dialogs/dialog.ts":
    /*!************************************!*\
      !*** ./src/core/dialogs/dialog.ts ***!
      \************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    /**
     * Dialog.
     * @remarks
     * A key concept for a user agent is that of a dialog.  A dialog
     * represents a peer-to-peer SIP relationship between two user agents
     * that persists for some time.  The dialog facilitates sequencing of
     * messages between the user agents and proper routing of requests
     * between both of them.  The dialog represents a context in which to
     * interpret SIP messages.
     * https://tools.ietf.org/html/rfc3261#section-12
     * @public
     */
    var Dialog = /** @class */ (function () {
        /**
         * Dialog constructor.
         * @param core - User agent core.
         * @param dialogState - Initial dialog state.
         */
        function Dialog(core, dialogState) {
            this.core = core;
            this.dialogState = dialogState;
            this.core.dialogs.set(this.id, this);
        }
        /**
         * When a UAC receives a response that establishes a dialog, it
         * constructs the state of the dialog.  This state MUST be maintained
         * for the duration of the dialog.
         * https://tools.ietf.org/html/rfc3261#section-12.1.2
         * @param outgoingRequestMessage - Outgoing request message for dialog.
         * @param incomingResponseMessage - Incoming response message creating dialog.
         */
        Dialog.initialDialogStateForUserAgentClient = function (outgoingRequestMessage, incomingResponseMessage) {
            // If the request was sent over TLS, and the Request-URI contained a
            // SIPS URI, the "secure" flag is set to TRUE.
            // https://tools.ietf.org/html/rfc3261#section-12.1.2
            var secure = false; // FIXME: Currently no support for TLS.
            // The route set MUST be set to the list of URIs in the Record-Route
            // header field from the response, taken in reverse order and preserving
            // all URI parameters.  If no Record-Route header field is present in
            // the response, the route set MUST be set to the empty set.  This route
            // set, even if empty, overrides any pre-existing route set for future
            // requests in this dialog.  The remote target MUST be set to the URI
            // from the Contact header field of the response.
            // https://tools.ietf.org/html/rfc3261#section-12.1.2
            var routeSet = incomingResponseMessage.getHeaders("record-route").reverse();
            var contact = incomingResponseMessage.parseHeader("contact");
            if (!contact) { // TODO: Review to make sure this will never happen
                throw new Error("Contact undefined.");
            }
            if (!(contact instanceof messages_1.NameAddrHeader)) {
                throw new Error("Contact not instance of NameAddrHeader.");
            }
            var remoteTarget = contact.uri;
            // The local sequence number MUST be set to the value of the sequence
            // number in the CSeq header field of the request.  The remote sequence
            // number MUST be empty (it is established when the remote UA sends a
            // request within the dialog).  The call identifier component of the
            // dialog ID MUST be set to the value of the Call-ID in the request.
            // The local tag component of the dialog ID MUST be set to the tag in
            // the From field in the request, and the remote tag component of the
            // dialog ID MUST be set to the tag in the To field of the response.  A
            // UAC MUST be prepared to receive a response without a tag in the To
            // field, in which case the tag is considered to have a value of null.
            //
            //    This is to maintain backwards compatibility with RFC 2543, which
            //    did not mandate To tags.
            //
            // https://tools.ietf.org/html/rfc3261#section-12.1.2
            var localSequenceNumber = outgoingRequestMessage.cseq;
            var remoteSequenceNumber = undefined;
            var callId = outgoingRequestMessage.callId;
            var localTag = outgoingRequestMessage.fromTag;
            var remoteTag = incomingResponseMessage.toTag;
            if (!callId) { // TODO: Review to make sure this will never happen
                throw new Error("Call id undefined.");
            }
            if (!localTag) { // TODO: Review to make sure this will never happen
                throw new Error("From tag undefined.");
            }
            if (!remoteTag) { // TODO: Review to make sure this will never happen
                throw new Error("To tag undefined."); // FIXME: No backwards compatibility with RFC 2543
            }
            // The remote URI MUST be set to the URI in the To field, and the local
            // URI MUST be set to the URI in the From field.
            // https://tools.ietf.org/html/rfc3261#section-12.1.2
            if (!outgoingRequestMessage.from) { // TODO: Review to make sure this will never happen
                throw new Error("From undefined.");
            }
            if (!outgoingRequestMessage.to) { // TODO: Review to make sure this will never happen
                throw new Error("To undefined.");
            }
            var localURI = outgoingRequestMessage.from.uri;
            var remoteURI = outgoingRequestMessage.to.uri;
            // A dialog can also be in the "early" state, which occurs when it is
            // created with a provisional response, and then transition to the
            // "confirmed" state when a 2xx final response arrives.
            // https://tools.ietf.org/html/rfc3261#section-12
            if (!incomingResponseMessage.statusCode) {
                throw new Error("Incoming response status code undefined.");
            }
            var early = incomingResponseMessage.statusCode < 200 ? true : false;
            var dialogState = {
                id: callId + localTag + remoteTag,
                early: early,
                callId: callId,
                localTag: localTag,
                remoteTag: remoteTag,
                localSequenceNumber: localSequenceNumber,
                remoteSequenceNumber: remoteSequenceNumber,
                localURI: localURI,
                remoteURI: remoteURI,
                remoteTarget: remoteTarget,
                routeSet: routeSet,
                secure: secure
            };
            return dialogState;
        };
        /**
         * The UAS then constructs the state of the dialog.  This state MUST be
         * maintained for the duration of the dialog.
         * https://tools.ietf.org/html/rfc3261#section-12.1.1
         * @param incomingRequestMessage - Incoming request message creating dialog.
         * @param toTag - Tag in the To field in the response to the incoming request.
         */
        Dialog.initialDialogStateForUserAgentServer = function (incomingRequestMessage, toTag, early) {
            if (early === void 0) { early = false; }
            // If the request arrived over TLS, and the Request-URI contained a SIPS
            // URI, the "secure" flag is set to TRUE.
            // https://tools.ietf.org/html/rfc3261#section-12.1.1
            var secure = false; // FIXME: Currently no support for TLS.
            // The route set MUST be set to the list of URIs in the Record-Route
            // header field from the request, taken in order and preserving all URI
            // parameters.  If no Record-Route header field is present in the
            // request, the route set MUST be set to the empty set.  This route set,
            // even if empty, overrides any pre-existing route set for future
            // requests in this dialog.  The remote target MUST be set to the URI
            // from the Contact header field of the request.
            // https://tools.ietf.org/html/rfc3261#section-12.1.1
            var routeSet = incomingRequestMessage.getHeaders("record-route");
            var contact = incomingRequestMessage.parseHeader("contact");
            if (!contact) { // TODO: Review to make sure this will never happen
                throw new Error("Contact undefined.");
            }
            if (!(contact instanceof messages_1.NameAddrHeader)) {
                throw new Error("Contact not instance of NameAddrHeader.");
            }
            var remoteTarget = contact.uri;
            // The remote sequence number MUST be set to the value of the sequence
            // number in the CSeq header field of the request.  The local sequence
            // number MUST be empty.  The call identifier component of the dialog ID
            // MUST be set to the value of the Call-ID in the request.  The local
            // tag component of the dialog ID MUST be set to the tag in the To field
            // in the response to the request (which always includes a tag), and the
            // remote tag component of the dialog ID MUST be set to the tag from the
            // From field in the request.  A UAS MUST be prepared to receive a
            // request without a tag in the From field, in which case the tag is
            // considered to have a value of null.
            //
            //    This is to maintain backwards compatibility with RFC 2543, which
            //    did not mandate From tags.
            //
            // https://tools.ietf.org/html/rfc3261#section-12.1.1
            var remoteSequenceNumber = incomingRequestMessage.cseq;
            var localSequenceNumber = undefined;
            var callId = incomingRequestMessage.callId;
            var localTag = toTag;
            var remoteTag = incomingRequestMessage.fromTag;
            // The remote URI MUST be set to the URI in the From field, and the
            // local URI MUST be set to the URI in the To field.
            // https://tools.ietf.org/html/rfc3261#section-12.1.1
            var remoteURI = incomingRequestMessage.from.uri;
            var localURI = incomingRequestMessage.to.uri;
            var dialogState = {
                id: callId + localTag + remoteTag,
                early: early,
                callId: callId,
                localTag: localTag,
                remoteTag: remoteTag,
                localSequenceNumber: localSequenceNumber,
                remoteSequenceNumber: remoteSequenceNumber,
                localURI: localURI,
                remoteURI: remoteURI,
                remoteTarget: remoteTarget,
                routeSet: routeSet,
                secure: secure
            };
            return dialogState;
        };
        /** Destructor. */
        Dialog.prototype.dispose = function () {
            this.core.dialogs.delete(this.id);
        };
        Object.defineProperty(Dialog.prototype, "id", {
            /**
             * A dialog is identified at each UA with a dialog ID, which consists of
             * a Call-ID value, a local tag and a remote tag.  The dialog ID at each
             * UA involved in the dialog is not the same.  Specifically, the local
             * tag at one UA is identical to the remote tag at the peer UA.  The
             * tags are opaque tokens that facilitate the generation of unique
             * dialog IDs.
             * https://tools.ietf.org/html/rfc3261#section-12
             */
            get: function () {
                return this.dialogState.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "early", {
            /**
             * A dialog can also be in the "early" state, which occurs when it is
             * created with a provisional response, and then it transition to the
             * "confirmed" state when a 2xx final response received or is sent.
             *
             * Note: RFC 3261 is concise on when a dialog is "confirmed", but it
             * can be a point of confusion if an INVITE dialog is "confirmed" after
             * a 2xx is sent or after receiving the ACK for the 2xx response.
             * With careful reading it can be inferred a dialog is always is
             * "confirmed" when the 2xx is sent (regardless of type of dialog).
             * However a INVITE dialog does have additional considerations
             * when it is confirmed but an ACK has not yet been received (in
             * particular with regard to a callee sending BYE requests).
             */
            get: function () {
                return this.dialogState.early;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "callId", {
            /** Call identifier component of the dialog id. */
            get: function () {
                return this.dialogState.callId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "localTag", {
            /** Local tag component of the dialog id. */
            get: function () {
                return this.dialogState.localTag;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "remoteTag", {
            /** Remote tag component of the dialog id. */
            get: function () {
                return this.dialogState.remoteTag;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "localSequenceNumber", {
            /** Local sequence number (used to order requests from the UA to its peer). */
            get: function () {
                return this.dialogState.localSequenceNumber;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "remoteSequenceNumber", {
            /** Remote sequence number (used to order requests from its peer to the UA). */
            get: function () {
                return this.dialogState.remoteSequenceNumber;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "localURI", {
            /** Local URI. */
            get: function () {
                return this.dialogState.localURI;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "remoteURI", {
            /** Remote URI. */
            get: function () {
                return this.dialogState.remoteURI;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "remoteTarget", {
            /** Remote target. */
            get: function () {
                return this.dialogState.remoteTarget;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "routeSet", {
            /**
             * Route set, which is an ordered list of URIs. The route set is the
             * list of servers that need to be traversed to send a request to the peer.
             */
            get: function () {
                return this.dialogState.routeSet;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "secure", {
            /**
             * If the request was sent over TLS, and the Request-URI contained
             * a SIPS URI, the "secure" flag is set to true. *NOT IMPLEMENTED*
             */
            get: function () {
                return this.dialogState.secure;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Dialog.prototype, "userAgentCore", {
            /** The user agent core servicing this dialog. */
            get: function () {
                return this.core;
            },
            enumerable: true,
            configurable: true
        });
        /** Confirm the dialog. Only matters if dialog is currently early. */
        Dialog.prototype.confirm = function () {
            this.dialogState.early = false;
        };
        /**
         * Requests sent within a dialog, as any other requests, are atomic.  If
         * a particular request is accepted by the UAS, all the state changes
         * associated with it are performed.  If the request is rejected, none
         * of the state changes are performed.
         *
         *    Note that some requests, such as INVITEs, affect several pieces of
         *    state.
         *
         * https://tools.ietf.org/html/rfc3261#section-12.2.2
         * @param message - Incoming request message within this dialog.
         */
        Dialog.prototype.receiveRequest = function (message) {
            // ACK guard.
            // By convention, the handling of ACKs is the responsibility
            // the particular dialog implementation. For example, see SessionDialog.
            // Furthermore, ACKs have same sequence number as the associated INVITE.
            if (message.method === messages_1.C.ACK) {
                return;
            }
            // If the remote sequence number was not empty, but the sequence number
            // of the request is lower than the remote sequence number, the request
            // is out of order and MUST be rejected with a 500 (Server Internal
            // Error) response.  If the remote sequence number was not empty, and
            // the sequence number of the request is greater than the remote
            // sequence number, the request is in order.  It is possible for the
            // CSeq sequence number to be higher than the remote sequence number by
            // more than one.  This is not an error condition, and a UAS SHOULD be
            // prepared to receive and process requests with CSeq values more than
            // one higher than the previous received request.  The UAS MUST then set
            // the remote sequence number to the value of the sequence number in the
            // CSeq header field value in the request.
            //
            //    If a proxy challenges a request generated by the UAC, the UAC has
            //    to resubmit the request with credentials.  The resubmitted request
            //    will have a new CSeq number.  The UAS will never see the first
            //    request, and thus, it will notice a gap in the CSeq number space.
            //    Such a gap does not represent any error condition.
            //
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            if (this.remoteSequenceNumber) {
                if (message.cseq <= this.remoteSequenceNumber) {
                    throw new Error("Out of sequence in dialog request. Did you forget to call sequenceGuard()?");
                }
                this.dialogState.remoteSequenceNumber = message.cseq;
            }
            // If the remote sequence number is empty, it MUST be set to the value
            // of the sequence number in the CSeq header field value in the request.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            if (!this.remoteSequenceNumber) {
                this.dialogState.remoteSequenceNumber = message.cseq;
            }
            // When a UAS receives a target refresh request, it MUST replace the
            // dialog's remote target URI with the URI from the Contact header field
            // in that request, if present.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            // Note: "target refresh request" processing delegated to sub-class.
        };
        /**
         * If the dialog identifier in the 2xx response matches the dialog
         * identifier of an existing dialog, the dialog MUST be transitioned to
         * the "confirmed" state, and the route set for the dialog MUST be
         * recomputed based on the 2xx response using the procedures of Section
         * 12.2.1.2.  Otherwise, a new dialog in the "confirmed" state MUST be
         * constructed using the procedures of Section 12.1.2.
         *
         * Note that the only piece of state that is recomputed is the route
         * set.  Other pieces of state such as the highest sequence numbers
         * (remote and local) sent within the dialog are not recomputed.  The
         * route set only is recomputed for backwards compatibility.  RFC
         * 2543 did not mandate mirroring of the Record-Route header field in
         * a 1xx, only 2xx.  However, we cannot update the entire state of
         * the dialog, since mid-dialog requests may have been sent within
         * the early dialog, modifying the sequence numbers, for example.
         *
         *  https://tools.ietf.org/html/rfc3261#section-13.2.2.4
         */
        Dialog.prototype.recomputeRouteSet = function (message) {
            this.dialogState.routeSet = message.getHeaders("record-route").reverse();
        };
        /**
         * A request within a dialog is constructed by using many of the
         * components of the state stored as part of the dialog.
         * https://tools.ietf.org/html/rfc3261#section-12.2.1.1
         * @param method - Outgoing request method.
         */
        Dialog.prototype.createOutgoingRequestMessage = function (method, options) {
            // The URI in the To field of the request MUST be set to the remote URI
            // from the dialog state.  The tag in the To header field of the request
            // MUST be set to the remote tag of the dialog ID.  The From URI of the
            // request MUST be set to the local URI from the dialog state.  The tag
            // in the From header field of the request MUST be set to the local tag
            // of the dialog ID.  If the value of the remote or local tags is null,
            // the tag parameter MUST be omitted from the To or From header fields,
            // respectively.
            //
            //    Usage of the URI from the To and From fields in the original
            //    request within subsequent requests is done for backwards
            //    compatibility with RFC 2543, which used the URI for dialog
            //    identification.  In this specification, only the tags are used for
            //    dialog identification.  It is expected that mandatory reflection
            //    of the original To and From URI in mid-dialog requests will be
            //    deprecated in a subsequent revision of this specification.
            // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
            var toUri = this.remoteURI;
            var toTag = this.remoteTag;
            var fromUri = this.localURI;
            var fromTag = this.localTag;
            // The Call-ID of the request MUST be set to the Call-ID of the dialog.
            // Requests within a dialog MUST contain strictly monotonically
            // increasing and contiguous CSeq sequence numbers (increasing-by-one)
            // in each direction (excepting ACK and CANCEL of course, whose numbers
            // equal the requests being acknowledged or cancelled).  Therefore, if
            // the local sequence number is not empty, the value of the local
            // sequence number MUST be incremented by one, and this value MUST be
            // placed into the CSeq header field.  If the local sequence number is
            // empty, an initial value MUST be chosen using the guidelines of
            // Section 8.1.1.5.  The method field in the CSeq header field value
            // MUST match the method of the request.
            // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
            var callId = this.callId;
            var cseq;
            if (options && options.cseq) {
                cseq = options.cseq;
            }
            else if (!this.dialogState.localSequenceNumber) {
                cseq = this.dialogState.localSequenceNumber = 1; // https://tools.ietf.org/html/rfc3261#section-8.1.1.5
            }
            else {
                cseq = this.dialogState.localSequenceNumber += 1;
            }
            // The UAC uses the remote target and route set to build the Request-URI
            // and Route header field of the request.
            //
            // If the route set is empty, the UAC MUST place the remote target URI
            // into the Request-URI.  The UAC MUST NOT add a Route header field to
            // the request.
            //
            // If the route set is not empty, and the first URI in the route set
            // contains the lr parameter (see Section 19.1.1), the UAC MUST place
            // the remote target URI into the Request-URI and MUST include a Route
            // header field containing the route set values in order, including all
            // parameters.
            //
            // If the route set is not empty, and its first URI does not contain the
            // lr parameter, the UAC MUST place the first URI from the route set
            // into the Request-URI, stripping any parameters that are not allowed
            // in a Request-URI.  The UAC MUST add a Route header field containing
            // the remainder of the route set values in order, including all
            // parameters.  The UAC MUST then place the remote target URI into the
            // Route header field as the last value.
            // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
            // The lr parameter, when present, indicates that the element
            // responsible for this resource implements the routing mechanisms
            // specified in this document.  This parameter will be used in the
            // URIs proxies place into Record-Route header field values, and
            // may appear in the URIs in a pre-existing route set.
            //
            // This parameter is used to achieve backwards compatibility with
            // systems implementing the strict-routing mechanisms of RFC 2543
            // and the rfc2543bis drafts up to bis-05.  An element preparing
            // to send a request based on a URI not containing this parameter
            // can assume the receiving element implements strict-routing and
            // reformat the message to preserve the information in the
            // Request-URI.
            // https://tools.ietf.org/html/rfc3261#section-19.1.1
            // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).
            var ruri = this.remoteTarget;
            var routeSet = this.routeSet;
            var extraHeaders = options && options.extraHeaders;
            var body = options && options.body;
            // The relative order of header fields with different field names is not
            // significant.  However, it is RECOMMENDED that header fields which are
            // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
            // Max-Forwards, and Proxy-Authorization, for example) appear towards
            // the top of the message to facilitate rapid parsing.
            // https://tools.ietf.org/html/rfc3261#section-7.3.1
            var message = this.userAgentCore.makeOutgoingRequestMessage(method, ruri, fromUri, toUri, {
                callId: callId,
                cseq: cseq,
                fromTag: fromTag,
                toTag: toTag,
                routeSet: routeSet
            }, extraHeaders, body);
            return message;
        };
        /**
         * If the remote sequence number was not empty, but the sequence number
         * of the request is lower than the remote sequence number, the request
         * is out of order and MUST be rejected with a 500 (Server Internal
         * Error) response.
         * https://tools.ietf.org/html/rfc3261#section-12.2.2
         * @param request - Incoming request to guard.
         * @returns True if the program execution is to continue in the branch in question.
         *          Otherwise a 500 Server Internal Error was stateless sent and request processing must stop.
         */
        Dialog.prototype.sequenceGuard = function (message) {
            // ACK guard.
            // By convention, handling of unexpected ACKs is responsibility
            // the particular dialog implementation. For example, see SessionDialog.
            // Furthermore, we cannot reply to an "out of sequence" ACK.
            if (message.method === messages_1.C.ACK) {
                return true;
            }
            // Note: We are rejecting on "less than or equal to" the remote
            // sequence number (excepting ACK whose numbers equal the requests
            // being acknowledged or cancelled), which is the correct thing to
            // do in our case. The only time a request with the same sequence number
            // will show up here if is a) it is a very late retransmission of a
            // request we already handled or b) it is a different request with the
            // same sequence number which would be violation of the standard.
            // Request retransmissions are absorbed by the transaction layer,
            // so any request with a duplicate sequence number getting here
            // would have to be a retransmission after the transaction terminated
            // or a broken request (with unique via branch value).
            // Requests within a dialog MUST contain strictly monotonically
            // increasing and contiguous CSeq sequence numbers (increasing-by-one)
            // in each direction (excepting ACK and CANCEL of course, whose numbers
            // equal the requests being acknowledged or cancelled).  Therefore, if
            // the local sequence number is not empty, the value of the local
            // sequence number MUST be incremented by one, and this value MUST be
            // placed into the CSeq header field.
            // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
            if (this.remoteSequenceNumber && message.cseq <= this.remoteSequenceNumber) {
                this.core.replyStateless(message, { statusCode: 500 });
                return false;
            }
            return true;
        };
        return Dialog;
    }());
    exports.Dialog = Dialog;
    
    
    /***/ }),
    
    /***/ "./src/core/dialogs/index.ts":
    /*!***********************************!*\
      !*** ./src/core/dialogs/index.ts ***!
      \***********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./dialog */ "./src/core/dialogs/dialog.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./session-dialog */ "./src/core/dialogs/session-dialog.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./subscription-dialog */ "./src/core/dialogs/subscription-dialog.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/dialogs/session-dialog.ts":
    /*!********************************************!*\
      !*** ./src/core/dialogs/session-dialog.ts ***!
      \********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var session_1 = __webpack_require__(/*! ../session */ "./src/core/session/index.ts");
    var timers_1 = __webpack_require__(/*! ../timers */ "./src/core/timers.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var bye_user_agent_client_1 = __webpack_require__(/*! ../user-agents/bye-user-agent-client */ "./src/core/user-agents/bye-user-agent-client.ts");
    var bye_user_agent_server_1 = __webpack_require__(/*! ../user-agents/bye-user-agent-server */ "./src/core/user-agents/bye-user-agent-server.ts");
    var info_user_agent_client_1 = __webpack_require__(/*! ../user-agents/info-user-agent-client */ "./src/core/user-agents/info-user-agent-client.ts");
    var info_user_agent_server_1 = __webpack_require__(/*! ../user-agents/info-user-agent-server */ "./src/core/user-agents/info-user-agent-server.ts");
    var notify_user_agent_client_1 = __webpack_require__(/*! ../user-agents/notify-user-agent-client */ "./src/core/user-agents/notify-user-agent-client.ts");
    var notify_user_agent_server_1 = __webpack_require__(/*! ../user-agents/notify-user-agent-server */ "./src/core/user-agents/notify-user-agent-server.ts");
    var prack_user_agent_client_1 = __webpack_require__(/*! ../user-agents/prack-user-agent-client */ "./src/core/user-agents/prack-user-agent-client.ts");
    var prack_user_agent_server_1 = __webpack_require__(/*! ../user-agents/prack-user-agent-server */ "./src/core/user-agents/prack-user-agent-server.ts");
    var re_invite_user_agent_client_1 = __webpack_require__(/*! ../user-agents/re-invite-user-agent-client */ "./src/core/user-agents/re-invite-user-agent-client.ts");
    var re_invite_user_agent_server_1 = __webpack_require__(/*! ../user-agents/re-invite-user-agent-server */ "./src/core/user-agents/re-invite-user-agent-server.ts");
    var refer_user_agent_client_1 = __webpack_require__(/*! ../user-agents/refer-user-agent-client */ "./src/core/user-agents/refer-user-agent-client.ts");
    var refer_user_agent_server_1 = __webpack_require__(/*! ../user-agents/refer-user-agent-server */ "./src/core/user-agents/refer-user-agent-server.ts");
    var dialog_1 = __webpack_require__(/*! ./dialog */ "./src/core/dialogs/dialog.ts");
    /**
     * Session Dialog.
     * @public
     */
    var SessionDialog = /** @class */ (function (_super) {
        tslib_1.__extends(SessionDialog, _super);
        function SessionDialog(initialTransaction, core, state, delegate) {
            var _this = _super.call(this, core, state) || this;
            _this.initialTransaction = initialTransaction;
            /** The state of the offer/answer exchange. */
            _this._signalingState = session_1.SignalingState.Initial;
            /** True if waiting for an ACK to the initial transaction 2xx (UAS only). */
            _this.ackWait = false;
            _this.delegate = delegate;
            if (initialTransaction instanceof transactions_1.InviteServerTransaction) {
                // If we're created by an invite server transaction, we're
                // going to be waiting for an ACK if are to be confirmed.
                _this.ackWait = true;
            }
            // If we're confirmed upon creation start the retransmitting whatever
            // the 2xx final response was that confirmed us into existence.
            if (!_this.early) {
                _this.start2xxRetransmissionTimer();
            }
            _this.signalingStateTransition(initialTransaction.request);
            _this.logger = core.loggerFactory.getLogger("sip.invite-dialog");
            _this.logger.log("INVITE dialog " + _this.id + " constructed");
            return _this;
        }
        SessionDialog.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._signalingState = session_1.SignalingState.Closed;
            this._offer = undefined;
            this._answer = undefined;
            if (this.invite2xxTimer) {
                clearTimeout(this.invite2xxTimer);
                this.invite2xxTimer = undefined;
            }
            // The UAS MUST still respond to any pending requests received for that
            // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response
            // be generated to those pending requests.
            // https://tools.ietf.org/html/rfc3261#section-15.1.2
            // TODO:
            // this.userAgentServers.forEach((uas) => uas.reply(487));
            this.logger.log("INVITE dialog " + this.id + " destroyed");
        };
        Object.defineProperty(SessionDialog.prototype, "sessionState", {
            // FIXME: Need real state machine
            get: function () {
                if (this.early) {
                    return session_1.SessionState.Early;
                }
                else if (this.ackWait) {
                    return session_1.SessionState.AckWait;
                }
                else if (this._signalingState === session_1.SignalingState.Closed) {
                    return session_1.SessionState.Terminated;
                }
                else {
                    return session_1.SessionState.Confirmed;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SessionDialog.prototype, "signalingState", {
            /** The state of the offer/answer exchange. */
            get: function () {
                return this._signalingState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SessionDialog.prototype, "offer", {
            /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */
            get: function () {
                return this._offer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SessionDialog.prototype, "answer", {
            /** The current answer. Undefined unless signaling state Stable. */
            get: function () {
                return this._answer;
            },
            enumerable: true,
            configurable: true
        });
        /** Confirm the dialog. Only matters if dialog is currently early. */
        SessionDialog.prototype.confirm = function () {
            // When we're confirmed start the retransmitting whatever
            // the 2xx final response that may have confirmed us.
            if (this.early) {
                this.start2xxRetransmissionTimer();
            }
            _super.prototype.confirm.call(this);
        };
        /** Re-confirm the dialog. Only matters if handling re-INVITE request. */
        SessionDialog.prototype.reConfirm = function () {
            // When we're confirmed start the retransmitting whatever
            // the 2xx final response that may have confirmed us.
            if (this.reinviteUserAgentServer) {
                this.startReInvite2xxRetransmissionTimer();
            }
        };
        /**
         * The UAC core MUST generate an ACK request for each 2xx received from
         * the transaction layer.  The header fields of the ACK are constructed
         * in the same way as for any request sent within a dialog (see Section
         * 12) with the exception of the CSeq and the header fields related to
         * authentication.  The sequence number of the CSeq header field MUST be
         * the same as the INVITE being acknowledged, but the CSeq method MUST
         * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
         * the 2xx contains an offer (based on the rules above), the ACK MUST
         * carry an answer in its body.  If the offer in the 2xx response is not
         * acceptable, the UAC core MUST generate a valid answer in the ACK and
         * then send a BYE immediately.
         * https://tools.ietf.org/html/rfc3261#section-13.2.2.4
         * @param options - ACK options bucket.
         */
        SessionDialog.prototype.ack = function (options) {
            if (options === void 0) { options = {}; }
            this.logger.log("INVITE dialog " + this.id + " sending ACK request");
            var transaction;
            if (this.reinviteUserAgentClient) {
                // We're sending ACK for a re-INVITE
                if (!(this.reinviteUserAgentClient.transaction instanceof transactions_1.InviteClientTransaction)) {
                    throw new Error("Transaction not instance of InviteClientTransaction.");
                }
                transaction = this.reinviteUserAgentClient.transaction;
                this.reinviteUserAgentClient = undefined;
            }
            else {
                // We're sending ACK for the initial INVITE
                if (!(this.initialTransaction instanceof transactions_1.InviteClientTransaction)) {
                    throw new Error("Initial transaction not instance of InviteClientTransaction.");
                }
                transaction = this.initialTransaction;
            }
            options.cseq = transaction.request.cseq; // ACK cseq is INVITE cseq
            var message = this.createOutgoingRequestMessage(messages_1.C.ACK, options);
            transaction.ackResponse(message); // See InviteClientTransaction for details.
            this.signalingStateTransition(message);
            return { message: message };
        };
        /**
         * Terminating a Session
         *
         * This section describes the procedures for terminating a session
         * established by SIP.  The state of the session and the state of the
         * dialog are very closely related.  When a session is initiated with an
         * INVITE, each 1xx or 2xx response from a distinct UAS creates a
         * dialog, and if that response completes the offer/answer exchange, it
         * also creates a session.  As a result, each session is "associated"
         * with a single dialog - the one which resulted in its creation.  If an
         * initial INVITE generates a non-2xx final response, that terminates
         * all sessions (if any) and all dialogs (if any) that were created
         * through responses to the request.  By virtue of completing the
         * transaction, a non-2xx final response also prevents further sessions
         * from being created as a result of the INVITE.  The BYE request is
         * used to terminate a specific session or attempted session.  In this
         * case, the specific session is the one with the peer UA on the other
         * side of the dialog.  When a BYE is received on a dialog, any session
         * associated with that dialog SHOULD terminate.  A UA MUST NOT send a
         * BYE outside of a dialog.  The caller's UA MAY send a BYE for either
         * confirmed or early dialogs, and the callee's UA MAY send a BYE on
         * confirmed dialogs, but MUST NOT send a BYE on early dialogs.
         *
         * However, the callee's UA MUST NOT send a BYE on a confirmed dialog
         * until it has received an ACK for its 2xx response or until the server
         * transaction times out.  If no SIP extensions have defined other
         * application layer states associated with the dialog, the BYE also
         * terminates the dialog.
         *
         * https://tools.ietf.org/html/rfc3261#section-15
         * FIXME: Make these proper Exceptions...
         * @param options - BYE options bucket.
         * @returns
         * Throws `Error` if callee's UA attempts a BYE on an early dialog.
         * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog
         *                while it's waiting on the ACK for its 2xx response.
         */
        SessionDialog.prototype.bye = function (delegate, options) {
            this.logger.log("INVITE dialog " + this.id + " sending BYE request");
            // The caller's UA MAY send a BYE for either
            // confirmed or early dialogs, and the callee's UA MAY send a BYE on
            // confirmed dialogs, but MUST NOT send a BYE on early dialogs.
            //
            // However, the callee's UA MUST NOT send a BYE on a confirmed dialog
            // until it has received an ACK for its 2xx response or until the server
            // transaction times out.
            // https://tools.ietf.org/html/rfc3261#section-15
            if (this.initialTransaction instanceof transactions_1.InviteServerTransaction) {
                if (this.early) {
                    // FIXME: TODO: This should throw a proper exception.
                    throw new Error("UAS MUST NOT send a BYE on early dialogs.");
                }
                if (this.ackWait && this.initialTransaction.state !== transactions_1.TransactionState.Terminated) {
                    // FIXME: TODO: This should throw a proper exception.
                    throw new Error("UAS MUST NOT send a BYE on a confirmed dialog " +
                        "until it has received an ACK for its 2xx response " +
                        "or until the server transaction times out.");
                }
            }
            // A BYE request is constructed as would any other request within a
            // dialog, as described in Section 12.
            //
            // Once the BYE is constructed, the UAC core creates a new non-INVITE
            // client transaction, and passes it the BYE request.  The UAC MUST
            // consider the session terminated (and therefore stop sending or
            // listening for media) as soon as the BYE request is passed to the
            // client transaction.  If the response for the BYE is a 481
            // (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no
            // response at all is received for the BYE (that is, a timeout is
            // returned by the client transaction), the UAC MUST consider the
            // session and the dialog terminated.
            // https://tools.ietf.org/html/rfc3261#section-15.1.1
            return new bye_user_agent_client_1.ByeUserAgentClient(this, delegate, options);
        };
        /**
         * An INFO request can be associated with an Info Package (see
         * Section 5), or associated with a legacy INFO usage (see Section 2).
         *
         * The construction of the INFO request is the same as any other
         * non-target refresh request within an existing invite dialog usage as
         * described in Section 12.2 of RFC 3261.
         * https://tools.ietf.org/html/rfc6086#section-4.2.1
         * @param options - Options bucket.
         */
        SessionDialog.prototype.info = function (delegate, options) {
            this.logger.log("INVITE dialog " + this.id + " sending INFO request");
            if (this.early) {
                // FIXME: TODO: This should throw a proper exception.
                throw new Error("Dialog not confirmed.");
            }
            return new info_user_agent_client_1.InfoUserAgentClient(this, delegate, options);
        };
        /**
         * Modifying an Existing Session
         *
         * A successful INVITE request (see Section 13) establishes both a
         * dialog between two user agents and a session using the offer-answer
         * model.  Section 12 explains how to modify an existing dialog using a
         * target refresh request (for example, changing the remote target URI
         * of the dialog).  This section describes how to modify the actual
         * session.  This modification can involve changing addresses or ports,
         * adding a media stream, deleting a media stream, and so on.  This is
         * accomplished by sending a new INVITE request within the same dialog
         * that established the session.  An INVITE request sent within an
         * existing dialog is known as a re-INVITE.
         *
         *    Note that a single re-INVITE can modify the dialog and the
         *    parameters of the session at the same time.
         *
         * Either the caller or callee can modify an existing session.
         * https://tools.ietf.org/html/rfc3261#section-14
         * @param options - Options bucket
         */
        SessionDialog.prototype.invite = function (delegate, options) {
            this.logger.log("INVITE dialog " + this.id + " sending INVITE request");
            if (this.early) {
                // FIXME: TODO: This should throw a proper exception.
                throw new Error("Dialog not confirmed.");
            }
            // Note that a UAC MUST NOT initiate a new INVITE transaction within a
            // dialog while another INVITE transaction is in progress in either
            // direction.
            //
            //    1. If there is an ongoing INVITE client transaction, the TU MUST
            //       wait until the transaction reaches the completed or terminated
            //       state before initiating the new INVITE.
            //
            //    2. If there is an ongoing INVITE server transaction, the TU MUST
            //       wait until the transaction reaches the confirmed or terminated
            //       state before initiating the new INVITE.
            //
            // However, a UA MAY initiate a regular transaction while an INVITE
            // transaction is in progress.  A UA MAY also initiate an INVITE
            // transaction while a regular transaction is in progress.
            // https://tools.ietf.org/html/rfc3261#section-14.1
            if (this.reinviteUserAgentClient) {
                // FIXME: TODO: This should throw a proper exception.
                throw new Error("There is an ongoing re-INVITE client transaction.");
            }
            if (this.reinviteUserAgentServer) {
                // FIXME: TODO: This should throw a proper exception.
                throw new Error("There is an ongoing re-INVITE server transaction.");
            }
            return new re_invite_user_agent_client_1.ReInviteUserAgentClient(this, delegate, options);
        };
        /**
         * The NOTIFY mechanism defined in [2] MUST be used to inform the agent
         * sending the REFER of the status of the reference.
         * https://tools.ietf.org/html/rfc3515#section-2.4.4
         * @param options - Options bucket.
         */
        SessionDialog.prototype.notify = function (delegate, options) {
            this.logger.log("INVITE dialog " + this.id + " sending NOTIFY request");
            if (this.early) {
                // FIXME: TODO: This should throw a proper exception.
                throw new Error("Dialog not confirmed.");
            }
            return new notify_user_agent_client_1.NotifyUserAgentClient(this, delegate, options);
        };
        /**
         * Assuming the response is to be transmitted reliably, the UAC MUST
         * create a new request with method PRACK.  This request is sent within
         * the dialog associated with the provisional response (indeed, the
         * provisional response may have created the dialog).  PRACK requests
         * MAY contain bodies, which are interpreted according to their type and
         * disposition.
         * https://tools.ietf.org/html/rfc3262#section-4
         * @param options - Options bucket.
         */
        SessionDialog.prototype.prack = function (delegate, options) {
            this.logger.log("INVITE dialog " + this.id + " sending PRACK request");
            return new prack_user_agent_client_1.PrackUserAgentClient(this, delegate, options);
        };
        /**
         * REFER is a SIP request and is constructed as defined in [1].  A REFER
         * request MUST contain exactly one Refer-To header field value.
         * https://tools.ietf.org/html/rfc3515#section-2.4.1
         * @param options - Options bucket.
         */
        SessionDialog.prototype.refer = function (delegate, options) {
            this.logger.log("INVITE dialog " + this.id + " sending REFER request");
            if (this.early) {
                // FIXME: TODO: This should throw a proper exception.
                throw new Error("Dialog not confirmed.");
            }
            // FIXME: TODO: Validate Refer-To header field value.
            return new refer_user_agent_client_1.ReferUserAgentClient(this, delegate, options);
        };
        /**
         * Requests sent within a dialog, as any other requests, are atomic.  If
         * a particular request is accepted by the UAS, all the state changes
         * associated with it are performed.  If the request is rejected, none
         * of the state changes are performed.
         * https://tools.ietf.org/html/rfc3261#section-12.2.2
         * @param message - Incoming request message within this dialog.
         */
        SessionDialog.prototype.receiveRequest = function (message) {
            this.logger.log("INVITE dialog " + this.id + " received " + message.method + " request");
            // Response retransmissions cease when an ACK request for the
            // response is received.  This is independent of whatever transport
            // protocols are used to send the response.
            // https://tools.ietf.org/html/rfc6026#section-8.1
            if (message.method === messages_1.C.ACK) {
                // If ackWait is true, then this is the ACK to the initial INVITE,
                // otherwise this is an ACK to an in dialog INVITE. In either case,
                // guard to make sure the sequence number of the ACK matches the INVITE.
                if (this.ackWait) {
                    if (this.initialTransaction instanceof transactions_1.InviteClientTransaction) {
                        this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                        return;
                    }
                    if (this.initialTransaction.request.cseq !== message.cseq) {
                        this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                        return;
                    }
                    // Update before the delegate has a chance to handle the
                    // message as delegate may callback into this dialog.
                    this.ackWait = false;
                }
                else {
                    if (!this.reinviteUserAgentServer) {
                        this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                        return;
                    }
                    if (this.reinviteUserAgentServer.transaction.request.cseq !== message.cseq) {
                        this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                        return;
                    }
                    this.reinviteUserAgentServer = undefined;
                }
                this.signalingStateTransition(message);
                if (this.delegate && this.delegate.onAck) {
                    this.delegate.onAck({ message: message });
                }
                return;
            }
            // Request within a dialog out of sequence guard.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            if (!this.sequenceGuard(message)) {
                this.logger.log("INVITE dialog " + this.id + " rejected out of order " + message.method + " request.");
                return;
            }
            if (message.method === messages_1.C.INVITE) {
                // A UAS that receives a second INVITE before it sends the final
                // response to a first INVITE with a lower CSeq sequence number on the
                // same dialog MUST return a 500 (Server Internal Error) response to the
                // second INVITE and MUST include a Retry-After header field with a
                // randomly chosen value of between 0 and 10 seconds.
                // https://tools.ietf.org/html/rfc3261#section-14.2
                if (this.reinviteUserAgentServer) {
                    // https://tools.ietf.org/html/rfc3261#section-20.33
                    var retryAfter = Math.floor((Math.random() * 10)) + 1;
                    var extraHeaders = ["Retry-After: " + retryAfter];
                    this.core.replyStateless(message, { statusCode: 500, extraHeaders: extraHeaders });
                    return;
                }
                // A UAS that receives an INVITE on a dialog while an INVITE it had sent
                // on that dialog is in progress MUST return a 491 (Request Pending)
                // response to the received INVITE.
                // https://tools.ietf.org/html/rfc3261#section-14.2
                if (this.reinviteUserAgentClient) {
                    this.core.replyStateless(message, { statusCode: 491 });
                    return;
                }
            }
            // Request within a dialog common processing.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            _super.prototype.receiveRequest.call(this, message);
            // Requests within a dialog MAY contain Record-Route and Contact header
            // fields.  However, these requests do not cause the dialog's route set
            // to be modified, although they may modify the remote target URI.
            // Specifically, requests that are not target refresh requests do not
            // modify the dialog's remote target URI, and requests that are target
            // refresh requests do.  For dialogs that have been established with an
            // INVITE, the only target refresh request defined is re-INVITE (see
            // Section 14).  Other extensions may define different target refresh
            // requests for dialogs established in other ways.
            //
            //    Note that an ACK is NOT a target refresh request.
            //
            // Target refresh requests only update the dialog's remote target URI,
            // and not the route set formed from the Record-Route.  Updating the
            // latter would introduce severe backwards compatibility problems with
            // RFC 2543-compliant systems.
            // https://tools.ietf.org/html/rfc3261#section-15
            if (message.method === messages_1.C.INVITE) {
                // FIXME: parser needs to be typed...
                var contact = message.parseHeader("contact");
                if (!contact) { // TODO: Review to make sure this will never happen
                    throw new Error("Contact undefined.");
                }
                if (!(contact instanceof messages_1.NameAddrHeader)) {
                    throw new Error("Contact not instance of NameAddrHeader.");
                }
                this.dialogState.remoteTarget = contact.uri;
            }
            // Switch on method and then delegate.
            switch (message.method) {
                case messages_1.C.BYE:
                    // A UAS core receiving a BYE request for an existing dialog MUST follow
                    // the procedures of Section 12.2.2 to process the request.  Once done,
                    // the UAS SHOULD terminate the session (and therefore stop sending and
                    // listening for media).  The only case where it can elect not to are
                    // multicast sessions, where participation is possible even if the other
                    // participant in the dialog has terminated its involvement in the
                    // session.  Whether or not it ends its participation on the session,
                    // the UAS core MUST generate a 2xx response to the BYE, and MUST pass
                    // that to the server transaction for transmission.
                    //
                    // The UAS MUST still respond to any pending requests received for that
                    // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response
                    // be generated to those pending requests.
                    // https://tools.ietf.org/html/rfc3261#section-15.1.2
                    {
                        var uas = new bye_user_agent_server_1.ByeUserAgentServer(this, message);
                        this.delegate && this.delegate.onBye ?
                            this.delegate.onBye(uas) :
                            uas.accept();
                        this.dispose();
                    }
                    break;
                case messages_1.C.INFO:
                    // If a UA receives an INFO request associated with an Info Package that
                    // the UA has not indicated willingness to receive, the UA MUST send a
                    // 469 (Bad Info Package) response (see Section 11.6), which contains a
                    // Recv-Info header field with Info Packages for which the UA is willing
                    // to receive INFO requests.
                    {
                        var uas = new info_user_agent_server_1.InfoUserAgentServer(this, message);
                        this.delegate && this.delegate.onInfo ?
                            this.delegate.onInfo(uas) :
                            uas.reject({
                                statusCode: 469,
                                extraHeaders: ["Recv-Info :"]
                            });
                    }
                    break;
                case messages_1.C.INVITE:
                    // If the new session description is not acceptable, the UAS can reject
                    // it by returning a 488 (Not Acceptable Here) response for the re-
                    // INVITE.  This response SHOULD include a Warning header field.
                    // https://tools.ietf.org/html/rfc3261#section-14.2
                    {
                        var uas = new re_invite_user_agent_server_1.ReInviteUserAgentServer(this, message);
                        this.signalingStateTransition(message);
                        this.delegate && this.delegate.onInvite ?
                            this.delegate.onInvite(uas) :
                            uas.reject({ statusCode: 488 }); // TODO: Warning header field.
                    }
                    break;
                case messages_1.C.NOTIFY:
                    // https://tools.ietf.org/html/rfc3515#section-2.4.4
                    {
                        var uas = new notify_user_agent_server_1.NotifyUserAgentServer(this, message);
                        this.delegate && this.delegate.onNotify ?
                            this.delegate.onNotify(uas) :
                            uas.accept();
                    }
                    break;
                case messages_1.C.PRACK:
                    // https://tools.ietf.org/html/rfc3262#section-4
                    {
                        var uas = new prack_user_agent_server_1.PrackUserAgentServer(this, message);
                        this.delegate && this.delegate.onPrack ?
                            this.delegate.onPrack(uas) :
                            uas.accept();
                    }
                    break;
                case messages_1.C.REFER:
                    // https://tools.ietf.org/html/rfc3515#section-2.4.2
                    {
                        var uas = new refer_user_agent_server_1.ReferUserAgentServer(this, message);
                        this.delegate && this.delegate.onRefer ?
                            this.delegate.onRefer(uas) :
                            uas.reject();
                    }
                    break;
                default:
                    {
                        this.logger.log("INVITE dialog " + this.id + " received unimplemented " + message.method + " request");
                        this.core.replyStateless(message, { statusCode: 501 });
                    }
                    break;
            }
        };
        SessionDialog.prototype.reliableSequenceGuard = function (message) {
            var statusCode = message.statusCode;
            if (!statusCode) {
                throw new Error("Status code undefined");
            }
            if (statusCode > 100 && statusCode < 200) {
                // If a provisional response is received for an initial request, and
                // that response contains a Require header field containing the option
                // tag 100rel, the response is to be sent reliably.  If the response is
                // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be
                // ignored, and the procedures below MUST NOT be used.
                // https://tools.ietf.org/html/rfc3262#section-4
                var requireHeader = message.getHeader("require");
                var rseqHeader = message.getHeader("rseq");
                var rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : undefined;
                if (rseq) {
                    // Handling of subsequent reliable provisional responses for the same
                    // initial request follows the same rules as above, with the following
                    // difference: reliable provisional responses are guaranteed to be in
                    // order.  As a result, if the UAC receives another reliable provisional
                    // response to the same request, and its RSeq value is not one higher
                    // than the value of the sequence number, that response MUST NOT be
                    // acknowledged with a PRACK, and MUST NOT be processed further by the
                    // UAC.  An implementation MAY discard the response, or MAY cache the
                    // response in the hopes of receiving the missing responses.
                    // https://tools.ietf.org/html/rfc3262#section-4
                    if (this.rseq && this.rseq + 1 !== rseq) {
                        return false;
                    }
                    // Once a reliable provisional response is received, retransmissions of
                    // that response MUST be discarded.  A response is a retransmission when
                    // its dialog ID, CSeq, and RSeq match the original response.  The UAC
                    // MUST maintain a sequence number that indicates the most recently
                    // received in-order reliable provisional response for the initial
                    // request.  This sequence number MUST be maintained until a final
                    // response is received for the initial request.  Its value MUST be
                    // initialized to the RSeq header field in the first reliable
                    // provisional response received for the initial request.
                    // https://tools.ietf.org/html/rfc3262#section-4
                    if (!this.rseq) {
                        this.rseq = rseq;
                    }
                }
            }
            return true;
        };
        /**
         * If not in a stable signaling state, rollback to prior stable signaling state.
         */
        SessionDialog.prototype.signalingStateRollback = function () {
            if (this._signalingState === session_1.SignalingState.HaveLocalOffer ||
                this.signalingState === session_1.SignalingState.HaveRemoteOffer) {
                if (this._rollbackOffer && this._rollbackAnswer) {
                    this._signalingState = session_1.SignalingState.Stable;
                    this._offer = this._rollbackOffer;
                    this._answer = this._rollbackAnswer;
                }
            }
        };
        /**
         * Update the signaling state of the dialog.
         * @param message - The message to base the update off of.
         */
        SessionDialog.prototype.signalingStateTransition = function (message) {
            var body = messages_1.getBody(message);
            // No body, no session. No, woman, no cry.
            if (!body || body.contentDisposition !== "session") {
                return;
            }
            // We've got an existing offer and answer which we may wish to rollback to
            if (this._signalingState === session_1.SignalingState.Stable) {
                this._rollbackOffer = this._offer;
                this._rollbackAnswer = this._answer;
            }
            // We're in UAS role, receiving incoming request with session description
            if (message instanceof messages_1.IncomingRequestMessage) {
                switch (this._signalingState) {
                    case session_1.SignalingState.Initial:
                    case session_1.SignalingState.Stable:
                        this._signalingState = session_1.SignalingState.HaveRemoteOffer;
                        this._offer = body;
                        this._answer = undefined;
                        break;
                    case session_1.SignalingState.HaveLocalOffer:
                        this._signalingState = session_1.SignalingState.Stable;
                        this._answer = body;
                        break;
                    case session_1.SignalingState.HaveRemoteOffer:
                        // You cannot make a new offer while one is in progress.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.1
                        // FIXME: What to do here?
                        break;
                    case session_1.SignalingState.Closed:
                        break;
                    default:
                        throw new Error("Unexpected signaling state.");
                }
            }
            // We're in UAC role, receiving incoming response with session description
            if (message instanceof messages_1.IncomingResponseMessage) {
                switch (this._signalingState) {
                    case session_1.SignalingState.Initial:
                    case session_1.SignalingState.Stable:
                        this._signalingState = session_1.SignalingState.HaveRemoteOffer;
                        this._offer = body;
                        this._answer = undefined;
                        break;
                    case session_1.SignalingState.HaveLocalOffer:
                        this._signalingState = session_1.SignalingState.Stable;
                        this._answer = body;
                        break;
                    case session_1.SignalingState.HaveRemoteOffer:
                        // You cannot make a new offer while one is in progress.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.1
                        // FIXME: What to do here?
                        break;
                    case session_1.SignalingState.Closed:
                        break;
                    default:
                        throw new Error("Unexpected signaling state.");
                }
            }
            // We're in UAC role, sending outgoing request with session description
            if (message instanceof messages_1.OutgoingRequestMessage) {
                switch (this._signalingState) {
                    case session_1.SignalingState.Initial:
                    case session_1.SignalingState.Stable:
                        this._signalingState = session_1.SignalingState.HaveLocalOffer;
                        this._offer = body;
                        this._answer = undefined;
                        break;
                    case session_1.SignalingState.HaveLocalOffer:
                        // You cannot make a new offer while one is in progress.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.1
                        // FIXME: What to do here?
                        break;
                    case session_1.SignalingState.HaveRemoteOffer:
                        this._signalingState = session_1.SignalingState.Stable;
                        this._answer = body;
                        break;
                    case session_1.SignalingState.Closed:
                        break;
                    default:
                        throw new Error("Unexpected signaling state.");
                }
            }
            // We're in UAS role, sending outgoing response with session description
            if (messages_1.isBody(message)) {
                switch (this._signalingState) {
                    case session_1.SignalingState.Initial:
                    case session_1.SignalingState.Stable:
                        this._signalingState = session_1.SignalingState.HaveLocalOffer;
                        this._offer = body;
                        this._answer = undefined;
                        break;
                    case session_1.SignalingState.HaveLocalOffer:
                        // You cannot make a new offer while one is in progress.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.1
                        // FIXME: What to do here?
                        break;
                    case session_1.SignalingState.HaveRemoteOffer:
                        this._signalingState = session_1.SignalingState.Stable;
                        this._answer = body;
                        break;
                    case session_1.SignalingState.Closed:
                        break;
                    default:
                        throw new Error("Unexpected signaling state.");
                }
            }
        };
        SessionDialog.prototype.start2xxRetransmissionTimer = function () {
            var _this = this;
            if (this.initialTransaction instanceof transactions_1.InviteServerTransaction) {
                var transaction_1 = this.initialTransaction;
                // Once the response has been constructed, it is passed to the INVITE
                // server transaction.  In order to ensure reliable end-to-end
                // transport of the response, it is necessary to periodically pass
                // the response directly to the transport until the ACK arrives.  The
                // 2xx response is passed to the transport with an interval that
                // starts at T1 seconds and doubles for each retransmission until it
                // reaches T2 seconds (T1 and T2 are defined in Section 17).
                // Response retransmissions cease when an ACK request for the
                // response is received.  This is independent of whatever transport
                // protocols are used to send the response.
                // https://tools.ietf.org/html/rfc6026#section-8.1
                var timeout_1 = timers_1.Timers.T1;
                var retransmission_1 = function () {
                    if (!_this.ackWait) {
                        _this.invite2xxTimer = undefined;
                        return;
                    }
                    _this.logger.log("No ACK for 2xx response received, attempting retransmission");
                    transaction_1.retransmitAcceptedResponse();
                    timeout_1 = Math.min(timeout_1 * 2, timers_1.Timers.T2);
                    _this.invite2xxTimer = setTimeout(retransmission_1, timeout_1);
                };
                this.invite2xxTimer = setTimeout(retransmission_1, timeout_1);
                // If the server retransmits the 2xx response for 64*T1 seconds without
                // receiving an ACK, the dialog is confirmed, but the session SHOULD be
                // terminated.  This is accomplished with a BYE, as described in Section 15.
                // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
                var stateChanged_1 = function () {
                    if (transaction_1.state === transactions_1.TransactionState.Terminated) {
                        transaction_1.removeListener("stateChanged", stateChanged_1);
                        if (_this.invite2xxTimer) {
                            clearTimeout(_this.invite2xxTimer);
                            _this.invite2xxTimer = undefined;
                        }
                        if (_this.ackWait) {
                            if (_this.delegate && _this.delegate.onAckTimeout) {
                                _this.delegate.onAckTimeout();
                            }
                            else {
                                _this.bye();
                            }
                        }
                    }
                };
                transaction_1.addListener("stateChanged", stateChanged_1);
            }
        };
        // FIXME: Refactor
        SessionDialog.prototype.startReInvite2xxRetransmissionTimer = function () {
            var _this = this;
            if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof transactions_1.InviteServerTransaction) {
                var transaction_2 = this.reinviteUserAgentServer.transaction;
                // Once the response has been constructed, it is passed to the INVITE
                // server transaction.  In order to ensure reliable end-to-end
                // transport of the response, it is necessary to periodically pass
                // the response directly to the transport until the ACK arrives.  The
                // 2xx response is passed to the transport with an interval that
                // starts at T1 seconds and doubles for each retransmission until it
                // reaches T2 seconds (T1 and T2 are defined in Section 17).
                // Response retransmissions cease when an ACK request for the
                // response is received.  This is independent of whatever transport
                // protocols are used to send the response.
                // https://tools.ietf.org/html/rfc6026#section-8.1
                var timeout_2 = timers_1.Timers.T1;
                var retransmission_2 = function () {
                    if (!_this.reinviteUserAgentServer) {
                        _this.invite2xxTimer = undefined;
                        return;
                    }
                    _this.logger.log("No ACK for 2xx response received, attempting retransmission");
                    transaction_2.retransmitAcceptedResponse();
                    timeout_2 = Math.min(timeout_2 * 2, timers_1.Timers.T2);
                    _this.invite2xxTimer = setTimeout(retransmission_2, timeout_2);
                };
                this.invite2xxTimer = setTimeout(retransmission_2, timeout_2);
                // If the server retransmits the 2xx response for 64*T1 seconds without
                // receiving an ACK, the dialog is confirmed, but the session SHOULD be
                // terminated.  This is accomplished with a BYE, as described in Section 15.
                // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
                var stateChanged_2 = function () {
                    if (transaction_2.state === transactions_1.TransactionState.Terminated) {
                        transaction_2.removeListener("stateChanged", stateChanged_2);
                        if (_this.invite2xxTimer) {
                            clearTimeout(_this.invite2xxTimer);
                            _this.invite2xxTimer = undefined;
                        }
                        if (_this.reinviteUserAgentServer) {
                            // FIXME: TODO: What to do here
                        }
                    }
                };
                transaction_2.addListener("stateChanged", stateChanged_2);
            }
        };
        return SessionDialog;
    }(dialog_1.Dialog));
    exports.SessionDialog = SessionDialog;
    
    
    /***/ }),
    
    /***/ "./src/core/dialogs/subscription-dialog.ts":
    /*!*************************************************!*\
      !*** ./src/core/dialogs/subscription-dialog.ts ***!
      \*************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var subscription_1 = __webpack_require__(/*! ../subscription */ "./src/core/subscription/index.ts");
    var timers_1 = __webpack_require__(/*! ../timers */ "./src/core/timers.ts");
    var allowed_methods_1 = __webpack_require__(/*! ../user-agent-core/allowed-methods */ "./src/core/user-agent-core/allowed-methods.ts");
    var notify_user_agent_server_1 = __webpack_require__(/*! ../user-agents/notify-user-agent-server */ "./src/core/user-agents/notify-user-agent-server.ts");
    var re_subscribe_user_agent_client_1 = __webpack_require__(/*! ../user-agents/re-subscribe-user-agent-client */ "./src/core/user-agents/re-subscribe-user-agent-client.ts");
    var dialog_1 = __webpack_require__(/*! ./dialog */ "./src/core/dialogs/dialog.ts");
    /**
     * Subscription Dialog.
     * @remarks
     * SIP-Specific Event Notification
     *
     * Abstract
     *
     *    This document describes an extension to the Session Initiation
     *    Protocol (SIP) defined by RFC 3261.  The purpose of this extension is
     *    to provide an extensible framework by which SIP nodes can request
     *    notification from remote nodes indicating that certain events have
     *    occurred.
     *
     *    Note that the event notification mechanisms defined herein are NOT
     *    intended to be a general-purpose infrastructure for all classes of
     *    event subscription and notification.
     *
     *    This document represents a backwards-compatible improvement on the
     *    original mechanism described by RFC 3265, taking into account several
     *    years of implementation experience.  Accordingly, this document
     *    obsoletes RFC 3265.  This document also updates RFC 4660 slightly to
     *    accommodate some small changes to the mechanism that were discussed
     *    in that document.
     *
     *  https://tools.ietf.org/html/rfc6665
     * @public
     */
    var SubscriptionDialog = /** @class */ (function (_super) {
        tslib_1.__extends(SubscriptionDialog, _super);
        function SubscriptionDialog(subscriptionEvent, subscriptionExpires, subscriptionState, core, state, delegate) {
            var _this = _super.call(this, core, state) || this;
            _this.delegate = delegate;
            _this._autoRefresh = false;
            _this._subscriptionEvent = subscriptionEvent;
            _this._subscriptionExpires = subscriptionExpires;
            _this._subscriptionExpiresInitial = subscriptionExpires;
            _this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);
            _this._subscriptionRefresh = undefined;
            _this._subscriptionRefreshLastSet = undefined;
            _this._subscriptionState = subscriptionState;
            _this.logger = core.loggerFactory.getLogger("sip.subscribe-dialog");
            _this.logger.log("SUBSCRIBE dialog " + _this.id + " constructed");
            return _this;
        }
        /**
         * When a UAC receives a response that establishes a dialog, it
         * constructs the state of the dialog.  This state MUST be maintained
         * for the duration of the dialog.
         * https://tools.ietf.org/html/rfc3261#section-12.1.2
         * @param outgoingRequestMessage - Outgoing request message for dialog.
         * @param incomingResponseMessage - Incoming response message creating dialog.
         */
        SubscriptionDialog.initialDialogStateForSubscription = function (outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {
            // If the request was sent over TLS, and the Request-URI contained a
            // SIPS URI, the "secure" flag is set to TRUE.
            // https://tools.ietf.org/html/rfc3261#section-12.1.2
            var secure = false; // FIXME: Currently no support for TLS.
            // The route set MUST be set to the list of URIs in the Record-Route
            // header field from the response, taken in reverse order and preserving
            // all URI parameters.  If no Record-Route header field is present in
            // the response, the route set MUST be set to the empty set.  This route
            // set, even if empty, overrides any pre-existing route set for future
            // requests in this dialog.  The remote target MUST be set to the URI
            // from the Contact header field of the response.
            // https://tools.ietf.org/html/rfc3261#section-12.1.2
            var routeSet = incomingNotifyRequestMessage.getHeaders("record-route");
            var contact = incomingNotifyRequestMessage.parseHeader("contact");
            if (!contact) { // TODO: Review to make sure this will never happen
                throw new Error("Contact undefined.");
            }
            if (!(contact instanceof messages_1.NameAddrHeader)) {
                throw new Error("Contact not instance of NameAddrHeader.");
            }
            var remoteTarget = contact.uri;
            // The local sequence number MUST be set to the value of the sequence
            // number in the CSeq header field of the request.  The remote sequence
            // number MUST be empty (it is established when the remote UA sends a
            // request within the dialog).  The call identifier component of the
            // dialog ID MUST be set to the value of the Call-ID in the request.
            // The local tag component of the dialog ID MUST be set to the tag in
            // the From field in the request, and the remote tag component of the
            // dialog ID MUST be set to the tag in the To field of the response.  A
            // UAC MUST be prepared to receive a response without a tag in the To
            // field, in which case the tag is considered to have a value of null.
            //
            //    This is to maintain backwards compatibility with RFC 2543, which
            //    did not mandate To tags.
            //
            // https://tools.ietf.org/html/rfc3261#section-12.1.2
            var localSequenceNumber = outgoingSubscribeRequestMessage.cseq;
            var remoteSequenceNumber = undefined;
            var callId = outgoingSubscribeRequestMessage.callId;
            var localTag = outgoingSubscribeRequestMessage.fromTag;
            var remoteTag = incomingNotifyRequestMessage.fromTag;
            if (!callId) { // TODO: Review to make sure this will never happen
                throw new Error("Call id undefined.");
            }
            if (!localTag) { // TODO: Review to make sure this will never happen
                throw new Error("From tag undefined.");
            }
            if (!remoteTag) { // TODO: Review to make sure this will never happen
                throw new Error("To tag undefined."); // FIXME: No backwards compatibility with RFC 2543
            }
            // The remote URI MUST be set to the URI in the To field, and the local
            // URI MUST be set to the URI in the From field.
            // https://tools.ietf.org/html/rfc3261#section-12.1.2
            if (!outgoingSubscribeRequestMessage.from) { // TODO: Review to make sure this will never happen
                throw new Error("From undefined.");
            }
            if (!outgoingSubscribeRequestMessage.to) { // TODO: Review to make sure this will never happen
                throw new Error("To undefined.");
            }
            var localURI = outgoingSubscribeRequestMessage.from.uri;
            var remoteURI = outgoingSubscribeRequestMessage.to.uri;
            // A dialog can also be in the "early" state, which occurs when it is
            // created with a provisional response, and then transition to the
            // "confirmed" state when a 2xx final response arrives.
            // https://tools.ietf.org/html/rfc3261#section-12
            var early = false;
            var dialogState = {
                id: callId + localTag + remoteTag,
                early: early,
                callId: callId,
                localTag: localTag,
                remoteTag: remoteTag,
                localSequenceNumber: localSequenceNumber,
                remoteSequenceNumber: remoteSequenceNumber,
                localURI: localURI,
                remoteURI: remoteURI,
                remoteTarget: remoteTarget,
                routeSet: routeSet,
                secure: secure
            };
            return dialogState;
        };
        SubscriptionDialog.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.N) {
                clearTimeout(this.N);
                this.N = undefined;
            }
            this.refreshTimerClear();
            this.logger.log("SUBSCRIBE dialog " + this.id + " destroyed");
        };
        Object.defineProperty(SubscriptionDialog.prototype, "autoRefresh", {
            get: function () {
                return this._autoRefresh;
            },
            set: function (autoRefresh) {
                this._autoRefresh = true;
                this.refreshTimerSet();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubscriptionDialog.prototype, "subscriptionEvent", {
            get: function () {
                return this._subscriptionEvent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubscriptionDialog.prototype, "subscriptionExpires", {
            /** Number of seconds until subscription expires. */
            get: function () {
                var secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionExpiresLastSet;
                var secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;
                return Math.max(secondsUntilExpires, 0);
            },
            set: function (expires) {
                if (expires < 0) {
                    throw new Error("Expires must be greater than or equal to zero.");
                }
                this._subscriptionExpires = expires;
                this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);
                if (this.autoRefresh) {
                    var refresh = this.subscriptionRefresh;
                    if (refresh === undefined || refresh >= expires) {
                        this.refreshTimerSet();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubscriptionDialog.prototype, "subscriptionExpiresInitial", {
            get: function () {
                return this._subscriptionExpiresInitial;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubscriptionDialog.prototype, "subscriptionRefresh", {
            /** Number of seconds until subscription auto refresh. */
            get: function () {
                if (this._subscriptionRefresh === undefined || this._subscriptionRefreshLastSet === undefined) {
                    return undefined;
                }
                var secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionRefreshLastSet;
                var secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;
                return Math.max(secondsUntilExpires, 0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SubscriptionDialog.prototype, "subscriptionState", {
            get: function () {
                return this._subscriptionState;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Receive in dialog request message from transport.
         * @param message -  The incoming request message.
         */
        SubscriptionDialog.prototype.receiveRequest = function (message) {
            this.logger.log("SUBSCRIBE dialog " + this.id + " received " + message.method + " request");
            // Request within a dialog out of sequence guard.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            if (!this.sequenceGuard(message)) {
                this.logger.log("SUBSCRIBE dialog " + this.id + " rejected out of order " + message.method + " request.");
                return;
            }
            // Request within a dialog common processing.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            _super.prototype.receiveRequest.call(this, message);
            // Switch on method and then delegate.
            switch (message.method) {
                case messages_1.C.NOTIFY:
                    this.onNotify(message);
                    break;
                default:
                    this.logger.log("SUBSCRIBE dialog " + this.id + " received unimplemented " + message.method + " request");
                    this.core.replyStateless(message, { statusCode: 501 });
                    break;
            }
        };
        /**
         * 4.1.2.2.  Refreshing of Subscriptions
         * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
         */
        SubscriptionDialog.prototype.refresh = function () {
            var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
            var options = {};
            options.extraHeaders = (options.extraHeaders || []).slice();
            options.extraHeaders.push(allowHeader);
            options.extraHeaders.push("Event: " + this.subscriptionEvent);
            options.extraHeaders.push("Expires: " + this.subscriptionExpiresInitial);
            options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
            return this.subscribe(undefined, options);
        };
        /**
         * 4.1.2.2.  Refreshing of Subscriptions
         * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
         * @param delegate - Delegate to handle responses.
         * @param options - Options bucket.
         */
        SubscriptionDialog.prototype.subscribe = function (delegate, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (this.subscriptionState !== subscription_1.SubscriptionState.Pending && this.subscriptionState !== subscription_1.SubscriptionState.Active) {
                // FIXME: This needs to be a proper exception
                throw new Error("Invalid state " + this.subscriptionState + ". May only re-subscribe while in state \"pending\" or \"active\".");
            }
            this.logger.log("SUBSCRIBE dialog " + this.id + " sending SUBSCRIBE request");
            var uac = new re_subscribe_user_agent_client_1.ReSubscribeUserAgentClient(this, delegate, options);
            // When refreshing a subscription, a subscriber starts Timer N, set to
            // 64*T1, when it sends the SUBSCRIBE request.
            // https://tools.ietf.org/html/rfc6665#section-4.1.2.2
            this.N = setTimeout(function () { return _this.timer_N(); }, timers_1.Timers.TIMER_N);
            return uac;
        };
        /**
         * 4.4.1.  Dialog Creation and Termination
         * A subscription is destroyed after a notifier sends a NOTIFY request
         * with a "Subscription-State" of "terminated", or in certain error
         * situations described elsewhere in this document.
         * https://tools.ietf.org/html/rfc6665#section-4.4.1
         */
        SubscriptionDialog.prototype.terminate = function () {
            this.stateTransition(subscription_1.SubscriptionState.Terminated);
            this.onTerminated();
        };
        /**
         * 4.1.2.3.  Unsubscribing
         * https://tools.ietf.org/html/rfc6665#section-4.1.2.3
         */
        SubscriptionDialog.prototype.unsubscribe = function () {
            var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
            var options = {};
            options.extraHeaders = (options.extraHeaders || []).slice();
            options.extraHeaders.push(allowHeader);
            options.extraHeaders.push("Event: " + this.subscriptionEvent);
            options.extraHeaders.push("Expires: 0");
            options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
            return this.subscribe(undefined, options);
        };
        /**
         * Handle in dialog NOTIFY requests.
         * This does not include the first NOTIFY which created the dialog.
         * @param message - The incoming NOTIFY request message.
         */
        SubscriptionDialog.prototype.onNotify = function (message) {
            // If, for some reason, the event package designated in the "Event"
            // header field of the NOTIFY request is not supported, the subscriber
            // will respond with a 489 (Bad Event) response.
            // https://tools.ietf.org/html/rfc6665#section-4.1.3
            var event = message.parseHeader("Event").event;
            if (!event || event !== this.subscriptionEvent) {
                this.core.replyStateless(message, { statusCode: 489 });
                return;
            }
            // In the state diagram, "Re-subscription times out" means that an
            // attempt to refresh or update the subscription using a new SUBSCRIBE
            // request does not result in a NOTIFY request before the corresponding
            // Timer N expires.
            // https://tools.ietf.org/html/rfc6665#section-4.1.2
            if (this.N) {
                clearTimeout(this.N);
                this.N = undefined;
            }
            // NOTIFY requests MUST contain "Subscription-State" header fields that
            // indicate the status of the subscription.
            // https://tools.ietf.org/html/rfc6665#section-4.1.3
            var subscriptionState = message.parseHeader("Subscription-State");
            if (!subscriptionState || !subscriptionState.state) {
                this.core.replyStateless(message, { statusCode: 489 });
                return;
            }
            var state = subscriptionState.state;
            var expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : undefined;
            // Update our state and expiration.
            switch (state) {
                case "pending":
                    this.stateTransition(subscription_1.SubscriptionState.Pending, expires);
                    break;
                case "active":
                    this.stateTransition(subscription_1.SubscriptionState.Active, expires);
                    break;
                case "terminated":
                    this.stateTransition(subscription_1.SubscriptionState.Terminated, expires);
                    break;
                default:
                    this.logger.warn("Unrecognized subscription state.");
                    break;
            }
            // Delegate remainder of NOTIFY handling.
            var uas = new notify_user_agent_server_1.NotifyUserAgentServer(this, message);
            if (this.delegate && this.delegate.onNotify) {
                this.delegate.onNotify(uas);
            }
            else {
                uas.accept();
            }
        };
        SubscriptionDialog.prototype.onRefresh = function (request) {
            if (this.delegate && this.delegate.onRefresh) {
                this.delegate.onRefresh(request);
            }
        };
        SubscriptionDialog.prototype.onTerminated = function () {
            if (this.delegate && this.delegate.onTerminated) {
                this.delegate.onTerminated();
            }
        };
        SubscriptionDialog.prototype.refreshTimerClear = function () {
            if (this.refreshTimer) {
                clearTimeout(this.refreshTimer);
                this.refreshTimer = undefined;
            }
        };
        SubscriptionDialog.prototype.refreshTimerSet = function () {
            var _this = this;
            this.refreshTimerClear();
            if (this.autoRefresh && this.subscriptionExpires > 0) {
                var refresh = this.subscriptionExpires * 900;
                this._subscriptionRefresh = Math.floor(refresh / 1000);
                this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1000);
                this.refreshTimer = setTimeout(function () {
                    _this.refreshTimer = undefined;
                    _this._subscriptionRefresh = undefined;
                    _this._subscriptionRefreshLastSet = undefined;
                    _this.onRefresh(_this.refresh());
                }, refresh);
            }
        };
        SubscriptionDialog.prototype.stateTransition = function (newState, newExpires) {
            var _this = this;
            // Assert valid state transitions.
            var invalidStateTransition = function () {
                _this.logger.warn("Invalid subscription state transition from " + _this.subscriptionState + " to " + newState);
            };
            switch (newState) {
                case subscription_1.SubscriptionState.Initial:
                    invalidStateTransition();
                    return;
                case subscription_1.SubscriptionState.NotifyWait:
                    invalidStateTransition();
                    return;
                case subscription_1.SubscriptionState.Pending:
                    if (this.subscriptionState !== subscription_1.SubscriptionState.NotifyWait &&
                        this.subscriptionState !== subscription_1.SubscriptionState.Pending) {
                        invalidStateTransition();
                        return;
                    }
                    break;
                case subscription_1.SubscriptionState.Active:
                    if (this.subscriptionState !== subscription_1.SubscriptionState.NotifyWait &&
                        this.subscriptionState !== subscription_1.SubscriptionState.Pending &&
                        this.subscriptionState !== subscription_1.SubscriptionState.Active) {
                        invalidStateTransition();
                        return;
                    }
                    break;
                case subscription_1.SubscriptionState.Terminated:
                    if (this.subscriptionState !== subscription_1.SubscriptionState.NotifyWait &&
                        this.subscriptionState !== subscription_1.SubscriptionState.Pending &&
                        this.subscriptionState !== subscription_1.SubscriptionState.Active) {
                        invalidStateTransition();
                        return;
                    }
                    break;
                default:
                    invalidStateTransition();
                    return;
            }
            // If the "Subscription-State" value is "pending", the subscription has
            // been received by the notifier, but there is insufficient policy
            // information to grant or deny the subscription yet.  If the header
            // field also contains an "expires" parameter, the subscriber SHOULD
            // take it as the authoritative subscription duration and adjust
            // accordingly.  No further action is necessary on the part of the
            // subscriber.  The "retry-after" and "reason" parameters have no
            // semantics for "pending".
            // https://tools.ietf.org/html/rfc6665#section-4.1.3
            if (newState === subscription_1.SubscriptionState.Pending) {
                if (newExpires) {
                    this.subscriptionExpires = newExpires;
                }
            }
            // If the "Subscription-State" header field value is "active", it means
            // that the subscription has been accepted and (in general) has been
            // authorized.  If the header field also contains an "expires"
            // parameter, the subscriber SHOULD take it as the authoritative
            // subscription duration and adjust accordingly.  The "retry-after" and
            // "reason" parameters have no semantics for "active".
            // https://tools.ietf.org/html/rfc6665#section-4.1.3
            if (newState === subscription_1.SubscriptionState.Active) {
                if (newExpires) {
                    this.subscriptionExpires = newExpires;
                }
            }
            // If the "Subscription-State" value is "terminated", the subscriber
            // MUST consider the subscription terminated.  The "expires" parameter
            // has no semantics for "terminated" -- notifiers SHOULD NOT include an
            // "expires" parameter on a "Subscription-State" header field with a
            // value of "terminated", and subscribers MUST ignore any such
            // parameter, if present.
            if (newState === subscription_1.SubscriptionState.Terminated) {
                this.dispose();
            }
            this._subscriptionState = newState;
        };
        /**
         * When refreshing a subscription, a subscriber starts Timer N, set to
         * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires
         * prior to the receipt of a NOTIFY request, the subscriber considers
         * the subscription terminated.  If the subscriber receives a success
         * response to the SUBSCRIBE request that indicates that no NOTIFY
         * request will be generated -- such as the 204 response defined for use
         * with the optional extension described in [RFC5839] -- then it MUST
         * cancel Timer N.
         * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
         */
        SubscriptionDialog.prototype.timer_N = function () {
            if (this.subscriptionState !== subscription_1.SubscriptionState.Terminated) {
                this.stateTransition(subscription_1.SubscriptionState.Terminated);
                this.onTerminated();
            }
        };
        return SubscriptionDialog;
    }(dialog_1.Dialog));
    exports.SubscriptionDialog = SubscriptionDialog;
    
    
    /***/ }),
    
    /***/ "./src/core/exceptions/exception.ts":
    /*!******************************************!*\
      !*** ./src/core/exceptions/exception.ts ***!
      \******************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    /**
     * An Exception is considered a condition that a reasonable application may wish to catch.
     * An Error indicates serious problems that a reasonable application should not try to catch.
     * @public
     */
    var Exception = /** @class */ (function (_super) {
        tslib_1.__extends(Exception, _super);
        function Exception(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain
            return _this;
        }
        return Exception;
    }(Error));
    exports.Exception = Exception;
    
    
    /***/ }),
    
    /***/ "./src/core/exceptions/index.ts":
    /*!**************************************!*\
      !*** ./src/core/exceptions/index.ts ***!
      \**************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./exception */ "./src/core/exceptions/exception.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./transaction-state-error */ "./src/core/exceptions/transaction-state-error.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./transport-error */ "./src/core/exceptions/transport-error.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/exceptions/transaction-state-error.ts":
    /*!********************************************************!*\
      !*** ./src/core/exceptions/transaction-state-error.ts ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var exception_1 = __webpack_require__(/*! ./exception */ "./src/core/exceptions/exception.ts");
    /**
     * Indicates that the operation could not be completed given the current transaction state.
     * @public
     */
    var TransactionStateError = /** @class */ (function (_super) {
        tslib_1.__extends(TransactionStateError, _super);
        function TransactionStateError(message) {
            return _super.call(this, message ? message : "Transaction state error.") || this;
        }
        return TransactionStateError;
    }(exception_1.Exception));
    exports.TransactionStateError = TransactionStateError;
    
    
    /***/ }),
    
    /***/ "./src/core/exceptions/transport-error.ts":
    /*!************************************************!*\
      !*** ./src/core/exceptions/transport-error.ts ***!
      \************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var exception_1 = __webpack_require__(/*! ./exception */ "./src/core/exceptions/exception.ts");
    /**
     * Transport error.
     * @public
     */
    var TransportError = /** @class */ (function (_super) {
        tslib_1.__extends(TransportError, _super);
        function TransportError(message) {
            return _super.call(this, message ? message : "Unspecified transport error.") || this;
        }
        return TransportError;
    }(exception_1.Exception));
    exports.TransportError = TransportError;
    
    
    /***/ }),
    
    /***/ "./src/core/index.ts":
    /*!***************************!*\
      !*** ./src/core/index.ts ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    /**
     * A core library implementing low level SIP protocol elements.
     * @packageDocumentation
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    // Directories
    tslib_1.__exportStar(__webpack_require__(/*! ./dialogs */ "./src/core/dialogs/index.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./exceptions */ "./src/core/exceptions/index.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./log */ "./src/core/log/index.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./messages */ "./src/core/messages/index.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./session */ "./src/core/session/index.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./subscription */ "./src/core/subscription/index.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./transactions */ "./src/core/transactions/index.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-core */ "./src/core/user-agent-core/index.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./user-agents */ "./src/core/user-agents/index.ts"), exports);
    // Files
    tslib_1.__exportStar(__webpack_require__(/*! ./timers */ "./src/core/timers.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/log/index.ts":
    /*!*******************************!*\
      !*** ./src/core/log/index.ts ***!
      \*******************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./levels */ "./src/core/log/levels.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./logger-factory */ "./src/core/log/logger-factory.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./logger */ "./src/core/log/logger.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/log/levels.ts":
    /*!********************************!*\
      !*** ./src/core/log/levels.ts ***!
      \********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Log levels.
     * @public
     */
    var Levels;
    (function (Levels) {
        Levels[Levels["error"] = 0] = "error";
        Levels[Levels["warn"] = 1] = "warn";
        Levels[Levels["log"] = 2] = "log";
        Levels[Levels["debug"] = 3] = "debug";
    })(Levels = exports.Levels || (exports.Levels = {}));
    
    
    /***/ }),
    
    /***/ "./src/core/log/logger-factory.ts":
    /*!****************************************!*\
      !*** ./src/core/log/logger-factory.ts ***!
      \****************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var levels_1 = __webpack_require__(/*! ./levels */ "./src/core/log/levels.ts");
    var logger_1 = __webpack_require__(/*! ./logger */ "./src/core/log/logger.ts");
    /**
     * Logger.
     * @public
     */
    var LoggerFactory = /** @class */ (function () {
        function LoggerFactory() {
            this.builtinEnabled = true;
            this._level = levels_1.Levels.log;
            this.loggers = {};
            this.logger = this.getLogger("sip:loggerfactory");
        }
        Object.defineProperty(LoggerFactory.prototype, "level", {
            get: function () { return this._level; },
            set: function (newLevel) {
                if (newLevel >= 0 && newLevel <= 3) {
                    this._level = newLevel;
                }
                else if (newLevel > 3) {
                    this._level = 3;
                }
                else if (levels_1.Levels.hasOwnProperty(newLevel)) {
                    this._level = newLevel;
                }
                else {
                    this.logger.error("invalid 'level' parameter value: " + JSON.stringify(newLevel));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LoggerFactory.prototype, "connector", {
            get: function () {
                return this._connector;
            },
            set: function (value) {
                if (!value) {
                    this._connector = undefined;
                }
                else if (typeof value === "function") {
                    this._connector = value;
                }
                else {
                    this.logger.error("invalid 'connector' parameter value: " + JSON.stringify(value));
                }
            },
            enumerable: true,
            configurable: true
        });
        LoggerFactory.prototype.getLogger = function (category, label) {
            if (label && this.level === 3) {
                return new logger_1.Logger(this, category, label);
            }
            else if (this.loggers[category]) {
                return this.loggers[category];
            }
            else {
                var logger = new logger_1.Logger(this, category);
                this.loggers[category] = logger;
                return logger;
            }
        };
        LoggerFactory.prototype.genericLog = function (levelToLog, category, label, content) {
            if (this.level >= levelToLog) {
                if (this.builtinEnabled) {
                    this.print(levelToLog, category, label, content);
                }
            }
            if (this.connector) {
                this.connector(levels_1.Levels[levelToLog], category, label, content);
            }
        };
        LoggerFactory.prototype.print = function (levelToLog, category, label, content) {
            if (typeof content === "string") {
                var prefix = [new Date(), category];
                if (label) {
                    prefix.push(label);
                }
                content = prefix.concat(content).join(" | ");
            }
            switch (levelToLog) {
                case levels_1.Levels.error:
                    // tslint:disable-next-line:no-console
                    console.error(content);
                    break;
                case levels_1.Levels.warn:
                    // tslint:disable-next-line:no-console
                    console.warn(content);
                    break;
                case levels_1.Levels.log:
                    // tslint:disable-next-line:no-console
                    console.log(content);
                    break;
                case levels_1.Levels.debug:
                    // tslint:disable-next-line:no-console
                    console.debug(content);
                    break;
                default:
                    break;
            }
        };
        return LoggerFactory;
    }());
    exports.LoggerFactory = LoggerFactory;
    
    
    /***/ }),
    
    /***/ "./src/core/log/logger.ts":
    /*!********************************!*\
      !*** ./src/core/log/logger.ts ***!
      \********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var levels_1 = __webpack_require__(/*! ./levels */ "./src/core/log/levels.ts");
    /**
     * Logger.
     * @public
     */
    var Logger = /** @class */ (function () {
        function Logger(logger, category, label) {
            this.logger = logger;
            this.category = category;
            this.label = label;
        }
        Logger.prototype.error = function (content) { this.genericLog(levels_1.Levels.error, content); };
        Logger.prototype.warn = function (content) { this.genericLog(levels_1.Levels.warn, content); };
        Logger.prototype.log = function (content) { this.genericLog(levels_1.Levels.log, content); };
        Logger.prototype.debug = function (content) { this.genericLog(levels_1.Levels.debug, content); };
        Logger.prototype.genericLog = function (level, content) {
            this.logger.genericLog(level, this.category, this.label, content);
        };
        return Logger;
    }());
    exports.Logger = Logger;
    
    
    /***/ }),
    
    /***/ "./src/core/messages/body.ts":
    /*!***********************************!*\
      !*** ./src/core/messages/body.ts ***!
      \***********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var incoming_request_message_1 = __webpack_require__(/*! ./incoming-request-message */ "./src/core/messages/incoming-request-message.ts");
    var incoming_response_message_1 = __webpack_require__(/*! ./incoming-response-message */ "./src/core/messages/incoming-response-message.ts");
    var outgoing_request_message_1 = __webpack_require__(/*! ./outgoing-request-message */ "./src/core/messages/outgoing-request-message.ts");
    /**
     * Create a Body given a legacy body type.
     * @param bodyLegacy - Body Object
     * @internal
     */
    function fromBodyLegacy(bodyLegacy) {
        var content = (typeof bodyLegacy === "string") ? bodyLegacy : bodyLegacy.body;
        var contentType = (typeof bodyLegacy === "string") ? "application/sdp" : bodyLegacy.contentType;
        var contentDisposition = contentTypeToContentDisposition(contentType);
        var body = { contentDisposition: contentDisposition, contentType: contentType, content: content };
        return body;
    }
    exports.fromBodyLegacy = fromBodyLegacy;
    /**
     * Given a message, get a normalized body.
     * The content disposition is inferred if not set.
     * @param message - The message.
     * @internal
     */
    function getBody(message) {
        var contentDisposition;
        var contentType;
        var content;
        // We're in UAS role, receiving incoming request
        if (message instanceof incoming_request_message_1.IncomingRequestMessage) {
            if (message.body) {
                // FIXME: Parsing needs typing
                var parse = message.parseHeader("Content-Disposition");
                contentDisposition = parse ? parse.type : undefined;
                contentType = message.parseHeader("Content-Type");
                content = message.body;
            }
        }
        // We're in UAC role, receiving incoming response
        if (message instanceof incoming_response_message_1.IncomingResponseMessage) {
            if (message.body) {
                // FIXME: Parsing needs typing
                var parse = message.parseHeader("Content-Disposition");
                contentDisposition = parse ? parse.type : undefined;
                contentType = message.parseHeader("Content-Type");
                content = message.body;
            }
        }
        // We're in UAC role, sending outgoing request
        if (message instanceof outgoing_request_message_1.OutgoingRequestMessage) {
            if (message.body) {
                contentDisposition = message.getHeader("Content-Disposition");
                contentType = message.getHeader("Content-Type");
                if (typeof message.body === "string") {
                    // FIXME: OutgoingRequest should not allow a "string" body without a "Content-Type" header.
                    if (!contentType) {
                        throw new Error("Header content type header does not equal body content type.");
                    }
                    content = message.body;
                }
                else {
                    // FIXME: OutgoingRequest should not allow the "Content-Type" header not to match th body content type
                    if (contentType && contentType !== message.body.contentType) {
                        throw new Error("Header content type header does not equal body content type.");
                    }
                    contentType = message.body.contentType;
                    content = message.body.body;
                }
            }
        }
        // We're in UAS role, sending outgoing response
        if (isBody(message)) {
            contentDisposition = message.contentDisposition;
            contentType = message.contentType;
            content = message.content;
        }
        // No content, no body.
        if (!content) {
            return undefined;
        }
        if (contentType && !contentDisposition) {
            contentDisposition = contentTypeToContentDisposition(contentType);
        }
        if (!contentDisposition) {
            throw new Error("Content disposition undefined.");
        }
        if (!contentType) {
            throw new Error("Content type undefined.");
        }
        return {
            contentDisposition: contentDisposition,
            contentType: contentType,
            content: content
        };
    }
    exports.getBody = getBody;
    /**
     * User-Defined Type Guard for Body.
     * @param body - Body to check.
     * @internal
     */
    function isBody(body) {
        return body &&
            typeof body.content === "string" &&
            typeof body.contentType === "string" &&
            body.contentDisposition === undefined ? true : typeof body.contentDisposition === "string";
    }
    exports.isBody = isBody;
    // If the Content-Disposition header field is missing, bodies of
    // Content-Type application/sdp imply the disposition "session", while
    // other content types imply "render".
    // https://tools.ietf.org/html/rfc3261#section-13.2.1
    function contentTypeToContentDisposition(contentType) {
        if (contentType === "application/sdp") {
            return "session";
        }
        else {
            return "render";
        }
    }
    
    
    /***/ }),
    
    /***/ "./src/core/messages/digest-authentication.ts":
    /*!****************************************************!*\
      !*** ./src/core/messages/digest-authentication.ts ***!
      \****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var md5_1 = tslib_1.__importDefault(__webpack_require__(/*! crypto-js/md5 */ "./node_modules/crypto-js/md5.js"));
    var utils_1 = __webpack_require__(/*! ./utils */ "./src/core/messages/utils.ts");
    /**
     * Digest Authentication.
     * @internal
     */
    var DigestAuthentication = /** @class */ (function () {
        /**
         * Constructor.
         * @param loggerFactory - LoggerFactory.
         * @param username - Username.
         * @param password - Password.
         */
        function DigestAuthentication(loggerFactory, username, password) {
            this.logger = loggerFactory.getLogger("sipjs.digestauthentication");
            this.username = username;
            this.password = password;
            this.nc = 0;
            this.ncHex = "00000000";
        }
        /**
         * Performs Digest authentication given a SIP request and the challenge
         * received in a response to that request.
         * @param request -
         * @param challenge -
         * @returns true if credentials were successfully generated, false otherwise.
         */
        DigestAuthentication.prototype.authenticate = function (request, challenge, body) {
            // Inspect and validate the challenge.
            this.algorithm = challenge.algorithm;
            this.realm = challenge.realm;
            this.nonce = challenge.nonce;
            this.opaque = challenge.opaque;
            this.stale = challenge.stale;
            if (this.algorithm) {
                if (this.algorithm !== "MD5") {
                    this.logger.warn("challenge with Digest algorithm different than 'MD5', authentication aborted");
                    return false;
                }
            }
            else {
                this.algorithm = "MD5";
            }
            if (!this.realm) {
                this.logger.warn("challenge without Digest realm, authentication aborted");
                return false;
            }
            if (!this.nonce) {
                this.logger.warn("challenge without Digest nonce, authentication aborted");
                return false;
            }
            // 'qop' can contain a list of values (Array). Let's choose just one.
            if (challenge.qop) {
                if (challenge.qop.indexOf("auth") > -1) {
                    this.qop = "auth";
                }
                else if (challenge.qop.indexOf("auth-int") > -1) {
                    this.qop = "auth-int";
                }
                else {
                    // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
                    this.logger.warn("challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted");
                    return false;
                }
            }
            else {
                this.qop = undefined;
            }
            // Fill other attributes.
            this.method = request.method;
            this.uri = request.ruri;
            this.cnonce = utils_1.createRandomToken(12);
            this.nc += 1;
            this.updateNcHex();
            // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
            if (this.nc === 4294967296) {
                this.nc = 1;
                this.ncHex = "00000001";
            }
            // Calculate the Digest "response" value.
            this.calculateResponse(body);
            return true;
        };
        /**
         * Return the Proxy-Authorization or WWW-Authorization header value.
         */
        DigestAuthentication.prototype.toString = function () {
            var authParams = [];
            if (!this.response) {
                throw new Error("response field does not exist, cannot generate Authorization header");
            }
            authParams.push("algorithm=" + this.algorithm);
            authParams.push('username="' + this.username + '"');
            authParams.push('realm="' + this.realm + '"');
            authParams.push('nonce="' + this.nonce + '"');
            authParams.push('uri="' + this.uri + '"');
            authParams.push('response="' + this.response + '"');
            if (this.opaque) {
                authParams.push('opaque="' + this.opaque + '"');
            }
            if (this.qop) {
                authParams.push("qop=" + this.qop);
                authParams.push('cnonce="' + this.cnonce + '"');
                authParams.push("nc=" + this.ncHex);
            }
            return "Digest " + authParams.join(", ");
        };
        /**
         * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
         */
        DigestAuthentication.prototype.updateNcHex = function () {
            var hex = Number(this.nc).toString(16);
            this.ncHex = "00000000".substr(0, 8 - hex.length) + hex;
        };
        /**
         * Generate Digest 'response' value.
         */
        DigestAuthentication.prototype.calculateResponse = function (body) {
            var ha2;
            // HA1 = MD5(A1) = MD5(username:realm:password)
            var ha1 = md5_1.default(this.username + ":" + this.realm + ":" + this.password);
            if (this.qop === "auth") {
                // HA2 = MD5(A2) = MD5(method:digestURI)
                ha2 = md5_1.default(this.method + ":" + this.uri);
                // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
                this.response = md5_1.default(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
            }
            else if (this.qop === "auth-int") {
                // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
                ha2 = md5_1.default(this.method + ":" + this.uri + ":" + md5_1.default(body ? body : ""));
                // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
                this.response = md5_1.default(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
            }
            else if (this.qop === undefined) {
                // HA2 = MD5(A2) = MD5(method:digestURI)
                ha2 = md5_1.default(this.method + ":" + this.uri);
                // response = MD5(HA1:nonce:HA2)
                this.response = md5_1.default(ha1 + ":" + this.nonce + ":" + ha2);
            }
        };
        return DigestAuthentication;
    }());
    exports.DigestAuthentication = DigestAuthentication;
    
    
    /***/ }),
    
    /***/ "./src/core/messages/grammar.ts":
    /*!**************************************!*\
      !*** ./src/core/messages/grammar.ts ***!
      \**************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var pegGrammar = tslib_1.__importStar(__webpack_require__(/*! ../../grammar/dist/grammar */ "./src/grammar/dist/grammar.ts"));
    /**
     * Grammar.
     * @internal
     */
    var Grammar;
    (function (Grammar) {
        /**
         * Parse.
         * @param input -
         * @param startRule -
         */
        function parse(input, startRule) {
            var options = { startRule: startRule };
            try {
                pegGrammar.parse(input, options);
            }
            catch (e) {
                options.data = -1;
            }
            return options.data;
        }
        Grammar.parse = parse;
        /**
         * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
         * it is an invalid NameAddrHeader.
         * @param name_addr_header -
         */
        function nameAddrHeaderParse(nameAddrHeader) {
            var parsedNameAddrHeader = Grammar.parse(nameAddrHeader, "Name_Addr_Header");
            return parsedNameAddrHeader !== -1 ? parsedNameAddrHeader : undefined;
        }
        Grammar.nameAddrHeaderParse = nameAddrHeaderParse;
        /**
         * Parse the given string and returns a SIP.URI instance or undefined if
         * it is an invalid URI.
         * @param uri -
         */
        function URIParse(uri) {
            var parsedUri = Grammar.parse(uri, "SIP_URI");
            return parsedUri !== -1 ? parsedUri : undefined;
        }
        Grammar.URIParse = URIParse;
    })(Grammar = exports.Grammar || (exports.Grammar = {}));
    
    
    /***/ }),
    
    /***/ "./src/core/messages/incoming-message.ts":
    /*!***********************************************!*\
      !*** ./src/core/messages/incoming-message.ts ***!
      \***********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var grammar_1 = __webpack_require__(/*! ./grammar */ "./src/core/messages/grammar.ts");
    var utils_1 = __webpack_require__(/*! ./utils */ "./src/core/messages/utils.ts");
    /**
     * Incoming message.
     * @public
     */
    var IncomingMessage = /** @class */ (function () {
        function IncomingMessage() {
            this.headers = {};
        }
        /**
         * Insert a header of the given name and value into the last position of the
         * header array.
         * @param name - header name
         * @param value - header value
         */
        IncomingMessage.prototype.addHeader = function (name, value) {
            var header = { raw: value };
            name = utils_1.headerize(name);
            if (this.headers[name]) {
                this.headers[name].push(header);
            }
            else {
                this.headers[name] = [header];
            }
        };
        /**
         * Get the value of the given header name at the given position.
         * @param name - header name
         * @returns Returns the specified header, undefined if header doesn't exist.
         */
        IncomingMessage.prototype.getHeader = function (name) {
            var header = this.headers[utils_1.headerize(name)];
            if (header) {
                if (header[0]) {
                    return header[0].raw;
                }
            }
            else {
                return;
            }
        };
        /**
         * Get the header/s of the given name.
         * @param name - header name
         * @returns Array - with all the headers of the specified name.
         */
        IncomingMessage.prototype.getHeaders = function (name) {
            var header = this.headers[utils_1.headerize(name)];
            var result = [];
            if (!header) {
                return [];
            }
            for (var _i = 0, header_1 = header; _i < header_1.length; _i++) {
                var headerPart = header_1[_i];
                result.push(headerPart.raw);
            }
            return result;
        };
        /**
         * Verify the existence of the given header.
         * @param name - header name
         * @returns true if header with given name exists, false otherwise
         */
        IncomingMessage.prototype.hasHeader = function (name) {
            return !!this.headers[utils_1.headerize(name)];
        };
        /**
         * Parse the given header on the given index.
         * @param name - header name
         * @param idx - header index
         * @returns Parsed header object, undefined if the
         *   header is not present or in case of a parsing error.
         */
        IncomingMessage.prototype.parseHeader = function (name, idx) {
            if (idx === void 0) { idx = 0; }
            name = utils_1.headerize(name);
            if (!this.headers[name]) {
                // this.logger.log("header '" + name + "' not present");
                return;
            }
            else if (idx >= this.headers[name].length) {
                // this.logger.log("not so many '" + name + "' headers present");
                return;
            }
            var header = this.headers[name][idx];
            var value = header.raw;
            if (header.parsed) {
                return header.parsed;
            }
            // substitute '-' by '_' for grammar rule matching.
            var parsed = grammar_1.Grammar.parse(value, name.replace(/-/g, "_"));
            if (parsed === -1) {
                this.headers[name].splice(idx, 1); // delete from headers
                // this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
                return;
            }
            else {
                header.parsed = parsed;
                return parsed;
            }
        };
        /**
         * Message Header attribute selector. Alias of parseHeader.
         * @param name - header name
         * @param idx - header index
         * @returns Parsed header object, undefined if the
         *   header is not present or in case of a parsing error.
         *
         * @example
         * message.s('via',3).port
         */
        IncomingMessage.prototype.s = function (name, idx) {
            if (idx === void 0) { idx = 0; }
            return this.parseHeader(name, idx);
        };
        /**
         * Replace the value of the given header by the value.
         * @param name - header name
         * @param value - header value
         */
        IncomingMessage.prototype.setHeader = function (name, value) {
            this.headers[utils_1.headerize(name)] = [{ raw: value }];
        };
        IncomingMessage.prototype.toString = function () {
            return this.data;
        };
        return IncomingMessage;
    }());
    exports.IncomingMessage = IncomingMessage;
    
    
    /***/ }),
    
    /***/ "./src/core/messages/incoming-request-message.ts":
    /*!*******************************************************!*\
      !*** ./src/core/messages/incoming-request-message.ts ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var incoming_message_1 = __webpack_require__(/*! ./incoming-message */ "./src/core/messages/incoming-message.ts");
    /**
     * Incoming request message.
     * @public
     */
    var IncomingRequestMessage = /** @class */ (function (_super) {
        tslib_1.__extends(IncomingRequestMessage, _super);
        function IncomingRequestMessage() {
            return _super.call(this) || this;
        }
        return IncomingRequestMessage;
    }(incoming_message_1.IncomingMessage));
    exports.IncomingRequestMessage = IncomingRequestMessage;
    
    
    /***/ }),
    
    /***/ "./src/core/messages/incoming-response-message.ts":
    /*!********************************************************!*\
      !*** ./src/core/messages/incoming-response-message.ts ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var incoming_message_1 = __webpack_require__(/*! ./incoming-message */ "./src/core/messages/incoming-message.ts");
    /**
     * Incoming response message.
     * @public
     */
    var IncomingResponseMessage = /** @class */ (function (_super) {
        tslib_1.__extends(IncomingResponseMessage, _super);
        function IncomingResponseMessage() {
            return _super.call(this) || this;
        }
        return IncomingResponseMessage;
    }(incoming_message_1.IncomingMessage));
    exports.IncomingResponseMessage = IncomingResponseMessage;
    
    
    /***/ }),
    
    /***/ "./src/core/messages/index.ts":
    /*!************************************!*\
      !*** ./src/core/messages/index.ts ***!
      \************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    // Directories
    tslib_1.__exportStar(__webpack_require__(/*! ./methods */ "./src/core/messages/methods/index.ts"), exports);
    // Files
    tslib_1.__exportStar(__webpack_require__(/*! ./body */ "./src/core/messages/body.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./digest-authentication */ "./src/core/messages/digest-authentication.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./grammar */ "./src/core/messages/grammar.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./incoming-message */ "./src/core/messages/incoming-message.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./incoming-request-message */ "./src/core/messages/incoming-request-message.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./incoming-response-message */ "./src/core/messages/incoming-response-message.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./name-addr-header */ "./src/core/messages/name-addr-header.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./outgoing-request-message */ "./src/core/messages/outgoing-request-message.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./outgoing-response */ "./src/core/messages/outgoing-response.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./parameters */ "./src/core/messages/parameters.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./parser */ "./src/core/messages/parser.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./uri */ "./src/core/messages/uri.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/messages/methods/constants.ts":
    /*!************************************************!*\
      !*** ./src/core/messages/methods/constants.ts ***!
      \************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * SIP Methods
     * @internal
     */
    var C;
    (function (C) {
        C.ACK = "ACK";
        C.BYE = "BYE";
        C.CANCEL = "CANCEL";
        C.INFO = "INFO";
        C.INVITE = "INVITE";
        C.MESSAGE = "MESSAGE";
        C.NOTIFY = "NOTIFY";
        C.OPTIONS = "OPTIONS";
        C.REGISTER = "REGISTER";
        C.UPDATE = "UPDATE";
        C.SUBSCRIBE = "SUBSCRIBE";
        C.PUBLISH = "PUBLISH";
        C.REFER = "REFER";
        C.PRACK = "PRACK";
    })(C = exports.C || (exports.C = {}));
    
    
    /***/ }),
    
    /***/ "./src/core/messages/methods/index.ts":
    /*!********************************************!*\
      !*** ./src/core/messages/methods/index.ts ***!
      \********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./constants */ "./src/core/messages/methods/constants.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/messages/name-addr-header.ts":
    /*!***********************************************!*\
      !*** ./src/core/messages/name-addr-header.ts ***!
      \***********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/core/messages/parameters.ts");
    /**
     * Name Address SIP header.
     * @public
     */
    var NameAddrHeader = /** @class */ (function (_super) {
        tslib_1.__extends(NameAddrHeader, _super);
        /**
         * Constructor
         * @param uri -
         * @param displayName -
         * @param parameters -
         */
        function NameAddrHeader(uri, displayName, parameters) {
            var _this = _super.call(this, parameters) || this;
            _this.uri = uri;
            _this._displayName = displayName;
            return _this;
        }
        Object.defineProperty(NameAddrHeader.prototype, "friendlyName", {
            get: function () {
                return this.displayName || this.uri.aor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NameAddrHeader.prototype, "displayName", {
            get: function () { return this._displayName; },
            set: function (value) {
                this._displayName = value;
            },
            enumerable: true,
            configurable: true
        });
        NameAddrHeader.prototype.clone = function () {
            return new NameAddrHeader(this.uri.clone(), this._displayName, JSON.parse(JSON.stringify(this.parameters)));
        };
        NameAddrHeader.prototype.toString = function () {
            var body = (this.displayName || this.displayName === "0") ? '"' + this.displayName + '" ' : "";
            body += "<" + this.uri.toString() + ">";
            for (var parameter in this.parameters) {
                if (this.parameters.hasOwnProperty(parameter)) {
                    body += ";" + parameter;
                    if (this.parameters[parameter] !== null) {
                        body += "=" + this.parameters[parameter];
                    }
                }
            }
            return body;
        };
        return NameAddrHeader;
    }(parameters_1.Parameters));
    exports.NameAddrHeader = NameAddrHeader;
    
    
    /***/ }),
    
    /***/ "./src/core/messages/outgoing-request-message.ts":
    /*!*******************************************************!*\
      !*** ./src/core/messages/outgoing-request-message.ts ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var name_addr_header_1 = __webpack_require__(/*! ./name-addr-header */ "./src/core/messages/name-addr-header.ts");
    var utils_1 = __webpack_require__(/*! ./utils */ "./src/core/messages/utils.ts");
    /**
     * Outgoing SIP request message.
     * @public
     */
    var OutgoingRequestMessage = /** @class */ (function () {
        function OutgoingRequestMessage(method, ruri, fromURI, toURI, options, extraHeaders, body) {
            this.headers = {};
            this.extraHeaders = [];
            this.options = OutgoingRequestMessage.getDefaultOptions();
            // Options - merge a deep copy
            if (options) {
                this.options = tslib_1.__assign(tslib_1.__assign({}, this.options), options);
                if (this.options.optionTags && this.options.optionTags.length) {
                    this.options.optionTags = this.options.optionTags.slice();
                }
                if (this.options.routeSet && this.options.routeSet.length) {
                    this.options.routeSet = this.options.routeSet.slice();
                }
            }
            // Extra headers - deep copy
            if (extraHeaders && extraHeaders.length) {
                this.extraHeaders = extraHeaders.slice();
            }
            // Body - deep copy
            if (body) {
                // TODO: internal representation should be Body
                // this.body = { ...body };
                this.body = {
                    body: body.content,
                    contentType: body.contentType
                };
            }
            // Method
            this.method = method;
            // RURI
            this.ruri = ruri.clone();
            // From
            this.fromURI = fromURI.clone();
            this.fromTag = this.options.fromTag ? this.options.fromTag : utils_1.newTag();
            this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag);
            // To
            this.toURI = toURI.clone();
            this.toTag = this.options.toTag;
            this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag);
            // Call-ID
            this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + utils_1.createRandomToken(15);
            // CSeq
            this.cseq = this.options.cseq;
            // The relative order of header fields with different field names is not
            // significant.  However, it is RECOMMENDED that header fields which are
            // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
            // Max-Forwards, and Proxy-Authorization, for example) appear towards
            // the top of the message to facilitate rapid parsing.
            // https://tools.ietf.org/html/rfc3261#section-7.3.1
            this.setHeader("route", this.options.routeSet);
            this.setHeader("via", "");
            this.setHeader("to", this.to.toString());
            this.setHeader("from", this.from.toString());
            this.setHeader("cseq", this.cseq + " " + this.method);
            this.setHeader("call-id", this.callId);
            this.setHeader("max-forwards", "70");
        }
        /** Get a copy of the default options. */
        OutgoingRequestMessage.getDefaultOptions = function () {
            return {
                callId: "",
                callIdPrefix: "",
                cseq: 1,
                toDisplayName: "",
                toTag: "",
                fromDisplayName: "",
                fromTag: "",
                forceRport: false,
                hackViaTcp: false,
                optionTags: ["outbound"],
                routeSet: [],
                userAgentString: "sip.js",
                viaHost: ""
            };
        };
        OutgoingRequestMessage.makeNameAddrHeader = function (uri, displayName, tag) {
            var parameters = {};
            if (tag) {
                parameters.tag = tag;
            }
            return new name_addr_header_1.NameAddrHeader(uri, displayName, parameters);
        };
        /**
         * Get the value of the given header name at the given position.
         * @param name - header name
         * @returns Returns the specified header, undefined if header doesn't exist.
         */
        OutgoingRequestMessage.prototype.getHeader = function (name) {
            var header = this.headers[utils_1.headerize(name)];
            if (header) {
                if (header[0]) {
                    return header[0];
                }
            }
            else {
                var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
                for (var _i = 0, _a = this.extraHeaders; _i < _a.length; _i++) {
                    var exHeader = _a[_i];
                    if (regexp.test(exHeader)) {
                        return exHeader.substring(exHeader.indexOf(":") + 1).trim();
                    }
                }
            }
            return;
        };
        /**
         * Get the header/s of the given name.
         * @param name - header name
         * @returns Array with all the headers of the specified name.
         */
        OutgoingRequestMessage.prototype.getHeaders = function (name) {
            var result = [];
            var headerArray = this.headers[utils_1.headerize(name)];
            if (headerArray) {
                for (var _i = 0, headerArray_1 = headerArray; _i < headerArray_1.length; _i++) {
                    var headerPart = headerArray_1[_i];
                    result.push(headerPart);
                }
            }
            else {
                var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
                for (var _a = 0, _b = this.extraHeaders; _a < _b.length; _a++) {
                    var exHeader = _b[_a];
                    if (regexp.test(exHeader)) {
                        result.push(exHeader.substring(exHeader.indexOf(":") + 1).trim());
                    }
                }
            }
            return result;
        };
        /**
         * Verify the existence of the given header.
         * @param name - header name
         * @returns true if header with given name exists, false otherwise
         */
        OutgoingRequestMessage.prototype.hasHeader = function (name) {
            if (this.headers[utils_1.headerize(name)]) {
                return true;
            }
            else {
                var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
                for (var _i = 0, _a = this.extraHeaders; _i < _a.length; _i++) {
                    var extraHeader = _a[_i];
                    if (regexp.test(extraHeader)) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * Replace the the given header by the given value.
         * @param name - header name
         * @param value - header value
         */
        OutgoingRequestMessage.prototype.setHeader = function (name, value) {
            this.headers[utils_1.headerize(name)] = (value instanceof Array) ? value : [value];
        };
        /**
         * The Via header field indicates the transport used for the transaction
         * and identifies the location where the response is to be sent.  A Via
         * header field value is added only after the transport that will be
         * used to reach the next hop has been selected (which may involve the
         * usage of the procedures in [4]).
         *
         * When the UAC creates a request, it MUST insert a Via into that
         * request.  The protocol name and protocol version in the header field
         * MUST be SIP and 2.0, respectively.  The Via header field value MUST
         * contain a branch parameter.  This parameter is used to identify the
         * transaction created by that request.  This parameter is used by both
         * the client and the server.
         * https://tools.ietf.org/html/rfc3261#section-8.1.1.7
         * @param branchParameter - The branch parameter.
         * @param transport - The sent protocol transport.
         */
        OutgoingRequestMessage.prototype.setViaHeader = function (branch, transport) {
            // FIXME: Hack
            if (this.options.hackViaTcp) {
                transport = "TCP";
            }
            var via = "SIP/2.0/" + transport;
            via += " " + this.options.viaHost + ";branch=" + branch;
            if (this.options.forceRport) {
                via += ";rport";
            }
            this.setHeader("via", via);
            this.branch = branch;
        };
        OutgoingRequestMessage.prototype.toString = function () {
            var msg = "";
            msg += this.method + " " + this.ruri.toRaw() + " SIP/2.0\r\n";
            for (var header in this.headers) {
                if (this.headers[header]) {
                    for (var _i = 0, _a = this.headers[header]; _i < _a.length; _i++) {
                        var headerPart = _a[_i];
                        msg += header + ": " + headerPart + "\r\n";
                    }
                }
            }
            for (var _b = 0, _c = this.extraHeaders; _b < _c.length; _b++) {
                var header = _c[_b];
                msg += header.trim() + "\r\n";
            }
            msg += "Supported: " + this.options.optionTags.join(", ") + "\r\n";
            msg += "User-Agent: " + this.options.userAgentString + "\r\n";
            if (this.body) {
                if (typeof this.body === "string") {
                    msg += "Content-Length: " + utils_1.str_utf8_length(this.body) + "\r\n\r\n";
                    msg += this.body;
                }
                else {
                    if (this.body.body && this.body.contentType) {
                        msg += "Content-Type: " + this.body.contentType + "\r\n";
                        msg += "Content-Length: " + utils_1.str_utf8_length(this.body.body) + "\r\n\r\n";
                        msg += this.body.body;
                    }
                    else {
                        msg += "Content-Length: " + 0 + "\r\n\r\n";
                    }
                }
            }
            else {
                msg += "Content-Length: " + 0 + "\r\n\r\n";
            }
            return msg;
        };
        return OutgoingRequestMessage;
    }());
    exports.OutgoingRequestMessage = OutgoingRequestMessage;
    
    
    /***/ }),
    
    /***/ "./src/core/messages/outgoing-response.ts":
    /*!************************************************!*\
      !*** ./src/core/messages/outgoing-response.ts ***!
      \************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = __webpack_require__(/*! ./utils */ "./src/core/messages/utils.ts");
    /**
     * When a UAS wishes to construct a response to a request, it follows
     * the general procedures detailed in the following subsections.
     * Additional behaviors specific to the response code in question, which
     * are not detailed in this section, may also be required.
     * https://tools.ietf.org/html/rfc3261#section-8.2.6
     * @internal
     */
    function constructOutgoingResponse(message, options) {
        var CRLF = "\r\n";
        if (options.statusCode < 100 || options.statusCode > 699) {
            throw new TypeError("Invalid statusCode: " + options.statusCode);
        }
        var reasonPhrase = options.reasonPhrase ? options.reasonPhrase : utils_1.getReasonPhrase(options.statusCode);
        // SIP responses are distinguished from requests by having a Status-Line
        // as their start-line.  A Status-Line consists of the protocol version
        // followed by a numeric Status-Code and its associated textual phrase,
        // with each element separated by a single SP character.
        // https://tools.ietf.org/html/rfc3261#section-7.2
        var response = "SIP/2.0 " + options.statusCode + " " + reasonPhrase + CRLF;
        // One largely non-method-specific guideline for the generation of
        // responses is that UASs SHOULD NOT issue a provisional response for a
        // non-INVITE request.  Rather, UASs SHOULD generate a final response to
        // a non-INVITE request as soon as possible.
        // https://tools.ietf.org/html/rfc3261#section-8.2.6.1
        if (options.statusCode >= 100 && options.statusCode < 200) {
            // TODO
        }
        // When a 100 (Trying) response is generated, any Timestamp header field
        // present in the request MUST be copied into this 100 (Trying)
        // response.  If there is a delay in generating the response, the UAS
        // SHOULD add a delay value into the Timestamp value in the response.
        // This value MUST contain the difference between the time of sending of
        // the response and receipt of the request, measured in seconds.
        // https://tools.ietf.org/html/rfc3261#section-8.2.6.1
        if (options.statusCode === 100) {
            // TODO
        }
        // The From field of the response MUST equal the From header field of
        // the request.  The Call-ID header field of the response MUST equal the
        // Call-ID header field of the request.  The CSeq header field of the
        // response MUST equal the CSeq field of the request.  The Via header
        // field values in the response MUST equal the Via header field values
        // in the request and MUST maintain the same ordering.
        // https://tools.ietf.org/html/rfc3261#section-8.2.6.2
        var fromHeader = "From: " + message.getHeader("From") + CRLF;
        var callIdHeader = "Call-ID: " + message.callId + CRLF;
        var cSeqHeader = "CSeq: " + message.cseq + " " + message.method + CRLF;
        var viaHeaders = message.getHeaders("via").reduce(function (previous, current) {
            return previous + "Via: " + current + CRLF;
        }, "");
        // If a request contained a To tag in the request, the To header field
        // in the response MUST equal that of the request.  However, if the To
        // header field in the request did not contain a tag, the URI in the To
        // header field in the response MUST equal the URI in the To header
        // field; additionally, the UAS MUST add a tag to the To header field in
        // the response (with the exception of the 100 (Trying) response, in
        // which a tag MAY be present).  This serves to identify the UAS that is
        // responding, possibly resulting in a component of a dialog ID.  The
        // same tag MUST be used for all responses to that request, both final
        // and provisional (again excepting the 100 (Trying)).
        // https://tools.ietf.org/html/rfc3261#section-8.2.6.2
        var toHeader = "To: " + message.getHeader("to");
        if (options.statusCode > 100 && !message.parseHeader("to").hasParam("tag")) {
            var toTag = options.toTag;
            if (!toTag) {
                // Stateless UAS Behavior...
                // o  To header tags MUST be generated for responses in a stateless
                //    manner - in a manner that will generate the same tag for the
                //    same request consistently.  For information on tag construction
                //    see Section 19.3.
                // https://tools.ietf.org/html/rfc3261#section-8.2.7
                toTag = utils_1.newTag(); // FIXME: newTag() currently generates random tags
            }
            toHeader += ";tag=" + toTag;
        }
        toHeader += CRLF;
        // FIXME: TODO: needs review... moved to InviteUserAgentServer (as it is specific to that)
        // let recordRouteHeaders = "";
        // if (request.method === C.INVITE && statusCode > 100 && statusCode <= 200) {
        //   recordRouteHeaders = request.getHeaders("record-route").reduce((previous, current) => {
        //     return previous + "Record-Route: " + current + CRLF;
        //   }, "");
        // }
        // FIXME: TODO: needs review...
        var supportedHeader = "";
        if (options.supported) {
            supportedHeader = "Supported: " + options.supported.join(", ") + CRLF;
        }
        // FIXME: TODO: needs review...
        var userAgentHeader = "";
        if (options.userAgent) {
            userAgentHeader = "User-Agent: " + options.userAgent + CRLF;
        }
        var extensionHeaders = "";
        if (options.extraHeaders) {
            extensionHeaders = options.extraHeaders.reduce(function (previous, current) {
                return previous + current.trim() + CRLF;
            }, "");
        }
        // The relative order of header fields with different field names is not
        // significant.  However, it is RECOMMENDED that header fields which are
        // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
        // Max-Forwards, and Proxy-Authorization, for example) appear towards
        // the top of the message to facilitate rapid parsing.
        // https://tools.ietf.org/html/rfc3261#section-7.3.1
        // response += recordRouteHeaders;
        response += viaHeaders;
        response += fromHeader;
        response += toHeader;
        response += cSeqHeader;
        response += callIdHeader;
        response += supportedHeader;
        response += userAgentHeader;
        response += extensionHeaders;
        if (options.body) {
            response += "Content-Type: " + options.body.contentType + CRLF;
            response += "Content-Length: " + utils_1.str_utf8_length(options.body.content) + CRLF + CRLF;
            response += options.body.content;
        }
        else {
            response += "Content-Length: " + 0 + CRLF + CRLF;
        }
        return { message: response };
    }
    exports.constructOutgoingResponse = constructOutgoingResponse;
    
    
    /***/ }),
    
    /***/ "./src/core/messages/parameters.ts":
    /*!*****************************************!*\
      !*** ./src/core/messages/parameters.ts ***!
      \*****************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @internal
     */
    var Parameters = /** @class */ (function () {
        function Parameters(parameters) {
            this.parameters = {};
            for (var param in parameters) {
                if (parameters.hasOwnProperty(param)) {
                    this.setParam(param, parameters[param]);
                }
            }
        }
        Parameters.prototype.setParam = function (key, value) {
            if (key) {
                this.parameters[key.toLowerCase()] = (typeof value === "undefined" || value === null) ? null : value.toString();
            }
        };
        Parameters.prototype.getParam = function (key) {
            if (key) {
                return this.parameters[key.toLowerCase()];
            }
        };
        Parameters.prototype.hasParam = function (key) {
            if (key) {
                return !!this.parameters.hasOwnProperty(key.toLowerCase());
            }
            return false;
        };
        Parameters.prototype.deleteParam = function (parameter) {
            parameter = parameter.toLowerCase();
            if (this.parameters.hasOwnProperty(parameter)) {
                var value = this.parameters[parameter];
                delete this.parameters[parameter];
                return value;
            }
        };
        Parameters.prototype.clearParams = function () {
            this.parameters = {};
        };
        return Parameters;
    }());
    exports.Parameters = Parameters;
    
    
    /***/ }),
    
    /***/ "./src/core/messages/parser.ts":
    /*!*************************************!*\
      !*** ./src/core/messages/parser.ts ***!
      \*************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var grammar_1 = __webpack_require__(/*! ./grammar */ "./src/core/messages/grammar.ts");
    var incoming_request_message_1 = __webpack_require__(/*! ./incoming-request-message */ "./src/core/messages/incoming-request-message.ts");
    var incoming_response_message_1 = __webpack_require__(/*! ./incoming-response-message */ "./src/core/messages/incoming-response-message.ts");
    /**
     * Extract and parse every header of a SIP message.
     * @internal
     */
    var Parser;
    (function (Parser) {
        function getHeader(data, headerStart) {
            // 'start' position of the header.
            var start = headerStart;
            // 'end' position of the header.
            var end = 0;
            // 'partial end' position of the header.
            var partialEnd = 0;
            // End of message.
            if (data.substring(start, start + 2).match(/(^\r\n)/)) {
                return -2;
            }
            while (end === 0) {
                // Partial End of Header.
                partialEnd = data.indexOf("\r\n", start);
                // 'indexOf' returns -1 if the value to be found never occurs.
                if (partialEnd === -1) {
                    return partialEnd;
                }
                if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) &&
                    data.charAt(partialEnd + 2).match(/(^\s+)/)) {
                    // Not the end of the message. Continue from the next position.
                    start = partialEnd + 2;
                }
                else {
                    end = partialEnd;
                }
            }
            return end;
        }
        Parser.getHeader = getHeader;
        function parseHeader(message, data, headerStart, headerEnd) {
            var hcolonIndex = data.indexOf(":", headerStart);
            var headerName = data.substring(headerStart, hcolonIndex).trim();
            var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
            var parsed;
            // If header-field is well-known, parse it.
            switch (headerName.toLowerCase()) {
                case "via":
                case "v":
                    message.addHeader("via", headerValue);
                    if (message.getHeaders("via").length === 1) {
                        parsed = message.parseHeader("Via");
                        if (parsed) {
                            message.via = parsed;
                            message.viaBranch = parsed.branch;
                        }
                    }
                    else {
                        parsed = 0;
                    }
                    break;
                case "from":
                case "f":
                    message.setHeader("from", headerValue);
                    parsed = message.parseHeader("from");
                    if (parsed) {
                        message.from = parsed;
                        message.fromTag = parsed.getParam("tag");
                    }
                    break;
                case "to":
                case "t":
                    message.setHeader("to", headerValue);
                    parsed = message.parseHeader("to");
                    if (parsed) {
                        message.to = parsed;
                        message.toTag = parsed.getParam("tag");
                    }
                    break;
                case "record-route":
                    parsed = grammar_1.Grammar.parse(headerValue, "Record_Route");
                    if (parsed === -1) {
                        parsed = undefined;
                        break;
                    }
                    if (!(parsed instanceof Array)) {
                        parsed = undefined;
                        break;
                    }
                    parsed.forEach(function (header) {
                        message.addHeader("record-route", headerValue.substring(header.position, header.offset));
                        message.headers["Record-Route"][message.getHeaders("record-route").length - 1].parsed = header.parsed;
                    });
                    break;
                case "call-id":
                case "i":
                    message.setHeader("call-id", headerValue);
                    parsed = message.parseHeader("call-id");
                    if (parsed) {
                        message.callId = headerValue;
                    }
                    break;
                case "contact":
                case "m":
                    parsed = grammar_1.Grammar.parse(headerValue, "Contact");
                    if (parsed === -1) {
                        parsed = undefined;
                        break;
                    }
                    if (!(parsed instanceof Array)) {
                        parsed = undefined;
                        break;
                    }
                    parsed.forEach(function (header) {
                        message.addHeader("contact", headerValue.substring(header.position, header.offset));
                        message.headers.Contact[message.getHeaders("contact").length - 1].parsed = header.parsed;
                    });
                    break;
                case "content-length":
                case "l":
                    message.setHeader("content-length", headerValue);
                    parsed = message.parseHeader("content-length");
                    break;
                case "content-type":
                case "c":
                    message.setHeader("content-type", headerValue);
                    parsed = message.parseHeader("content-type");
                    break;
                case "cseq":
                    message.setHeader("cseq", headerValue);
                    parsed = message.parseHeader("cseq");
                    if (parsed) {
                        message.cseq = parsed.value;
                    }
                    if (message instanceof incoming_response_message_1.IncomingResponseMessage) {
                        message.method = parsed.method;
                    }
                    break;
                case "max-forwards":
                    message.setHeader("max-forwards", headerValue);
                    parsed = message.parseHeader("max-forwards");
                    break;
                case "www-authenticate":
                    message.setHeader("www-authenticate", headerValue);
                    parsed = message.parseHeader("www-authenticate");
                    break;
                case "proxy-authenticate":
                    message.setHeader("proxy-authenticate", headerValue);
                    parsed = message.parseHeader("proxy-authenticate");
                    break;
                case "refer-to":
                case "r":
                    message.setHeader("refer-to", headerValue);
                    parsed = message.parseHeader("refer-to");
                    if (parsed) {
                        message.referTo = parsed;
                    }
                    break;
                default:
                    // Do not parse this header.
                    message.addHeader(headerName.toLowerCase(), headerValue);
                    parsed = 0;
            }
            if (parsed === undefined) {
                return {
                    error: "error parsing header '" + headerName + "'"
                };
            }
            else {
                return true;
            }
        }
        Parser.parseHeader = parseHeader;
        function parseMessage(data, logger) {
            var headerStart = 0;
            var headerEnd = data.indexOf("\r\n");
            if (headerEnd === -1) {
                logger.warn("no CRLF found, not a SIP message, discarded");
                return;
            }
            // Parse first line. Check if it is a Request or a Reply.
            var firstLine = data.substring(0, headerEnd);
            var parsed = grammar_1.Grammar.parse(firstLine, "Request_Response");
            var message;
            if (parsed === -1) {
                logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
                return;
            }
            else if (!parsed.status_code) {
                message = new incoming_request_message_1.IncomingRequestMessage();
                message.method = parsed.method;
                message.ruri = parsed.uri;
            }
            else {
                message = new incoming_response_message_1.IncomingResponseMessage();
                message.statusCode = parsed.status_code;
                message.reasonPhrase = parsed.reason_phrase;
            }
            message.data = data;
            headerStart = headerEnd + 2;
            // Loop over every line in data. Detect the end of each header and parse
            // it or simply add to the headers collection.
            var bodyStart;
            while (true) {
                headerEnd = getHeader(data, headerStart);
                // The SIP message has normally finished.
                if (headerEnd === -2) {
                    bodyStart = headerStart + 2;
                    break;
                }
                else if (headerEnd === -1) {
                    // data.indexOf returned -1 due to a malformed message.
                    logger.error("malformed message");
                    return;
                }
                var parsedHeader = parseHeader(message, data, headerStart, headerEnd);
                if (parsedHeader !== true) {
                    logger.error(parsed.error);
                    return;
                }
                headerStart = headerEnd + 2;
            }
            // RFC3261 18.3.
            // If there are additional bytes in the transport packet
            // beyond the end of the body, they MUST be discarded.
            if (message.hasHeader("content-length")) {
                message.body = data.substr(bodyStart, Number(message.getHeader("content-length")));
            }
            else {
                message.body = data.substring(bodyStart);
            }
            return message;
        }
        Parser.parseMessage = parseMessage;
    })(Parser = exports.Parser || (exports.Parser = {}));
    
    
    /***/ }),
    
    /***/ "./src/core/messages/uri.ts":
    /*!**********************************!*\
      !*** ./src/core/messages/uri.ts ***!
      \**********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/core/messages/parameters.ts");
    /**
     * URI.
     * @public
     */
    var URI = /** @class */ (function (_super) {
        tslib_1.__extends(URI, _super);
        /**
         * Constructor
         * @param scheme -
         * @param user -
         * @param host -
         * @param port -
         * @param parameters -
         * @param headers -
         */
        function URI(scheme, user, host, port, parameters, headers) {
            var _this = _super.call(this, parameters) || this;
            _this.headers = {};
            // Checks
            if (!host) {
                throw new TypeError('missing or invalid "host" parameter');
            }
            // Initialize parameters
            scheme = scheme || "sip";
            for (var header in headers) {
                if (headers.hasOwnProperty(header)) {
                    _this.setHeader(header, headers[header]);
                }
            }
            // Raw URI
            _this.raw = {
                scheme: scheme,
                user: user,
                host: host,
                port: port
            };
            // Normalized URI
            _this.normal = {
                scheme: scheme.toLowerCase(),
                user: user,
                host: host.toLowerCase(),
                port: port
            };
            return _this;
        }
        Object.defineProperty(URI.prototype, "scheme", {
            get: function () { return this.normal.scheme; },
            set: function (value) {
                this.raw.scheme = value;
                this.normal.scheme = value.toLowerCase();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "user", {
            get: function () { return this.normal.user; },
            set: function (value) {
                this.normal.user = this.raw.user = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "host", {
            get: function () { return this.normal.host; },
            set: function (value) {
                this.raw.host = value;
                this.normal.host = value.toLowerCase();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "aor", {
            get: function () { return this.normal.user + "@" + this.normal.host; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "port", {
            get: function () { return this.normal.port; },
            set: function (value) {
                this.normal.port = this.raw.port = value === 0 ? value : value;
            },
            enumerable: true,
            configurable: true
        });
        URI.prototype.setHeader = function (name, value) {
            this.headers[this.headerize(name)] = (value instanceof Array) ? value : [value];
        };
        URI.prototype.getHeader = function (name) {
            if (name) {
                return this.headers[this.headerize(name)];
            }
        };
        URI.prototype.hasHeader = function (name) {
            return !!name && !!this.headers.hasOwnProperty(this.headerize(name));
        };
        URI.prototype.deleteHeader = function (header) {
            header = this.headerize(header);
            if (this.headers.hasOwnProperty(header)) {
                var value = this.headers[header];
                delete this.headers[header];
                return value;
            }
        };
        URI.prototype.clearHeaders = function () {
            this.headers = {};
        };
        URI.prototype.clone = function () {
            return new URI(this._raw.scheme, this._raw.user || "", this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));
        };
        URI.prototype.toRaw = function () {
            return this._toString(this._raw);
        };
        URI.prototype.toString = function () {
            return this._toString(this._normal);
        };
        Object.defineProperty(URI.prototype, "_normal", {
            get: function () { return this.normal; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "_raw", {
            get: function () { return this.raw; },
            enumerable: true,
            configurable: true
        });
        URI.prototype._toString = function (uri) {
            var uriString = uri.scheme + ":";
            // add slashes if it's not a sip(s) URI
            if (!uri.scheme.toLowerCase().match("^sips?$")) {
                uriString += "//";
            }
            if (uri.user) {
                uriString += this.escapeUser(uri.user) + "@";
            }
            uriString += uri.host;
            if (uri.port || uri.port === 0) {
                uriString += ":" + uri.port;
            }
            for (var parameter in this.parameters) {
                if (this.parameters.hasOwnProperty(parameter)) {
                    uriString += ";" + parameter;
                    if (this.parameters[parameter] !== null) {
                        uriString += "=" + this.parameters[parameter];
                    }
                }
            }
            var headers = [];
            for (var header in this.headers) {
                if (this.headers.hasOwnProperty(header)) {
                    for (var idx in this.headers[header]) {
                        if (this.headers[header].hasOwnProperty(idx)) {
                            headers.push(header + "=" + this.headers[header][idx]);
                        }
                    }
                }
            }
            if (headers.length > 0) {
                uriString += "?" + headers.join("&");
            }
            return uriString;
        };
        /*
         * Hex-escape a SIP URI user.
         * @private
         * @param {String} user
         */
        URI.prototype.escapeUser = function (user) {
            var decodedUser;
            // FIXME: This is called by toString above which should never throw, but
            // decodeURIComponent can throw and I've seen one case in production where
            // it did throw resulting in a cascading failure. This class should be
            // fixed so that decodeURIComponent is not called at this point (in toString).
            // The user should be decoded when the URI is constructor or some other
            // place where we can catch the error before the URI is created or somesuch.
            try {
                decodedUser = decodeURIComponent(user);
            }
            catch (error) {
                throw error;
            }
            // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
            return encodeURIComponent(decodedUser)
                .replace(/%3A/ig, ":")
                .replace(/%2B/ig, "+")
                .replace(/%3F/ig, "?")
                .replace(/%2F/ig, "/");
        };
        URI.prototype.headerize = function (str) {
            var exceptions = {
                "Call-Id": "Call-ID",
                "Cseq": "CSeq",
                "Min-Se": "Min-SE",
                "Rack": "RAck",
                "Rseq": "RSeq",
                "Www-Authenticate": "WWW-Authenticate",
            };
            var name = str.toLowerCase().replace(/_/g, "-").split("-");
            var parts = name.length;
            var hname = "";
            for (var part = 0; part < parts; part++) {
                if (part !== 0) {
                    hname += "-";
                }
                hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
            }
            if (exceptions[hname]) {
                hname = exceptions[hname];
            }
            return hname;
        };
        return URI;
    }(parameters_1.Parameters));
    exports.URI = URI;
    
    
    /***/ }),
    
    /***/ "./src/core/messages/utils.ts":
    /*!************************************!*\
      !*** ./src/core/messages/utils.ts ***!
      \************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @param size -
     * @param base -
     * @internal
     */
    function createRandomToken(size, base) {
        if (base === void 0) { base = 32; }
        var token = "";
        for (var i = 0; i < size; i++) {
            var r = Math.floor(Math.random() * base);
            token += r.toString(base);
        }
        return token;
    }
    exports.createRandomToken = createRandomToken;
    /**
     * @internal
     */
    function getReasonPhrase(code) {
        return REASON_PHRASE[code] || "";
    }
    exports.getReasonPhrase = getReasonPhrase;
    /**
     * @internal
     */
    function newTag() {
        return createRandomToken(10);
    }
    exports.newTag = newTag;
    /**
     * @param str -
     * @internal
     */
    function headerize(str) {
        var exceptions = {
            "Call-Id": "Call-ID",
            "Cseq": "CSeq",
            "Min-Se": "Min-SE",
            "Rack": "RAck",
            "Rseq": "RSeq",
            "Www-Authenticate": "WWW-Authenticate",
        };
        var name = str.toLowerCase().replace(/_/g, "-").split("-");
        var parts = name.length;
        var hname = "";
        for (var part = 0; part < parts; part++) {
            if (part !== 0) {
                hname += "-";
            }
            hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
        }
        if (exceptions[hname]) {
            hname = exceptions[hname];
        }
        return hname;
    }
    exports.headerize = headerize;
    /**
     * @param str -
     * @internal
     */
    function str_utf8_length(str) {
        return encodeURIComponent(str).replace(/%[A-F\d]{2}/g, "U").length;
    }
    exports.str_utf8_length = str_utf8_length;
    /**
     * SIP Response Reasons
     * DOC: http://www.iana.org/assignments/sip-parameters
     * @internal
     */
    var REASON_PHRASE = {
        100: "Trying",
        180: "Ringing",
        181: "Call Is Being Forwarded",
        182: "Queued",
        183: "Session Progress",
        199: "Early Dialog Terminated",
        200: "OK",
        202: "Accepted",
        204: "No Notification",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Moved Temporarily",
        305: "Use Proxy",
        380: "Alternative Service",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        410: "Gone",
        412: "Conditional Request Failed",
        413: "Request Entity Too Large",
        414: "Request-URI Too Long",
        415: "Unsupported Media Type",
        416: "Unsupported URI Scheme",
        417: "Unknown Resource-Priority",
        420: "Bad Extension",
        421: "Extension Required",
        422: "Session Interval Too Small",
        423: "Interval Too Brief",
        428: "Use Identity Header",
        429: "Provide Referrer Identity",
        430: "Flow Failed",
        433: "Anonymity Disallowed",
        436: "Bad Identity-Info",
        437: "Unsupported Certificate",
        438: "Invalid Identity Header",
        439: "First Hop Lacks Outbound Support",
        440: "Max-Breadth Exceeded",
        469: "Bad Info Package",
        470: "Consent Needed",
        478: "Unresolvable Destination",
        480: "Temporarily Unavailable",
        481: "Call/Transaction Does Not Exist",
        482: "Loop Detected",
        483: "Too Many Hops",
        484: "Address Incomplete",
        485: "Ambiguous",
        486: "Busy Here",
        487: "Request Terminated",
        488: "Not Acceptable Here",
        489: "Bad Event",
        491: "Request Pending",
        493: "Undecipherable",
        494: "Security Agreement Required",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Server Time-out",
        505: "Version Not Supported",
        513: "Message Too Large",
        580: "Precondition Failure",
        600: "Busy Everywhere",
        603: "Decline",
        604: "Does Not Exist Anywhere",
        606: "Not Acceptable"
    };
    
    
    /***/ }),
    
    /***/ "./src/core/session/index.ts":
    /*!***********************************!*\
      !*** ./src/core/session/index.ts ***!
      \***********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./session */ "./src/core/session/session.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/session/session.ts":
    /*!*************************************!*\
      !*** ./src/core/session/session.ts ***!
      \*************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Session state.
     * @remarks
     * https://tools.ietf.org/html/rfc3261#section-13
     * @public
     */
    var SessionState;
    (function (SessionState) {
        SessionState["Initial"] = "Initial";
        SessionState["Early"] = "Early";
        SessionState["AckWait"] = "AckWait";
        SessionState["Confirmed"] = "Confirmed";
        SessionState["Terminated"] = "Terminated";
    })(SessionState = exports.SessionState || (exports.SessionState = {}));
    /**
     * Offer/Answer state.
     * @remarks
     * ```txt
     *         Offer                Answer             RFC    Ini Est Early
     *  -------------------------------------------------------------------
     *  1. INVITE Req.          2xx INVITE Resp.     RFC 3261  Y   Y    N
     *  2. 2xx INVITE Resp.     ACK Req.             RFC 3261  Y   Y    N
     *  3. INVITE Req.          1xx-rel INVITE Resp. RFC 3262  Y   Y    N
     *  4. 1xx-rel INVITE Resp. PRACK Req.           RFC 3262  Y   Y    N
     *  5. PRACK Req.           200 PRACK Resp.      RFC 3262  N   Y    Y
     *  6. UPDATE Req.          2xx UPDATE Resp.     RFC 3311  N   Y    Y
     *
     *       Table 1: Summary of SIP Usage of the Offer/Answer Model
     * ```
     * https://tools.ietf.org/html/rfc6337#section-2.2
     * @public
     */
    var SignalingState;
    (function (SignalingState) {
        SignalingState["Initial"] = "Initial";
        SignalingState["HaveLocalOffer"] = "HaveLocalOffer";
        SignalingState["HaveRemoteOffer"] = "HaveRemoteOffer";
        SignalingState["Stable"] = "Stable";
        SignalingState["Closed"] = "Closed";
    })(SignalingState = exports.SignalingState || (exports.SignalingState = {}));
    
    
    /***/ }),
    
    /***/ "./src/core/subscription/index.ts":
    /*!****************************************!*\
      !*** ./src/core/subscription/index.ts ***!
      \****************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./subscription */ "./src/core/subscription/subscription.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/subscription/subscription.ts":
    /*!***********************************************!*\
      !*** ./src/core/subscription/subscription.ts ***!
      \***********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Subscription state.
     * @remarks
     * https://tools.ietf.org/html/rfc6665#section-4.1.2
     * @public
     */
    var SubscriptionState;
    (function (SubscriptionState) {
        SubscriptionState["Initial"] = "Initial";
        SubscriptionState["NotifyWait"] = "NotifyWait";
        SubscriptionState["Pending"] = "Pending";
        SubscriptionState["Active"] = "Active";
        SubscriptionState["Terminated"] = "Terminated";
    })(SubscriptionState = exports.SubscriptionState || (exports.SubscriptionState = {}));
    
    
    /***/ }),
    
    /***/ "./src/core/timers.ts":
    /*!****************************!*\
      !*** ./src/core/timers.ts ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var T1 = 500;
    var T2 = 4000;
    var T4 = 5000;
    /**
     * Timers.
     * @public
     */
    exports.Timers = {
        T1: T1,
        T2: T2,
        T4: T4,
        TIMER_B: 64 * T1,
        TIMER_D: 0 * T1,
        TIMER_F: 64 * T1,
        TIMER_H: 64 * T1,
        TIMER_I: 0 * T4,
        TIMER_J: 0 * T1,
        TIMER_K: 0 * T4,
        TIMER_L: 64 * T1,
        TIMER_M: 64 * T1,
        TIMER_N: 64 * T1,
        PROVISIONAL_RESPONSE_INTERVAL: 60000 // See RFC 3261 Section 13.3.1.1
    };
    
    
    /***/ }),
    
    /***/ "./src/core/transactions/client-transaction.ts":
    /*!*****************************************************!*\
      !*** ./src/core/transactions/client-transaction.ts ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transaction_1 = __webpack_require__(/*! ./transaction */ "./src/core/transactions/transaction.ts");
    /**
     * Client Transaction.
     * @remarks
     * The client transaction provides its functionality through the
     * maintenance of a state machine.
     *
     * The TU communicates with the client transaction through a simple
     * interface.  When the TU wishes to initiate a new transaction, it
     * creates a client transaction and passes it the SIP request to send
     * and an IP address, port, and transport to which to send it.  The
     * client transaction begins execution of its state machine.  Valid
     * responses are passed up to the TU from the client transaction.
     * https://tools.ietf.org/html/rfc3261#section-17.1
     * @public
     */
    var ClientTransaction = /** @class */ (function (_super) {
        tslib_1.__extends(ClientTransaction, _super);
        function ClientTransaction(_request, transport, user, state, loggerCategory) {
            var _this = _super.call(this, transport, user, ClientTransaction.makeId(_request), state, loggerCategory) || this;
            _this._request = _request;
            _this.user = user;
            // The Via header field indicates the transport used for the transaction
            // and identifies the location where the response is to be sent.  A Via
            // header field value is added only after the transport that will be
            // used to reach the next hop has been selected (which may involve the
            // usage of the procedures in [4]).
            // https://tools.ietf.org/html/rfc3261#section-8.1.1.7
            _request.setViaHeader(_this.id, transport.protocol);
            return _this;
        }
        ClientTransaction.makeId = function (request) {
            if (request.method === "CANCEL") {
                if (!request.branch) {
                    throw new Error("Outgoing CANCEL request without a branch.");
                }
                return request.branch;
            }
            else {
                return "z9hG4bK" + Math.floor(Math.random() * 10000000);
            }
        };
        Object.defineProperty(ClientTransaction.prototype, "request", {
            /** The outgoing request the transaction handling. */
            get: function () {
                return this._request;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * A 408 to non-INVITE will always arrive too late to be useful ([3]),
         * The client already has full knowledge of the timeout. The only
         * information this message would convey is whether or not the server
         * believed the transaction timed out. However, with the current design
         * of the NIT, a client cannot do anything with this knowledge. Thus,
         * the 408 is simply wasting network resources and contributes to the
         * response bombardment illustrated in [3].
         * https://tools.ietf.org/html/rfc4320#section-4.1
         */
        ClientTransaction.prototype.onRequestTimeout = function () {
            if (this.user.onRequestTimeout) {
                this.user.onRequestTimeout();
            }
        };
        return ClientTransaction;
    }(transaction_1.Transaction));
    exports.ClientTransaction = ClientTransaction;
    
    
    /***/ }),
    
    /***/ "./src/core/transactions/index.ts":
    /*!****************************************!*\
      !*** ./src/core/transactions/index.ts ***!
      \****************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./client-transaction */ "./src/core/transactions/client-transaction.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./invite-client-transaction */ "./src/core/transactions/invite-client-transaction.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./invite-server-transaction */ "./src/core/transactions/invite-server-transaction.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./non-invite-client-transaction */ "./src/core/transactions/non-invite-client-transaction.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./non-invite-server-transaction */ "./src/core/transactions/non-invite-server-transaction.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./invite-client-transaction */ "./src/core/transactions/invite-client-transaction.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./server-transaction */ "./src/core/transactions/server-transaction.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./transaction-state */ "./src/core/transactions/transaction-state.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./transaction */ "./src/core/transactions/transaction.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/transactions/invite-client-transaction.ts":
    /*!************************************************************!*\
      !*** ./src/core/transactions/invite-client-transaction.ts ***!
      \************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var timers_1 = __webpack_require__(/*! ../timers */ "./src/core/timers.ts");
    var client_transaction_1 = __webpack_require__(/*! ./client-transaction */ "./src/core/transactions/client-transaction.ts");
    var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./src/core/transactions/transaction-state.ts");
    /**
     * INVITE Client Transaction.
     * @remarks
     * The INVITE transaction consists of a three-way handshake.  The client
     * transaction sends an INVITE, the server transaction sends responses,
     * and the client transaction sends an ACK.
     * https://tools.ietf.org/html/rfc3261#section-17.1.1
     * @public
     */
    var InviteClientTransaction = /** @class */ (function (_super) {
        tslib_1.__extends(InviteClientTransaction, _super);
        /**
         * Constructor.
         * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
         * Then `toString` is called on the outgoing request and the message is sent via the transport.
         * After construction the transaction will be in the "calling" state and the transaction id
         * will equal the branch parameter set in the Via header of the outgoing request.
         * https://tools.ietf.org/html/rfc3261#section-17.1.1
         * @param request - The outgoing INVITE request.
         * @param transport - The transport.
         * @param user - The transaction user.
         */
        function InviteClientTransaction(request, transport, user) {
            var _this = _super.call(this, request, transport, user, transaction_state_1.TransactionState.Calling, "sip.transaction.ict") || this;
            /**
             * Map of 2xx to-tag to ACK.
             * If value is not undefined, value is the ACK which was sent.
             * If key exists but value is undefined, a 2xx was received but the ACK not yet sent.
             * Otherwise, a 2xx was not (yet) received for this transaction.
             */
            _this.ackRetransmissionCache = new Map();
            // FIXME: Timer A for unreliable transport not implemented
            //
            // If an unreliable transport is being used, the client transaction
            // MUST start timer A with a value of T1. If a reliable transport is being used,
            // the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions).
            // For any transport, the client transaction MUST start timer B with a value
            // of 64*T1 seconds (Timer B controls transaction timeouts).
            // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
            //
            // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender
            // will wait for an INVITE message to be acknowledged (a SIP response message is received).
            // So Timer B should be cleared when the transaction state proceeds from "Calling".
            _this.B = setTimeout(function () { return _this.timer_B(); }, timers_1.Timers.TIMER_B);
            _this.send(request.toString()).catch(function (error) {
                _this.logTransportError(error, "Failed to send initial outgoing request.");
            });
            return _this;
        }
        /**
         * Destructor.
         */
        InviteClientTransaction.prototype.dispose = function () {
            if (this.B) {
                clearTimeout(this.B);
                this.B = undefined;
            }
            if (this.D) {
                clearTimeout(this.D);
                this.D = undefined;
            }
            if (this.M) {
                clearTimeout(this.M);
                this.M = undefined;
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(InviteClientTransaction.prototype, "kind", {
            /** Transaction kind. Deprecated. */
            get: function () {
                return "ict";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * ACK a 2xx final response.
         *
         * The transaction includes the ACK only if the final response was not a 2xx response (the
         * transaction will generate and send the ACK to the transport automagically). If the
         * final response was a 2xx, the ACK is not considered part of the transaction (the
         * transaction user needs to generate and send the ACK).
         *
         * This library is not strictly RFC compliant with regard to ACK handling for 2xx final
         * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled
         * by the transaction layer (instead of the UAC core). The "standard" approach is for
         * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to
         * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses
         * and any retransmissions of those ACKs as needed.
         *
         * @param ack - The outgoing ACK request.
         */
        InviteClientTransaction.prototype.ackResponse = function (ack) {
            var _this = this;
            var toTag = ack.toTag;
            if (!toTag) {
                throw new Error("To tag undefined.");
            }
            var id = "z9hG4bK" + Math.floor(Math.random() * 10000000);
            ack.setViaHeader(id, this.transport.protocol);
            this.ackRetransmissionCache.set(toTag, ack); // Add to ACK retransmission cache
            this.send(ack.toString()).catch(function (error) {
                _this.logTransportError(error, "Failed to send ACK to 2xx response.");
            });
        };
        /**
         * Handler for incoming responses from the transport which match this transaction.
         * @param response - The incoming response.
         */
        InviteClientTransaction.prototype.receiveResponse = function (response) {
            var _this = this;
            var statusCode = response.statusCode;
            if (!statusCode || statusCode < 100 || statusCode > 699) {
                throw new Error("Invalid status code " + statusCode);
            }
            switch (this.state) {
                case transaction_state_1.TransactionState.Calling:
                    // If the client transaction receives a provisional response while in
                    // the "Calling" state, it transitions to the "Proceeding" state. In the
                    // "Proceeding" state, the client transaction SHOULD NOT retransmit the
                    // request any longer. Furthermore, the provisional response MUST be
                    // passed to the TU.  Any further provisional responses MUST be passed
                    // up to the TU while in the "Proceeding" state.
                    // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
                    if (statusCode >= 100 && statusCode <= 199) {
                        this.stateTransition(transaction_state_1.TransactionState.Proceeding);
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                    // When a 2xx response is received while in either the "Calling" or
                    // "Proceeding" states, the client transaction MUST transition to
                    // the "Accepted" state... The 2xx response MUST be passed up to the TU.
                    // The client transaction MUST NOT generate an ACK to the 2xx response -- its
                    // handling is delegated to the TU. A UAC core will send an ACK to
                    // the 2xx response using a new transaction.
                    // https://tools.ietf.org/html/rfc6026#section-8.4
                    if (statusCode >= 200 && statusCode <= 299) {
                        this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
                        this.stateTransition(transaction_state_1.TransactionState.Accepted);
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                    // When in either the "Calling" or "Proceeding" states, reception of
                    // a response with status code from 300-699 MUST cause the client
                    // transaction to transition to "Completed". The client transaction
                    // MUST pass the received response up to the TU, and the client
                    // transaction MUST generate an ACK request, even if the transport is
                    // reliable (guidelines for constructing the ACK from the response
                    // are given in Section 17.1.1.3), and then pass the ACK to the
                    // transport layer for transmission. The ACK MUST be sent to the
                    // same address, port, and transport to which the original request was sent.
                    // https://tools.ietf.org/html/rfc6026#section-8.4
                    if (statusCode >= 300 && statusCode <= 699) {
                        this.stateTransition(transaction_state_1.TransactionState.Completed);
                        this.ack(response);
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Proceeding:
                    // In the "Proceeding" state, the client transaction SHOULD NOT retransmit the
                    // request any longer. Furthermore, the provisional response MUST be
                    // passed to the TU.  Any further provisional responses MUST be passed
                    // up to the TU while in the "Proceeding" state.
                    // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
                    if (statusCode >= 100 && statusCode <= 199) {
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                    // When a 2xx response is received while in either the "Calling" or "Proceeding" states,
                    // the client transaction MUST transition to the "Accepted" state...
                    // The 2xx response MUST be passed up to the TU. The client
                    // transaction MUST NOT generate an ACK to the 2xx response -- its
                    // handling is delegated to the TU. A UAC core will send an ACK to
                    // the 2xx response using a new transaction.
                    // https://tools.ietf.org/html/rfc6026#section-8.4
                    if (statusCode >= 200 && statusCode <= 299) {
                        this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
                        this.stateTransition(transaction_state_1.TransactionState.Accepted);
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                    // When in either the "Calling" or "Proceeding" states, reception of
                    // a response with status code from 300-699 MUST cause the client
                    // transaction to transition to "Completed". The client transaction
                    // MUST pass the received response up to the TU, and the client
                    // transaction MUST generate an ACK request, even if the transport is
                    // reliable (guidelines for constructing the ACK from the response
                    // are given in Section 17.1.1.3), and then pass the ACK to the
                    // transport layer for transmission. The ACK MUST be sent to the
                    // same address, port, and transport to which the original request was sent.
                    // https://tools.ietf.org/html/rfc6026#section-8.4
                    if (statusCode >= 300 && statusCode <= 699) {
                        this.stateTransition(transaction_state_1.TransactionState.Completed);
                        this.ack(response);
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Accepted:
                    // The purpose of the "Accepted" state is to allow the client
                    // transaction to continue to exist to receive, and pass to the TU,
                    // any retransmissions of the 2xx response and any additional 2xx
                    // responses from other branches of the INVITE if it forked
                    // downstream. Timer M reflects the amount of time that the
                    // transaction user will wait for such messages.
                    //
                    // Any 2xx responses that match this client transaction and that are
                    // received while in the "Accepted" state MUST be passed up to the
                    // TU. The client transaction MUST NOT generate an ACK to the 2xx
                    // response. The client transaction takes no further action.
                    // https://tools.ietf.org/html/rfc6026#section-8.4
                    if (statusCode >= 200 && statusCode <= 299) {
                        // NOTE: This implementation herein is intentionally not RFC compliant.
                        // While the first 2xx response for a given branch is passed up to the TU,
                        // retransmissions of 2xx responses are absorbed and the ACK associated
                        // with the original response is resent. This approach is taken because
                        // our current transaction users are not currently in a good position to
                        // deal with 2xx retransmission. This SHOULD NOT cause any compliance issues - ;)
                        //
                        // If we don't have a cache hit, pass the response to the TU.
                        if (!this.ackRetransmissionCache.has(response.toTag)) {
                            this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
                            if (this.user.receiveResponse) {
                                this.user.receiveResponse(response);
                            }
                            return;
                        }
                        // If we have a cache hit, try pulling the ACK from cache and retransmitting it.
                        var ack = this.ackRetransmissionCache.get(response.toTag);
                        if (ack) {
                            this.send(ack.toString()).catch(function (error) {
                                _this.logTransportError(error, "Failed to send retransmission of ACK to 2xx response.");
                            });
                            return;
                        }
                        // If an ACK was not found in cache then we have received a retransmitted 2xx
                        // response before the TU responded to the original response (we don't have an ACK yet).
                        // So discard this response under the assumption that the TU will eventually
                        // get us a ACK for the original response.
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Completed:
                    // Any retransmissions of a response with status code 300-699 that
                    // are received while in the "Completed" state MUST cause the ACK to
                    // be re-passed to the transport layer for retransmission, but the
                    // newly received response MUST NOT be passed up to the TU.
                    // https://tools.ietf.org/html/rfc6026#section-8.4
                    if (statusCode >= 300 && statusCode <= 699) {
                        this.ack(response);
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Terminated:
                    break;
                default:
                    throw new Error("Invalid state " + this.state);
            }
            // Any response received that does not match an existing client
            // transaction state machine is simply dropped. (Implementations are,
            // of course, free to log or do other implementation-specific things
            // with such responses, but the implementer should be sure to consider
            // the impact of large numbers of malicious stray responses.)
            // https://tools.ietf.org/html/rfc6026#section-7.2
            var message = "Received unexpected " + statusCode + " response while in state " + this.state + ".";
            this.logger.warn(message);
            return;
        };
        /**
         * The client transaction SHOULD inform the TU that a transport failure
         * has occurred, and the client transaction SHOULD transition directly
         * to the "Terminated" state.  The TU will handle the failover
         * mechanisms described in [4].
         * https://tools.ietf.org/html/rfc3261#section-17.1.4
         * @param error - The error.
         */
        InviteClientTransaction.prototype.onTransportError = function (error) {
            if (this.user.onTransportError) {
                this.user.onTransportError(error);
            }
            this.stateTransition(transaction_state_1.TransactionState.Terminated, true);
        };
        /** For logging. */
        InviteClientTransaction.prototype.typeToString = function () {
            return "INVITE client transaction";
        };
        InviteClientTransaction.prototype.ack = function (response) {
            var _this = this;
            // The ACK request constructed by the client transaction MUST contain
            // values for the Call-ID, From, and Request-URI that are equal to the
            // values of those header fields in the request passed to the transport
            // by the client transaction (call this the "original request"). The To
            // header field in the ACK MUST equal the To header field in the
            // response being acknowledged, and therefore will usually differ from
            // the To header field in the original request by the addition of the
            // tag parameter. The ACK MUST contain a single Via header field, and
            // this MUST be equal to the top Via header field of the original
            // request. The CSeq header field in the ACK MUST contain the same
            // value for the sequence number as was present in the original request,
            // but the method parameter MUST be equal to "ACK".
            //
            // If the INVITE request whose response is being acknowledged had Route
            // header fields, those header fields MUST appear in the ACK. This is
            // to ensure that the ACK can be routed properly through any downstream
            // stateless proxies.
            // https://tools.ietf.org/html/rfc3261#section-17.1.1.3
            var ruri = this.request.ruri;
            var callId = this.request.callId;
            var cseq = this.request.cseq;
            var from = this.request.getHeader("from");
            var to = response.getHeader("to");
            var via = this.request.getHeader("via");
            var route = this.request.getHeader("route");
            if (!from) {
                throw new Error("From undefined.");
            }
            if (!to) {
                throw new Error("To undefined.");
            }
            if (!via) {
                throw new Error("Via undefined.");
            }
            var ack = "ACK " + ruri + " SIP/2.0\r\n";
            if (route) {
                ack += "Route: " + route + "\r\n";
            }
            ack += "Via: " + via + "\r\n";
            ack += "To: " + to + "\r\n";
            ack += "From: " + from + "\r\n";
            ack += "Call-ID: " + callId + "\r\n";
            ack += "CSeq: " + cseq + " ACK\r\n";
            ack += "Max-Forwards: 70\r\n";
            ack += "Content-Length: 0\r\n\r\n";
            // TOOO: "User-Agent" header
            this.send(ack).catch(function (error) {
                _this.logTransportError(error, "Failed to send ACK to non-2xx response.");
            });
            return;
        };
        /**
         * Execute a state transition.
         * @param newState - New state.
         */
        InviteClientTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
            var _this = this;
            if (dueToTransportError === void 0) { dueToTransportError = false; }
            // Assert valid state transitions.
            var invalidStateTransition = function () {
                throw new Error("Invalid state transition from " + _this.state + " to " + newState);
            };
            switch (newState) {
                case transaction_state_1.TransactionState.Calling:
                    invalidStateTransition();
                    break;
                case transaction_state_1.TransactionState.Proceeding:
                    if (this.state !== transaction_state_1.TransactionState.Calling) {
                        invalidStateTransition();
                    }
                    break;
                case transaction_state_1.TransactionState.Accepted:
                case transaction_state_1.TransactionState.Completed:
                    if (this.state !== transaction_state_1.TransactionState.Calling &&
                        this.state !== transaction_state_1.TransactionState.Proceeding) {
                        invalidStateTransition();
                    }
                    break;
                case transaction_state_1.TransactionState.Terminated:
                    if (this.state !== transaction_state_1.TransactionState.Calling &&
                        this.state !== transaction_state_1.TransactionState.Accepted &&
                        this.state !== transaction_state_1.TransactionState.Completed) {
                        if (!dueToTransportError) {
                            invalidStateTransition();
                        }
                    }
                    break;
                default:
                    invalidStateTransition();
            }
            // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender
            // will wait for an INVITE message to be acknowledged (a SIP response message is received).
            // So Timer B should be cleared when the transaction state proceeds from "Calling".
            if (this.B) {
                clearTimeout(this.B);
                this.B = undefined;
            }
            if (newState === transaction_state_1.TransactionState.Proceeding) {
                // Timers have no effect on "Proceeding" state.
                // In the "Proceeding" state, the client transaction
                // SHOULD NOT retransmit the request any longer.
                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
            }
            // The client transaction MUST start Timer D when it enters the "Completed" state
            // for any reason, with a value of at least 32 seconds for unreliable transports,
            // and a value of zero seconds for reliable transports.
            // https://tools.ietf.org/html/rfc6026#section-8.4
            if (newState === transaction_state_1.TransactionState.Completed) {
                this.D = setTimeout(function () { return _this.timer_D(); }, timers_1.Timers.TIMER_D);
            }
            // The client transaction MUST transition to the "Accepted" state,
            // and Timer M MUST be started with a value of 64*T1.
            // https://tools.ietf.org/html/rfc6026#section-8.4
            if (newState === transaction_state_1.TransactionState.Accepted) {
                this.M = setTimeout(function () { return _this.timer_M(); }, timers_1.Timers.TIMER_M);
            }
            // Once the transaction is in the "Terminated" state, it MUST be destroyed immediately.
            // https://tools.ietf.org/html/rfc6026#section-8.7
            if (newState === transaction_state_1.TransactionState.Terminated) {
                this.dispose();
            }
            // Update state.
            this.setState(newState);
        };
        /**
         * When timer A fires, the client transaction MUST retransmit the
         * request by passing it to the transport layer, and MUST reset the
         * timer with a value of 2*T1.
         * When timer A fires 2*T1 seconds later, the request MUST be
         * retransmitted again (assuming the client transaction is still in this
         * state). This process MUST continue so that the request is
         * retransmitted with intervals that double after each transmission.
         * These retransmissions SHOULD only be done while the client
         * transaction is in the "Calling" state.
         * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
         */
        InviteClientTransaction.prototype.timer_A = function () {
            // TODO
        };
        /**
         * If the client transaction is still in the "Calling" state when timer
         * B fires, the client transaction SHOULD inform the TU that a timeout
         * has occurred.  The client transaction MUST NOT generate an ACK.
         * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
         */
        InviteClientTransaction.prototype.timer_B = function () {
            this.logger.debug("Timer B expired for INVITE client transaction " + this.id + ".");
            if (this.state === transaction_state_1.TransactionState.Calling) {
                this.onRequestTimeout();
                this.stateTransition(transaction_state_1.TransactionState.Terminated);
            }
        };
        /**
         * If Timer D fires while the client transaction is in the "Completed" state,
         * the client transaction MUST move to the "Terminated" state.
         * https://tools.ietf.org/html/rfc6026#section-8.4
         */
        InviteClientTransaction.prototype.timer_D = function () {
            this.logger.debug("Timer D expired for INVITE client transaction " + this.id + ".");
            if (this.state === transaction_state_1.TransactionState.Completed) {
                this.stateTransition(transaction_state_1.TransactionState.Terminated);
            }
        };
        /**
         * If Timer M fires while the client transaction is in the "Accepted"
         * state, the client transaction MUST move to the "Terminated" state.
         * https://tools.ietf.org/html/rfc6026#section-8.4
         */
        InviteClientTransaction.prototype.timer_M = function () {
            this.logger.debug("Timer M expired for INVITE client transaction " + this.id + ".");
            if (this.state === transaction_state_1.TransactionState.Accepted) {
                this.stateTransition(transaction_state_1.TransactionState.Terminated);
            }
        };
        return InviteClientTransaction;
    }(client_transaction_1.ClientTransaction));
    exports.InviteClientTransaction = InviteClientTransaction;
    
    
    /***/ }),
    
    /***/ "./src/core/transactions/invite-server-transaction.ts":
    /*!************************************************************!*\
      !*** ./src/core/transactions/invite-server-transaction.ts ***!
      \************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var timers_1 = __webpack_require__(/*! ../timers */ "./src/core/timers.ts");
    var server_transaction_1 = __webpack_require__(/*! ./server-transaction */ "./src/core/transactions/server-transaction.ts");
    var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./src/core/transactions/transaction-state.ts");
    /**
     * INVITE Server Transaction.
     * @remarks
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     * @public
     */
    var InviteServerTransaction = /** @class */ (function (_super) {
        tslib_1.__extends(InviteServerTransaction, _super);
        /**
         * Constructor.
         * Upon construction, a "100 Trying" reply will be immediately sent.
         * After construction the transaction will be in the "proceeding" state and the transaction
         * `id` will equal the branch parameter set in the Via header of the incoming request.
         * https://tools.ietf.org/html/rfc3261#section-17.2.1
         * @param request - Incoming INVITE request from the transport.
         * @param transport - The transport.
         * @param user - The transaction user.
         */
        function InviteServerTransaction(request, transport, user) {
            return _super.call(this, request, transport, user, transaction_state_1.TransactionState.Proceeding, "sip.transaction.ist") || this;
        }
        /**
         * Destructor.
         */
        InviteServerTransaction.prototype.dispose = function () {
            this.stopProgressExtensionTimer();
            if (this.H) {
                clearTimeout(this.H);
                this.H = undefined;
            }
            if (this.I) {
                clearTimeout(this.I);
                this.I = undefined;
            }
            if (this.L) {
                clearTimeout(this.L);
                this.L = undefined;
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(InviteServerTransaction.prototype, "kind", {
            /** Transaction kind. Deprecated. */
            get: function () {
                return "ist";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Receive requests from transport matching this transaction.
         * @param request - Request matching this transaction.
         */
        InviteServerTransaction.prototype.receiveRequest = function (request) {
            var _this = this;
            switch (this.state) {
                case transaction_state_1.TransactionState.Proceeding:
                    // If a request retransmission is received while in the "Proceeding" state, the most
                    // recent provisional response that was received from the TU MUST be passed to the
                    // transport layer for retransmission.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.1
                    if (request.method === messages_1.C.INVITE) {
                        if (this.lastProvisionalResponse) {
                            this.send(this.lastProvisionalResponse).catch(function (error) {
                                _this.logTransportError(error, "Failed to send retransmission of provisional response.");
                            });
                        }
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Accepted:
                    // While in the "Accepted" state, any retransmissions of the INVITE
                    // received will match this transaction state machine and will be
                    // absorbed by the machine without changing its state. These
                    // retransmissions are not passed onto the TU.
                    // https://tools.ietf.org/html/rfc6026#section-7.1
                    if (request.method === messages_1.C.INVITE) {
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Completed:
                    // Furthermore, while in the "Completed" state, if a request retransmission is
                    // received, the server SHOULD pass the response to the transport for retransmission.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.1
                    if (request.method === messages_1.C.INVITE) {
                        if (!this.lastFinalResponse) {
                            throw new Error("Last final response undefined.");
                        }
                        this.send(this.lastFinalResponse).catch(function (error) {
                            _this.logTransportError(error, "Failed to send retransmission of final response.");
                        });
                        return;
                    }
                    // If an ACK is received while the server transaction is in the "Completed" state,
                    // the server transaction MUST transition to the "Confirmed" state.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.1
                    if (request.method === messages_1.C.ACK) {
                        this.stateTransition(transaction_state_1.TransactionState.Confirmed);
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Confirmed:
                    // The purpose of the "Confirmed" state is to absorb any additional ACK messages that arrive,
                    // triggered from retransmissions of the final response.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.1
                    if (request.method === messages_1.C.INVITE || request.method === messages_1.C.ACK) {
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Terminated:
                    // For good measure absorb any additional messages that arrive (should not happen).
                    if (request.method === messages_1.C.INVITE || request.method === messages_1.C.ACK) {
                        return;
                    }
                    break;
                default:
                    throw new Error("Invalid state " + this.state);
            }
            var message = "INVITE server transaction received unexpected " + request.method + " request while in state " + this.state + ".";
            this.logger.warn(message);
            return;
        };
        /**
         * Receive responses from TU for this transaction.
         * @param statusCode - Status code of response.
         * @param response - Response.
         */
        InviteServerTransaction.prototype.receiveResponse = function (statusCode, response) {
            var _this = this;
            if (statusCode < 100 || statusCode > 699) {
                throw new Error("Invalid status code " + statusCode);
            }
            switch (this.state) {
                case transaction_state_1.TransactionState.Proceeding:
                    // The TU passes any number of provisional responses to the server
                    // transaction. So long as the server transaction is in the
                    // "Proceeding" state, each of these MUST be passed to the transport
                    // layer for transmission. They are not sent reliably by the
                    // transaction layer (they are not retransmitted by it) and do not cause
                    // a change in the state of the server transaction.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.1
                    if (statusCode >= 100 && statusCode <= 199) {
                        this.lastProvisionalResponse = response;
                        // Start the progress extension timer only for a non-100 provisional response.
                        if (statusCode > 100) {
                            this.startProgressExtensionTimer(); // FIXME: remove
                        }
                        this.send(response).catch(function (error) {
                            _this.logTransportError(error, "Failed to send 1xx response.");
                        });
                        return;
                    }
                    // If, while in the "Proceeding" state, the TU passes a 2xx response
                    // to the server transaction, the server transaction MUST pass this
                    // response to the transport layer for transmission. It is not
                    // retransmitted by the server transaction; retransmissions of 2xx
                    // responses are handled by the TU. The server transaction MUST then
                    // transition to the "Accepted" state.
                    // https://tools.ietf.org/html/rfc6026#section-8.5
                    if (statusCode >= 200 && statusCode <= 299) {
                        this.lastFinalResponse = response;
                        this.stateTransition(transaction_state_1.TransactionState.Accepted);
                        this.send(response).catch(function (error) {
                            _this.logTransportError(error, "Failed to send 2xx response.");
                        });
                        return;
                    }
                    // While in the "Proceeding" state, if the TU passes a response with
                    // status code from 300 to 699 to the server transaction, the response
                    // MUST be passed to the transport layer for transmission, and the state
                    // machine MUST enter the "Completed" state.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.1
                    if (statusCode >= 300 && statusCode <= 699) {
                        this.lastFinalResponse = response;
                        this.stateTransition(transaction_state_1.TransactionState.Completed);
                        this.send(response).catch(function (error) {
                            _this.logTransportError(error, "Failed to send non-2xx final response.");
                        });
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Accepted:
                    // While in the "Accepted" state, if the TU passes a 2xx response,
                    // the server transaction MUST pass the response to the transport layer for transmission.
                    // https://tools.ietf.org/html/rfc6026#section-8.7
                    if (statusCode >= 200 && statusCode <= 299) {
                        this.send(response).catch(function (error) {
                            _this.logTransportError(error, "Failed to send 2xx response.");
                        });
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Completed:
                    break;
                case transaction_state_1.TransactionState.Confirmed:
                    break;
                case transaction_state_1.TransactionState.Terminated:
                    break;
                default:
                    throw new Error("Invalid state " + this.state);
            }
            var message = "INVITE server transaction received unexpected " + statusCode + " response from TU while in state " + this.state + ".";
            this.logger.error(message);
            throw new Error(message);
        };
        /**
         * Retransmit the last 2xx response. This is a noop if not in the "accepted" state.
         */
        InviteServerTransaction.prototype.retransmitAcceptedResponse = function () {
            var _this = this;
            if (this.state === transaction_state_1.TransactionState.Accepted && this.lastFinalResponse) {
                this.send(this.lastFinalResponse).catch(function (error) {
                    _this.logTransportError(error, "Failed to send 2xx response.");
                });
            }
        };
        /**
         * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
         * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
         * inform the TU that a failure has occurred, and MUST remain in the current state.
         * https://tools.ietf.org/html/rfc6026#section-8.8
         */
        InviteServerTransaction.prototype.onTransportError = function (error) {
            if (this.user.onTransportError) {
                this.user.onTransportError(error);
            }
        };
        /** For logging. */
        InviteServerTransaction.prototype.typeToString = function () {
            return "INVITE server transaction";
        };
        /**
         * Execute a state transition.
         * @param newState - New state.
         */
        InviteServerTransaction.prototype.stateTransition = function (newState) {
            var _this = this;
            // Assert valid state transitions.
            var invalidStateTransition = function () {
                throw new Error("Invalid state transition from " + _this.state + " to " + newState);
            };
            switch (newState) {
                case transaction_state_1.TransactionState.Proceeding:
                    invalidStateTransition();
                    break;
                case transaction_state_1.TransactionState.Accepted:
                case transaction_state_1.TransactionState.Completed:
                    if (this.state !== transaction_state_1.TransactionState.Proceeding) {
                        invalidStateTransition();
                    }
                    break;
                case transaction_state_1.TransactionState.Confirmed:
                    if (this.state !== transaction_state_1.TransactionState.Completed) {
                        invalidStateTransition();
                    }
                    break;
                case transaction_state_1.TransactionState.Terminated:
                    if (this.state !== transaction_state_1.TransactionState.Accepted &&
                        this.state !== transaction_state_1.TransactionState.Completed &&
                        this.state !== transaction_state_1.TransactionState.Confirmed) {
                        invalidStateTransition();
                    }
                    break;
                default:
                    invalidStateTransition();
            }
            // On any state transition, stop resending provisonal responses
            this.stopProgressExtensionTimer();
            // The purpose of the "Accepted" state is to absorb retransmissions of an accepted INVITE request.
            // Any such retransmissions are absorbed entirely within the server transaction.
            // They are not passed up to the TU since any downstream UAS cores that accepted the request have
            // taken responsibility for reliability and will already retransmit their 2xx responses if necessary.
            // https://tools.ietf.org/html/rfc6026#section-8.7
            if (newState === transaction_state_1.TransactionState.Accepted) {
                this.L = setTimeout(function () { return _this.timer_L(); }, timers_1.Timers.TIMER_L);
            }
            // When the "Completed" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports.
            // Timer H determines when the server transaction abandons retransmitting the response.
            // If an ACK is received while the server transaction is in the "Completed" state,
            // the server transaction MUST transition to the "Confirmed" state.
            // https://tools.ietf.org/html/rfc3261#section-17.2.1
            if (newState === transaction_state_1.TransactionState.Completed) {
                // FIXME: Missing timer G for unreliable transports.
                this.H = setTimeout(function () { return _this.timer_H(); }, timers_1.Timers.TIMER_H);
            }
            // The purpose of the "Confirmed" state is to absorb any additional ACK messages that arrive,
            // triggered from retransmissions of the final response. When this state is entered, timer I
            // is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable
            // transports. Once timer I fires, the server MUST transition to the "Terminated" state.
            // https://tools.ietf.org/html/rfc3261#section-17.2.1
            if (newState === transaction_state_1.TransactionState.Confirmed) {
                // FIXME: This timer is not getting set correctly for unreliable transports.
                this.I = setTimeout(function () { return _this.timer_I(); }, timers_1.Timers.TIMER_I);
            }
            // Once the transaction is in the "Terminated" state, it MUST be destroyed immediately.
            // https://tools.ietf.org/html/rfc6026#section-8.7
            if (newState === transaction_state_1.TransactionState.Terminated) {
                this.dispose();
            }
            // Update state.
            this.setState(newState);
        };
        /**
         * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1
         * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
         */
        InviteServerTransaction.prototype.startProgressExtensionTimer = function () {
            var _this = this;
            // Start the progress extension timer only for the first non-100 provisional response.
            if (this.progressExtensionTimer === undefined) {
                this.progressExtensionTimer = setInterval(function () {
                    _this.logger.debug("Progress extension timer expired for INVITE server transaction " + _this.id + ".");
                    if (!_this.lastProvisionalResponse) {
                        throw new Error("Last provisional response undefined.");
                    }
                    _this.send(_this.lastProvisionalResponse).catch(function (error) {
                        _this.logTransportError(error, "Failed to send retransmission of provisional response.");
                    });
                }, timers_1.Timers.PROVISIONAL_RESPONSE_INTERVAL);
            }
        };
        /**
         * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1
         * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
         */
        InviteServerTransaction.prototype.stopProgressExtensionTimer = function () {
            if (this.progressExtensionTimer !== undefined) {
                clearInterval(this.progressExtensionTimer);
                this.progressExtensionTimer = undefined;
            }
        };
        /**
         * While in the "Proceeding" state, if the TU passes a response with status code
         * from 300 to 699 to the server transaction, the response MUST be passed to the
         * transport layer for transmission, and the state machine MUST enter the "Completed" state.
         * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for
         * reliable transports. If timer G fires, the response is passed to the transport layer once
         * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,
         * when timer G fires, the response is passed to the transport again for transmission, and
         * timer G is reset with a value that doubles, unless that value exceeds T2, in which case
         * it is reset with the value of T2.
         * https://tools.ietf.org/html/rfc3261#section-17.2.1
         */
        InviteServerTransaction.prototype.timer_G = function () {
            // TODO
        };
        /**
         * If timer H fires while in the "Completed" state, it implies that the ACK was never received.
         * In this case, the server transaction MUST transition to the "Terminated" state, and MUST
         * indicate to the TU that a transaction failure has occurred.
         * https://tools.ietf.org/html/rfc3261#section-17.2.1
         */
        InviteServerTransaction.prototype.timer_H = function () {
            this.logger.debug("Timer H expired for INVITE server transaction " + this.id + ".");
            if (this.state === transaction_state_1.TransactionState.Completed) {
                this.logger.warn("ACK to negative final response was never received, terminating transaction.");
                this.stateTransition(transaction_state_1.TransactionState.Terminated);
            }
        };
        /**
         * Once timer I fires, the server MUST transition to the "Terminated" state.
         * https://tools.ietf.org/html/rfc3261#section-17.2.1
         */
        InviteServerTransaction.prototype.timer_I = function () {
            this.logger.debug("Timer I expired for INVITE server transaction " + this.id + ".");
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        };
        /**
         * When Timer L fires and the state machine is in the "Accepted" state, the machine MUST
         * transition to the "Terminated" state. Once the transaction is in the "Terminated" state,
         * it MUST be destroyed immediately. Timer L reflects the amount of time the server
         * transaction could receive 2xx responses for retransmission from the
         * TU while it is waiting to receive an ACK.
         * https://tools.ietf.org/html/rfc6026#section-7.1
         * https://tools.ietf.org/html/rfc6026#section-8.7
         */
        InviteServerTransaction.prototype.timer_L = function () {
            this.logger.debug("Timer L expired for INVITE server transaction " + this.id + ".");
            if (this.state === transaction_state_1.TransactionState.Accepted) {
                this.stateTransition(transaction_state_1.TransactionState.Terminated);
            }
        };
        return InviteServerTransaction;
    }(server_transaction_1.ServerTransaction));
    exports.InviteServerTransaction = InviteServerTransaction;
    
    
    /***/ }),
    
    /***/ "./src/core/transactions/non-invite-client-transaction.ts":
    /*!****************************************************************!*\
      !*** ./src/core/transactions/non-invite-client-transaction.ts ***!
      \****************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var timers_1 = __webpack_require__(/*! ../timers */ "./src/core/timers.ts");
    var client_transaction_1 = __webpack_require__(/*! ./client-transaction */ "./src/core/transactions/client-transaction.ts");
    var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./src/core/transactions/transaction-state.ts");
    /**
     * Non-INVITE Client Transaction.
     * @remarks
     * Non-INVITE transactions do not make use of ACK.
     * They are simple request-response interactions.
     * https://tools.ietf.org/html/rfc3261#section-17.1.2
     * @public
     */
    var NonInviteClientTransaction = /** @class */ (function (_super) {
        tslib_1.__extends(NonInviteClientTransaction, _super);
        /**
         * Constructor
         * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
         * Then `toString` is called on the outgoing request and the message is sent via the transport.
         * After construction the transaction will be in the "calling" state and the transaction id
         * will equal the branch parameter set in the Via header of the outgoing request.
         * https://tools.ietf.org/html/rfc3261#section-17.1.2
         * @param request - The outgoing Non-INVITE request.
         * @param transport - The transport.
         * @param user - The transaction user.
         */
        function NonInviteClientTransaction(request, transport, user) {
            var _this = _super.call(this, request, transport, user, transaction_state_1.TransactionState.Trying, "sip.transaction.nict") || this;
            // FIXME: Timer E for unreliable transports not implemented.
            //
            // The "Trying" state is entered when the TU initiates a new client
            // transaction with a request.  When entering this state, the client
            // transaction SHOULD set timer F to fire in 64*T1 seconds. The request
            // MUST be passed to the transport layer for transmission.
            // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
            _this.F = setTimeout(function () { return _this.timer_F(); }, timers_1.Timers.TIMER_F);
            _this.send(request.toString()).catch(function (error) {
                _this.logTransportError(error, "Failed to send initial outgoing request.");
            });
            return _this;
        }
        /**
         * Destructor.
         */
        NonInviteClientTransaction.prototype.dispose = function () {
            if (this.F) {
                clearTimeout(this.F);
                this.F = undefined;
            }
            if (this.K) {
                clearTimeout(this.K);
                this.K = undefined;
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(NonInviteClientTransaction.prototype, "kind", {
            /** Transaction kind. Deprecated. */
            get: function () {
                return "nict";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Handler for incoming responses from the transport which match this transaction.
         * @param response - The incoming response.
         */
        NonInviteClientTransaction.prototype.receiveResponse = function (response) {
            var statusCode = response.statusCode;
            if (!statusCode || statusCode < 100 || statusCode > 699) {
                throw new Error("Invalid status code " + statusCode);
            }
            switch (this.state) {
                case transaction_state_1.TransactionState.Trying:
                    // If a provisional response is received while in the "Trying" state, the
                    // response MUST be passed to the TU, and then the client transaction
                    // SHOULD move to the "Proceeding" state.
                    // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                    if (statusCode >= 100 && statusCode <= 199) {
                        this.stateTransition(transaction_state_1.TransactionState.Proceeding);
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                    // If a final response (status codes 200-699) is received while in the
                    // "Trying" state, the response MUST be passed to the TU, and the
                    // client transaction MUST transition to the "Completed" state.
                    // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                    if (statusCode >= 200 && statusCode <= 699) {
                        this.stateTransition(transaction_state_1.TransactionState.Completed);
                        if (statusCode === 408) {
                            this.onRequestTimeout();
                            return;
                        }
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Proceeding:
                    // If a provisional response is received while in the "Proceeding" state,
                    // the response MUST be passed to the TU. (From Figure 6)
                    // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                    if (statusCode >= 100 && statusCode <= 199) {
                        if (this.user.receiveResponse) {
                            return this.user.receiveResponse(response);
                        }
                    }
                    // If a final response (status codes 200-699) is received while in the
                    // "Proceeding" state, the response MUST be passed to the TU, and the
                    // client transaction MUST transition to the "Completed" state.
                    // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                    if (statusCode >= 200 && statusCode <= 699) {
                        this.stateTransition(transaction_state_1.TransactionState.Completed);
                        if (statusCode === 408) {
                            this.onRequestTimeout();
                            return;
                        }
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                case transaction_state_1.TransactionState.Completed:
                    // The "Completed" state exists to buffer any additional response
                    // retransmissions that may be received (which is why the client
                    // transaction remains there only for unreliable transports).
                    // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                    return;
                case transaction_state_1.TransactionState.Terminated:
                    // For good measure just absorb additional response retransmissions.
                    return;
                default:
                    throw new Error("Invalid state " + this.state);
            }
            var message = "Non-INVITE client transaction received unexpected " + statusCode + " response while in state " + this.state + ".";
            this.logger.warn(message);
            return;
        };
        /**
         * The client transaction SHOULD inform the TU that a transport failure has occurred,
         * and the client transaction SHOULD transition directly to the "Terminated" state.
         * The TU will handle the failover mechanisms described in [4].
         * https://tools.ietf.org/html/rfc3261#section-17.1.4
         * @param error - Trasnsport error
         */
        NonInviteClientTransaction.prototype.onTransportError = function (error) {
            if (this.user.onTransportError) {
                this.user.onTransportError(error);
            }
            this.stateTransition(transaction_state_1.TransactionState.Terminated, true);
        };
        /** For logging. */
        NonInviteClientTransaction.prototype.typeToString = function () {
            return "non-INVITE client transaction";
        };
        /**
         * Execute a state transition.
         * @param newState - New state.
         */
        NonInviteClientTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
            var _this = this;
            if (dueToTransportError === void 0) { dueToTransportError = false; }
            // Assert valid state transitions.
            var invalidStateTransition = function () {
                throw new Error("Invalid state transition from " + _this.state + " to " + newState);
            };
            switch (newState) {
                case transaction_state_1.TransactionState.Trying:
                    invalidStateTransition();
                    break;
                case transaction_state_1.TransactionState.Proceeding:
                    if (this.state !== transaction_state_1.TransactionState.Trying) {
                        invalidStateTransition();
                    }
                    break;
                case transaction_state_1.TransactionState.Completed:
                    if (this.state !== transaction_state_1.TransactionState.Trying &&
                        this.state !== transaction_state_1.TransactionState.Proceeding) {
                        invalidStateTransition();
                    }
                    break;
                case transaction_state_1.TransactionState.Terminated:
                    if (this.state !== transaction_state_1.TransactionState.Trying &&
                        this.state !== transaction_state_1.TransactionState.Proceeding &&
                        this.state !== transaction_state_1.TransactionState.Completed) {
                        if (!dueToTransportError) {
                            invalidStateTransition();
                        }
                    }
                    break;
                default:
                    invalidStateTransition();
            }
            // Once the client transaction enters the "Completed" state, it MUST set
            // Timer K to fire in T4 seconds for unreliable transports, and zero
            // seconds for reliable transports  The "Completed" state exists to
            // buffer any additional response retransmissions that may be received
            // (which is why the client transaction remains there only for unreliable transports).
            // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
            if (newState === transaction_state_1.TransactionState.Completed) {
                if (this.F) {
                    clearTimeout(this.F);
                    this.F = undefined;
                }
                this.K = setTimeout(function () { return _this.timer_K(); }, timers_1.Timers.TIMER_K);
            }
            // Once the transaction is in the terminated state, it MUST be destroyed immediately.
            // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
            if (newState === transaction_state_1.TransactionState.Terminated) {
                this.dispose();
            }
            // Update state.
            this.setState(newState);
        };
        /**
         * If Timer F fires while the client transaction is still in the
         * "Trying" state, the client transaction SHOULD inform the TU about the
         * timeout, and then it SHOULD enter the "Terminated" state.
         * If timer F fires while in the "Proceeding" state, the TU MUST be informed of
         * a timeout, and the client transaction MUST transition to the terminated state.
         * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
         */
        NonInviteClientTransaction.prototype.timer_F = function () {
            this.logger.debug("Timer F expired for non-INVITE client transaction " + this.id + ".");
            if (this.state === transaction_state_1.TransactionState.Trying || this.state === transaction_state_1.TransactionState.Proceeding) {
                this.onRequestTimeout();
                this.stateTransition(transaction_state_1.TransactionState.Terminated);
            }
        };
        /**
         * If Timer K fires while in this (COMPLETED) state, the client transaction
         * MUST transition to the "Terminated" state.
         * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
         */
        NonInviteClientTransaction.prototype.timer_K = function () {
            if (this.state === transaction_state_1.TransactionState.Completed) {
                this.stateTransition(transaction_state_1.TransactionState.Terminated);
            }
        };
        return NonInviteClientTransaction;
    }(client_transaction_1.ClientTransaction));
    exports.NonInviteClientTransaction = NonInviteClientTransaction;
    
    
    /***/ }),
    
    /***/ "./src/core/transactions/non-invite-server-transaction.ts":
    /*!****************************************************************!*\
      !*** ./src/core/transactions/non-invite-server-transaction.ts ***!
      \****************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var timers_1 = __webpack_require__(/*! ../timers */ "./src/core/timers.ts");
    var server_transaction_1 = __webpack_require__(/*! ./server-transaction */ "./src/core/transactions/server-transaction.ts");
    var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./src/core/transactions/transaction-state.ts");
    /**
     * Non-INVITE Server Transaction.
     * @remarks
     * https://tools.ietf.org/html/rfc3261#section-17.2.2
     * @public
     */
    var NonInviteServerTransaction = /** @class */ (function (_super) {
        tslib_1.__extends(NonInviteServerTransaction, _super);
        /**
         * Constructor.
         * After construction the transaction will be in the "trying": state and the transaction
         * `id` will equal the branch parameter set in the Via header of the incoming request.
         * https://tools.ietf.org/html/rfc3261#section-17.2.2
         * @param request - Incoming Non-INVITE request from the transport.
         * @param transport - The transport.
         * @param user - The transaction user.
         */
        function NonInviteServerTransaction(request, transport, user) {
            return _super.call(this, request, transport, user, transaction_state_1.TransactionState.Trying, "sip.transaction.nist") || this;
        }
        /**
         * Destructor.
         */
        NonInviteServerTransaction.prototype.dispose = function () {
            if (this.J) {
                clearTimeout(this.J);
                this.J = undefined;
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(NonInviteServerTransaction.prototype, "kind", {
            /** Transaction kind. Deprecated. */
            get: function () {
                return "nist";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Receive requests from transport matching this transaction.
         * @param request - Request matching this transaction.
         */
        NonInviteServerTransaction.prototype.receiveRequest = function (request) {
            var _this = this;
            switch (this.state) {
                case transaction_state_1.TransactionState.Trying:
                    // Once in the "Trying" state, any further request retransmissions are discarded.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.2
                    break;
                case transaction_state_1.TransactionState.Proceeding:
                    // If a retransmission of the request is received while in the "Proceeding" state,
                    // the most recently sent provisional response MUST be passed to the transport layer for retransmission.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.2
                    if (!this.lastResponse) {
                        throw new Error("Last response undefined.");
                    }
                    this.send(this.lastResponse).catch(function (error) {
                        _this.logTransportError(error, "Failed to send retransmission of provisional response.");
                    });
                    break;
                case transaction_state_1.TransactionState.Completed:
                    // While in the "Completed" state, the server transaction MUST pass the final response to the transport
                    // layer for retransmission whenever a retransmission of the request is received. Any other final responses
                    // passed by the TU to the server transaction MUST be discarded while in the "Completed" state.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.2
                    if (!this.lastResponse) {
                        throw new Error("Last response undefined.");
                    }
                    this.send(this.lastResponse).catch(function (error) {
                        _this.logTransportError(error, "Failed to send retransmission of final response.");
                    });
                    break;
                case transaction_state_1.TransactionState.Terminated:
                    break;
                default:
                    throw new Error("Invalid state " + this.state);
            }
        };
        /**
         * Receive responses from TU for this transaction.
         * @param statusCode - Status code of repsonse. 101-199 not allowed per RFC 4320.
         * @param response - Response to send.
         */
        NonInviteServerTransaction.prototype.receiveResponse = function (statusCode, response) {
            var _this = this;
            if (statusCode < 100 || statusCode > 699) {
                throw new Error("Invalid status code " + statusCode);
            }
            // An SIP element MUST NOT send any provisional response with a
            // Status-Code other than 100 to a non-INVITE request.
            // An SIP element MUST NOT respond to a non-INVITE request with a
            // Status-Code of 100 over any unreliable transport, such as UDP,
            // before the amount of time it takes a client transaction's Timer E to be reset to T2.
            // An SIP element MAY respond to a non-INVITE request with a
            // Status-Code of 100 over a reliable transport at any time.
            // https://tools.ietf.org/html/rfc4320#section-4.1
            if (statusCode > 100 && statusCode <= 199) {
                throw new Error("Provisional response other than 100 not allowed.");
            }
            switch (this.state) {
                case transaction_state_1.TransactionState.Trying:
                    // While in the "Trying" state, if the TU passes a provisional response
                    // to the server transaction, the server transaction MUST enter the "Proceeding" state.
                    // The response MUST be passed to the transport layer for transmission.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.2
                    this.lastResponse = response;
                    if (statusCode >= 100 && statusCode < 200) {
                        this.stateTransition(transaction_state_1.TransactionState.Proceeding);
                        this.send(response).catch(function (error) {
                            _this.logTransportError(error, "Failed to send provisional response.");
                        });
                        return;
                    }
                    if (statusCode >= 200 && statusCode <= 699) {
                        this.stateTransition(transaction_state_1.TransactionState.Completed);
                        this.send(response).catch(function (error) {
                            _this.logTransportError(error, "Failed to send final response.");
                        });
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Proceeding:
                    // Any further provisional responses that are received from the TU while
                    // in the "Proceeding" state MUST be passed to the transport layer for transmission.
                    // If the TU passes a final response (status codes 200-699) to the server while in
                    // the "Proceeding" state, the transaction MUST enter the "Completed" state, and
                    // the response MUST be passed to the transport layer for transmission.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.2
                    this.lastResponse = response;
                    if (statusCode >= 200 && statusCode <= 699) {
                        this.stateTransition(transaction_state_1.TransactionState.Completed);
                        this.send(response).catch(function (error) {
                            _this.logTransportError(error, "Failed to send final response.");
                        });
                        return;
                    }
                    break;
                case transaction_state_1.TransactionState.Completed:
                    // Any other final responses passed by the TU to the server
                    // transaction MUST be discarded while in the "Completed" state.
                    // https://tools.ietf.org/html/rfc3261#section-17.2.2
                    return;
                case transaction_state_1.TransactionState.Terminated:
                    break;
                default:
                    throw new Error("Invalid state " + this.state);
            }
            var message = "Non-INVITE server transaction received unexpected " + statusCode + " response from TU while in state " + this.state + ".";
            this.logger.error(message);
            throw new Error(message);
        };
        /**
         * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
         * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
         * inform the TU that a failure has occurred, and SHOULD transition to the terminated state.
         * https://tools.ietf.org/html/rfc3261#section-17.2.4
         */
        NonInviteServerTransaction.prototype.onTransportError = function (error) {
            if (this.user.onTransportError) {
                this.user.onTransportError(error);
            }
            this.stateTransition(transaction_state_1.TransactionState.Terminated, true);
        };
        /** For logging. */
        NonInviteServerTransaction.prototype.typeToString = function () {
            return "non-INVITE server transaction";
        };
        NonInviteServerTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
            var _this = this;
            if (dueToTransportError === void 0) { dueToTransportError = false; }
            // Assert valid state transitions.
            var invalidStateTransition = function () {
                throw new Error("Invalid state transition from " + _this.state + " to " + newState);
            };
            switch (newState) {
                case transaction_state_1.TransactionState.Trying:
                    invalidStateTransition();
                    break;
                case transaction_state_1.TransactionState.Proceeding:
                    if (this.state !== transaction_state_1.TransactionState.Trying) {
                        invalidStateTransition();
                    }
                    break;
                case transaction_state_1.TransactionState.Completed:
                    if (this.state !== transaction_state_1.TransactionState.Trying && this.state !== transaction_state_1.TransactionState.Proceeding) {
                        invalidStateTransition();
                    }
                    break;
                case transaction_state_1.TransactionState.Terminated:
                    if (this.state !== transaction_state_1.TransactionState.Proceeding && this.state !== transaction_state_1.TransactionState.Completed) {
                        if (!dueToTransportError) {
                            invalidStateTransition();
                        }
                    }
                    break;
                default:
                    invalidStateTransition();
            }
            // When the server transaction enters the "Completed" state, it MUST set Timer J to fire
            // in 64*T1 seconds for unreliable transports, and zero seconds for reliable transports.
            // https://tools.ietf.org/html/rfc3261#section-17.2.2
            if (newState === transaction_state_1.TransactionState.Completed) {
                this.J = setTimeout(function () { return _this.timer_J(); }, timers_1.Timers.TIMER_J);
            }
            // The server transaction MUST be destroyed the instant it enters the "Terminated" state.
            // https://tools.ietf.org/html/rfc3261#section-17.2.2
            if (newState === transaction_state_1.TransactionState.Terminated) {
                this.dispose();
            }
            this.setState(newState);
        };
        /**
         * The server transaction remains in this state until Timer J fires,
         * at which point it MUST transition to the "Terminated" state.
         * https://tools.ietf.org/html/rfc3261#section-17.2.2
         */
        NonInviteServerTransaction.prototype.timer_J = function () {
            this.logger.debug("Timer J expired for NON-INVITE server transaction " + this.id + ".");
            if (this.state === transaction_state_1.TransactionState.Completed) {
                this.stateTransition(transaction_state_1.TransactionState.Terminated);
            }
        };
        return NonInviteServerTransaction;
    }(server_transaction_1.ServerTransaction));
    exports.NonInviteServerTransaction = NonInviteServerTransaction;
    
    
    /***/ }),
    
    /***/ "./src/core/transactions/server-transaction.ts":
    /*!*****************************************************!*\
      !*** ./src/core/transactions/server-transaction.ts ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transaction_1 = __webpack_require__(/*! ./transaction */ "./src/core/transactions/transaction.ts");
    /**
     * Server Transaction.
     * @remarks
     * The server transaction is responsible for the delivery of requests to
     * the TU and the reliable transmission of responses.  It accomplishes
     * this through a state machine.  Server transactions are created by the
     * core when a request is received, and transaction handling is desired
     * for that request (this is not always the case).
     * https://tools.ietf.org/html/rfc3261#section-17.2
     * @public
     */
    var ServerTransaction = /** @class */ (function (_super) {
        tslib_1.__extends(ServerTransaction, _super);
        function ServerTransaction(_request, transport, user, state, loggerCategory) {
            var _this = _super.call(this, transport, user, _request.viaBranch, state, loggerCategory) || this;
            _this._request = _request;
            _this.user = user;
            return _this;
        }
        Object.defineProperty(ServerTransaction.prototype, "request", {
            /** The incoming request the transaction handling. */
            get: function () {
                return this._request;
            },
            enumerable: true,
            configurable: true
        });
        return ServerTransaction;
    }(transaction_1.Transaction));
    exports.ServerTransaction = ServerTransaction;
    
    
    /***/ }),
    
    /***/ "./src/core/transactions/transaction-state.ts":
    /*!****************************************************!*\
      !*** ./src/core/transactions/transaction-state.ts ***!
      \****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Transaction state.
     * @public
     */
    var TransactionState;
    (function (TransactionState) {
        TransactionState["Accepted"] = "Accepted";
        TransactionState["Calling"] = "Calling";
        TransactionState["Completed"] = "Completed";
        TransactionState["Confirmed"] = "Confirmed";
        TransactionState["Proceeding"] = "Proceeding";
        TransactionState["Terminated"] = "Terminated";
        TransactionState["Trying"] = "Trying";
    })(TransactionState = exports.TransactionState || (exports.TransactionState = {}));
    
    
    /***/ }),
    
    /***/ "./src/core/transactions/transaction.ts":
    /*!**********************************************!*\
      !*** ./src/core/transactions/transaction.ts ***!
      \**********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
    var exceptions_1 = __webpack_require__(/*! ../exceptions */ "./src/core/exceptions/index.ts");
    /**
     * Transaction.
     * @remarks
     * SIP is a transactional protocol: interactions between components take
     * place in a series of independent message exchanges.  Specifically, a
     * SIP transaction consists of a single request and any responses to
     * that request, which include zero or more provisional responses and
     * one or more final responses.  In the case of a transaction where the
     * request was an INVITE (known as an INVITE transaction), the
     * transaction also includes the ACK only if the final response was not
     * a 2xx response.  If the response was a 2xx, the ACK is not considered
     * part of the transaction.
     * https://tools.ietf.org/html/rfc3261#section-17
     * @public
     */
    var Transaction = /** @class */ (function (_super) {
        tslib_1.__extends(Transaction, _super);
        function Transaction(_transport, _user, _id, _state, loggerCategory) {
            var _this = _super.call(this) || this;
            _this._transport = _transport;
            _this._user = _user;
            _this._id = _id;
            _this._state = _state;
            _this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);
            _this.logger.debug("Constructing " + _this.typeToString() + " with id " + _this.id + ".");
            return _this;
        }
        /**
         * Destructor.
         * Once the transaction is in the "terminated" state, it is destroyed
         * immediately and there is no need to call `dispose`. However, if a
         * transaction needs to be ended prematurely, the transaction user may
         * do so by calling this method (for example, perhaps the UA is shutting down).
         * No state transition will occur upon calling this method, all outstanding
         * transmission timers will be cancelled, and use of the transaction after
         * calling `dispose` is undefined.
         */
        Transaction.prototype.dispose = function () {
            this.logger.debug("Destroyed " + this.typeToString() + " with id " + this.id + ".");
        };
        Object.defineProperty(Transaction.prototype, "id", {
            /** Transaction id. */
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transaction.prototype, "kind", {
            /** Transaction kind. Deprecated. */
            get: function () {
                throw new Error("Invalid kind.");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transaction.prototype, "state", {
            /** Transaction state. */
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transaction.prototype, "transport", {
            /** Transaction transport. */
            get: function () {
                return this._transport;
            },
            enumerable: true,
            configurable: true
        });
        Transaction.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
        Transaction.prototype.logTransportError = function (error, message) {
            this.logger.error(error.message);
            this.logger.error("Transport error occurred in " + this.typeToString() + " with id " + this.id + ".");
            this.logger.error(message);
        };
        /**
         * Pass message to transport for transmission. If transport fails,
         * the transaction user is notified by callback to onTransportError().
         * @returns
         * Rejects with `TransportError` if transport fails.
         */
        Transaction.prototype.send = function (message) {
            var _this = this;
            return this.transport.send(message).catch(function (error) {
                // If the transport rejects, it SHOULD reject with a TransportError.
                // But the transport may be external code, so we are careful
                // make sure we convert it to a TransportError if need be.
                if (error instanceof exceptions_1.TransportError) {
                    _this.onTransportError(error);
                    throw error;
                }
                var transportError;
                if (error && typeof error.message === "string") {
                    transportError = new exceptions_1.TransportError(error.message);
                }
                else {
                    transportError = new exceptions_1.TransportError();
                }
                _this.onTransportError(transportError);
                throw transportError;
            });
        };
        Transaction.prototype.setState = function (state) {
            this.logger.debug("State change to \"" + state + "\" on " + this.typeToString() + " with id " + this.id + ".");
            this._state = state;
            if (this._user.onStateChange) {
                this._user.onStateChange(state);
            }
            this.emit("stateChanged");
        };
        Transaction.prototype.typeToString = function () {
            return "UnknownType";
        };
        return Transaction;
    }(events_1.EventEmitter));
    exports.Transaction = Transaction;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agent-core/allowed-methods.ts":
    /*!*****************************************************!*\
      !*** ./src/core/user-agent-core/allowed-methods.ts ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    /**
     * FIXME: TODO: Should be configurable/variable.
     */
    exports.AllowedMethods = [
        messages_1.C.ACK,
        messages_1.C.BYE,
        messages_1.C.CANCEL,
        messages_1.C.INFO,
        messages_1.C.INVITE,
        messages_1.C.MESSAGE,
        messages_1.C.NOTIFY,
        messages_1.C.OPTIONS,
        messages_1.C.PRACK,
        messages_1.C.REFER,
        messages_1.C.REGISTER,
        messages_1.C.SUBSCRIBE
    ];
    
    
    /***/ }),
    
    /***/ "./src/core/user-agent-core/index.ts":
    /*!*******************************************!*\
      !*** ./src/core/user-agent-core/index.ts ***!
      \*******************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-core */ "./src/core/user-agent-core/user-agent-core.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/user-agent-core/user-agent-core.ts":
    /*!*****************************************************!*\
      !*** ./src/core/user-agent-core/user-agent-core.ts ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agents_1 = __webpack_require__(/*! ../user-agents */ "./src/core/user-agents/index.ts");
    var allowed_methods_1 = __webpack_require__(/*! ./allowed-methods */ "./src/core/user-agent-core/allowed-methods.ts");
    /**
     * This is ported from UA.C.ACCEPTED_BODY_TYPES.
     * FIXME: TODO: Should be configurable/variable.
     */
    var acceptedBodyTypes = [
        "application/sdp",
        "application/dtmf-relay"
    ];
    /**
     * User Agent Core.
     * @remarks
     * Core designates the functions specific to a particular type
     * of SIP entity, i.e., specific to either a stateful or stateless
     * proxy, a user agent or registrar.  All cores, except those for
     * the stateless proxy, are transaction users.
     * https://tools.ietf.org/html/rfc3261#section-6
     *
     * UAC Core: The set of processing functions required of a UAC that
     * reside above the transaction and transport layers.
     * https://tools.ietf.org/html/rfc3261#section-6
     *
     * UAS Core: The set of processing functions required at a UAS that
     * resides above the transaction and transport layers.
     * https://tools.ietf.org/html/rfc3261#section-6
     * @public
     */
    var UserAgentCore = /** @class */ (function () {
        /**
         * Constructor.
         * @param configuration - Configuration.
         * @param delegate - Delegate.
         */
        function UserAgentCore(configuration, delegate) {
            if (delegate === void 0) { delegate = {}; }
            /** UACs. */
            this.userAgentClients = new Map();
            /** UASs. */
            this.userAgentServers = new Map();
            this.configuration = configuration;
            this.delegate = delegate;
            this.dialogs = new Map();
            this.subscribers = new Map();
            this.logger = configuration.loggerFactory.getLogger("sip.user-agent-core");
        }
        /** Destructor. */
        UserAgentCore.prototype.dispose = function () {
            this.reset();
        };
        /** Reset. */
        UserAgentCore.prototype.reset = function () {
            this.dialogs.forEach(function (dialog) { return dialog.dispose(); });
            this.dialogs.clear();
            this.subscribers.forEach(function (subscriber) { return subscriber.dispose(); });
            this.subscribers.clear();
            this.userAgentClients.forEach(function (uac) { return uac.dispose(); });
            this.userAgentClients.clear();
            this.userAgentServers.forEach(function (uac) { return uac.dispose(); });
            this.userAgentServers.clear();
        };
        Object.defineProperty(UserAgentCore.prototype, "loggerFactory", {
            /** Logger factory. */
            get: function () {
                return this.configuration.loggerFactory;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgentCore.prototype, "transport", {
            /** Transport. */
            get: function () {
                var transport = this.configuration.transportAccessor();
                if (!transport) {
                    throw new Error("Transport undefined.");
                }
                return transport;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Send INVITE.
         * @param request - Outgoing request.
         * @param delegate - Request delegate.
         */
        UserAgentCore.prototype.invite = function (request, delegate) {
            return new user_agents_1.InviteUserAgentClient(this, request, delegate);
        };
        /**
         * Send MESSAGE.
         * @param request - Outgoing request.
         * @param delegate - Request delegate.
         */
        UserAgentCore.prototype.message = function (request, delegate) {
            return new user_agents_1.MessageUserAgentClient(this, request, delegate);
        };
        /**
         * Send PUBLISH.
         * @param request - Outgoing request.
         * @param delegate - Request delegate.
         */
        UserAgentCore.prototype.publish = function (request, delegate) {
            return new user_agents_1.PublishUserAgentClient(this, request, delegate);
        };
        /**
         * Send REGISTER.
         * @param request - Outgoing request.
         * @param delegate - Request delegate.
         */
        UserAgentCore.prototype.register = function (request, delegate) {
            return new user_agents_1.RegisterUserAgentClient(this, request, delegate);
        };
        /**
         * Send SUBSCRIBE.
         * @param request - Outgoing request.
         * @param delegate - Request delegate.
         */
        UserAgentCore.prototype.subscribe = function (request, delegate) {
            return new user_agents_1.SubscribeUserAgentClient(this, request, delegate);
        };
        /**
         * Send a request.
         * @param request - Outgoing request.
         * @param delegate - Request delegate.
         */
        UserAgentCore.prototype.request = function (request, delegate) {
            return new user_agents_1.UserAgentClient(transactions_1.NonInviteClientTransaction, this, request, delegate);
        };
        /**
         * Outgoing request message factory function.
         * @param method - Method.
         * @param requestURI - Request-URI.
         * @param fromURI - From URI.
         * @param toURI - To URI.
         * @param options - Request options.
         * @param extraHeaders - Extra headers to add.
         * @param body - Message body.
         */
        UserAgentCore.prototype.makeOutgoingRequestMessage = function (method, requestURI, fromURI, toURI, options, extraHeaders, body) {
            // default values from user agent configuration
            var callIdPrefix = this.configuration.sipjsId;
            var fromDisplayName = this.configuration.displayName;
            var forceRport = this.configuration.viaForceRport;
            var hackViaTcp = this.configuration.hackViaTcp;
            var optionTags = this.configuration.supportedOptionTags.slice();
            if (method === messages_1.C.REGISTER) {
                optionTags.push("path", "gruu");
            }
            if (method === messages_1.C.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu)) {
                optionTags.push("gruu");
            }
            var routeSet = this.configuration.routeSet;
            var userAgentString = this.configuration.userAgentHeaderFieldValue;
            var viaHost = this.configuration.viaHost;
            var defaultOptions = {
                callIdPrefix: callIdPrefix,
                forceRport: forceRport,
                fromDisplayName: fromDisplayName,
                hackViaTcp: hackViaTcp,
                optionTags: optionTags,
                routeSet: routeSet,
                userAgentString: userAgentString,
                viaHost: viaHost,
            };
            // merge provided options with default options
            var requestOptions = tslib_1.__assign(tslib_1.__assign({}, defaultOptions), options);
            return new messages_1.OutgoingRequestMessage(method, requestURI, fromURI, toURI, requestOptions, extraHeaders, body);
        };
        /**
         * Handle an incoming request message from the transport.
         * @param message - Incoming request message from transport layer.
         */
        UserAgentCore.prototype.receiveIncomingRequestFromTransport = function (message) {
            this.receiveRequestFromTransport(message);
        };
        /**
         * Handle an incoming response message from the transport.
         * @param message - Incoming response message from transport layer.
         */
        UserAgentCore.prototype.receiveIncomingResponseFromTransport = function (message) {
            this.receiveResponseFromTransport(message);
        };
        /**
         * A stateless UAS is a UAS that does not maintain transaction state.
         * It replies to requests normally, but discards any state that would
         * ordinarily be retained by a UAS after a response has been sent.  If a
         * stateless UAS receives a retransmission of a request, it regenerates
         * the response and re-sends it, just as if it were replying to the first
         * instance of the request. A UAS cannot be stateless unless the request
         * processing for that method would always result in the same response
         * if the requests are identical. This rules out stateless registrars,
         * for example.  Stateless UASs do not use a transaction layer; they
         * receive requests directly from the transport layer and send responses
         * directly to the transport layer.
         * https://tools.ietf.org/html/rfc3261#section-8.2.7
         * @param message - Incoming request message to reply to.
         * @param statusCode - Status code to reply with.
         */
        UserAgentCore.prototype.replyStateless = function (message, options) {
            var _this = this;
            var userAgent = this.configuration.userAgentHeaderFieldValue;
            var supported = this.configuration.supportedOptionTagsResponse;
            options = tslib_1.__assign(tslib_1.__assign({}, options), { userAgent: userAgent, supported: supported });
            var response = messages_1.constructOutgoingResponse(message, options);
            this.transport.send(response.message).catch(function (error) {
                // If the transport rejects, it SHOULD reject with a TransportError.
                // But the transport may be external code, so we are careful...
                if (error instanceof Error) {
                    _this.logger.error(error.message);
                }
                _this.logger.error("Transport error occurred sending stateless reply to " + message.method + " request.");
                // TODO: Currently there is no hook to provide notification that a transport error occurred
                // and throwing would result in an uncaught error (in promise), so we siliently eat the error.
                // Furthermore, silienty eating stateless reply transport errors is arguably what we want to do here.
            });
            return response;
        };
        /**
         * In Section 18.2.1, replace the last paragraph with:
         *
         * Next, the server transport attempts to match the request to a
         * server transaction.  It does so using the matching rules described
         * in Section 17.2.3.  If a matching server transaction is found, the
         * request is passed to that transaction for processing.  If no match
         * is found, the request is passed to the core, which may decide to
         * construct a new server transaction for that request.
         * https://tools.ietf.org/html/rfc6026#section-8.10
         * @param message - Incoming request message from transport layer.
         */
        UserAgentCore.prototype.receiveRequestFromTransport = function (message) {
            // When a request is received from the network by the server, it has to
            // be matched to an existing transaction.  This is accomplished in the
            // following manner.
            //
            // The branch parameter in the topmost Via header field of the request
            // is examined.  If it is present and begins with the magic cookie
            // "z9hG4bK", the request was generated by a client transaction
            // compliant to this specification.  Therefore, the branch parameter
            // will be unique across all transactions sent by that client.  The
            // request matches a transaction if:
            //
            //    1. the branch parameter in the request is equal to the one in the
            //       top Via header field of the request that created the
            //       transaction, and
            //
            //    2. the sent-by value in the top Via of the request is equal to the
            //       one in the request that created the transaction, and
            //
            //    3. the method of the request matches the one that created the
            //       transaction, except for ACK, where the method of the request
            //       that created the transaction is INVITE.
            //
            // This matching rule applies to both INVITE and non-INVITE transactions
            // alike.
            //
            //    The sent-by value is used as part of the matching process because
            //    there could be accidental or malicious duplication of branch
            //    parameters from different clients.
            // https://tools.ietf.org/html/rfc3261#section-17.2.3
            var transactionId = message.viaBranch; // FIXME: Currently only using rule 1...
            var uas = this.userAgentServers.get(transactionId);
            // When receiving an ACK that matches an existing INVITE server
            // transaction and that does not contain a branch parameter containing
            // the magic cookie defined in RFC 3261, the matching transaction MUST
            // be checked to see if it is in the "Accepted" state.  If it is, then
            // the ACK must be passed directly to the transaction user instead of
            // being absorbed by the transaction state machine.  This is necessary
            // as requests from RFC 2543 clients will not include a unique branch
            // parameter, and the mechanisms for calculating the transaction ID from
            // such a request will be the same for both INVITE and ACKs.
            // https://tools.ietf.org/html/rfc6026#section-6
            // Any ACKs received from the network while in the "Accepted" state MUST be
            // passed directly to the TU and not absorbed.
            // https://tools.ietf.org/html/rfc6026#section-7.1
            if (message.method === messages_1.C.ACK) {
                if (uas && uas.transaction.state === transactions_1.TransactionState.Accepted) {
                    if (uas instanceof user_agents_1.InviteUserAgentServer) {
                        // These are ACKs matching an INVITE server transaction.
                        // These should never happen with RFC 3261 compliant user agents
                        // (would be a broken ACK to negative final response or something)
                        // but is apparently how RFC 2543 user agents do things.
                        // We are not currently supporting this case.
                        // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).
                        this.logger.warn("Discarding out of dialog ACK after 2xx response sent on transaction " + transactionId + ".");
                        return;
                    }
                }
            }
            // The CANCEL method requests that the TU at the server side cancel a
            // pending transaction.  The TU determines the transaction to be
            // cancelled by taking the CANCEL request, and then assuming that the
            // request method is anything but CANCEL or ACK and applying the
            // transaction matching procedures of Section 17.2.3.  The matching
            // transaction is the one to be cancelled.
            // https://tools.ietf.org/html/rfc3261#section-9.2
            if (message.method === messages_1.C.CANCEL) {
                if (uas) {
                    // Regardless of the method of the original request, as long as the
                    // CANCEL matched an existing transaction, the UAS answers the CANCEL
                    // request itself with a 200 (OK) response.
                    // https://tools.ietf.org/html/rfc3261#section-9.2
                    this.replyStateless(message, { statusCode: 200 });
                    // If the transaction for the original request still exists, the behavior
                    // of the UAS on receiving a CANCEL request depends on whether it has already
                    // sent a final response for the original request. If it has, the CANCEL
                    // request has no effect on the processing of the original request, no
                    // effect on any session state, and no effect on the responses generated
                    // for the original request. If the UAS has not issued a final response
                    // for the original request, its behavior depends on the method of the
                    // original request. If the original request was an INVITE, the UAS
                    // SHOULD immediately respond to the INVITE with a 487 (Request
                    // Terminated).
                    // https://tools.ietf.org/html/rfc3261#section-9.2
                    if (uas.transaction instanceof transactions_1.InviteServerTransaction &&
                        uas.transaction.state === transactions_1.TransactionState.Proceeding) {
                        if (uas instanceof user_agents_1.InviteUserAgentServer) {
                            uas.receiveCancel(message);
                        }
                        // A CANCEL request has no impact on the processing of
                        // transactions with any other method defined in this specification.
                        // https://tools.ietf.org/html/rfc3261#section-9.2
                    }
                }
                else {
                    // If the UAS did not find a matching transaction for the CANCEL
                    // according to the procedure above, it SHOULD respond to the CANCEL
                    // with a 481 (Call Leg/Transaction Does Not Exist).
                    // https://tools.ietf.org/html/rfc3261#section-9.2
                    this.replyStateless(message, { statusCode: 481 });
                }
                return;
            }
            // If a matching server transaction is found, the request is passed to that
            // transaction for processing.
            // https://tools.ietf.org/html/rfc6026#section-8.10
            if (uas) {
                uas.transaction.receiveRequest(message);
                return;
            }
            // If no match is found, the request is passed to the core, which may decide to
            // construct a new server transaction for that request.
            // https://tools.ietf.org/html/rfc6026#section-8.10
            this.receiveRequest(message);
            return;
        };
        /**
         * UAC and UAS procedures depend strongly on two factors.  First, based
         * on whether the request or response is inside or outside of a dialog,
         * and second, based on the method of a request.  Dialogs are discussed
         * thoroughly in Section 12; they represent a peer-to-peer relationship
         * between user agents and are established by specific SIP methods, such
         * as INVITE.
         * @param message - Incoming request message.
         */
        UserAgentCore.prototype.receiveRequest = function (message) {
            // 8.2 UAS Behavior
            // UASs SHOULD process the requests in the order of the steps that
            // follow in this section (that is, starting with authentication, then
            // inspecting the method, the header fields, and so on throughout the
            // remainder of this section).
            // https://tools.ietf.org/html/rfc3261#section-8.2
            // 8.2.1 Method Inspection
            // Once a request is authenticated (or authentication is skipped), the
            // UAS MUST inspect the method of the request.  If the UAS recognizes
            // but does not support the method of a request, it MUST generate a 405
            // (Method Not Allowed) response.  Procedures for generating responses
            // are described in Section 8.2.6.  The UAS MUST also add an Allow
            // header field to the 405 (Method Not Allowed) response.  The Allow
            // header field MUST list the set of methods supported by the UAS
            // generating the message.
            // https://tools.ietf.org/html/rfc3261#section-8.2.1
            if (allowed_methods_1.AllowedMethods.indexOf(message.method) === -1) {
                var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
                this.replyStateless(message, {
                    statusCode: 405,
                    extraHeaders: [allowHeader]
                });
                return;
            }
            // 8.2.2 Header Inspection
            // https://tools.ietf.org/html/rfc3261#section-8.2.2
            if (!message.ruri) { // FIXME: A request message should always have an ruri
                throw new Error("Request-URI undefined.");
            }
            // 8.2.2.1 To and Request-URI
            // If the Request-URI uses a scheme not supported by the UAS, it SHOULD
            // reject the request with a 416 (Unsupported URI Scheme) response.
            // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
            if (message.ruri.scheme !== "sip") {
                this.replyStateless(message, { statusCode: 416 });
                return;
            }
            // 8.2.2.1 To and Request-URI
            // If the Request-URI does not identify an address that the
            // UAS is willing to accept requests for, it SHOULD reject
            // the request with a 404 (Not Found) response.
            // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
            var ruri = message.ruri;
            var ruriMatches = function (uri) {
                return !!uri && uri.user === ruri.user;
            };
            if (!ruriMatches(this.configuration.aor) &&
                !(ruriMatches(this.configuration.contact.uri) ||
                    ruriMatches(this.configuration.contact.pubGruu) ||
                    ruriMatches(this.configuration.contact.tempGruu))) {
                this.logger.warn("Request-URI does not point to us.");
                if (message.method !== messages_1.C.ACK) {
                    this.replyStateless(message, { statusCode: 404 });
                }
                return;
            }
            // 8.2.2.1 To and Request-URI
            // Other potential sources of received Request-URIs include
            // the Contact header fields of requests and responses sent by the UA
            // that establish or refresh dialogs.
            // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
            if (message.method === messages_1.C.INVITE) {
                if (!message.hasHeader("Contact")) {
                    this.replyStateless(message, {
                        statusCode: 400,
                        reasonPhrase: "Missing Contact Header"
                    });
                    return;
                }
            }
            // 8.2.2.2 Merged Requests
            // If the request has no tag in the To header field, the UAS core MUST
            // check the request against ongoing transactions.  If the From tag,
            // Call-ID, and CSeq exactly match those associated with an ongoing
            // transaction, but the request does not match that transaction (based
            // on the matching rules in Section 17.2.3), the UAS core SHOULD
            // generate a 482 (Loop Detected) response and pass it to the server
            // transaction.
            //
            //    The same request has arrived at the UAS more than once, following
            //    different paths, most likely due to forking.  The UAS processes
            //    the first such request received and responds with a 482 (Loop
            //    Detected) to the rest of them.
            // https://tools.ietf.org/html/rfc3261#section-8.2.2.2
            if (!message.toTag) {
                var transactionId = message.viaBranch;
                if (!this.userAgentServers.has(transactionId)) {
                    var mergedRequest = Array.from(this.userAgentServers.values())
                        .some(function (uas) {
                        return uas.transaction.request.fromTag === message.fromTag &&
                            uas.transaction.request.callId === message.callId &&
                            uas.transaction.request.cseq === message.cseq;
                    });
                    if (mergedRequest) {
                        this.replyStateless(message, { statusCode: 482 });
                        return;
                    }
                }
            }
            // 8.2.2.3 Require
            // https://tools.ietf.org/html/rfc3261#section-8.2.2.3
            // TODO
            // 8.2.3 Content Processing
            // https://tools.ietf.org/html/rfc3261#section-8.2.3
            // TODO
            // 8.2.4 Applying Extensions
            // https://tools.ietf.org/html/rfc3261#section-8.2.4
            // TODO
            // 8.2.5 Processing the Request
            // Assuming all of the checks in the previous subsections are passed,
            // the UAS processing becomes method-specific.
            // https://tools.ietf.org/html/rfc3261#section-8.2.5
            // The UAS will receive the request from the transaction layer.  If the
            // request has a tag in the To header field, the UAS core computes the
            // dialog identifier corresponding to the request and compares it with
            // existing dialogs.  If there is a match, this is a mid-dialog request.
            // In that case, the UAS first applies the same processing rules for
            // requests outside of a dialog, discussed in Section 8.2.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            if (message.toTag) {
                this.receiveInsideDialogRequest(message);
            }
            else {
                this.receiveOutsideDialogRequest(message);
            }
            return;
        };
        /**
         * Once a dialog has been established between two UAs, either of them
         * MAY initiate new transactions as needed within the dialog.  The UA
         * sending the request will take the UAC role for the transaction.  The
         * UA receiving the request will take the UAS role.  Note that these may
         * be different roles than the UAs held during the transaction that
         * established the dialog.
         * https://tools.ietf.org/html/rfc3261#section-12.2
         * @param message - Incoming request message.
         */
        UserAgentCore.prototype.receiveInsideDialogRequest = function (message) {
            // NOTIFY requests are matched to such SUBSCRIBE requests if they
            // contain the same "Call-ID", a "To" header field "tag" parameter that
            // matches the "From" header field "tag" parameter of the SUBSCRIBE
            // request, and the same "Event" header field.  Rules for comparisons of
            // the "Event" header fields are described in Section 8.2.1.
            // https://tools.ietf.org/html/rfc6665#section-4.4.1
            if (message.method === messages_1.C.NOTIFY) {
                var event_1 = message.parseHeader("Event");
                if (!event_1 || !event_1.event) {
                    this.replyStateless(message, { statusCode: 489 });
                    return;
                }
                // FIXME: Subscriber id should also matching on event id.
                var subscriberId = message.callId + message.toTag + event_1.event;
                var subscriber = this.subscribers.get(subscriberId);
                if (subscriber) {
                    var uas = new user_agents_1.NotifyUserAgentServer(this, message);
                    subscriber.onNotify(uas);
                    return;
                }
            }
            // Requests sent within a dialog, as any other requests, are atomic.  If
            // a particular request is accepted by the UAS, all the state changes
            // associated with it are performed.  If the request is rejected, none
            // of the state changes are performed.
            //
            //    Note that some requests, such as INVITEs, affect several pieces of
            //    state.
            //
            // The UAS will receive the request from the transaction layer.  If the
            // request has a tag in the To header field, the UAS core computes the
            // dialog identifier corresponding to the request and compares it with
            // existing dialogs.  If there is a match, this is a mid-dialog request.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            var dialogId = message.callId + message.toTag + message.fromTag;
            var dialog = this.dialogs.get(dialogId);
            if (dialog) {
                // [Sip-implementors] Reg. SIP reinvite, UPDATE and OPTIONS
                // You got the question right.
                //
                // And you got the right answer too. :-)
                //
                //   Thanks,
                //   Paul
                //
                // Robert Sparks wrote:
                // > So I've lost track of the question during the musing.
                // >
                // > I _think_ the fundamental question being asked is this:
                // >
                // > Is an endpoint required to reject (with a 481) an OPTIONS request that
                // > arrives with at to-tag but does not match any existing dialog state.
                // > (Assuming some earlier requirement hasn't forced another error code). Or
                // > is it OK if it just sends
                // > a 200 OK anyhow.
                // >
                // > My take on the collection of specs is that its _not_ ok for it to send
                // > the 200 OK anyhow and that it is required to send
                // > the 481. I base this primarily on these sentences from 11.2 in 3261:
                // >
                // >    The response to an OPTIONS is constructed using the standard rules
                // >    for a SIP response as discussed in Section 8.2.6.  The response code
                // >    chosen MUST be the same that would have been chosen had the request
                // >    been an INVITE.
                // >
                // > Did I miss the point of the question?
                // >
                // > On May 15, 2008, at 12:48 PM, Paul Kyzivat wrote:
                // >
                // >> [Including Robert in hopes of getting his insight on this.]
                // https://lists.cs.columbia.edu/pipermail/sip-implementors/2008-May/019178.html
                //
                // Requests that do not change in any way the state of a dialog may be
                // received within a dialog (for example, an OPTIONS request).  They are
                // processed as if they had been received outside the dialog.
                // https://tools.ietf.org/html/rfc3261#section-12.2.2
                if (message.method === messages_1.C.OPTIONS) {
                    var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
                    var acceptHeader = "Accept: " + acceptedBodyTypes.toString();
                    this.replyStateless(message, {
                        statusCode: 200,
                        extraHeaders: [allowHeader, acceptHeader]
                    });
                    return;
                }
                // Pass the incoming request to the dialog for further handling.
                dialog.receiveRequest(message);
                return;
            }
            // The most important behaviors of a stateless UAS are the following:
            // ...
            // o  A stateless UAS MUST ignore ACK requests.
            // ...
            // https://tools.ietf.org/html/rfc3261#section-8.2.7
            if (message.method === messages_1.C.ACK) {
                // If a final response to an INVITE was sent statelessly,
                // the corresponding ACK:
                // - will not match an existing transaction
                // - may have tag in the To header field
                // - not not match any existing dialogs
                // Absorb unmatched ACKs.
                return;
            }
            // If the request has a tag in the To header field, but the dialog
            // identifier does not match any existing dialogs, the UAS may have
            // crashed and restarted, or it may have received a request for a
            // different (possibly failed) UAS (the UASs can construct the To tags
            // so that a UAS can identify that the tag was for a UAS for which it is
            // providing recovery).  Another possibility is that the incoming
            // request has been simply mis-routed.  Based on the To tag, the UAS MAY
            // either accept or reject the request.  Accepting the request for
            // acceptable To tags provides robustness, so that dialogs can persist
            // even through crashes.  UAs wishing to support this capability must
            // take into consideration some issues such as choosing monotonically
            // increasing CSeq sequence numbers even across reboots, reconstructing
            // the route set, and accepting out-of-range RTP timestamps and sequence
            // numbers.
            //
            // If the UAS wishes to reject the request because it does not wish to
            // recreate the dialog, it MUST respond to the request with a 481
            // (Call/Transaction Does Not Exist) status code and pass that to the
            // server transaction.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            this.replyStateless(message, { statusCode: 481 });
            return;
        };
        /**
         * Assuming all of the checks in the previous subsections are passed,
         * the UAS processing becomes method-specific.
         *  https://tools.ietf.org/html/rfc3261#section-8.2.5
         * @param message - Incoming request message.
         */
        UserAgentCore.prototype.receiveOutsideDialogRequest = function (message) {
            switch (message.method) {
                case messages_1.C.ACK:
                    // Absorb stray out of dialog ACKs
                    break;
                case messages_1.C.BYE:
                    // If the BYE does not match an existing dialog, the UAS core SHOULD
                    // generate a 481 (Call/Transaction Does Not Exist) response and pass
                    // that to the server transaction. This rule means that a BYE sent
                    // without tags by a UAC will be rejected.
                    // https://tools.ietf.org/html/rfc3261#section-15.1.2
                    this.replyStateless(message, { statusCode: 481 });
                    break;
                case messages_1.C.CANCEL:
                    throw new Error("Unexpected out of dialog request method " + message.method + ".");
                    break;
                case messages_1.C.INFO:
                    // Use of the INFO method does not constitute a separate dialog usage.
                    // INFO messages are always part of, and share the fate of, an invite
                    // dialog usage [RFC5057].  INFO messages cannot be sent as part of
                    // other dialog usages, or outside an existing dialog.
                    // https://tools.ietf.org/html/rfc6086#section-1
                    this.replyStateless(message, { statusCode: 405 }); // Should never happen
                    break;
                case messages_1.C.INVITE:
                    // https://tools.ietf.org/html/rfc3261#section-13.3.1
                    {
                        var uas = new user_agents_1.InviteUserAgentServer(this, message);
                        this.delegate.onInvite ?
                            this.delegate.onInvite(uas) :
                            uas.reject();
                    }
                    break;
                case messages_1.C.MESSAGE:
                    // MESSAGE requests are discouraged inside a dialog.  Implementations
                    // are restricted from creating a usage for the purpose of carrying a
                    // sequence of MESSAGE requests (though some implementations use it that
                    // way, against the standard recommendation).
                    // https://tools.ietf.org/html/rfc5057#section-5.3
                    {
                        var uas = new user_agents_1.MessageUserAgentServer(this, message);
                        this.delegate.onMessage ?
                            this.delegate.onMessage(uas) :
                            uas.accept();
                    }
                    break;
                case messages_1.C.NOTIFY:
                    // Obsoleted by: RFC 6665
                    // If any non-SUBSCRIBE mechanisms are defined to create subscriptions,
                    // it is the responsibility of the parties defining those mechanisms to
                    // ensure that correlation of a NOTIFY message to the corresponding
                    // subscription is possible.  Designers of such mechanisms are also
                    // warned to make a distinction between sending a NOTIFY message to a
                    // subscriber who is aware of the subscription, and sending a NOTIFY
                    // message to an unsuspecting node.  The latter behavior is invalid, and
                    // MUST receive a "481 Subscription does not exist" response (unless
                    // some other 400- or 500-class error code is more applicable), as
                    // described in section 3.2.4.  In other words, knowledge of a
                    // subscription must exist in both the subscriber and the notifier to be
                    // valid, even if installed via a non-SUBSCRIBE mechanism.
                    // https://tools.ietf.org/html/rfc3265#section-3.2
                    //
                    // NOTIFY requests are sent to inform subscribers of changes in state to
                    // which the subscriber has a subscription.  Subscriptions are created
                    // using the SUBSCRIBE method.  In legacy implementations, it is
                    // possible that other means of subscription creation have been used.
                    // However, this specification does not allow the creation of
                    // subscriptions except through SUBSCRIBE requests and (for backwards-
                    // compatibility) REFER requests [RFC3515].
                    // https://tools.ietf.org/html/rfc6665#section-3.2
                    {
                        var uas = new user_agents_1.NotifyUserAgentServer(this, message);
                        this.delegate.onNotify ?
                            this.delegate.onNotify(uas) :
                            uas.reject({ statusCode: 405 });
                    }
                    break;
                case messages_1.C.OPTIONS:
                    // https://tools.ietf.org/html/rfc3261#section-11.2
                    {
                        var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
                        var acceptHeader = "Accept: " + acceptedBodyTypes.toString();
                        this.replyStateless(message, {
                            statusCode: 200,
                            extraHeaders: [allowHeader, acceptHeader]
                        });
                    }
                    break;
                case messages_1.C.REFER:
                    // https://tools.ietf.org/html/rfc3515#section-2.4.2
                    {
                        var uas = new user_agents_1.ReferUserAgentServer(this, message);
                        this.delegate.onRefer ?
                            this.delegate.onRefer(uas) :
                            uas.reject({ statusCode: 405 });
                    }
                    break;
                case messages_1.C.REGISTER:
                    // https://tools.ietf.org/html/rfc3261#section-10.3
                    {
                        var uas = new user_agents_1.RegisterUserAgentServer(this, message);
                        this.delegate.onRegister ?
                            this.delegate.onRegister(uas) :
                            uas.reject({ statusCode: 405 });
                    }
                    break;
                case messages_1.C.SUBSCRIBE:
                    // https://tools.ietf.org/html/rfc6665#section-4.2
                    {
                        var uas = new user_agents_1.SubscribeUserAgentServer(this, message);
                        this.delegate.onSubscribe ?
                            this.delegate.onSubscribe(uas) :
                            uas.reject({ statusCode: 480 });
                    }
                    break;
                default:
                    throw new Error("Unexpected out of dialog request method " + message.method + ".");
            }
            return;
        };
        /**
         * Responses are first processed by the transport layer and then passed
         * up to the transaction layer.  The transaction layer performs its
         * processing and then passes the response up to the TU.  The majority
         * of response processing in the TU is method specific.  However, there
         * are some general behaviors independent of the method.
         * https://tools.ietf.org/html/rfc3261#section-8.1.3
         * @param message - Incoming response message from transport layer.
         */
        UserAgentCore.prototype.receiveResponseFromTransport = function (message) {
            // 8.1.3.1 Transaction Layer Errors
            // https://tools.ietf.org/html/rfc3261#section-8.1.3.1
            // Handled by transaction layer callbacks.
            // 8.1.3.2 Unrecognized Responses
            // https://tools.ietf.org/html/rfc3261#section-8.1.3.1
            // TODO
            // 8.1.3.3 Vias
            // https://tools.ietf.org/html/rfc3261#section-8.1.3.3
            if (message.getHeaders("via").length > 1) {
                this.logger.warn("More than one Via header field present in the response, dropping");
                return;
            }
            // 8.1.3.4 Processing 3xx Responses
            // https://tools.ietf.org/html/rfc3261#section-8.1.3.4
            // TODO
            // 8.1.3.5 Processing 4xx Responses
            // https://tools.ietf.org/html/rfc3261#section-8.1.3.5
            // TODO
            // When the transport layer in the client receives a response, it has to
            // determine which client transaction will handle the response, so that
            // the processing of Sections 17.1.1 and 17.1.2 can take place.  The
            // branch parameter in the top Via header field is used for this
            // purpose.  A response matches a client transaction under two
            // conditions:
            //
            //    1.  If the response has the same value of the branch parameter in
            //        the top Via header field as the branch parameter in the top
            //        Via header field of the request that created the transaction.
            //
            //    2.  If the method parameter in the CSeq header field matches the
            //        method of the request that created the transaction.  The
            //        method is needed since a CANCEL request constitutes a
            //        different transaction, but shares the same value of the branch
            //        parameter.
            // https://tools.ietf.org/html/rfc3261#section-17.1.3
            var userAgentClientId = message.viaBranch + message.method;
            var userAgentClient = this.userAgentClients.get(userAgentClientId);
            // The client transport uses the matching procedures of Section
            // 17.1.3 to attempt to match the response to an existing
            // transaction.  If there is a match, the response MUST be passed to
            // that transaction.  Otherwise, any element other than a stateless
            // proxy MUST silently discard the response.
            // https://tools.ietf.org/html/rfc6026#section-8.9
            if (userAgentClient) {
                userAgentClient.transaction.receiveResponse(message);
            }
            else {
                this.logger.warn("Discarding unmatched " + message.statusCode + " response to " + message.method + " " + userAgentClientId + ".");
            }
        };
        return UserAgentCore;
    }());
    exports.UserAgentCore = UserAgentCore;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/bye-user-agent-client.ts":
    /*!*******************************************************!*\
      !*** ./src/core/user-agents/bye-user-agent-client.ts ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * BYE UAC.
     * @public
     */
    var ByeUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(ByeUserAgentClient, _super);
        function ByeUserAgentClient(dialog, delegate, options) {
            var _this = this;
            var message = dialog.createOutgoingRequestMessage(messages_1.C.BYE, options);
            _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
            dialog.dispose();
            return _this;
        }
        return ByeUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.ByeUserAgentClient = ByeUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/bye-user-agent-server.ts":
    /*!*******************************************************!*\
      !*** ./src/core/user-agents/bye-user-agent-server.ts ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * BYE UAS.
     * @public
     */
    var ByeUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(ByeUserAgentServer, _super);
        function ByeUserAgentServer(dialog, message, delegate) {
            return _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
        }
        return ByeUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.ByeUserAgentServer = ByeUserAgentServer;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/cancel-user-agent-client.ts":
    /*!**********************************************************!*\
      !*** ./src/core/user-agents/cancel-user-agent-client.ts ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * CANCEL UAC.
     * @public
     */
    var CancelUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(CancelUserAgentClient, _super);
        function CancelUserAgentClient(core, message, delegate) {
            return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
        }
        return CancelUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.CancelUserAgentClient = CancelUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/index.ts":
    /*!***************************************!*\
      !*** ./src/core/user-agents/index.ts ***!
      \***************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./bye-user-agent-client */ "./src/core/user-agents/bye-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./bye-user-agent-server */ "./src/core/user-agents/bye-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./cancel-user-agent-client */ "./src/core/user-agents/cancel-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./info-user-agent-client */ "./src/core/user-agents/info-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./info-user-agent-server */ "./src/core/user-agents/info-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./invite-user-agent-client */ "./src/core/user-agents/invite-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./invite-user-agent-server */ "./src/core/user-agents/invite-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./message-user-agent-client */ "./src/core/user-agents/message-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./message-user-agent-server */ "./src/core/user-agents/message-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./notify-user-agent-client */ "./src/core/user-agents/notify-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./notify-user-agent-server */ "./src/core/user-agents/notify-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./publish-user-agent-client */ "./src/core/user-agents/publish-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./prack-user-agent-client */ "./src/core/user-agents/prack-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./prack-user-agent-server */ "./src/core/user-agents/prack-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./re-invite-user-agent-client */ "./src/core/user-agents/re-invite-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./re-invite-user-agent-server */ "./src/core/user-agents/re-invite-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./re-subscribe-user-agent-client */ "./src/core/user-agents/re-subscribe-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./re-subscribe-user-agent-server */ "./src/core/user-agents/re-subscribe-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./refer-user-agent-client */ "./src/core/user-agents/refer-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./refer-user-agent-server */ "./src/core/user-agents/refer-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./register-user-agent-client */ "./src/core/user-agents/register-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./register-user-agent-server */ "./src/core/user-agents/register-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./subscribe-user-agent-client */ "./src/core/user-agents/subscribe-user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./subscribe-user-agent-server */ "./src/core/user-agents/subscribe-user-agent-server.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/info-user-agent-client.ts":
    /*!********************************************************!*\
      !*** ./src/core/user-agents/info-user-agent-client.ts ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * INFO UAC.
     * @public
     */
    var InfoUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(InfoUserAgentClient, _super);
        function InfoUserAgentClient(dialog, delegate, options) {
            var _this = this;
            var message = dialog.createOutgoingRequestMessage(messages_1.C.INFO, options);
            _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
            return _this;
        }
        return InfoUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.InfoUserAgentClient = InfoUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/info-user-agent-server.ts":
    /*!********************************************************!*\
      !*** ./src/core/user-agents/info-user-agent-server.ts ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * INFO UAS.
     * @public
     */
    var InfoUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(InfoUserAgentServer, _super);
        function InfoUserAgentServer(dialog, message, delegate) {
            return _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
        }
        return InfoUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.InfoUserAgentServer = InfoUserAgentServer;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/invite-user-agent-client.ts":
    /*!**********************************************************!*\
      !*** ./src/core/user-agents/invite-user-agent-client.ts ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var dialogs_1 = __webpack_require__(/*! ../dialogs */ "./src/core/dialogs/index.ts");
    var session_1 = __webpack_require__(/*! ../session */ "./src/core/session/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * INVITE UAC.
     * @remarks
     * 13 Initiating a Session
     * https://tools.ietf.org/html/rfc3261#section-13
     * 13.1 Overview
     * https://tools.ietf.org/html/rfc3261#section-13.1
     * 13.2 UAC Processing
     * https://tools.ietf.org/html/rfc3261#section-13.2
     * @public
     */
    var InviteUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(InviteUserAgentClient, _super);
        function InviteUserAgentClient(core, message, delegate) {
            var _this = _super.call(this, transactions_1.InviteClientTransaction, core, message, delegate) || this;
            _this.confirmedDialogAcks = new Map();
            _this.confirmedDialogs = new Map();
            _this.earlyDialogs = new Map();
            _this.delegate = delegate;
            return _this;
        }
        InviteUserAgentClient.prototype.dispose = function () {
            // The UAC core considers the INVITE transaction completed 64*T1 seconds
            // after the reception of the first 2xx response.  At this point all the
            // early dialogs that have not transitioned to established dialogs are
            // terminated.  Once the INVITE transaction is considered completed by
            // the UAC core, no more new 2xx responses are expected to arrive.
            //
            // If, after acknowledging any 2xx response to an INVITE, the UAC does
            // not want to continue with that dialog, then the UAC MUST terminate
            // the dialog by sending a BYE request as described in Section 15.
            // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
            this.earlyDialogs.forEach(function (earlyDialog) { return earlyDialog.dispose(); });
            this.earlyDialogs.clear();
            _super.prototype.dispose.call(this);
        };
        /**
         * Special case for transport error while sending ACK.
         * @param error - Transport error
         */
        InviteUserAgentClient.prototype.onTransportError = function (error) {
            if (this.transaction.state === transactions_1.TransactionState.Calling) {
                return _super.prototype.onTransportError.call(this, error);
            }
            // If not in 'calling' state, the transport error occurred while sending an ACK.
            this.logger.error(error.message);
            this.logger.error("User agent client request transport error while sending ACK.");
        };
        /**
         * Once the INVITE has been passed to the INVITE client transaction, the
         * UAC waits for responses for the INVITE.
         * https://tools.ietf.org/html/rfc3261#section-13.2.2
         * @param incomingResponse - Incoming response to INVITE request.
         */
        InviteUserAgentClient.prototype.receiveResponse = function (message) {
            var _this = this;
            if (!this.authenticationGuard(message)) {
                return;
            }
            var statusCode = message.statusCode ? message.statusCode.toString() : "";
            if (!statusCode) {
                throw new Error("Response status code undefined.");
            }
            switch (true) {
                case /^100$/.test(statusCode):
                    if (this.delegate && this.delegate.onTrying) {
                        this.delegate.onTrying({ message: message });
                    }
                    return;
                case /^1[0-9]{2}$/.test(statusCode):
                    // Zero, one or multiple provisional responses may arrive before one or
                    // more final responses are received.  Provisional responses for an
                    // INVITE request can create "early dialogs".  If a provisional response
                    // has a tag in the To field, and if the dialog ID of the response does
                    // not match an existing dialog, one is constructed using the procedures
                    // defined in Section 12.1.2.
                    //
                    // The early dialog will only be needed if the UAC needs to send a
                    // request to its peer within the dialog before the initial INVITE
                    // transaction completes.  Header fields present in a provisional
                    // response are applicable as long as the dialog is in the early state
                    // (for example, an Allow header field in a provisional response
                    // contains the methods that can be used in the dialog while this is in
                    // the early state).
                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.1
                    {
                        // Provisional without to tag, no dialog to create.
                        if (!message.toTag) {
                            this.logger.warn("Non-100 1xx INVITE response received without a to tag, dropping.");
                            return;
                        }
                        // Compute dialog state.
                        var dialogState = dialogs_1.Dialog.initialDialogStateForUserAgentClient(this.message, message);
                        // Have existing early dialog or create a new one.
                        var earlyDialog = this.earlyDialogs.get(dialogState.id);
                        if (!earlyDialog) {
                            var transaction = this.transaction;
                            if (!(transaction instanceof transactions_1.InviteClientTransaction)) {
                                throw new Error("Transaction not instance of InviteClientTransaction.");
                            }
                            earlyDialog = new dialogs_1.SessionDialog(transaction, this.core, dialogState);
                            this.earlyDialogs.set(earlyDialog.id, earlyDialog);
                        }
                        // Guard against out of order reliable provisional responses.
                        // Note that this is where the rseq tracking is done.
                        if (!earlyDialog.reliableSequenceGuard(message)) {
                            this.logger.warn("1xx INVITE reliable response received out of order, dropping.");
                            return;
                        }
                        // If the initial offer is in an INVITE, the answer MUST be in a
                        // reliable non-failure message from UAS back to UAC which is
                        // correlated to that INVITE.  For this specification, that is
                        // only the final 2xx response to that INVITE.  That same exact
                        // answer MAY also be placed in any provisional responses sent
                        // prior to the answer.  The UAC MUST treat the first session
                        // description it receives as the answer, and MUST ignore any
                        // session descriptions in subsequent responses to the initial
                        // INVITE.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.1
                        if (earlyDialog.signalingState === session_1.SignalingState.Initial ||
                            earlyDialog.signalingState === session_1.SignalingState.HaveLocalOffer) {
                            earlyDialog.signalingStateTransition(message);
                        }
                        // Pass response to delegate.
                        var session_2 = earlyDialog;
                        if (this.delegate && this.delegate.onProgress) {
                            this.delegate.onProgress({
                                message: message,
                                session: session_2,
                                prack: function (options) {
                                    var outgoingPrackRequest = session_2.prack(undefined, options);
                                    return outgoingPrackRequest;
                                }
                            });
                        }
                    }
                    return;
                case /^2[0-9]{2}$/.test(statusCode):
                    // Multiple 2xx responses may arrive at the UAC for a single INVITE
                    // request due to a forking proxy.  Each response is distinguished by
                    // the tag parameter in the To header field, and each represents a
                    // distinct dialog, with a distinct dialog identifier.
                    //
                    // If the dialog identifier in the 2xx response matches the dialog
                    // identifier of an existing dialog, the dialog MUST be transitioned to
                    // the "confirmed" state, and the route set for the dialog MUST be
                    // recomputed based on the 2xx response using the procedures of Section
                    // 12.2.1.2.  Otherwise, a new dialog in the "confirmed" state MUST be
                    // constructed using the procedures of Section 12.1.2.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                    {
                        // Compute dialog state.
                        var dialogState = dialogs_1.Dialog.initialDialogStateForUserAgentClient(this.message, message);
                        // NOTE: Currently our transaction layer is caching the 2xx ACKs and
                        // handling retransmissions of the ACK which is an approach which is
                        // not to spec. In any event, this block is intended to provide a to
                        // spec implementation of ACK retransmissions, but it should not be
                        // hit currently.
                        var dialog = this.confirmedDialogs.get(dialogState.id);
                        if (dialog) {
                            // Once the ACK has been constructed, the procedures of [4] are used to
                            // determine the destination address, port and transport.  However, the
                            // request is passed to the transport layer directly for transmission,
                            // rather than a client transaction.  This is because the UAC core
                            // handles retransmissions of the ACK, not the transaction layer.  The
                            // ACK MUST be passed to the client transport every time a
                            // retransmission of the 2xx final response that triggered the ACK
                            // arrives.
                            // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                            var outgoingAckRequest = this.confirmedDialogAcks.get(dialogState.id);
                            if (outgoingAckRequest) {
                                var transaction = this.transaction;
                                if (!(transaction instanceof transactions_1.InviteClientTransaction)) {
                                    throw new Error("Client transaction not instance of InviteClientTransaction.");
                                }
                                transaction.ackResponse(outgoingAckRequest.message);
                            }
                            else {
                                // If still waiting for an ACK, drop the retransmission of the 2xx final response.
                            }
                            return;
                        }
                        // If the dialog identifier in the 2xx response matches the dialog
                        // identifier of an existing dialog, the dialog MUST be transitioned to
                        // the "confirmed" state, and the route set for the dialog MUST be
                        // recomputed based on the 2xx response using the procedures of Section
                        // 12.2.1.2. Otherwise, a new dialog in the "confirmed" state MUST be
                        // constructed using the procedures of Section 12.1.2.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                        dialog = this.earlyDialogs.get(dialogState.id);
                        if (dialog) {
                            dialog.confirm();
                            dialog.recomputeRouteSet(message);
                            this.earlyDialogs.delete(dialog.id);
                            this.confirmedDialogs.set(dialog.id, dialog);
                        }
                        else {
                            var transaction = this.transaction;
                            if (!(transaction instanceof transactions_1.InviteClientTransaction)) {
                                throw new Error("Transaction not instance of InviteClientTransaction.");
                            }
                            dialog = new dialogs_1.SessionDialog(transaction, this.core, dialogState);
                            this.confirmedDialogs.set(dialog.id, dialog);
                        }
                        // If the initial offer is in an INVITE, the answer MUST be in a
                        // reliable non-failure message from UAS back to UAC which is
                        // correlated to that INVITE.  For this specification, that is
                        // only the final 2xx response to that INVITE.  That same exact
                        // answer MAY also be placed in any provisional responses sent
                        // prior to the answer.  The UAC MUST treat the first session
                        // description it receives as the answer, and MUST ignore any
                        // session descriptions in subsequent responses to the initial
                        // INVITE.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.1
                        if (dialog.signalingState === session_1.SignalingState.Initial ||
                            dialog.signalingState === session_1.SignalingState.HaveLocalOffer) {
                            dialog.signalingStateTransition(message);
                        }
                        // Session Initiated! :)
                        var session_3 = dialog;
                        // The UAC core MUST generate an ACK request for each 2xx received from
                        // the transaction layer.  The header fields of the ACK are constructed
                        // in the same way as for any request sent within a dialog (see Section
                        // 12) with the exception of the CSeq and the header fields related to
                        // authentication.  The sequence number of the CSeq header field MUST be
                        // the same as the INVITE being acknowledged, but the CSeq method MUST
                        // be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
                        // the 2xx contains an offer (based on the rules above), the ACK MUST
                        // carry an answer in its body.  If the offer in the 2xx response is not
                        // acceptable, the UAC core MUST generate a valid answer in the ACK and
                        // then send a BYE immediately.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                        if (this.delegate && this.delegate.onAccept) {
                            this.delegate.onAccept({
                                message: message,
                                session: session_3,
                                ack: function (options) {
                                    var outgoingAckRequest = session_3.ack(options);
                                    _this.confirmedDialogAcks.set(session_3.id, outgoingAckRequest);
                                    return outgoingAckRequest;
                                }
                            });
                        }
                        else {
                            var outgoingAckRequest = session_3.ack();
                            this.confirmedDialogAcks.set(session_3.id, outgoingAckRequest);
                        }
                    }
                    return;
                case /^3[0-9]{2}$/.test(statusCode):
                    // 12.3 Termination of a Dialog
                    //
                    // Independent of the method, if a request outside of a dialog generates
                    // a non-2xx final response, any early dialogs created through
                    // provisional responses to that request are terminated.  The mechanism
                    // for terminating confirmed dialogs is method specific.  In this
                    // specification, the BYE method terminates a session and the dialog
                    // associated with it.  See Section 15 for details.
                    // https://tools.ietf.org/html/rfc3261#section-12.3
                    // All early dialogs are considered terminated upon reception of the
                    // non-2xx final response.
                    //
                    // After having received the non-2xx final response the UAC core
                    // considers the INVITE transaction completed.  The INVITE client
                    // transaction handles the generation of ACKs for the response (see
                    // Section 17).
                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
                    this.earlyDialogs.forEach(function (earlyDialog) { return earlyDialog.dispose(); });
                    this.earlyDialogs.clear();
                    // A 3xx response may contain one or more Contact header field values
                    // providing new addresses where the callee might be reachable.
                    // Depending on the status code of the 3xx response (see Section 21.3),
                    // the UAC MAY choose to try those new addresses.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.2
                    if (this.delegate && this.delegate.onRedirect) {
                        this.delegate.onRedirect({ message: message });
                    }
                    return;
                case /^[4-6][0-9]{2}$/.test(statusCode):
                    // 12.3 Termination of a Dialog
                    //
                    // Independent of the method, if a request outside of a dialog generates
                    // a non-2xx final response, any early dialogs created through
                    // provisional responses to that request are terminated.  The mechanism
                    // for terminating confirmed dialogs is method specific.  In this
                    // specification, the BYE method terminates a session and the dialog
                    // associated with it.  See Section 15 for details.
                    // https://tools.ietf.org/html/rfc3261#section-12.3
                    // All early dialogs are considered terminated upon reception of the
                    // non-2xx final response.
                    //
                    // After having received the non-2xx final response the UAC core
                    // considers the INVITE transaction completed.  The INVITE client
                    // transaction handles the generation of ACKs for the response (see
                    // Section 17).
                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
                    this.earlyDialogs.forEach(function (earlyDialog) { return earlyDialog.dispose(); });
                    this.earlyDialogs.clear();
                    // A single non-2xx final response may be received for the INVITE.  4xx,
                    // 5xx and 6xx responses may contain a Contact header field value
                    // indicating the location where additional information about the error
                    // can be found.  Subsequent final responses (which would only arrive
                    // under error conditions) MUST be ignored.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
                    if (this.delegate && this.delegate.onReject) {
                        this.delegate.onReject({ message: message });
                    }
                    return;
                default:
                    throw new Error("Invalid status code " + statusCode);
            }
            throw new Error("Executing what should be an unreachable code path receiving " + statusCode + " response.");
        };
        return InviteUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.InviteUserAgentClient = InviteUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/invite-user-agent-server.ts":
    /*!**********************************************************!*\
      !*** ./src/core/user-agents/invite-user-agent-server.ts ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var dialogs_1 = __webpack_require__(/*! ../dialogs */ "./src/core/dialogs/index.ts");
    var exceptions_1 = __webpack_require__(/*! ../exceptions */ "./src/core/exceptions/index.ts");
    var session_1 = __webpack_require__(/*! ../session */ "./src/core/session/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var allowed_methods_1 = __webpack_require__(/*! ../user-agent-core/allowed-methods */ "./src/core/user-agent-core/allowed-methods.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * INVITE UAS.
     * @remarks
     * 13 Initiating a Session
     * https://tools.ietf.org/html/rfc3261#section-13
     * 13.1 Overview
     * https://tools.ietf.org/html/rfc3261#section-13.1
     * 13.3 UAS Processing
     * https://tools.ietf.org/html/rfc3261#section-13.3
     * @public
     */
    var InviteUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(InviteUserAgentServer, _super);
        function InviteUserAgentServer(core, message, delegate) {
            var _this = _super.call(this, transactions_1.InviteServerTransaction, core, message, delegate) || this;
            _this.core = core;
            return _this;
        }
        InviteUserAgentServer.prototype.dispose = function () {
            if (this.earlyDialog) {
                this.earlyDialog.dispose();
            }
            _super.prototype.dispose.call(this);
        };
        /**
         * 13.3.1.4 The INVITE is Accepted
         * The UAS core generates a 2xx response.  This response establishes a
         * dialog, and therefore follows the procedures of Section 12.1.1 in
         * addition to those of Section 8.2.6.
         * https://tools.ietf.org/html/rfc3261#section-13.3.1.4
         * @param options - Accept options bucket.
         */
        InviteUserAgentServer.prototype.accept = function (options) {
            if (options === void 0) { options = { statusCode: 200 }; }
            if (!this.acceptable) {
                throw new exceptions_1.TransactionStateError(this.message.method + " not acceptable in state " + this.transaction.state + ".");
            }
            // This response establishes a dialog...
            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
            if (!this.confirmedDialog) {
                if (this.earlyDialog) {
                    this.earlyDialog.confirm();
                    this.confirmedDialog = this.earlyDialog;
                    this.earlyDialog = undefined;
                }
                else {
                    var transaction = this.transaction;
                    if (!(transaction instanceof transactions_1.InviteServerTransaction)) {
                        throw new Error("Transaction not instance of InviteClientTransaction.");
                    }
                    var state = dialogs_1.Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag);
                    this.confirmedDialog = new dialogs_1.SessionDialog(transaction, this.core, state);
                }
            }
            // When a UAS responds to a request with a response that establishes a
            // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
            // header field values from the request into the response (including the
            // URIs, URI parameters, and any Record-Route header field parameters,
            // whether they are known or unknown to the UAS) and MUST maintain the
            // order of those values.  The UAS MUST add a Contact header field to
            // the response.  The Contact header field contains an address where the
            // UAS would like to be contacted for subsequent requests in the dialog
            // (which includes the ACK for a 2xx response in the case of an INVITE).
            // Generally, the host portion of this URI is the IP address or FQDN of
            // the host.  The URI provided in the Contact header field MUST be a SIP
            // or SIPS URI.  If the request that initiated the dialog contained a
            // SIPS URI in the Request-URI or in the top Record-Route header field
            // value, if there was any, or the Contact header field if there was no
            // Record-Route header field, the Contact header field in the response
            // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the
            // same URI can be used in messages outside this dialog).  The same way,
            // the scope of the URI in the Contact header field of the INVITE is not
            // limited to this dialog either.  It can therefore be used in messages
            // to the UAC even outside this dialog.
            // https://tools.ietf.org/html/rfc3261#section-12.1.1
            var recordRouteHeader = this.message
                .getHeaders("record-route")
                .map(function (header) { return "Record-Route: " + header; });
            var contactHeader = "Contact: " + this.core.configuration.contact.toString();
            // A 2xx response to an INVITE SHOULD contain the Allow header field and
            // the Supported header field, and MAY contain the Accept header field.
            // Including these header fields allows the UAC to determine the
            // features and extensions supported by the UAS for the duration of the
            // call, without probing.
            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
            // FIXME: TODO: This should not be hard coded.
            var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
            // FIXME: TODO: Supported header (see reply())
            // FIXME: TODO: Accept header
            // If the INVITE request contained an offer, and the UAS had not yet
            // sent an answer, the 2xx MUST contain an answer.  If the INVITE did
            // not contain an offer, the 2xx MUST contain an offer if the UAS had
            // not yet sent an offer.
            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
            if (!options.body) {
                if (this.confirmedDialog.signalingState === session_1.SignalingState.Stable) {
                    options.body = this.confirmedDialog.answer; // resend the answer sent in provisional response
                }
                else if (this.confirmedDialog.signalingState === session_1.SignalingState.Initial ||
                    this.confirmedDialog.signalingState === session_1.SignalingState.HaveRemoteOffer) {
                    throw new Error("Response must have a body.");
                }
            }
            options.statusCode = options.statusCode || 200;
            options.extraHeaders = options.extraHeaders || [];
            options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
            options.extraHeaders.push(allowHeader);
            options.extraHeaders.push(contactHeader);
            var response = _super.prototype.accept.call(this, options);
            var session = this.confirmedDialog;
            var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
            // Update dialog signaling state
            if (options.body) {
                // Once the UAS has sent or received an answer to the initial
                // offer, it MUST NOT generate subsequent offers in any responses
                // to the initial INVITE.  This means that a UAS based on this
                // specification alone can never generate subsequent offers until
                // completion of the initial transaction.
                // https://tools.ietf.org/html/rfc3261#section-13.2.1
                if (this.confirmedDialog.signalingState !== session_1.SignalingState.Stable) {
                    this.confirmedDialog.signalingStateTransition(options.body);
                }
            }
            return result;
        };
        /**
         * 13.3.1.1 Progress
         * If the UAS is not able to answer the invitation immediately, it can
         * choose to indicate some kind of progress to the UAC (for example, an
         * indication that a phone is ringing).  This is accomplished with a
         * provisional response between 101 and 199.  These provisional
         * responses establish early dialogs and therefore follow the procedures
         * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY
         * send as many provisional responses as it likes.  Each of these MUST
         * indicate the same dialog ID.  However, these will not be delivered
         * reliably.
         *
         * If the UAS desires an extended period of time to answer the INVITE,
         * it will need to ask for an "extension" in order to prevent proxies
         * from canceling the transaction.  A proxy has the option of canceling
         * a transaction when there is a gap of 3 minutes between responses in a
         * transaction.  To prevent cancellation, the UAS MUST send a non-100
         * provisional response at every minute, to handle the possibility of
         * lost provisional responses.
         * https://tools.ietf.org/html/rfc3261#section-13.3.1.1
         * @param options - Progress options bucket.
         */
        InviteUserAgentServer.prototype.progress = function (options) {
            if (options === void 0) { options = { statusCode: 180 }; }
            if (!this.progressable) {
                throw new exceptions_1.TransactionStateError(this.message.method + " not progressable in state " + this.transaction.state + ".");
            }
            // This response establishes a dialog...
            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
            if (!this.earlyDialog) {
                var transaction = this.transaction;
                if (!(transaction instanceof transactions_1.InviteServerTransaction)) {
                    throw new Error("Transaction not instance of InviteClientTransaction.");
                }
                var state = dialogs_1.Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag, true);
                this.earlyDialog = new dialogs_1.SessionDialog(transaction, this.core, state);
            }
            // When a UAS responds to a request with a response that establishes a
            // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
            // header field values from the request into the response (including the
            // URIs, URI parameters, and any Record-Route header field parameters,
            // whether they are known or unknown to the UAS) and MUST maintain the
            // order of those values.  The UAS MUST add a Contact header field to
            // the response.  The Contact header field contains an address where the
            // UAS would like to be contacted for subsequent requests in the dialog
            // (which includes the ACK for a 2xx response in the case of an INVITE).
            // Generally, the host portion of this URI is the IP address or FQDN of
            // the host.  The URI provided in the Contact header field MUST be a SIP
            // or SIPS URI.  If the request that initiated the dialog contained a
            // SIPS URI in the Request-URI or in the top Record-Route header field
            // value, if there was any, or the Contact header field if there was no
            // Record-Route header field, the Contact header field in the response
            // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the
            // same URI can be used in messages outside this dialog).  The same way,
            // the scope of the URI in the Contact header field of the INVITE is not
            // limited to this dialog either.  It can therefore be used in messages
            // to the UAC even outside this dialog.
            // https://tools.ietf.org/html/rfc3261#section-12.1.1
            var recordRouteHeader = this.message
                .getHeaders("record-route")
                .map(function (header) { return "Record-Route: " + header; });
            var contactHeader = "Contact: " + this.core.configuration.contact;
            options.extraHeaders = options.extraHeaders || [];
            options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
            options.extraHeaders.push(contactHeader);
            var response = _super.prototype.progress.call(this, options);
            var session = this.earlyDialog;
            var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
            // Update dialog signaling state
            if (options.body) {
                // Once the UAS has sent or received an answer to the initial
                // offer, it MUST NOT generate subsequent offers in any responses
                // to the initial INVITE.  This means that a UAS based on this
                // specification alone can never generate subsequent offers until
                // completion of the initial transaction.
                // https://tools.ietf.org/html/rfc3261#section-13.2.1
                if (this.earlyDialog.signalingState !== session_1.SignalingState.Stable) {
                    this.earlyDialog.signalingStateTransition(options.body);
                }
            }
            return result;
        };
        /**
         * 13.3.1.2 The INVITE is Redirected
         * If the UAS decides to redirect the call, a 3xx response is sent.  A
         * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved
         * Temporarily) response SHOULD contain a Contact header field
         * containing one or more URIs of new addresses to be tried.  The
         * response is passed to the INVITE server transaction, which will deal
         * with its retransmissions.
         * https://tools.ietf.org/html/rfc3261#section-13.3.1.2
         * @param contacts - Contacts to redirect to.
         * @param options - Redirect options bucket.
         */
        InviteUserAgentServer.prototype.redirect = function (contacts, options) {
            if (options === void 0) { options = { statusCode: 302 }; }
            return _super.prototype.redirect.call(this, contacts, options);
        };
        /**
         * 13.3.1.3 The INVITE is Rejected
         * A common scenario occurs when the callee is currently not willing or
         * able to take additional calls at this end system.  A 486 (Busy Here)
         * SHOULD be returned in such a scenario.
         * https://tools.ietf.org/html/rfc3261#section-13.3.1.3
         * @param options - Reject options bucket.
         */
        InviteUserAgentServer.prototype.reject = function (options) {
            if (options === void 0) { options = { statusCode: 486 }; }
            return _super.prototype.reject.call(this, options);
        };
        return InviteUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.InviteUserAgentServer = InviteUserAgentServer;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/message-user-agent-client.ts":
    /*!***********************************************************!*\
      !*** ./src/core/user-agents/message-user-agent-client.ts ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * MESSAGE UAS.
     * @public
     */
    var MessageUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(MessageUserAgentClient, _super);
        function MessageUserAgentClient(core, message, delegate) {
            return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
        }
        return MessageUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.MessageUserAgentClient = MessageUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/message-user-agent-server.ts":
    /*!***********************************************************!*\
      !*** ./src/core/user-agents/message-user-agent-server.ts ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * MESSAGE UAS.
     * @public
     */
    var MessageUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(MessageUserAgentServer, _super);
        function MessageUserAgentServer(core, message, delegate) {
            var _this = _super.call(this, transactions_1.NonInviteServerTransaction, core, message, delegate) || this;
            _this.core = core;
            return _this;
        }
        return MessageUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.MessageUserAgentServer = MessageUserAgentServer;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/notify-user-agent-client.ts":
    /*!**********************************************************!*\
      !*** ./src/core/user-agents/notify-user-agent-client.ts ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * NOTIFY UAS.
     * @public
     */
    var NotifyUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(NotifyUserAgentClient, _super);
        function NotifyUserAgentClient(dialog, delegate, options) {
            var _this = this;
            var message = dialog.createOutgoingRequestMessage(messages_1.C.NOTIFY, options);
            _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
            return _this;
        }
        return NotifyUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.NotifyUserAgentClient = NotifyUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/notify-user-agent-server.ts":
    /*!**********************************************************!*\
      !*** ./src/core/user-agents/notify-user-agent-server.ts ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * NOTIFY UAS.
     * @public
     */
    var NotifyUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(NotifyUserAgentServer, _super);
        /**
         * NOTIFY UAS constructor.
         * @param dialogOrCore - Dialog for in dialog NOTIFY, UserAgentCore for out of dialog NOTIFY (deprecated).
         * @param message - Incoming NOTIFY request message.
         */
        function NotifyUserAgentServer(dialogOrCore, message, delegate) {
            var _this = this;
            var userAgentCore = instanceOfDialog(dialogOrCore) ?
                dialogOrCore.userAgentCore :
                dialogOrCore;
            _this = _super.call(this, transactions_1.NonInviteServerTransaction, userAgentCore, message, delegate) || this;
            return _this;
        }
        return NotifyUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.NotifyUserAgentServer = NotifyUserAgentServer;
    function instanceOfDialog(object) {
        return object.userAgentCore !== undefined;
    }
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/prack-user-agent-client.ts":
    /*!*********************************************************!*\
      !*** ./src/core/user-agents/prack-user-agent-client.ts ***!
      \*********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * PRACK UAC.
     * @public
     */
    var PrackUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(PrackUserAgentClient, _super);
        function PrackUserAgentClient(dialog, delegate, options) {
            var _this = this;
            var message = dialog.createOutgoingRequestMessage(messages_1.C.PRACK, options);
            _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
            dialog.signalingStateTransition(message);
            return _this;
        }
        return PrackUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.PrackUserAgentClient = PrackUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/prack-user-agent-server.ts":
    /*!*********************************************************!*\
      !*** ./src/core/user-agents/prack-user-agent-server.ts ***!
      \*********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * PRACK UAS.
     * @public
     */
    var PrackUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(PrackUserAgentServer, _super);
        function PrackUserAgentServer(dialog, message, delegate) {
            var _this = _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
            // Update dialog signaling state with offer/answer in body
            dialog.signalingStateTransition(message);
            _this.dialog = dialog;
            return _this;
        }
        /**
         * Update the dialog signaling state on a 2xx response.
         * @param options - Options bucket.
         */
        PrackUserAgentServer.prototype.accept = function (options) {
            if (options === void 0) { options = { statusCode: 200 }; }
            if (options.body) {
                // Update dialog signaling state with offer/answer in body
                this.dialog.signalingStateTransition(options.body);
            }
            return _super.prototype.accept.call(this, options);
        };
        return PrackUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.PrackUserAgentServer = PrackUserAgentServer;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/publish-user-agent-client.ts":
    /*!***********************************************************!*\
      !*** ./src/core/user-agents/publish-user-agent-client.ts ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * PUBLISH UAC.
     * @public
     */
    var PublishUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(PublishUserAgentClient, _super);
        function PublishUserAgentClient(core, message, delegate) {
            return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
        }
        return PublishUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.PublishUserAgentClient = PublishUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/re-invite-user-agent-client.ts":
    /*!*************************************************************!*\
      !*** ./src/core/user-agents/re-invite-user-agent-client.ts ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * Re-INVITE UAC.
     * @remarks
     * 14 Modifying an Existing Session
     * https://tools.ietf.org/html/rfc3261#section-14
     * 14.1 UAC Behavior
     * https://tools.ietf.org/html/rfc3261#section-14.1
     * @public
     */
    var ReInviteUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(ReInviteUserAgentClient, _super);
        function ReInviteUserAgentClient(dialog, delegate, options) {
            var _this = this;
            var message = dialog.createOutgoingRequestMessage(messages_1.C.INVITE, options);
            _this = _super.call(this, transactions_1.InviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
            _this.delegate = delegate;
            dialog.signalingStateTransition(message);
            // FIXME: TODO: next line obviously needs to be improved...
            dialog.reinviteUserAgentClient = _this; // let the dialog know re-invite request sent
            _this.dialog = dialog;
            return _this;
        }
        ReInviteUserAgentClient.prototype.receiveResponse = function (message) {
            var _this = this;
            var statusCode = message.statusCode ? message.statusCode.toString() : "";
            if (!statusCode) {
                throw new Error("Response status code undefined.");
            }
            switch (true) {
                case /^100$/.test(statusCode):
                    if (this.delegate && this.delegate.onTrying) {
                        this.delegate.onTrying({ message: message });
                    }
                    break;
                case /^1[0-9]{2}$/.test(statusCode):
                    if (this.delegate && this.delegate.onProgress) {
                        this.delegate.onProgress({
                            message: message,
                            session: this.dialog,
                            prack: function (options) {
                                throw new Error("Unimplemented.");
                            }
                        });
                    }
                    break;
                case /^2[0-9]{2}$/.test(statusCode):
                    // Update dialog signaling state with offer/answer in body
                    this.dialog.signalingStateTransition(message);
                    if (this.delegate && this.delegate.onAccept) {
                        this.delegate.onAccept({
                            message: message,
                            session: this.dialog,
                            ack: function (options) {
                                var outgoingAckRequest = _this.dialog.ack(options);
                                return outgoingAckRequest;
                            }
                        });
                    }
                    break;
                case /^3[0-9]{2}$/.test(statusCode):
                    this.dialog.signalingStateRollback();
                    this.dialog.reinviteUserAgentClient = undefined; // ACK was handled by transaction
                    if (this.delegate && this.delegate.onRedirect) {
                        this.delegate.onRedirect({ message: message });
                    }
                    break;
                case /^[4-6][0-9]{2}$/.test(statusCode):
                    this.dialog.signalingStateRollback();
                    this.dialog.reinviteUserAgentClient = undefined; // ACK was handled by transaction
                    if (this.delegate && this.delegate.onReject) {
                        this.delegate.onReject({ message: message });
                    }
                    else {
                        // If a UA receives a non-2xx final response to a re-INVITE, the session
                        // parameters MUST remain unchanged, as if no re-INVITE had been issued.
                        // Note that, as stated in Section 12.2.1.2, if the non-2xx final
                        // response is a 481 (Call/Transaction Does Not Exist), or a 408
                        // (Request Timeout), or no response at all is received for the re-
                        // INVITE (that is, a timeout is returned by the INVITE client
                        // transaction), the UAC will terminate the dialog.
                        //
                        // If a UAC receives a 491 response to a re-INVITE, it SHOULD start a
                        // timer with a value T chosen as follows:
                        //
                        //    1. If the UAC is the owner of the Call-ID of the dialog ID
                        //       (meaning it generated the value), T has a randomly chosen value
                        //       between 2.1 and 4 seconds in units of 10 ms.
                        //
                        //    2. If the UAC is not the owner of the Call-ID of the dialog ID, T
                        //       has a randomly chosen value of between 0 and 2 seconds in units
                        //       of 10 ms.
                        //
                        // When the timer fires, the UAC SHOULD attempt the re-INVITE once more,
                        // if it still desires for that session modification to take place.  For
                        // example, if the call was already hung up with a BYE, the re-INVITE
                        // would not take place.
                        // https://tools.ietf.org/html/rfc3261#section-14.1
                        // FIXME: TODO: The above.
                    }
                    break;
                default:
                    throw new Error("Invalid status code " + statusCode);
            }
        };
        return ReInviteUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.ReInviteUserAgentClient = ReInviteUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/re-invite-user-agent-server.ts":
    /*!*************************************************************!*\
      !*** ./src/core/user-agents/re-invite-user-agent-server.ts ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * Re-INVITE UAS.
     * @remarks
     * 14 Modifying an Existing Session
     * https://tools.ietf.org/html/rfc3261#section-14
     * 14.2 UAS Behavior
     * https://tools.ietf.org/html/rfc3261#section-14.2
     * @public
     */
    var ReInviteUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(ReInviteUserAgentServer, _super);
        function ReInviteUserAgentServer(dialog, message, delegate) {
            var _this = _super.call(this, transactions_1.InviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
            dialog.reinviteUserAgentServer = _this;
            _this.dialog = dialog;
            return _this;
        }
        /**
         * Update the dialog signaling state on a 2xx response.
         * @param options - Options bucket.
         */
        ReInviteUserAgentServer.prototype.accept = function (options) {
            if (options === void 0) { options = { statusCode: 200 }; }
            // FIXME: The next two lines SHOULD go away, but I suppose it's technically harmless...
            // These are here because some versions of SIP.js prior to 0.13.8 set the route set
            // of all in dialog ACKs based on the Record-Route headers in the associated 2xx
            // response. While this worked for dialog forming 2xx responses, it was technically
            // broken for re-INVITE ACKS as it only worked if the UAS populated the Record-Route
            // headers in the re-INVITE 2xx response (which is not required and a waste of bandwidth
            // as the should be ignored if present in re-INVITE ACKS) and the UAS populated
            // the Record-Route headers with the correct values (would be weird not too, but...).
            // Anyway, for now the technically useless Record-Route headers are being added
            // to maintain "backwards compatibility" with the older broken versions of SIP.js.
            options.extraHeaders = options.extraHeaders || [];
            options.extraHeaders = options.extraHeaders.concat(this.dialog.routeSet.map(function (route) { return "Record-Route: " + route; }));
            // Send and return the response
            var response = _super.prototype.accept.call(this, options);
            var session = this.dialog;
            var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
            if (options.body) {
                // Update dialog signaling state with offer/answer in body
                this.dialog.signalingStateTransition(options.body);
            }
            // Update dialog
            this.dialog.reConfirm();
            return result;
        };
        /**
         * Update the dialog signaling state on a 1xx response.
         * @param options - Progress options bucket.
         */
        ReInviteUserAgentServer.prototype.progress = function (options) {
            if (options === void 0) { options = { statusCode: 180 }; }
            // Send and return the response
            var response = _super.prototype.progress.call(this, options);
            var session = this.dialog;
            var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
            // Update dialog signaling state
            if (options.body) {
                this.dialog.signalingStateTransition(options.body);
            }
            return result;
        };
        /**
         * TODO: Not Yet Supported
         * @param contacts - Contacts to redirect to.
         * @param options - Redirect options bucket.
         */
        ReInviteUserAgentServer.prototype.redirect = function (contacts, options) {
            if (options === void 0) { options = { statusCode: 302 }; }
            this.dialog.signalingStateRollback();
            this.dialog.reinviteUserAgentServer = undefined; // ACK will be handled by transaction
            throw new Error("Unimplemented.");
        };
        /**
         * 3.1 Background on Re-INVITE Handling by UASs
         * An error response to a re-INVITE has the following semantics.  As
         * specified in Section 12.2.2 of RFC 3261 [RFC3261], if a re-INVITE is
         * rejected, no state changes are performed.
         * https://tools.ietf.org/html/rfc6141#section-3.1
         * @param options - Reject options bucket.
         */
        ReInviteUserAgentServer.prototype.reject = function (options) {
            if (options === void 0) { options = { statusCode: 488 }; }
            this.dialog.signalingStateRollback();
            this.dialog.reinviteUserAgentServer = undefined; // ACK will be handled by transaction
            return _super.prototype.reject.call(this, options);
        };
        return ReInviteUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.ReInviteUserAgentServer = ReInviteUserAgentServer;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/re-subscribe-user-agent-client.ts":
    /*!****************************************************************!*\
      !*** ./src/core/user-agents/re-subscribe-user-agent-client.ts ***!
      \****************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * Re-SUBSCRIBE UAC.
     * @public
     */
    var ReSubscribeUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(ReSubscribeUserAgentClient, _super);
        function ReSubscribeUserAgentClient(dialog, delegate, options) {
            var _this = this;
            var message = dialog.createOutgoingRequestMessage(messages_1.C.SUBSCRIBE, options);
            _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
            _this.dialog = dialog;
            return _this;
        }
        ReSubscribeUserAgentClient.prototype.waitNotifyStop = function () {
            // TODO: Placeholder. Not utilized currently.
            return;
        };
        /**
         * Receive a response from the transaction layer.
         * @param message - Incoming response message.
         */
        ReSubscribeUserAgentClient.prototype.receiveResponse = function (message) {
            if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {
                //  The "Expires" header field in a 200-class response to SUBSCRIBE
                //  request indicates the actual duration for which the subscription will
                //  remain active (unless refreshed).  The received value might be
                //  smaller than the value indicated in the SUBSCRIBE request but cannot
                //  be larger; see Section 4.2.1 for details.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                var expires = message.getHeader("Expires");
                if (!expires) {
                    this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
                }
                else {
                    var subscriptionExpiresReceived = Number(expires);
                    if (this.dialog.subscriptionExpires > subscriptionExpiresReceived) {
                        this.dialog.subscriptionExpires = subscriptionExpiresReceived;
                    }
                }
            }
            if (message.statusCode && message.statusCode >= 400 && message.statusCode < 700) {
                // If a SUBSCRIBE request to refresh a subscription receives a 404, 405,
                // 410, 416, 480-485, 489, 501, or 604 response, the subscriber MUST
                // consider the subscription terminated.  (See [RFC5057] for further
                // details and notes about the effect of error codes on dialogs and
                // usages within dialog, such as subscriptions).  If the subscriber
                // wishes to re-subscribe to the state, he does so by composing an
                // unrelated initial SUBSCRIBE request with a freshly generated Call-ID
                // and a new, unique "From" tag (see Section 4.1.2.1).
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.2
                var errorCodes = [404, 405, 410, 416, 480, 481, 482, 483, 484, 485, 489, 501, 604];
                if (errorCodes.indexOf(message.statusCode) !== -1) {
                    this.dialog.terminate();
                }
                // If a SUBSCRIBE request to refresh a subscription fails with any error
                // code other than those listed above, the original subscription is
                // still considered valid for the duration of the most recently known
                // "Expires" value as negotiated by the most recent successful SUBSCRIBE
                // transaction, or as communicated by a NOTIFY request in its
                // "Subscription-State" header field "expires" parameter.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.2
            }
            _super.prototype.receiveResponse.call(this, message);
        };
        return ReSubscribeUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.ReSubscribeUserAgentClient = ReSubscribeUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/re-subscribe-user-agent-server.ts":
    /*!****************************************************************!*\
      !*** ./src/core/user-agents/re-subscribe-user-agent-server.ts ***!
      \****************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * Re-SUBSCRIBE UAS.
     * @public
     */
    var ReSubscribeUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(ReSubscribeUserAgentServer, _super);
        function ReSubscribeUserAgentServer(dialog, message, delegate) {
            return _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
        }
        return ReSubscribeUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.ReSubscribeUserAgentServer = ReSubscribeUserAgentServer;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/refer-user-agent-client.ts":
    /*!*********************************************************!*\
      !*** ./src/core/user-agents/refer-user-agent-client.ts ***!
      \*********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * REFER UAC.
     * @public
     */
    var ReferUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(ReferUserAgentClient, _super);
        function ReferUserAgentClient(dialog, delegate, options) {
            var _this = this;
            var message = dialog.createOutgoingRequestMessage(messages_1.C.REFER, options);
            _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
            return _this;
        }
        return ReferUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.ReferUserAgentClient = ReferUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/refer-user-agent-server.ts":
    /*!*********************************************************!*\
      !*** ./src/core/user-agents/refer-user-agent-server.ts ***!
      \*********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * REFER UAS.
     * @public
     */
    var ReferUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(ReferUserAgentServer, _super);
        /**
         * REFER UAS constructor.
         * @param dialogOrCore - Dialog for in dialog REFER, UserAgentCore for out of dialog REFER.
         * @param message - Incoming REFER request message.
         */
        function ReferUserAgentServer(dialogOrCore, message, delegate) {
            var _this = this;
            var userAgentCore = instanceOfSessionDialog(dialogOrCore) ?
                dialogOrCore.userAgentCore :
                dialogOrCore;
            _this = _super.call(this, transactions_1.NonInviteServerTransaction, userAgentCore, message, delegate) || this;
            return _this;
        }
        return ReferUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.ReferUserAgentServer = ReferUserAgentServer;
    function instanceOfSessionDialog(object) {
        return object.userAgentCore !== undefined;
    }
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/register-user-agent-client.ts":
    /*!************************************************************!*\
      !*** ./src/core/user-agents/register-user-agent-client.ts ***!
      \************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * REGISTER UAC.
     * @public
     */
    var RegisterUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(RegisterUserAgentClient, _super);
        function RegisterUserAgentClient(core, message, delegate) {
            return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
        }
        return RegisterUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.RegisterUserAgentClient = RegisterUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/register-user-agent-server.ts":
    /*!************************************************************!*\
      !*** ./src/core/user-agents/register-user-agent-server.ts ***!
      \************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * REGISTER UAS.
     * @public
     */
    var RegisterUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(RegisterUserAgentServer, _super);
        function RegisterUserAgentServer(core, message, delegate) {
            var _this = _super.call(this, transactions_1.NonInviteServerTransaction, core, message, delegate) || this;
            _this.core = core;
            return _this;
        }
        return RegisterUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.RegisterUserAgentServer = RegisterUserAgentServer;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/subscribe-user-agent-client.ts":
    /*!*************************************************************!*\
      !*** ./src/core/user-agents/subscribe-user-agent-client.ts ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var subscription_dialog_1 = __webpack_require__(/*! ../dialogs/subscription-dialog */ "./src/core/dialogs/subscription-dialog.ts");
    var subscription_1 = __webpack_require__(/*! ../subscription */ "./src/core/subscription/index.ts");
    var timers_1 = __webpack_require__(/*! ../timers */ "./src/core/timers.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./src/core/user-agents/user-agent-client.ts");
    /**
     * SUBSCRIBE UAC.
     * @remarks
     * 4.1.  Subscriber Behavior
     * https://tools.ietf.org/html/rfc6665#section-4.1
     *
     * User agent client for installation of a single subscription per SUBSCRIBE request.
     * TODO: Support for installation of multiple subscriptions on forked SUBSCRIBE reqeuests.
     * @public
     */
    var SubscribeUserAgentClient = /** @class */ (function (_super) {
        tslib_1.__extends(SubscribeUserAgentClient, _super);
        function SubscribeUserAgentClient(core, message, delegate) {
            var _this = this;
            // Get event from request message.
            var event = message.getHeader("Event");
            if (!event) {
                throw new Error("Event undefined");
            }
            // Get expires from reqeust message.
            var expires = message.getHeader("Expires");
            if (!expires) {
                throw new Error("Expires undefined");
            }
            _this = _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
            _this.delegate = delegate;
            // FIXME: Subscriber id should also be matching on event id.
            _this.subscriberId = message.callId + message.fromTag + event;
            _this.subscriptionExpiresRequested = _this.subscriptionExpires = Number(expires);
            _this.subscriptionEvent = event;
            _this.subscriptionState = subscription_1.SubscriptionState.NotifyWait;
            // Start waiting for a NOTIFY we can use to create a subscription.
            _this.waitNotifyStart();
            return _this;
        }
        /**
         * Destructor.
         * Note that Timer N may live on waiting for an initial NOTIFY and
         * the delegate may still receive that NOTIFY. If you don't want
         * that behavior then either clear the delegate so the delegate
         * doesn't get called (a 200 will be sent in response to the NOTIFY)
         * or call `waitNotifyStop` which will clear Timer N and remove this
         * UAC from the core (a 481 will be sent in response to the NOTIFY).
         */
        SubscribeUserAgentClient.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        /**
         * Handle out of dialog NOTIFY assoicated with SUBSCRIBE request.
         * This is the first NOTIFY received after the SUBSCRIBE request.
         * @param uas - User agent server handling the subscription creating NOTIFY.
         */
        SubscribeUserAgentClient.prototype.onNotify = function (uas) {
            // NOTIFY requests are matched to such SUBSCRIBE requests if they
            // contain the same "Call-ID", a "To" header field "tag" parameter that
            // matches the "From" header field "tag" parameter of the SUBSCRIBE
            // request, and the same "Event" header field.  Rules for comparisons of
            // the "Event" header fields are described in Section 8.2.1.
            // https://tools.ietf.org/html/rfc6665#section-4.4.1
            var event = uas.message.parseHeader("Event").event;
            if (!event || event !== this.subscriptionEvent) {
                this.logger.warn("Failed to parse event.");
                uas.reject({ statusCode: 489 });
                return;
            }
            // NOTIFY requests MUST contain "Subscription-State" header fields that
            // indicate the status of the subscription.
            // https://tools.ietf.org/html/rfc6665#section-4.1.3
            var subscriptionState = uas.message.parseHeader("Subscription-State");
            if (!subscriptionState || !subscriptionState.state) {
                this.logger.warn("Failed to parse subscription state.");
                uas.reject({ statusCode: 489 });
                return;
            }
            // Validate subscription state.
            var state = subscriptionState.state;
            switch (state) {
                case "pending":
                    break;
                case "active":
                    break;
                case "terminated":
                    break;
                default:
                    this.logger.warn("Invalid subscription state " + state);
                    uas.reject({ statusCode: 489 });
                    return;
            }
            // Dialogs usages are created upon completion of a NOTIFY transaction
            // for a new subscription, unless the NOTIFY request contains a
            // "Subscription-State" of "terminated."
            // https://tools.ietf.org/html/rfc6665#section-4.4.1
            if (state !== "terminated") {
                // The Contact header field MUST be present and contain exactly one SIP
                // or SIPS URI in any request that can result in the establishment of a
                // dialog.
                // https://tools.ietf.org/html/rfc3261#section-8.1.1.8
                var contact = uas.message.parseHeader("contact");
                if (!contact) {
                    this.logger.warn("Failed to parse contact.");
                    uas.reject({ statusCode: 489 });
                    return;
                }
            }
            // In accordance with the rules for proxying non-INVITE requests as
            // defined in [RFC3261], successful SUBSCRIBE requests will receive only
            // one 200-class response; however, due to forking, the subscription may
            // have been accepted by multiple nodes.  The subscriber MUST therefore
            // be prepared to receive NOTIFY requests with "From:" tags that differ
            // from the "To:" tag received in the SUBSCRIBE 200-class response.
            //
            // If multiple NOTIFY requests are received in different dialogs in
            // response to a single SUBSCRIBE request, each dialog represents a
            // different destination to which the SUBSCRIBE request was forked.
            // Subscriber handling in such situations varies by event package; see
            // Section 5.4.9 for details.
            // https://tools.ietf.org/html/rfc6665#section-4.1.4
            // Each event package MUST specify whether forked SUBSCRIBE requests are
            // allowed to install multiple subscriptions.
            //
            // If such behavior is not allowed, the first potential dialog-
            // establishing message will create a dialog.  All subsequent NOTIFY
            // requests that correspond to the SUBSCRIBE request (i.e., have
            // matching "To", "From", "Call-ID", and "Event" header fields, as well
            // as "From" header field "tag" parameter and "Event" header field "id"
            // parameter) but that do not match the dialog would be rejected with a
            // 481 response.  Note that the 200-class response to the SUBSCRIBE
            // request can arrive after a matching NOTIFY request has been received;
            // such responses might not correlate to the same dialog established by
            // the NOTIFY request.  Except as required to complete the SUBSCRIBE
            // transaction, such non-matching 200-class responses are ignored.
            //
            // If installing of multiple subscriptions by way of a single forked
            // SUBSCRIBE request is allowed, the subscriber establishes a new dialog
            // towards each notifier by returning a 200-class response to each
            // NOTIFY request.  Each dialog is then handled as its own entity and is
            // refreshed independently of the other dialogs.
            //
            // In the case that multiple subscriptions are allowed, the event
            // package MUST specify whether merging of the notifications to form a
            // single state is required, and how such merging is to be performed.
            // Note that it is possible that some event packages may be defined in
            // such a way that each dialog is tied to a mutually exclusive state
            // that is unaffected by the other dialogs; this MUST be clearly stated
            // if it is the case.
            // https://tools.ietf.org/html/rfc6665#section-5.4.9
            // *** NOTE: This implementation is only for event packages which
            // do not allow forked requests to install muliple subscriptions.
            // As such and in accordance with the specificaiton, we stop waiting
            // and any future NOTIFY requests will be rejected with a 481.
            if (this.dialog) {
                throw new Error("Dialog already created. This implementation only supports install of single subscriptions.");
            }
            this.waitNotifyStop();
            // Update expires.
            this.subscriptionExpires =
                subscriptionState.expires ?
                    Math.min(this.subscriptionExpires, Math.max(subscriptionState.expires, 0)) :
                    this.subscriptionExpires;
            // Update subscriptoin state.
            switch (state) {
                case "pending":
                    this.subscriptionState = subscription_1.SubscriptionState.Pending;
                    break;
                case "active":
                    this.subscriptionState = subscription_1.SubscriptionState.Active;
                    break;
                case "terminated":
                    this.subscriptionState = subscription_1.SubscriptionState.Terminated;
                    break;
                default:
                    throw new Error("Unrecognized state " + state + ".");
            }
            // Dialogs usages are created upon completion of a NOTIFY transaction
            // for a new subscription, unless the NOTIFY request contains a
            // "Subscription-State" of "terminated."
            // https://tools.ietf.org/html/rfc6665#section-4.4.1
            if (this.subscriptionState !== subscription_1.SubscriptionState.Terminated) {
                // Because the dialog usage is established by the NOTIFY request, the
                // route set at the subscriber is taken from the NOTIFY request itself,
                // as opposed to the route set present in the 200-class response to the
                // SUBSCRIBE request.
                // https://tools.ietf.org/html/rfc6665#section-4.4.1
                var dialogState = subscription_dialog_1.SubscriptionDialog.initialDialogStateForSubscription(this.message, uas.message);
                // Subscription Initiated! :)
                this.dialog = new subscription_dialog_1.SubscriptionDialog(this.subscriptionEvent, this.subscriptionExpires, this.subscriptionState, this.core, dialogState);
            }
            // Delegate.
            if (this.delegate && this.delegate.onNotify) {
                var request = uas;
                var subscription = this.dialog;
                this.delegate.onNotify({ request: request, subscription: subscription });
            }
            else {
                uas.accept();
            }
        };
        SubscribeUserAgentClient.prototype.waitNotifyStart = function () {
            var _this = this;
            if (!this.N) {
                // Add ourselves to the core's subscriber map.
                // This allows the core to route out of dialog NOTIFY messages to us.
                this.core.subscribers.set(this.subscriberId, this);
                this.N = setTimeout(function () { return _this.timer_N(); }, timers_1.Timers.TIMER_N);
            }
        };
        SubscribeUserAgentClient.prototype.waitNotifyStop = function () {
            if (this.N) {
                // Remove ourselves to the core's subscriber map.
                // Any future out of dialog NOTIFY messages will be rejected with a 481.
                this.core.subscribers.delete(this.subscriberId);
                clearTimeout(this.N);
                this.N = undefined;
            }
        };
        /**
         * Receive a response from the transaction layer.
         * @param message - Incoming response message.
         */
        SubscribeUserAgentClient.prototype.receiveResponse = function (message) {
            if (!this.authenticationGuard(message)) {
                return;
            }
            if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {
                //  The "Expires" header field in a 200-class response to SUBSCRIBE
                //  request indicates the actual duration for which the subscription will
                //  remain active (unless refreshed).  The received value might be
                //  smaller than the value indicated in the SUBSCRIBE request but cannot
                //  be larger; see Section 4.2.1 for details.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                // The "Expires" values present in SUBSCRIBE 200-class responses behave
                // in the same way as they do in REGISTER responses: the server MAY
                // shorten the interval but MUST NOT lengthen it.
                //
                //    If the duration specified in a SUBSCRIBE request is unacceptably
                //    short, the notifier may be able to send a 423 response, as
                //    described earlier in this section.
                //
                // 200-class responses to SUBSCRIBE requests will not generally contain
                // any useful information beyond subscription duration; their primary
                // purpose is to serve as a reliability mechanism.  State information
                // will be communicated via a subsequent NOTIFY request from the
                // notifier.
                // https://tools.ietf.org/html/rfc6665#section-4.2.1.1
                var expires = message.getHeader("Expires");
                if (!expires) {
                    this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
                }
                else {
                    var subscriptionExpiresReceived = Number(expires);
                    if (subscriptionExpiresReceived > this.subscriptionExpiresRequested) {
                        this.logger.warn("Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request");
                    }
                    if (subscriptionExpiresReceived < this.subscriptionExpires) {
                        this.subscriptionExpires = subscriptionExpiresReceived;
                    }
                }
                // If a NOTIFY arrived before 200-class response a dialog may have been created.
                // Updated the dialogs expiration only if this indicates earlier expiration.
                if (this.dialog) {
                    if (this.dialog.subscriptionExpires > this.subscriptionExpires) {
                        this.dialog.subscriptionExpires = this.subscriptionExpires;
                    }
                }
            }
            if (message.statusCode && message.statusCode >= 300 && message.statusCode < 700) {
                this.waitNotifyStop(); // No NOTIFY will be sent after a negative final response.
            }
            _super.prototype.receiveResponse.call(this, message);
        };
        /**
         * To ensure that subscribers do not wait indefinitely for a
         * subscription to be established, a subscriber starts a Timer N, set to
         * 64*T1, when it sends a SUBSCRIBE request.  If this Timer N expires
         * prior to the receipt of a NOTIFY request, the subscriber considers
         * the subscription failed, and cleans up any state associated with the
         * subscription attempt.
         * https://tools.ietf.org/html/rfc6665#section-4.1.2.4
         */
        SubscribeUserAgentClient.prototype.timer_N = function () {
            this.logger.warn("Timer N expired for SUBSCRIBE user agent client. Timed out waiting for NOTIFY.");
            this.waitNotifyStop();
            if (this.delegate && this.delegate.onNotifyTimeout) {
                this.delegate.onNotifyTimeout();
            }
        };
        return SubscribeUserAgentClient;
    }(user_agent_client_1.UserAgentClient));
    exports.SubscribeUserAgentClient = SubscribeUserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/subscribe-user-agent-server.ts":
    /*!*************************************************************!*\
      !*** ./src/core/user-agents/subscribe-user-agent-server.ts ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./src/core/user-agents/user-agent-server.ts");
    /**
     * SUBSCRIBE UAS.
     * @public
     */
    var SubscribeUserAgentServer = /** @class */ (function (_super) {
        tslib_1.__extends(SubscribeUserAgentServer, _super);
        function SubscribeUserAgentServer(core, message, delegate) {
            var _this = _super.call(this, transactions_1.NonInviteServerTransaction, core, message, delegate) || this;
            _this.core = core;
            return _this;
        }
        return SubscribeUserAgentServer;
    }(user_agent_server_1.UserAgentServer));
    exports.SubscribeUserAgentServer = SubscribeUserAgentServer;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/user-agent-client.ts":
    /*!***************************************************!*\
      !*** ./src/core/user-agents/user-agent-client.ts ***!
      \***************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    /**
     * User Agent Client (UAC).
     * @remarks
     * A user agent client is a logical entity
     * that creates a new request, and then uses the client
     * transaction state machinery to send it.  The role of UAC lasts
     * only for the duration of that transaction.  In other words, if
     * a piece of software initiates a request, it acts as a UAC for
     * the duration of that transaction.  If it receives a request
     * later, it assumes the role of a user agent server for the
     * processing of that transaction.
     * https://tools.ietf.org/html/rfc3261#section-6
     * @public
     */
    var UserAgentClient = /** @class */ (function () {
        function UserAgentClient(transactionConstructor, core, message, delegate) {
            this.transactionConstructor = transactionConstructor;
            this.core = core;
            this.message = message;
            this.delegate = delegate;
            this.challenged = false;
            this.stale = false;
            this.logger = this.loggerFactory.getLogger("sip.user-agent-client");
            this.init();
        }
        UserAgentClient.prototype.dispose = function () {
            this.transaction.dispose();
        };
        Object.defineProperty(UserAgentClient.prototype, "loggerFactory", {
            get: function () {
                return this.core.loggerFactory;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgentClient.prototype, "transaction", {
            /** The transaction associated with this request. */
            get: function () {
                if (!this._transaction) {
                    throw new Error("Transaction undefined.");
                }
                return this._transaction;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Since requests other than INVITE are responded to immediately, sending a
         * CANCEL for a non-INVITE request would always create a race condition.
         * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.
         * https://tools.ietf.org/html/rfc3261#section-9.1
         * @param options - Cancel options bucket.
         */
        UserAgentClient.prototype.cancel = function (reason, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (!this.transaction) {
                throw new Error("Transaction undefined.");
            }
            if (!this.message.to) {
                throw new Error("To undefined.");
            }
            if (!this.message.from) {
                throw new Error("From undefined.");
            }
            // The following procedures are used to construct a CANCEL request.  The
            // Request-URI, Call-ID, To, the numeric part of CSeq, and From header
            // fields in the CANCEL request MUST be identical to those in the
            // request being cancelled, including tags.  A CANCEL constructed by a
            // client MUST have only a single Via header field value matching the
            // top Via value in the request being cancelled.  Using the same values
            // for these header fields allows the CANCEL to be matched with the
            // request it cancels (Section 9.2 indicates how such matching occurs).
            // However, the method part of the CSeq header field MUST have a value
            // of CANCEL.  This allows it to be identified and processed as a
            // transaction in its own right (See Section 17).
            // https://tools.ietf.org/html/rfc3261#section-9.1
            var message = this.core.makeOutgoingRequestMessage(messages_1.C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {
                toTag: this.message.toTag,
                fromTag: this.message.fromTag,
                callId: this.message.callId,
                cseq: this.message.cseq
            }, options.extraHeaders);
            // TODO: Revisit this.
            // The CANCEL needs to use the same branch parameter so that
            // it matches the INVITE transaction, but this is a hacky way to do this.
            // Or at the very least not well documented. If the the branch parameter
            // is set on the outgoing request, the transaction will use it.
            // Otherwise the transaction will make a new one.
            message.branch = this.message.branch;
            if (this.message.headers.Route) {
                message.headers.Route = this.message.headers.Route;
            }
            if (reason) {
                message.setHeader("Reason", reason);
            }
            // If no provisional response has been received, the CANCEL request MUST
            // NOT be sent; rather, the client MUST wait for the arrival of a
            // provisional response before sending the request. If the original
            // request has generated a final response, the CANCEL SHOULD NOT be
            // sent, as it is an effective no-op, since CANCEL has no effect on
            // requests that have already generated a final response.
            // https://tools.ietf.org/html/rfc3261#section-9.1
            if (this.transaction.state === transactions_1.TransactionState.Proceeding) {
                var uac = new UserAgentClient(transactions_1.NonInviteClientTransaction, this.core, message);
            }
            else {
                this.transaction.once("stateChanged", function () {
                    if (_this.transaction && _this.transaction.state === transactions_1.TransactionState.Proceeding) {
                        var uac = new UserAgentClient(transactions_1.NonInviteClientTransaction, _this.core, message);
                    }
                });
            }
            return message;
        };
        /**
         * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)
         * response is received, the UAC SHOULD follow the authorization
         * procedures of Section 22.2 and Section 22.3 to retry the request with
         * credentials.
         * https://tools.ietf.org/html/rfc3261#section-8.1.3.5
         * 22 Usage of HTTP Authentication
         * https://tools.ietf.org/html/rfc3261#section-22
         * 22.1 Framework
         * https://tools.ietf.org/html/rfc3261#section-22.1
         * 22.2 User-to-User Authentication
         * https://tools.ietf.org/html/rfc3261#section-22.2
         * 22.3 Proxy-to-User Authentication
         * https://tools.ietf.org/html/rfc3261#section-22.3
         *
         * FIXME: This "guard for and retry the request with credentials"
         * implementation is not complete and at best minimally passable.
         * @param response - The incoming response to guard.
         * @returns True if the program execution is to continue in the branch in question.
         *          Otherwise the request is retried with credentials and current request processing must stop.
         */
        UserAgentClient.prototype.authenticationGuard = function (message) {
            var statusCode = message.statusCode;
            if (!statusCode) {
                throw new Error("Response status code undefined.");
            }
            // If a 401 (Unauthorized) or 407 (Proxy Authentication Required)
            // response is received, the UAC SHOULD follow the authorization
            // procedures of Section 22.2 and Section 22.3 to retry the request with
            // credentials.
            // https://tools.ietf.org/html/rfc3261#section-8.1.3.5
            if (statusCode !== 401 && statusCode !== 407) {
                return true;
            }
            // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
            var challenge;
            var authorizationHeaderName;
            if (statusCode === 401) {
                challenge = message.parseHeader("www-authenticate");
                authorizationHeaderName = "authorization";
            }
            else {
                challenge = message.parseHeader("proxy-authenticate");
                authorizationHeaderName = "proxy-authorization";
            }
            // Verify it seems a valid challenge.
            if (!challenge) {
                this.logger.warn(statusCode + " with wrong or missing challenge, cannot authenticate");
                return true;
            }
            // Avoid infinite authentications.
            if (this.challenged && (this.stale || challenge.stale !== true)) {
                this.logger.warn(statusCode + " apparently in authentication loop, cannot authenticate");
                return true;
            }
            // Get credentials.
            if (!this.credentials) {
                this.credentials = this.core.configuration.authenticationFactory();
                if (!this.credentials) {
                    this.logger.warn("Unable to obtain credentials, cannot authenticate");
                    return true;
                }
            }
            // Verify that the challenge is really valid.
            if (!this.credentials.authenticate(this.message, challenge)) {
                return true;
            }
            this.challenged = true;
            if (challenge.stale) {
                this.stale = true;
            }
            var cseq = this.message.cseq += 1;
            this.message.setHeader("cseq", cseq + " " + this.message.method);
            this.message.setHeader(authorizationHeaderName, this.credentials.toString());
            // Calling init (again) will swap out our existing client transaction with a new one.
            // FIXME: HACK: An assumption is being made here that there is nothing that needs to
            // be cleaned up beyond the client transaction which is being replaced. For example,
            // it is assumed that no early dialogs have been created.
            this.init();
            return false;
        };
        /**
         * 8.1.3.1 Transaction Layer Errors
         * In some cases, the response returned by the transaction layer will
         * not be a SIP message, but rather a transaction layer error.  When a
         * timeout error is received from the transaction layer, it MUST be
         * treated as if a 408 (Request Timeout) status code has been received.
         * If a fatal transport error is reported by the transport layer
         * (generally, due to fatal ICMP errors in UDP or connection failures in
         * TCP), the condition MUST be treated as a 503 (Service Unavailable)
         * status code.
         * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
         */
        UserAgentClient.prototype.onRequestTimeout = function () {
            this.logger.warn("User agent client request timed out. Generating internal 408 Request Timeout.");
            var message = new messages_1.IncomingResponseMessage();
            message.statusCode = 408;
            message.reasonPhrase = "Request Timeout";
            this.receiveResponse(message);
            return;
        };
        /**
         * 8.1.3.1 Transaction Layer Errors
         * In some cases, the response returned by the transaction layer will
         * not be a SIP message, but rather a transaction layer error.  When a
         * timeout error is received from the transaction layer, it MUST be
         * treated as if a 408 (Request Timeout) status code has been received.
         * If a fatal transport error is reported by the transport layer
         * (generally, due to fatal ICMP errors in UDP or connection failures in
         * TCP), the condition MUST be treated as a 503 (Service Unavailable)
         * status code.
         * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
         * @param error - Transport error
         */
        UserAgentClient.prototype.onTransportError = function (error) {
            this.logger.error(error.message);
            this.logger.error("User agent client request transport error. Generating internal 503 Service Unavailable.");
            var message = new messages_1.IncomingResponseMessage();
            message.statusCode = 503;
            message.reasonPhrase = "Service Unavailable";
            this.receiveResponse(message);
        };
        /**
         * Receive a response from the transaction layer.
         * @param message - Incoming response message.
         */
        UserAgentClient.prototype.receiveResponse = function (message) {
            if (!this.authenticationGuard(message)) {
                return;
            }
            var statusCode = message.statusCode ? message.statusCode.toString() : "";
            if (!statusCode) {
                throw new Error("Response status code undefined.");
            }
            switch (true) {
                case /^100$/.test(statusCode):
                    if (this.delegate && this.delegate.onTrying) {
                        this.delegate.onTrying({ message: message });
                    }
                    break;
                case /^1[0-9]{2}$/.test(statusCode):
                    if (this.delegate && this.delegate.onProgress) {
                        this.delegate.onProgress({ message: message });
                    }
                    break;
                case /^2[0-9]{2}$/.test(statusCode):
                    if (this.delegate && this.delegate.onAccept) {
                        this.delegate.onAccept({ message: message });
                    }
                    break;
                case /^3[0-9]{2}$/.test(statusCode):
                    if (this.delegate && this.delegate.onRedirect) {
                        this.delegate.onRedirect({ message: message });
                    }
                    break;
                case /^[4-6][0-9]{2}$/.test(statusCode):
                    if (this.delegate && this.delegate.onReject) {
                        this.delegate.onReject({ message: message });
                    }
                    break;
                default:
                    throw new Error("Invalid status code " + statusCode);
            }
        };
        UserAgentClient.prototype.init = function () {
            var _this = this;
            // We are the transaction user.
            var user = {
                loggerFactory: this.loggerFactory,
                onRequestTimeout: function () { return _this.onRequestTimeout(); },
                onStateChange: function (newState) {
                    if (newState === transactions_1.TransactionState.Terminated) {
                        // Remove the terminated transaction from the core.
                        _this.core.userAgentClients.delete(userAgentClientId);
                        // FIXME: HACK: Our transaction may have been swapped out with a new one
                        // post authentication (see above), so make sure to only to dispose of
                        // ourselves if this terminating transaction is our current transaction.
                        if (transaction === _this._transaction) {
                            _this.dispose();
                        }
                    }
                },
                onTransportError: function (error) { return _this.onTransportError(error); },
                receiveResponse: function (message) { return _this.receiveResponse(message); }
            };
            // Create a new transaction with us as the user.
            var transaction = new this.transactionConstructor(this.message, this.core.transport, user);
            this._transaction = transaction;
            // Add the new transaction to the core.
            var userAgentClientId = transaction.id + transaction.request.method;
            this.core.userAgentClients.set(userAgentClientId, this);
        };
        return UserAgentClient;
    }());
    exports.UserAgentClient = UserAgentClient;
    
    
    /***/ }),
    
    /***/ "./src/core/user-agents/user-agent-server.ts":
    /*!***************************************************!*\
      !*** ./src/core/user-agents/user-agent-server.ts ***!
      \***************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var exceptions_1 = __webpack_require__(/*! ../exceptions */ "./src/core/exceptions/index.ts");
    var messages_1 = __webpack_require__(/*! ../messages */ "./src/core/messages/index.ts");
    var utils_1 = __webpack_require__(/*! ../messages/utils */ "./src/core/messages/utils.ts");
    var transactions_1 = __webpack_require__(/*! ../transactions */ "./src/core/transactions/index.ts");
    /**
     * User Agent Server (UAS).
     * @remarks
     * A user agent server is a logical entity
     * that generates a response to a SIP request.  The response
     * accepts, rejects, or redirects the request.  This role lasts
     * only for the duration of that transaction.  In other words, if
     * a piece of software responds to a request, it acts as a UAS for
     * the duration of that transaction.  If it generates a request
     * later, it assumes the role of a user agent client for the
     * processing of that transaction.
     * https://tools.ietf.org/html/rfc3261#section-6
     * @public
     */
    var UserAgentServer = /** @class */ (function () {
        function UserAgentServer(transactionConstructor, core, message, delegate) {
            this.transactionConstructor = transactionConstructor;
            this.core = core;
            this.message = message;
            this.delegate = delegate;
            this.logger = this.loggerFactory.getLogger("sip.user-agent-server");
            this.toTag = message.toTag ? message.toTag : utils_1.newTag();
            this.init();
        }
        UserAgentServer.prototype.dispose = function () {
            this.transaction.dispose();
        };
        Object.defineProperty(UserAgentServer.prototype, "loggerFactory", {
            get: function () {
                return this.core.loggerFactory;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgentServer.prototype, "transaction", {
            /** The transaction associated with this request. */
            get: function () {
                if (!this._transaction) {
                    throw new Error("Transaction undefined.");
                }
                return this._transaction;
            },
            enumerable: true,
            configurable: true
        });
        UserAgentServer.prototype.accept = function (options) {
            if (options === void 0) { options = { statusCode: 200 }; }
            if (!this.acceptable) {
                throw new exceptions_1.TransactionStateError(this.message.method + " not acceptable in state " + this.transaction.state + ".");
            }
            var statusCode = options.statusCode;
            if (statusCode < 200 || statusCode > 299) {
                throw new TypeError("Invalid statusCode: " + statusCode);
            }
            var response = this.reply(options);
            return response;
        };
        UserAgentServer.prototype.progress = function (options) {
            if (options === void 0) { options = { statusCode: 180 }; }
            if (!this.progressable) {
                throw new exceptions_1.TransactionStateError(this.message.method + " not progressable in state " + this.transaction.state + ".");
            }
            var statusCode = options.statusCode;
            if (statusCode < 101 || statusCode > 199) {
                throw new TypeError("Invalid statusCode: " + statusCode);
            }
            var response = this.reply(options);
            return response;
        };
        UserAgentServer.prototype.redirect = function (contacts, options) {
            if (options === void 0) { options = { statusCode: 302 }; }
            if (!this.redirectable) {
                throw new exceptions_1.TransactionStateError(this.message.method + " not redirectable in state " + this.transaction.state + ".");
            }
            var statusCode = options.statusCode;
            if (statusCode < 300 || statusCode > 399) {
                throw new TypeError("Invalid statusCode: " + statusCode);
            }
            var contactHeaders = new Array();
            contacts.forEach(function (contact) { return contactHeaders.push("Contact: " + contact.toString()); });
            options.extraHeaders = (options.extraHeaders || []).concat(contactHeaders);
            var response = this.reply(options);
            return response;
        };
        UserAgentServer.prototype.reject = function (options) {
            if (options === void 0) { options = { statusCode: 480 }; }
            if (!this.rejectable) {
                throw new exceptions_1.TransactionStateError(this.message.method + " not rejectable in state " + this.transaction.state + ".");
            }
            var statusCode = options.statusCode;
            if (statusCode < 400 || statusCode > 699) {
                throw new TypeError("Invalid statusCode: " + statusCode);
            }
            var response = this.reply(options);
            return response;
        };
        UserAgentServer.prototype.trying = function (options) {
            if (!this.tryingable) {
                throw new exceptions_1.TransactionStateError(this.message.method + " not tryingable in state " + this.transaction.state + ".");
            }
            var response = this.reply({ statusCode: 100 });
            return response;
        };
        /**
         * If the UAS did not find a matching transaction for the CANCEL
         * according to the procedure above, it SHOULD respond to the CANCEL
         * with a 481 (Call Leg/Transaction Does Not Exist).  If the transaction
         * for the original request still exists, the behavior of the UAS on
         * receiving a CANCEL request depends on whether it has already sent a
         * final response for the original request.  If it has, the CANCEL
         * request has no effect on the processing of the original request, no
         * effect on any session state, and no effect on the responses generated
         * for the original request.  If the UAS has not issued a final response
         * for the original request, its behavior depends on the method of the
         * original request.  If the original request was an INVITE, the UAS
         * SHOULD immediately respond to the INVITE with a 487 (Request
         * Terminated).  A CANCEL request has no impact on the processing of
         * transactions with any other method defined in this specification.
         * https://tools.ietf.org/html/rfc3261#section-9.2
         * @param request - Incoming CANCEL request.
         */
        UserAgentServer.prototype.receiveCancel = function (message) {
            // Note: Currently CANCEL is being handled as a special case.
            // No UAS is created to handle the CANCEL and the response to
            // it CANCEL is being handled statelessly by the user agent core.
            // As such, there is currently no way to externally impact the
            // response to the a CANCEL request.
            if (this.delegate && this.delegate.onCancel) {
                this.delegate.onCancel(message);
            }
        };
        Object.defineProperty(UserAgentServer.prototype, "acceptable", {
            get: function () {
                if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                    return (this.transaction.state === transactions_1.TransactionState.Proceeding ||
                        this.transaction.state === transactions_1.TransactionState.Accepted);
                }
                if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                    return (this.transaction.state === transactions_1.TransactionState.Trying ||
                        this.transaction.state === transactions_1.TransactionState.Proceeding);
                }
                throw new Error("Unknown transaction type.");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgentServer.prototype, "progressable", {
            get: function () {
                if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                    return this.transaction.state === transactions_1.TransactionState.Proceeding;
                }
                if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                    return false; // https://tools.ietf.org/html/rfc4320#section-4.1
                }
                throw new Error("Unknown transaction type.");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgentServer.prototype, "redirectable", {
            get: function () {
                if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                    return this.transaction.state === transactions_1.TransactionState.Proceeding;
                }
                if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                    return (this.transaction.state === transactions_1.TransactionState.Trying ||
                        this.transaction.state === transactions_1.TransactionState.Proceeding);
                }
                throw new Error("Unknown transaction type.");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgentServer.prototype, "rejectable", {
            get: function () {
                if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                    return this.transaction.state === transactions_1.TransactionState.Proceeding;
                }
                if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                    return (this.transaction.state === transactions_1.TransactionState.Trying ||
                        this.transaction.state === transactions_1.TransactionState.Proceeding);
                }
                throw new Error("Unknown transaction type.");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserAgentServer.prototype, "tryingable", {
            get: function () {
                if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                    return this.transaction.state === transactions_1.TransactionState.Proceeding;
                }
                if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                    return this.transaction.state === transactions_1.TransactionState.Trying;
                }
                throw new Error("Unknown transaction type.");
            },
            enumerable: true,
            configurable: true
        });
        /**
         * When a UAS wishes to construct a response to a request, it follows
         * the general procedures detailed in the following subsections.
         * Additional behaviors specific to the response code in question, which
         * are not detailed in this section, may also be required.
         *
         * Once all procedures associated with the creation of a response have
         * been completed, the UAS hands the response back to the server
         * transaction from which it received the request.
         * https://tools.ietf.org/html/rfc3261#section-8.2.6
         * @param statusCode - Status code to reply with.
         * @param options - Reply options bucket.
         */
        UserAgentServer.prototype.reply = function (options) {
            if (!options.toTag && options.statusCode !== 100) {
                options.toTag = this.toTag;
            }
            options.userAgent = options.userAgent || this.core.configuration.userAgentHeaderFieldValue;
            options.supported = options.supported || this.core.configuration.supportedOptionTagsResponse;
            var response = messages_1.constructOutgoingResponse(this.message, options);
            this.transaction.receiveResponse(options.statusCode, response.message);
            return response;
        };
        UserAgentServer.prototype.init = function () {
            var _this = this;
            // We are the transaction user.
            var user = {
                loggerFactory: this.loggerFactory,
                onStateChange: function (newState) {
                    if (newState === transactions_1.TransactionState.Terminated) {
                        // Remove the terminated transaction from the core.
                        _this.core.userAgentServers.delete(userAgentServerId);
                        _this.dispose();
                    }
                },
                onTransportError: function (error) {
                    _this.logger.error(error.message);
                    if (_this.delegate && _this.delegate.onTransportError) {
                        _this.delegate.onTransportError(error);
                    }
                    else {
                        _this.logger.error("User agent server response transport error.");
                    }
                }
            };
            // Create a new transaction with us as the user.
            var transaction = new this.transactionConstructor(this.message, this.core.transport, user);
            this._transaction = transaction;
            // Add the new transaction to the core.
            var userAgentServerId = transaction.id;
            this.core.userAgentServers.set(transaction.id, this);
        };
        return UserAgentServer;
    }());
    exports.UserAgentServer = UserAgentServer;
    
    
    /***/ }),
    
    /***/ "./src/grammar/dist/grammar.ts":
    /*!*************************************!*\
      !*** ./src/grammar/dist/grammar.ts ***!
      \*************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    // tslint:disable:interface-name
    // tslint:disable: trailing-comma
    // tslint:disable: object-literal-sort-keys
    // tslint:disable: max-line-length
    // tslint:disable: only-arrow-functions
    // tslint:disable: one-variable-per-declaration
    // tslint:disable: no-consecutive-blank-lines
    // tslint:disable: align
    // tslint:disable: radix
    // tslint:disable: quotemark
    // tslint:disable: semicolon
    // tslint:disable: object-literal-shorthand
    // tslint:disable: variable-name
    // tslint:disable: no-var-keyword
    // tslint:disable: whitespace
    // tslint:disable: curly
    // tslint:disable: prefer-const
    // tslint:disable: object-literal-key-quotes
    // tslint:disable: no-string-literal
    // tslint:disable: one-line
    // tslint:disable: no-unused-expression
    // tslint:disable: space-before-function-paren
    // tslint:disable: arrow-return-shorthand
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    // Generated by PEG.js v. 0.10.0 (ts-pegjs plugin v. 0.2.6 )
    //
    // https://pegjs.org/   https://github.com/metadevpro/ts-pegjs
    var name_addr_header_1 = __webpack_require__(/*! ../../core/messages/name-addr-header */ "./src/core/messages/name-addr-header.ts");
    var uri_1 = __webpack_require__(/*! ../../core/messages/uri */ "./src/core/messages/uri.ts");
    var SyntaxError = /** @class */ (function (_super) {
        tslib_1.__extends(SyntaxError, _super);
        function SyntaxError(message, expected, found, location) {
            var _this = _super.call(this) || this;
            _this.message = message;
            _this.expected = expected;
            _this.found = found;
            _this.location = location;
            _this.name = "SyntaxError";
            if (typeof Error.captureStackTrace === "function") {
                Error.captureStackTrace(_this, SyntaxError);
            }
            return _this;
        }
        SyntaxError.buildMessage = function (expected, found) {
            function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s) {
                return s
                    .replace(/\\/g, "\\\\")
                    .replace(/"/g, "\\\"")
                    .replace(/\0/g, "\\0")
                    .replace(/\t/g, "\\t")
                    .replace(/\n/g, "\\n")
                    .replace(/\r/g, "\\r")
                    .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
                    .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
            }
            function classEscape(s) {
                return s
                    .replace(/\\/g, "\\\\")
                    .replace(/\]/g, "\\]")
                    .replace(/\^/g, "\\^")
                    .replace(/-/g, "\\-")
                    .replace(/\0/g, "\\0")
                    .replace(/\t/g, "\\t")
                    .replace(/\n/g, "\\n")
                    .replace(/\r/g, "\\r")
                    .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
                    .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
            }
            function describeExpectation(expectation) {
                switch (expectation.type) {
                    case "literal":
                        return "\"" + literalEscape(expectation.text) + "\"";
                    case "class":
                        var escapedParts = expectation.parts.map(function (part) {
                            return Array.isArray(part)
                                ? classEscape(part[0]) + "-" + classEscape(part[1])
                                : classEscape(part);
                        });
                        return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                    case "any":
                        return "any character";
                    case "end":
                        return "end of input";
                    case "other":
                        return expectation.description;
                }
            }
            function describeExpected(expected1) {
                var descriptions = expected1.map(describeExpectation);
                var i;
                var j;
                descriptions.sort();
                if (descriptions.length > 0) {
                    for (i = 1, j = 1; i < descriptions.length; i++) {
                        if (descriptions[i - 1] !== descriptions[i]) {
                            descriptions[j] = descriptions[i];
                            j++;
                        }
                    }
                    descriptions.length = j;
                }
                switch (descriptions.length) {
                    case 1:
                        return descriptions[0];
                    case 2:
                        return descriptions[0] + " or " + descriptions[1];
                    default:
                        return descriptions.slice(0, -1).join(", ")
                            + ", or "
                            + descriptions[descriptions.length - 1];
                }
            }
            function describeFound(found1) {
                return found1 ? "\"" + literalEscape(found1) + "\"" : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        return SyntaxError;
    }(Error));
    exports.SyntaxError = SyntaxError;
    function peg$parse(input, options) {
        options = options !== undefined ? options : {};
        var peg$FAILED = {};
        var peg$startRuleIndices = { Contact: 119, Name_Addr_Header: 156, Record_Route: 176, Request_Response: 81, SIP_URI: 45, Subscription_State: 186, Supported: 191, Require: 182, Via: 194, absoluteURI: 84, Call_ID: 118, Content_Disposition: 130, Content_Length: 135, Content_Type: 136, CSeq: 146, displayName: 122, Event: 149, From: 151, host: 52, Max_Forwards: 154, Min_SE: 213, Proxy_Authenticate: 157, quoted_string: 40, Refer_To: 178, Replaces: 179, Session_Expires: 210, stun_URI: 217, To: 192, turn_URI: 223, uuid: 226, WWW_Authenticate: 209, challenge: 158, sipfrag: 230, Referred_By: 231 };
        var peg$startRuleIndex = 119;
        var peg$consts = [
            "\r\n",
            peg$literalExpectation("\r\n", false),
            /^[0-9]/,
            peg$classExpectation([["0", "9"]], false, false),
            /^[a-zA-Z]/,
            peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
            /^[0-9a-fA-F]/,
            peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
            /^[\0-\xFF]/,
            peg$classExpectation([["\0", "\xFF"]], false, false),
            /^["]/,
            peg$classExpectation(["\""], false, false),
            " ",
            peg$literalExpectation(" ", false),
            "\t",
            peg$literalExpectation("\t", false),
            /^[a-zA-Z0-9]/,
            peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
            ";",
            peg$literalExpectation(";", false),
            "/",
            peg$literalExpectation("/", false),
            "?",
            peg$literalExpectation("?", false),
            ":",
            peg$literalExpectation(":", false),
            "@",
            peg$literalExpectation("@", false),
            "&",
            peg$literalExpectation("&", false),
            "=",
            peg$literalExpectation("=", false),
            "+",
            peg$literalExpectation("+", false),
            "$",
            peg$literalExpectation("$", false),
            ",",
            peg$literalExpectation(",", false),
            "-",
            peg$literalExpectation("-", false),
            "_",
            peg$literalExpectation("_", false),
            ".",
            peg$literalExpectation(".", false),
            "!",
            peg$literalExpectation("!", false),
            "~",
            peg$literalExpectation("~", false),
            "*",
            peg$literalExpectation("*", false),
            "'",
            peg$literalExpectation("'", false),
            "(",
            peg$literalExpectation("(", false),
            ")",
            peg$literalExpectation(")", false),
            "%",
            peg$literalExpectation("%", false),
            function () { return " "; },
            function () { return ':'; },
            /^[!-~]/,
            peg$classExpectation([["!", "~"]], false, false),
            /^[\x80-\uFFFF]/,
            peg$classExpectation([["\x80", "\uFFFF"]], false, false),
            /^[\x80-\xBF]/,
            peg$classExpectation([["\x80", "\xBF"]], false, false),
            /^[a-f]/,
            peg$classExpectation([["a", "f"]], false, false),
            "`",
            peg$literalExpectation("`", false),
            "<",
            peg$literalExpectation("<", false),
            ">",
            peg$literalExpectation(">", false),
            "\\",
            peg$literalExpectation("\\", false),
            "[",
            peg$literalExpectation("[", false),
            "]",
            peg$literalExpectation("]", false),
            "{",
            peg$literalExpectation("{", false),
            "}",
            peg$literalExpectation("}", false),
            function () { return "*"; },
            function () { return "/"; },
            function () { return "="; },
            function () { return "("; },
            function () { return ")"; },
            function () { return ">"; },
            function () { return "<"; },
            function () { return ","; },
            function () { return ";"; },
            function () { return ":"; },
            function () { return "\""; },
            /^[!-']/,
            peg$classExpectation([["!", "'"]], false, false),
            /^[*-[]/,
            peg$classExpectation([["*", "["]], false, false),
            /^[\]-~]/,
            peg$classExpectation([["]", "~"]], false, false),
            function (contents) {
                return contents;
            },
            /^[#-[]/,
            peg$classExpectation([["#", "["]], false, false),
            /^[\0-\t]/,
            peg$classExpectation([["\0", "\t"]], false, false),
            /^[\x0B-\f]/,
            peg$classExpectation([["\x0B", "\f"]], false, false),
            /^[\x0E-\x7F]/,
            peg$classExpectation([["\x0E", "\x7F"]], false, false),
            function () {
                options = options || { data: {} };
                options.data.uri = new uri_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
                delete options.data.scheme;
                delete options.data.user;
                delete options.data.host;
                delete options.data.host_type;
                delete options.data.port;
            },
            function () {
                options = options || { data: {} };
                options.data.uri = new uri_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
                delete options.data.scheme;
                delete options.data.user;
                delete options.data.host;
                delete options.data.host_type;
                delete options.data.port;
                delete options.data.uri_params;
                if (options.startRule === 'SIP_URI') {
                    options.data = options.data.uri;
                }
            },
            "sips",
            peg$literalExpectation("sips", true),
            "sip",
            peg$literalExpectation("sip", true),
            function (uri_scheme) {
                options = options || { data: {} };
                options.data.scheme = uri_scheme;
            },
            function () {
                options = options || { data: {} };
                options.data.user = decodeURIComponent(text().slice(0, -1));
            },
            function () {
                options = options || { data: {} };
                options.data.password = text();
            },
            function () {
                options = options || { data: {} };
                options.data.host = text();
                return options.data.host;
            },
            function () {
                options = options || { data: {} };
                options.data.host_type = 'domain';
                return text();
            },
            /^[a-zA-Z0-9_\-]/,
            peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false),
            /^[a-zA-Z0-9\-]/,
            peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
            function () {
                options = options || { data: {} };
                options.data.host_type = 'IPv6';
                return text();
            },
            "::",
            peg$literalExpectation("::", false),
            function () {
                options = options || { data: {} };
                options.data.host_type = 'IPv6';
                return text();
            },
            function () {
                options = options || { data: {} };
                options.data.host_type = 'IPv4';
                return text();
            },
            "25",
            peg$literalExpectation("25", false),
            /^[0-5]/,
            peg$classExpectation([["0", "5"]], false, false),
            "2",
            peg$literalExpectation("2", false),
            /^[0-4]/,
            peg$classExpectation([["0", "4"]], false, false),
            "1",
            peg$literalExpectation("1", false),
            /^[1-9]/,
            peg$classExpectation([["1", "9"]], false, false),
            function (port) {
                options = options || { data: {} };
                port = parseInt(port.join(''));
                options.data.port = port;
                return port;
            },
            "transport=",
            peg$literalExpectation("transport=", true),
            "udp",
            peg$literalExpectation("udp", true),
            "tcp",
            peg$literalExpectation("tcp", true),
            "sctp",
            peg$literalExpectation("sctp", true),
            "tls",
            peg$literalExpectation("tls", true),
            function (transport) {
                options = options || { data: {} };
                if (!options.data.uri_params)
                    options.data.uri_params = {};
                options.data.uri_params['transport'] = transport.toLowerCase();
            },
            "user=",
            peg$literalExpectation("user=", true),
            "phone",
            peg$literalExpectation("phone", true),
            "ip",
            peg$literalExpectation("ip", true),
            function (user) {
                options = options || { data: {} };
                if (!options.data.uri_params)
                    options.data.uri_params = {};
                options.data.uri_params['user'] = user.toLowerCase();
            },
            "method=",
            peg$literalExpectation("method=", true),
            function (method) {
                options = options || { data: {} };
                if (!options.data.uri_params)
                    options.data.uri_params = {};
                options.data.uri_params['method'] = method;
            },
            "ttl=",
            peg$literalExpectation("ttl=", true),
            function (ttl) {
                options = options || { data: {} };
                if (!options.data.params)
                    options.data.params = {};
                options.data.params['ttl'] = ttl;
            },
            "maddr=",
            peg$literalExpectation("maddr=", true),
            function (maddr) {
                options = options || { data: {} };
                if (!options.data.uri_params)
                    options.data.uri_params = {};
                options.data.uri_params['maddr'] = maddr;
            },
            "lr",
            peg$literalExpectation("lr", true),
            function () {
                options = options || { data: {} };
                if (!options.data.uri_params)
                    options.data.uri_params = {};
                options.data.uri_params['lr'] = undefined;
            },
            function (param, value) {
                options = options || { data: {} };
                if (!options.data.uri_params)
                    options.data.uri_params = {};
                if (value === null) {
                    value = undefined;
                }
                else {
                    value = value[1];
                }
                options.data.uri_params[param.toLowerCase()] = value;
            },
            function (hname, hvalue) {
                hname = hname.join('').toLowerCase();
                hvalue = hvalue.join('');
                options = options || { data: {} };
                if (!options.data.uri_headers)
                    options.data.uri_headers = {};
                if (!options.data.uri_headers[hname]) {
                    options.data.uri_headers[hname] = [hvalue];
                }
                else {
                    options.data.uri_headers[hname].push(hvalue);
                }
            },
            function () {
                options = options || { data: {} };
                // lots of tests fail if this isn't guarded...
                if (options.startRule === 'Refer_To') {
                    options.data.uri = new uri_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
                    delete options.data.scheme;
                    delete options.data.user;
                    delete options.data.host;
                    delete options.data.host_type;
                    delete options.data.port;
                    delete options.data.uri_params;
                }
            },
            "//",
            peg$literalExpectation("//", false),
            function () {
                options = options || { data: {} };
                options.data.scheme = text();
            },
            peg$literalExpectation("SIP", true),
            function () {
                options = options || { data: {} };
                options.data.sip_version = text();
            },
            "INVITE",
            peg$literalExpectation("INVITE", false),
            "ACK",
            peg$literalExpectation("ACK", false),
            "VXACH",
            peg$literalExpectation("VXACH", false),
            "OPTIONS",
            peg$literalExpectation("OPTIONS", false),
            "BYE",
            peg$literalExpectation("BYE", false),
            "CANCEL",
            peg$literalExpectation("CANCEL", false),
            "REGISTER",
            peg$literalExpectation("REGISTER", false),
            "SUBSCRIBE",
            peg$literalExpectation("SUBSCRIBE", false),
            "NOTIFY",
            peg$literalExpectation("NOTIFY", false),
            "REFER",
            peg$literalExpectation("REFER", false),
            "PUBLISH",
            peg$literalExpectation("PUBLISH", false),
            function () {
                options = options || { data: {} };
                options.data.method = text();
                return options.data.method;
            },
            function (status_code) {
                options = options || { data: {} };
                options.data.status_code = parseInt(status_code.join(''));
            },
            function () {
                options = options || { data: {} };
                options.data.reason_phrase = text();
            },
            function () {
                options = options || { data: {} };
                options.data = text();
            },
            function () {
                var idx, length;
                options = options || { data: {} };
                length = options.data.multi_header.length;
                for (idx = 0; idx < length; idx++) {
                    if (options.data.multi_header[idx].parsed === null) {
                        options.data = null;
                        break;
                    }
                }
                if (options.data !== null) {
                    options.data = options.data.multi_header;
                }
                else {
                    options.data = -1;
                }
            },
            function () {
                var header;
                options = options || { data: {} };
                if (!options.data.multi_header)
                    options.data.multi_header = [];
                try {
                    header = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
                    delete options.data.uri;
                    delete options.data.displayName;
                    delete options.data.params;
                }
                catch (e) {
                    header = null;
                }
                options.data.multi_header.push({ 'position': peg$currPos,
                    'offset': location().start.offset,
                    'parsed': header
                });
            },
            function (displayName) {
                displayName = text().trim();
                if (displayName[0] === '\"') {
                    displayName = displayName.substring(1, displayName.length - 1);
                }
                options = options || { data: {} };
                options.data.displayName = displayName;
            },
            "q",
            peg$literalExpectation("q", true),
            function (q) {
                options = options || { data: {} };
                if (!options.data.params)
                    options.data.params = {};
                options.data.params['q'] = q;
            },
            "expires",
            peg$literalExpectation("expires", true),
            function (expires) {
                options = options || { data: {} };
                if (!options.data.params)
                    options.data.params = {};
                options.data.params['expires'] = expires;
            },
            function (delta_seconds) {
                return parseInt(delta_seconds.join(''));
            },
            "0",
            peg$literalExpectation("0", false),
            function () {
                return parseFloat(text());
            },
            function (param, value) {
                options = options || { data: {} };
                if (!options.data.params)
                    options.data.params = {};
                if (value === null) {
                    value = undefined;
                }
                else {
                    value = value[1];
                }
                options.data.params[param.toLowerCase()] = value;
            },
            "render",
            peg$literalExpectation("render", true),
            "session",
            peg$literalExpectation("session", true),
            "icon",
            peg$literalExpectation("icon", true),
            "alert",
            peg$literalExpectation("alert", true),
            function () {
                options = options || { data: {} };
                if (options.startRule === 'Content_Disposition') {
                    options.data.type = text().toLowerCase();
                }
            },
            "handling",
            peg$literalExpectation("handling", true),
            "optional",
            peg$literalExpectation("optional", true),
            "required",
            peg$literalExpectation("required", true),
            function (length) {
                options = options || { data: {} };
                options.data = parseInt(length.join(''));
            },
            function () {
                options = options || { data: {} };
                options.data = text();
            },
            "text",
            peg$literalExpectation("text", true),
            "image",
            peg$literalExpectation("image", true),
            "audio",
            peg$literalExpectation("audio", true),
            "video",
            peg$literalExpectation("video", true),
            "application",
            peg$literalExpectation("application", true),
            "message",
            peg$literalExpectation("message", true),
            "multipart",
            peg$literalExpectation("multipart", true),
            "x-",
            peg$literalExpectation("x-", true),
            function (cseq_value) {
                options = options || { data: {} };
                options.data.value = parseInt(cseq_value.join(''));
            },
            function (expires) { options = options || { data: {} }; options.data = expires; },
            function (event_type) {
                options = options || { data: {} };
                options.data.event = event_type.toLowerCase();
            },
            function () {
                options = options || { data: {} };
                var tag = options.data.tag;
                options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
                if (tag) {
                    options.data.setParam('tag', tag);
                }
            },
            "tag",
            peg$literalExpectation("tag", true),
            function (tag) { options = options || { data: {} }; options.data.tag = tag; },
            function (forwards) {
                options = options || { data: {} };
                options.data = parseInt(forwards.join(''));
            },
            function (min_expires) { options = options || { data: {} }; options.data = min_expires; },
            function () {
                options = options || { data: {} };
                options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
            },
            "digest",
            peg$literalExpectation("Digest", true),
            "realm",
            peg$literalExpectation("realm", true),
            function (realm) { options = options || { data: {} }; options.data.realm = realm; },
            "domain",
            peg$literalExpectation("domain", true),
            "nonce",
            peg$literalExpectation("nonce", true),
            function (nonce) { options = options || { data: {} }; options.data.nonce = nonce; },
            "opaque",
            peg$literalExpectation("opaque", true),
            function (opaque) { options = options || { data: {} }; options.data.opaque = opaque; },
            "stale",
            peg$literalExpectation("stale", true),
            "true",
            peg$literalExpectation("true", true),
            function () { options = options || { data: {} }; options.data.stale = true; },
            "false",
            peg$literalExpectation("false", true),
            function () { options = options || { data: {} }; options.data.stale = false; },
            "algorithm",
            peg$literalExpectation("algorithm", true),
            "md5",
            peg$literalExpectation("MD5", true),
            "md5-sess",
            peg$literalExpectation("MD5-sess", true),
            function (algorithm) {
                options = options || { data: {} };
                options.data.algorithm = algorithm.toUpperCase();
            },
            "qop",
            peg$literalExpectation("qop", true),
            "auth-int",
            peg$literalExpectation("auth-int", true),
            "auth",
            peg$literalExpectation("auth", true),
            function (qop_value) {
                options = options || { data: {} };
                options.data.qop || (options.data.qop = []);
                options.data.qop.push(qop_value.toLowerCase());
            },
            function (rack_value) {
                options = options || { data: {} };
                options.data.value = parseInt(rack_value.join(''));
            },
            function () {
                var idx, length;
                options = options || { data: {} };
                length = options.data.multi_header.length;
                for (idx = 0; idx < length; idx++) {
                    if (options.data.multi_header[idx].parsed === null) {
                        options.data = null;
                        break;
                    }
                }
                if (options.data !== null) {
                    options.data = options.data.multi_header;
                }
                else {
                    options.data = -1;
                }
            },
            function () {
                var header;
                options = options || { data: {} };
                if (!options.data.multi_header)
                    options.data.multi_header = [];
                try {
                    header = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
                    delete options.data.uri;
                    delete options.data.displayName;
                    delete options.data.params;
                }
                catch (e) {
                    header = null;
                }
                options.data.multi_header.push({ 'position': peg$currPos,
                    'offset': location().start.offset,
                    'parsed': header
                });
            },
            function () {
                options = options || { data: {} };
                options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
            },
            function () {
                options = options || { data: {} };
                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
                    options.data = -1;
                }
            },
            function () {
                options = options || { data: {} };
                options.data = {
                    call_id: options.data
                };
            },
            "from-tag",
            peg$literalExpectation("from-tag", true),
            function (from_tag) {
                options = options || { data: {} };
                options.data.replaces_from_tag = from_tag;
            },
            "to-tag",
            peg$literalExpectation("to-tag", true),
            function (to_tag) {
                options = options || { data: {} };
                options.data.replaces_to_tag = to_tag;
            },
            "early-only",
            peg$literalExpectation("early-only", true),
            function () {
                options = options || { data: {} };
                options.data.early_only = true;
            },
            function (head, r) { return r; },
            function (head, tail) { return list(head, tail); },
            function (value) {
                options = options || { data: {} };
                if (options.startRule === 'Require') {
                    options.data = value || [];
                }
            },
            function (rseq_value) {
                options = options || { data: {} };
                options.data.value = parseInt(rseq_value.join(''));
            },
            "active",
            peg$literalExpectation("active", true),
            "pending",
            peg$literalExpectation("pending", true),
            "terminated",
            peg$literalExpectation("terminated", true),
            function () {
                options = options || { data: {} };
                options.data.state = text();
            },
            "reason",
            peg$literalExpectation("reason", true),
            function (reason) {
                options = options || { data: {} };
                if (typeof reason !== 'undefined')
                    options.data.reason = reason;
            },
            function (expires) {
                options = options || { data: {} };
                if (typeof expires !== 'undefined')
                    options.data.expires = expires;
            },
            "retry_after",
            peg$literalExpectation("retry_after", true),
            function (retry_after) {
                options = options || { data: {} };
                if (typeof retry_after !== 'undefined')
                    options.data.retry_after = retry_after;
            },
            "deactivated",
            peg$literalExpectation("deactivated", true),
            "probation",
            peg$literalExpectation("probation", true),
            "rejected",
            peg$literalExpectation("rejected", true),
            "timeout",
            peg$literalExpectation("timeout", true),
            "giveup",
            peg$literalExpectation("giveup", true),
            "noresource",
            peg$literalExpectation("noresource", true),
            "invariant",
            peg$literalExpectation("invariant", true),
            function (value) {
                options = options || { data: {} };
                if (options.startRule === 'Supported') {
                    options.data = value || [];
                }
            },
            function () {
                options = options || { data: {} };
                var tag = options.data.tag;
                options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
                if (tag) {
                    options.data.setParam('tag', tag);
                }
            },
            "ttl",
            peg$literalExpectation("ttl", true),
            function (via_ttl_value) {
                options = options || { data: {} };
                options.data.ttl = via_ttl_value;
            },
            "maddr",
            peg$literalExpectation("maddr", true),
            function (via_maddr) {
                options = options || { data: {} };
                options.data.maddr = via_maddr;
            },
            "received",
            peg$literalExpectation("received", true),
            function (via_received) {
                options = options || { data: {} };
                options.data.received = via_received;
            },
            "branch",
            peg$literalExpectation("branch", true),
            function (via_branch) {
                options = options || { data: {} };
                options.data.branch = via_branch;
            },
            "rport",
            peg$literalExpectation("rport", true),
            function (response_port) {
                options = options || { data: {} };
                if (typeof response_port !== 'undefined')
                    options.data.rport = response_port.join('');
            },
            function (via_protocol) {
                options = options || { data: {} };
                options.data.protocol = via_protocol;
            },
            peg$literalExpectation("UDP", true),
            peg$literalExpectation("TCP", true),
            peg$literalExpectation("TLS", true),
            peg$literalExpectation("SCTP", true),
            function (via_transport) {
                options = options || { data: {} };
                options.data.transport = via_transport;
            },
            function () {
                options = options || { data: {} };
                options.data.host = text();
            },
            function (via_sent_by_port) {
                options = options || { data: {} };
                options.data.port = parseInt(via_sent_by_port.join(''));
            },
            function (ttl) {
                return parseInt(ttl.join(''));
            },
            function (deltaSeconds) {
                options = options || { data: {} };
                if (options.startRule === 'Session_Expires') {
                    options.data.deltaSeconds = deltaSeconds;
                }
            },
            "refresher",
            peg$literalExpectation("refresher", false),
            "uas",
            peg$literalExpectation("uas", false),
            "uac",
            peg$literalExpectation("uac", false),
            function (endpoint) {
                options = options || { data: {} };
                if (options.startRule === 'Session_Expires') {
                    options.data.refresher = endpoint;
                }
            },
            function (deltaSeconds) {
                options = options || { data: {} };
                if (options.startRule === 'Min_SE') {
                    options.data = deltaSeconds;
                }
            },
            "stuns",
            peg$literalExpectation("stuns", true),
            "stun",
            peg$literalExpectation("stun", true),
            function (scheme) {
                options = options || { data: {} };
                options.data.scheme = scheme;
            },
            function (host) {
                options = options || { data: {} };
                options.data.host = host;
            },
            "?transport=",
            peg$literalExpectation("?transport=", false),
            "turns",
            peg$literalExpectation("turns", true),
            "turn",
            peg$literalExpectation("turn", true),
            function (transport) {
                options = options || { data: {} };
                options.data.transport = transport;
            },
            function () {
                options = options || { data: {} };
                options.data = text();
            },
            "Referred-By",
            peg$literalExpectation("Referred-By", false),
            "b",
            peg$literalExpectation("b", false),
            "cid",
            peg$literalExpectation("cid", false)
        ];
        var peg$bytecode = [
            peg$decode("2 \"\"6 7!"),
            peg$decode("4\"\"\"5!7#"),
            peg$decode("4$\"\"5!7%"),
            peg$decode("4&\"\"5!7'"),
            peg$decode(";'.# &;("),
            peg$decode("4(\"\"5!7)"),
            peg$decode("4*\"\"5!7+"),
            peg$decode("2,\"\"6,7-"),
            peg$decode("2.\"\"6.7/"),
            peg$decode("40\"\"5!71"),
            peg$decode("22\"\"6273.\x89 &24\"\"6475.} &26\"\"6677.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"),
            peg$decode(";).# &;,"),
            peg$decode("2F\"\"6F7G.} &2H\"\"6H7I.q &2J\"\"6J7K.e &2L\"\"6L7M.Y &2N\"\"6N7O.M &2P\"\"6P7Q.A &2R\"\"6R7S.5 &2T\"\"6T7U.) &2V\"\"6V7W"),
            peg$decode("%%2X\"\"6X7Y/5#;#/,$;#/#$+#)(#'#(\"'#&'#/\"!&,)"),
            peg$decode("%%$;$0#*;$&/,#; /#$+\")(\"'#&'#.\" &\"/=#$;$/&#0#*;$&&&#/'$8\":Z\" )(\"'#&'#"),
            peg$decode(";..\" &\""),
            peg$decode("%$;'.# &;(0)*;'.# &;(&/?#28\"\"6879/0$;//'$8#:[# )(#'#(\"'#&'#"),
            peg$decode("%%$;2/&#0#*;2&&&#/g#$%$;.0#*;.&/,#;2/#$+\")(\"'#&'#0=*%$;.0#*;.&/,#;2/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/\"!&,)"),
            peg$decode("4\\\"\"5!7].# &;3"),
            peg$decode("4^\"\"5!7_"),
            peg$decode("4`\"\"5!7a"),
            peg$decode(";!.) &4b\"\"5!7c"),
            peg$decode("%$;).\x95 &2F\"\"6F7G.\x89 &2J\"\"6J7K.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O/\x9E#0\x9B*;).\x95 &2F\"\"6F7G.\x89 &2J\"\"6J7K.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O&&&#/\"!&,)"),
            peg$decode("%$;).\x89 &2F\"\"6F7G.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O/\x92#0\x8F*;).\x89 &2F\"\"6F7G.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O&&&#/\"!&,)"),
            peg$decode("2T\"\"6T7U.\xE3 &2V\"\"6V7W.\xD7 &2f\"\"6f7g.\xCB &2h\"\"6h7i.\xBF &2:\"\"6:7;.\xB3 &2D\"\"6D7E.\xA7 &22\"\"6273.\x9B &28\"\"6879.\x8F &2j\"\"6j7k.\x83 &;&.} &24\"\"6475.q &2l\"\"6l7m.e &2n\"\"6n7o.Y &26\"\"6677.M &2>\"\"6>7?.A &2p\"\"6p7q.5 &2r\"\"6r7s.) &;'.# &;("),
            peg$decode("%$;).\u012B &2F\"\"6F7G.\u011F &2J\"\"6J7K.\u0113 &2L\"\"6L7M.\u0107 &2X\"\"6X7Y.\xFB &2P\"\"6P7Q.\xEF &2H\"\"6H7I.\xE3 &2@\"\"6@7A.\xD7 &2d\"\"6d7e.\xCB &2R\"\"6R7S.\xBF &2N\"\"6N7O.\xB3 &2T\"\"6T7U.\xA7 &2V\"\"6V7W.\x9B &2f\"\"6f7g.\x8F &2h\"\"6h7i.\x83 &28\"\"6879.w &2j\"\"6j7k.k &;&.e &24\"\"6475.Y &2l\"\"6l7m.M &2n\"\"6n7o.A &26\"\"6677.5 &2p\"\"6p7q.) &2r\"\"6r7s/\u0134#0\u0131*;).\u012B &2F\"\"6F7G.\u011F &2J\"\"6J7K.\u0113 &2L\"\"6L7M.\u0107 &2X\"\"6X7Y.\xFB &2P\"\"6P7Q.\xEF &2H\"\"6H7I.\xE3 &2@\"\"6@7A.\xD7 &2d\"\"6d7e.\xCB &2R\"\"6R7S.\xBF &2N\"\"6N7O.\xB3 &2T\"\"6T7U.\xA7 &2V\"\"6V7W.\x9B &2f\"\"6f7g.\x8F &2h\"\"6h7i.\x83 &28\"\"6879.w &2j\"\"6j7k.k &;&.e &24\"\"6475.Y &2l\"\"6l7m.M &2n\"\"6n7o.A &26\"\"6677.5 &2p\"\"6p7q.) &2r\"\"6r7s&&&#/\"!&,)"),
            peg$decode("%;//?#2P\"\"6P7Q/0$;//'$8#:t# )(#'#(\"'#&'#"),
            peg$decode("%;//?#24\"\"6475/0$;//'$8#:u# )(#'#(\"'#&'#"),
            peg$decode("%;//?#2>\"\"6>7?/0$;//'$8#:v# )(#'#(\"'#&'#"),
            peg$decode("%;//?#2T\"\"6T7U/0$;//'$8#:w# )(#'#(\"'#&'#"),
            peg$decode("%;//?#2V\"\"6V7W/0$;//'$8#:x# )(#'#(\"'#&'#"),
            peg$decode("%2h\"\"6h7i/0#;//'$8\":y\" )(\"'#&'#"),
            peg$decode("%;//6#2f\"\"6f7g/'$8\":z\" )(\"'#&'#"),
            peg$decode("%;//?#2D\"\"6D7E/0$;//'$8#:{# )(#'#(\"'#&'#"),
            peg$decode("%;//?#22\"\"6273/0$;//'$8#:|# )(#'#(\"'#&'#"),
            peg$decode("%;//?#28\"\"6879/0$;//'$8#:}# )(#'#(\"'#&'#"),
            peg$decode("%;//0#;&/'$8\":~\" )(\"'#&'#"),
            peg$decode("%;&/0#;//'$8\":~\" )(\"'#&'#"),
            peg$decode("%;=/T#$;G.) &;K.# &;F0/*;G.) &;K.# &;F&/,$;>/#$+#)(#'#(\"'#&'#"),
            peg$decode("4\x7F\"\"5!7\x80.A &4\x81\"\"5!7\x82.5 &4\x83\"\"5!7\x84.) &;3.# &;."),
            peg$decode("%%;//Q#;&/H$$;J.# &;K0)*;J.# &;K&/,$;&/#$+$)($'#(#'#(\"'#&'#/\"!&,)"),
            peg$decode("%;//]#;&/T$%$;J.# &;K0)*;J.# &;K&/\"!&,)/1$;&/($8$:\x85$!!)($'#(#'#(\"'#&'#"),
            peg$decode(";..G &2L\"\"6L7M.; &4\x86\"\"5!7\x87./ &4\x83\"\"5!7\x84.# &;3"),
            peg$decode("%2j\"\"6j7k/J#4\x88\"\"5!7\x89.5 &4\x8A\"\"5!7\x8B.) &4\x8C\"\"5!7\x8D/#$+\")(\"'#&'#"),
            peg$decode("%;N/M#28\"\"6879/>$;O.\" &\"/0$;S/'$8$:\x8E$ )($'#(#'#(\"'#&'#"),
            peg$decode("%;N/d#28\"\"6879/U$;O.\" &\"/G$;S/>$;_/5$;l.\" &\"/'$8&:\x8F& )(&'#(%'#($'#(#'#(\"'#&'#"),
            peg$decode("%3\x90\"\"5$7\x91.) &3\x92\"\"5#7\x93/' 8!:\x94!! )"),
            peg$decode("%;P/]#%28\"\"6879/,#;R/#$+\")(\"'#&'#.\" &\"/6$2:\"\"6:7;/'$8#:\x95# )(#'#(\"'#&'#"),
            peg$decode("$;+.) &;-.# &;Q/2#0/*;+.) &;-.# &;Q&&&#"),
            peg$decode("2<\"\"6<7=.q &2>\"\"6>7?.e &2@\"\"6@7A.Y &2B\"\"6B7C.M &2D\"\"6D7E.A &22\"\"6273.5 &26\"\"6677.) &24\"\"6475"),
            peg$decode("%$;+._ &;-.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E0e*;+._ &;-.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E&/& 8!:\x96! )"),
            peg$decode("%;T/J#%28\"\"6879/,#;^/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
            peg$decode("%;U.) &;\\.# &;X/& 8!:\x97! )"),
            peg$decode("%$%;V/2#2J\"\"6J7K/#$+\")(\"'#&'#0<*%;V/2#2J\"\"6J7K/#$+\")(\"'#&'#&/D#;W/;$2J\"\"6J7K.\" &\"/'$8#:\x98# )(#'#(\"'#&'#"),
            peg$decode("$4\x99\"\"5!7\x9A/,#0)*4\x99\"\"5!7\x9A&&&#"),
            peg$decode("%4$\"\"5!7%/?#$4\x9B\"\"5!7\x9C0)*4\x9B\"\"5!7\x9C&/#$+\")(\"'#&'#"),
            peg$decode("%2l\"\"6l7m/?#;Y/6$2n\"\"6n7o/'$8#:\x9D# )(#'#(\"'#&'#"),
            peg$decode("%%;Z/\xB3#28\"\"6879/\xA4$;Z/\x9B$28\"\"6879/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+-)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0790 &%2\x9E\"\"6\x9E7\x9F/\xA4#;Z/\x9B$28\"\"6879/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+,)(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u06F9 &%2\x9E\"\"6\x9E7\x9F/\x8C#;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u067A &%2\x9E\"\"6\x9E7\x9F/t#;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0613 &%2\x9E\"\"6\x9E7\x9F/\\#;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+&)(&'#(%'#($'#(#'#(\"'#&'#.\u05C4 &%2\x9E\"\"6\x9E7\x9F/D#;Z/;$28\"\"6879/,$;[/#$+$)($'#(#'#(\"'#&'#.\u058D &%2\x9E\"\"6\x9E7\x9F/,#;[/#$+\")(\"'#&'#.\u056E &%2\x9E\"\"6\x9E7\x9F/,#;Z/#$+\")(\"'#&'#.\u054F &%;Z/\x9B#2\x9E\"\"6\x9E7\x9F/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$++)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u04C7 &%;Z/\xAA#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x83$2\x9E\"\"6\x9E7\x9F/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0430 &%;Z/\xB9#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x92$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/k$2\x9E\"\"6\x9E7\x9F/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+))()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u038A &%;Z/\xC8#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xA1$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/z$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/S$2\x9E\"\"6\x9E7\x9F/D$;Z/;$28\"\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u02D5 &%;Z/\xD7#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xB0$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x89$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/b$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/;$2\x9E\"\"6\x9E7\x9F/,$;[/#$+')(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0211 &%;Z/\xFE#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xD7$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xB0$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x89$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/b$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/;$2\x9E\"\"6\x9E7\x9F/,$;Z/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0126 &%;Z/\u011C#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xF5$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xCE$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xA7$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x80$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/Y$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/2$2\x9E\"\"6\x9E7\x9F/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/& 8!:\xA0! )"),
            peg$decode("%;#/M#;#.\" &\"/?$;#.\" &\"/1$;#.\" &\"/#$+$)($'#(#'#(\"'#&'#"),
            peg$decode("%;Z/;#28\"\"6879/,$;Z/#$+#)(#'#(\"'#&'#.# &;\\"),
            peg$decode("%;]/o#2J\"\"6J7K/`$;]/W$2J\"\"6J7K/H$;]/?$2J\"\"6J7K/0$;]/'$8':\xA1' )(''#(&'#(%'#($'#(#'#(\"'#&'#"),
            peg$decode("%2\xA2\"\"6\xA27\xA3/2#4\xA4\"\"5!7\xA5/#$+\")(\"'#&'#.\x98 &%2\xA6\"\"6\xA67\xA7/;#4\xA8\"\"5!7\xA9/,$;!/#$+#)(#'#(\"'#&'#.j &%2\xAA\"\"6\xAA7\xAB/5#;!/,$;!/#$+#)(#'#(\"'#&'#.B &%4\xAC\"\"5!7\xAD/,#;!/#$+\")(\"'#&'#.# &;!"),
            peg$decode("%%;!.\" &\"/[#;!.\" &\"/M$;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+%)(%'#($'#(#'#(\"'#&'#/' 8!:\xAE!! )"),
            peg$decode("$%22\"\"6273/,#;`/#$+\")(\"'#&'#0<*%22\"\"6273/,#;`/#$+\")(\"'#&'#&"),
            peg$decode(";a.A &;b.; &;c.5 &;d./ &;e.) &;f.# &;g"),
            peg$decode("%3\xAF\"\"5*7\xB0/a#3\xB1\"\"5#7\xB2.G &3\xB3\"\"5#7\xB4.; &3\xB5\"\"5$7\xB6./ &3\xB7\"\"5#7\xB8.# &;6/($8\":\xB9\"! )(\"'#&'#"),
            peg$decode("%3\xBA\"\"5%7\xBB/I#3\xBC\"\"5%7\xBD./ &3\xBE\"\"5\"7\xBF.# &;6/($8\":\xC0\"! )(\"'#&'#"),
            peg$decode("%3\xC1\"\"5'7\xC2/1#;\x90/($8\":\xC3\"! )(\"'#&'#"),
            peg$decode("%3\xC4\"\"5$7\xC5/1#;\xF0/($8\":\xC6\"! )(\"'#&'#"),
            peg$decode("%3\xC7\"\"5&7\xC8/1#;T/($8\":\xC9\"! )(\"'#&'#"),
            peg$decode("%3\xCA\"\"5\"7\xCB/N#%2>\"\"6>7?/,#;6/#$+\")(\"'#&'#.\" &\"/'$8\":\xCC\" )(\"'#&'#"),
            peg$decode("%;h/P#%2>\"\"6>7?/,#;i/#$+\")(\"'#&'#.\" &\"/)$8\":\xCD\"\"! )(\"'#&'#"),
            peg$decode("%$;j/&#0#*;j&&&#/\"!&,)"),
            peg$decode("%$;j/&#0#*;j&&&#/\"!&,)"),
            peg$decode(";k.) &;+.# &;-"),
            peg$decode("2l\"\"6l7m.e &2n\"\"6n7o.Y &24\"\"6475.M &28\"\"6879.A &2<\"\"6<7=.5 &2@\"\"6@7A.) &2B\"\"6B7C"),
            peg$decode("%26\"\"6677/n#;m/e$$%2<\"\"6<7=/,#;m/#$+\")(\"'#&'#0<*%2<\"\"6<7=/,#;m/#$+\")(\"'#&'#&/#$+#)(#'#(\"'#&'#"),
            peg$decode("%;n/A#2>\"\"6>7?/2$;o/)$8#:\xCE#\"\" )(#'#(\"'#&'#"),
            peg$decode("$;p.) &;+.# &;-/2#0/*;p.) &;+.# &;-&&&#"),
            peg$decode("$;p.) &;+.# &;-0/*;p.) &;+.# &;-&"),
            peg$decode("2l\"\"6l7m.e &2n\"\"6n7o.Y &24\"\"6475.M &26\"\"6677.A &28\"\"6879.5 &2@\"\"6@7A.) &2B\"\"6B7C"),
            peg$decode(";\x91.# &;r"),
            peg$decode("%;\x90/G#;'/>$;s/5$;'/,$;\x84/#$+%)(%'#($'#(#'#(\"'#&'#"),
            peg$decode(";M.# &;t"),
            peg$decode("%;\x7F/E#28\"\"6879/6$;u.# &;x/'$8#:\xCF# )(#'#(\"'#&'#"),
            peg$decode("%;v.# &;w/J#%26\"\"6677/,#;\x83/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
            peg$decode("%2\xD0\"\"6\xD07\xD1/:#;\x80/1$;w.\" &\"/#$+#)(#'#(\"'#&'#"),
            peg$decode("%24\"\"6475/,#;{/#$+\")(\"'#&'#"),
            peg$decode("%;z/3#$;y0#*;y&/#$+\")(\"'#&'#"),
            peg$decode(";*.) &;+.# &;-"),
            peg$decode(";+.\x8F &;-.\x89 &22\"\"6273.} &26\"\"6677.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"),
            peg$decode("%;|/e#$%24\"\"6475/,#;|/#$+\")(\"'#&'#0<*%24\"\"6475/,#;|/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
            peg$decode("%$;~0#*;~&/e#$%22\"\"6273/,#;}/#$+\")(\"'#&'#0<*%22\"\"6273/,#;}/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
            peg$decode("$;~0#*;~&"),
            peg$decode(";+.w &;-.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"),
            peg$decode("%%;\"/\x87#$;\".G &;!.A &2@\"\"6@7A.5 &2F\"\"6F7G.) &2J\"\"6J7K0M*;\".G &;!.A &2@\"\"6@7A.5 &2F\"\"6F7G.) &2J\"\"6J7K&/#$+\")(\"'#&'#/& 8!:\xD2! )"),
            peg$decode(";\x81.# &;\x82"),
            peg$decode("%%;O/2#2:\"\"6:7;/#$+\")(\"'#&'#.\" &\"/,#;S/#$+\")(\"'#&'#.\" &\""),
            peg$decode("$;+.\x83 &;-.} &2B\"\"6B7C.q &2D\"\"6D7E.e &22\"\"6273.Y &28\"\"6879.M &2:\"\"6:7;.A &2<\"\"6<7=.5 &2>\"\"6>7?.) &2@\"\"6@7A/\x8C#0\x89*;+.\x83 &;-.} &2B\"\"6B7C.q &2D\"\"6D7E.e &22\"\"6273.Y &28\"\"6879.M &2:\"\"6:7;.A &2<\"\"6<7=.5 &2>\"\"6>7?.) &2@\"\"6@7A&&&#"),
            peg$decode("$;y0#*;y&"),
            peg$decode("%3\x92\"\"5#7\xD3/q#24\"\"6475/b$$;!/&#0#*;!&&&#/L$2J\"\"6J7K/=$$;!/&#0#*;!&&&#/'$8%:\xD4% )(%'#($'#(#'#(\"'#&'#"),
            peg$decode("2\xD5\"\"6\xD57\xD6"),
            peg$decode("2\xD7\"\"6\xD77\xD8"),
            peg$decode("2\xD9\"\"6\xD97\xDA"),
            peg$decode("2\xDB\"\"6\xDB7\xDC"),
            peg$decode("2\xDD\"\"6\xDD7\xDE"),
            peg$decode("2\xDF\"\"6\xDF7\xE0"),
            peg$decode("2\xE1\"\"6\xE17\xE2"),
            peg$decode("2\xE3\"\"6\xE37\xE4"),
            peg$decode("2\xE5\"\"6\xE57\xE6"),
            peg$decode("2\xE7\"\"6\xE77\xE8"),
            peg$decode("2\xE9\"\"6\xE97\xEA"),
            peg$decode("%;\x85.Y &;\x86.S &;\x88.M &;\x89.G &;\x8A.A &;\x8B.; &;\x8C.5 &;\x8F./ &;\x8D.) &;\x8E.# &;6/& 8!:\xEB! )"),
            peg$decode("%;\x84/G#;'/>$;\x92/5$;'/,$;\x94/#$+%)(%'#($'#(#'#(\"'#&'#"),
            peg$decode("%;\x93/' 8!:\xEC!! )"),
            peg$decode("%;!/5#;!/,$;!/#$+#)(#'#(\"'#&'#"),
            peg$decode("%$;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(0G*;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(&/& 8!:\xED! )"),
            peg$decode("%;\xB6/Y#$%;A/,#;\xB6/#$+\")(\"'#&'#06*%;A/,#;\xB6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
            peg$decode("%;9/N#%2:\"\"6:7;/,#;9/#$+\")(\"'#&'#.\" &\"/'$8\":\xEE\" )(\"'#&'#"),
            peg$decode("%;:.c &%;\x98/Y#$%;A/,#;\x98/#$+\")(\"'#&'#06*%;A/,#;\x98/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/& 8!:\xEF! )"),
            peg$decode("%;L.# &;\x99/]#$%;B/,#;\x9B/#$+\")(\"'#&'#06*%;B/,#;\x9B/#$+\")(\"'#&'#&/'$8\":\xF0\" )(\"'#&'#"),
            peg$decode("%;\x9A.\" &\"/>#;@/5$;M/,$;?/#$+$)($'#(#'#(\"'#&'#"),
            peg$decode("%%;6/Y#$%;./,#;6/#$+\")(\"'#&'#06*%;./,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#.# &;H/' 8!:\xF1!! )"),
            peg$decode(";\x9C.) &;\x9D.# &;\xA0"),
            peg$decode("%3\xF2\"\"5!7\xF3/:#;</1$;\x9F/($8#:\xF4#! )(#'#(\"'#&'#"),
            peg$decode("%3\xF5\"\"5'7\xF6/:#;</1$;\x9E/($8#:\xF7#! )(#'#(\"'#&'#"),
            peg$decode("%$;!/&#0#*;!&&&#/' 8!:\xF8!! )"),
            peg$decode("%2\xF9\"\"6\xF97\xFA/o#%2J\"\"6J7K/M#;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+$)($'#(#'#(\"'#&'#.\" &\"/'$8\":\xFB\" )(\"'#&'#"),
            peg$decode("%;6/J#%;</,#;\xA1/#$+\")(\"'#&'#.\" &\"/)$8\":\xFC\"\"! )(\"'#&'#"),
            peg$decode(";6.) &;T.# &;H"),
            peg$decode("%;\xA3/Y#$%;B/,#;\xA4/#$+\")(\"'#&'#06*%;B/,#;\xA4/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
            peg$decode("%3\xFD\"\"5&7\xFE.G &3\xFF\"\"5'7\u0100.; &3\u0101\"\"5$7\u0102./ &3\u0103\"\"5%7\u0104.# &;6/& 8!:\u0105! )"),
            peg$decode(";\xA5.# &;\xA0"),
            peg$decode("%3\u0106\"\"5(7\u0107/M#;</D$3\u0108\"\"5(7\u0109./ &3\u010A\"\"5(7\u010B.# &;6/#$+#)(#'#(\"'#&'#"),
            peg$decode("%;6/Y#$%;A/,#;6/#$+\")(\"'#&'#06*%;A/,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
            peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u010C!! )"),
            peg$decode("%;\xA9/& 8!:\u010D! )"),
            peg$decode("%;\xAA/k#;;/b$;\xAF/Y$$%;B/,#;\xB0/#$+\")(\"'#&'#06*%;B/,#;\xB0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
            peg$decode(";\xAB.# &;\xAC"),
            peg$decode("3\u010E\"\"5$7\u010F.S &3\u0110\"\"5%7\u0111.G &3\u0112\"\"5%7\u0113.; &3\u0114\"\"5%7\u0115./ &3\u0116\"\"5+7\u0117.# &;\xAD"),
            peg$decode("3\u0118\"\"5'7\u0119./ &3\u011A\"\"5)7\u011B.# &;\xAD"),
            peg$decode(";6.# &;\xAE"),
            peg$decode("%3\u011C\"\"5\"7\u011D/,#;6/#$+\")(\"'#&'#"),
            peg$decode(";\xAD.# &;6"),
            peg$decode("%;6/5#;</,$;\xB1/#$+#)(#'#(\"'#&'#"),
            peg$decode(";6.# &;H"),
            peg$decode("%;\xB3/5#;./,$;\x90/#$+#)(#'#(\"'#&'#"),
            peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u011E!! )"),
            peg$decode("%;\x9E/' 8!:\u011F!! )"),
            peg$decode("%;\xB6/^#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/($8\":\u0120\"!!)(\"'#&'#"),
            peg$decode("%%;7/e#$%2J\"\"6J7K/,#;7/#$+\")(\"'#&'#0<*%2J\"\"6J7K/,#;7/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/\"!&,)"),
            peg$decode("%;L.# &;\x99/]#$%;B/,#;\xB8/#$+\")(\"'#&'#06*%;B/,#;\xB8/#$+\")(\"'#&'#&/'$8\":\u0121\" )(\"'#&'#"),
            peg$decode(";\xB9.# &;\xA0"),
            peg$decode("%3\u0122\"\"5#7\u0123/:#;</1$;6/($8#:\u0124#! )(#'#(\"'#&'#"),
            peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u0125!! )"),
            peg$decode("%;\x9E/' 8!:\u0126!! )"),
            peg$decode("%$;\x9A0#*;\x9A&/x#;@/o$;M/f$;?/]$$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8%:\u0127% )(%'#($'#(#'#(\"'#&'#"),
            peg$decode(";\xBE"),
            peg$decode("%3\u0128\"\"5&7\u0129/k#;./b$;\xC1/Y$$%;A/,#;\xC1/#$+\")(\"'#&'#06*%;A/,#;\xC1/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#.# &;\xBF"),
            peg$decode("%;6/k#;./b$;\xC0/Y$$%;A/,#;\xC0/#$+\")(\"'#&'#06*%;A/,#;\xC0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
            peg$decode("%;6/;#;</2$;6.# &;H/#$+#)(#'#(\"'#&'#"),
            peg$decode(";\xC2.G &;\xC4.A &;\xC6.; &;\xC8.5 &;\xC9./ &;\xCA.) &;\xCB.# &;\xC0"),
            peg$decode("%3\u012A\"\"5%7\u012B/5#;</,$;\xC3/#$+#)(#'#(\"'#&'#"),
            peg$decode("%;I/' 8!:\u012C!! )"),
            peg$decode("%3\u012D\"\"5&7\u012E/\x97#;</\x8E$;D/\x85$;\xC5/|$$%$;'/&#0#*;'&&&#/,#;\xC5/#$+\")(\"'#&'#0C*%$;'/&#0#*;'&&&#/,#;\xC5/#$+\")(\"'#&'#&/,$;E/#$+&)(&'#(%'#($'#(#'#(\"'#&'#"),
            peg$decode(";t.# &;w"),
            peg$decode("%3\u012F\"\"5%7\u0130/5#;</,$;\xC7/#$+#)(#'#(\"'#&'#"),
            peg$decode("%;I/' 8!:\u0131!! )"),
            peg$decode("%3\u0132\"\"5&7\u0133/:#;</1$;I/($8#:\u0134#! )(#'#(\"'#&'#"),
            peg$decode("%3\u0135\"\"5%7\u0136/]#;</T$%3\u0137\"\"5$7\u0138/& 8!:\u0139! ).4 &%3\u013A\"\"5%7\u013B/& 8!:\u013C! )/#$+#)(#'#(\"'#&'#"),
            peg$decode("%3\u013D\"\"5)7\u013E/R#;</I$3\u013F\"\"5#7\u0140./ &3\u0141\"\"5(7\u0142.# &;6/($8#:\u0143#! )(#'#(\"'#&'#"),
            peg$decode("%3\u0144\"\"5#7\u0145/\x93#;</\x8A$;D/\x81$%;\xCC/e#$%2D\"\"6D7E/,#;\xCC/#$+\")(\"'#&'#0<*%2D\"\"6D7E/,#;\xCC/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#"),
            peg$decode("%3\u0146\"\"5(7\u0147./ &3\u0148\"\"5$7\u0149.# &;6/' 8!:\u014A!! )"),
            peg$decode("%;6/Y#$%;A/,#;6/#$+\")(\"'#&'#06*%;A/,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
            peg$decode("%;\xCF/G#;./>$;\xCF/5$;./,$;\x90/#$+%)(%'#($'#(#'#(\"'#&'#"),
            peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u014B!! )"),
            peg$decode("%;\xD1/]#$%;A/,#;\xD1/#$+\")(\"'#&'#06*%;A/,#;\xD1/#$+\")(\"'#&'#&/'$8\":\u014C\" )(\"'#&'#"),
            peg$decode("%;\x99/]#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8\":\u014D\" )(\"'#&'#"),
            peg$decode("%;L.O &;\x99.I &%;@.\" &\"/:#;t/1$;?.\" &\"/#$+#)(#'#(\"'#&'#/]#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8\":\u014E\" )(\"'#&'#"),
            peg$decode("%;\xD4/]#$%;B/,#;\xD5/#$+\")(\"'#&'#06*%;B/,#;\xD5/#$+\")(\"'#&'#&/'$8\":\u014F\" )(\"'#&'#"),
            peg$decode("%;\x96/& 8!:\u0150! )"),
            peg$decode("%3\u0151\"\"5(7\u0152/:#;</1$;6/($8#:\u0153#! )(#'#(\"'#&'#.g &%3\u0154\"\"5&7\u0155/:#;</1$;6/($8#:\u0156#! )(#'#(\"'#&'#.: &%3\u0157\"\"5*7\u0158/& 8!:\u0159! ).# &;\xA0"),
            peg$decode("%%;6/k#$%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#0<*%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#&/)$8\":\u015B\"\"! )(\"'#&'#.\" &\"/' 8!:\u015C!! )"),
            peg$decode("%;\xD8/Y#$%;A/,#;\xD8/#$+\")(\"'#&'#06*%;A/,#;\xD8/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
            peg$decode("%;\x99/Y#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
            peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u015D!! )"),
            peg$decode("%;\xDB/Y#$%;B/,#;\xDC/#$+\")(\"'#&'#06*%;B/,#;\xDC/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
            peg$decode("%3\u015E\"\"5&7\u015F.; &3\u0160\"\"5'7\u0161./ &3\u0162\"\"5*7\u0163.# &;6/& 8!:\u0164! )"),
            peg$decode("%3\u0165\"\"5&7\u0166/:#;</1$;\xDD/($8#:\u0167#! )(#'#(\"'#&'#.} &%3\xF5\"\"5'7\xF6/:#;</1$;\x9E/($8#:\u0168#! )(#'#(\"'#&'#.P &%3\u0169\"\"5+7\u016A/:#;</1$;\x9E/($8#:\u016B#! )(#'#(\"'#&'#.# &;\xA0"),
            peg$decode("3\u016C\"\"5+7\u016D.k &3\u016E\"\"5)7\u016F._ &3\u0170\"\"5(7\u0171.S &3\u0172\"\"5'7\u0173.G &3\u0174\"\"5&7\u0175.; &3\u0176\"\"5*7\u0177./ &3\u0178\"\"5)7\u0179.# &;6"),
            peg$decode(";1.\" &\""),
            peg$decode("%%;6/k#$%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#0<*%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#&/)$8\":\u015B\"\"! )(\"'#&'#.\" &\"/' 8!:\u017A!! )"),
            peg$decode("%;L.# &;\x99/]#$%;B/,#;\xE1/#$+\")(\"'#&'#06*%;B/,#;\xE1/#$+\")(\"'#&'#&/'$8\":\u017B\" )(\"'#&'#"),
            peg$decode(";\xB9.# &;\xA0"),
            peg$decode("%;\xE3/Y#$%;A/,#;\xE3/#$+\")(\"'#&'#06*%;A/,#;\xE3/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
            peg$decode("%;\xEA/k#;./b$;\xED/Y$$%;B/,#;\xE4/#$+\")(\"'#&'#06*%;B/,#;\xE4/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
            peg$decode(";\xE5.; &;\xE6.5 &;\xE7./ &;\xE8.) &;\xE9.# &;\xA0"),
            peg$decode("%3\u017C\"\"5#7\u017D/:#;</1$;\xF0/($8#:\u017E#! )(#'#(\"'#&'#"),
            peg$decode("%3\u017F\"\"5%7\u0180/:#;</1$;T/($8#:\u0181#! )(#'#(\"'#&'#"),
            peg$decode("%3\u0182\"\"5(7\u0183/F#;</=$;\\.) &;Y.# &;X/($8#:\u0184#! )(#'#(\"'#&'#"),
            peg$decode("%3\u0185\"\"5&7\u0186/:#;</1$;6/($8#:\u0187#! )(#'#(\"'#&'#"),
            peg$decode("%3\u0188\"\"5%7\u0189/A#;</8$$;!0#*;!&/($8#:\u018A#! )(#'#(\"'#&'#"),
            peg$decode("%;\xEB/G#;;/>$;6/5$;;/,$;\xEC/#$+%)(%'#($'#(#'#(\"'#&'#"),
            peg$decode("%3\x92\"\"5#7\xD3.# &;6/' 8!:\u018B!! )"),
            peg$decode("%3\xB1\"\"5#7\u018C.G &3\xB3\"\"5#7\u018D.; &3\xB7\"\"5#7\u018E./ &3\xB5\"\"5$7\u018F.# &;6/' 8!:\u0190!! )"),
            peg$decode("%;\xEE/D#%;C/,#;\xEF/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
            peg$decode("%;U.) &;\\.# &;X/& 8!:\u0191! )"),
            peg$decode("%%;!.\" &\"/[#;!.\" &\"/M$;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+%)(%'#($'#(#'#(\"'#&'#/' 8!:\u0192!! )"),
            peg$decode("%%;!/?#;!.\" &\"/1$;!.\" &\"/#$+#)(#'#(\"'#&'#/' 8!:\u0193!! )"),
            peg$decode(";\xBE"),
            peg$decode("%;\x9E/^#$%;B/,#;\xF3/#$+\")(\"'#&'#06*%;B/,#;\xF3/#$+\")(\"'#&'#&/($8\":\u0194\"!!)(\"'#&'#"),
            peg$decode(";\xF4.# &;\xA0"),
            peg$decode("%2\u0195\"\"6\u01957\u0196/L#;</C$2\u0197\"\"6\u01977\u0198.) &2\u0199\"\"6\u01997\u019A/($8#:\u019B#! )(#'#(\"'#&'#"),
            peg$decode("%;\x9E/^#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/($8\":\u019C\"!!)(\"'#&'#"),
            peg$decode("%;6/5#;0/,$;\xF7/#$+#)(#'#(\"'#&'#"),
            peg$decode("$;2.) &;4.# &;.0/*;2.) &;4.# &;.&"),
            peg$decode("$;%0#*;%&"),
            peg$decode("%;\xFA/;#28\"\"6879/,$;\xFB/#$+#)(#'#(\"'#&'#"),
            peg$decode("%3\u019D\"\"5%7\u019E.) &3\u019F\"\"5$7\u01A0/' 8!:\u01A1!! )"),
            peg$decode("%;\xFC/J#%28\"\"6879/,#;^/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
            peg$decode("%;\\.) &;X.# &;\x82/' 8!:\u01A2!! )"),
            peg$decode(";\".S &;!.M &2F\"\"6F7G.A &2J\"\"6J7K.5 &2H\"\"6H7I.) &2N\"\"6N7O"),
            peg$decode("2L\"\"6L7M.\x95 &2B\"\"6B7C.\x89 &2<\"\"6<7=.} &2R\"\"6R7S.q &2T\"\"6T7U.e &2V\"\"6V7W.Y &2P\"\"6P7Q.M &2@\"\"6@7A.A &2D\"\"6D7E.5 &22\"\"6273.) &2>\"\"6>7?"),
            peg$decode("%;\u0100/b#28\"\"6879/S$;\xFB/J$%2\u01A3\"\"6\u01A37\u01A4/,#;\xEC/#$+\")(\"'#&'#.\" &\"/#$+$)($'#(#'#(\"'#&'#"),
            peg$decode("%3\u01A5\"\"5%7\u01A6.) &3\u01A7\"\"5$7\u01A8/' 8!:\u01A1!! )"),
            peg$decode("%3\xB1\"\"5#7\xB2.6 &3\xB3\"\"5#7\xB4.* &$;+0#*;+&/' 8!:\u01A9!! )"),
            peg$decode("%;\u0104/\x87#2F\"\"6F7G/x$;\u0103/o$2F\"\"6F7G/`$;\u0103/W$2F\"\"6F7G/H$;\u0103/?$2F\"\"6F7G/0$;\u0105/'$8):\u01AA) )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
            peg$decode("%;#/>#;#/5$;#/,$;#/#$+$)($'#(#'#(\"'#&'#"),
            peg$decode("%;\u0103/,#;\u0103/#$+\")(\"'#&'#"),
            peg$decode("%;\u0103/5#;\u0103/,$;\u0103/#$+#)(#'#(\"'#&'#"),
            peg$decode("%;q/T#$;m0#*;m&/D$%; /,#;\xF8/#$+\")(\"'#&'#.\" &\"/#$+#)(#'#(\"'#&'#"),
            peg$decode("%2\u01AB\"\"6\u01AB7\u01AC.) &2\u01AD\"\"6\u01AD7\u01AE/w#;0/n$;\u0108/e$$%;B/2#;\u0109.# &;\xA0/#$+\")(\"'#&'#0<*%;B/2#;\u0109.# &;\xA0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
            peg$decode(";\x99.# &;L"),
            peg$decode("%2\u01AF\"\"6\u01AF7\u01B0/5#;</,$;\u010A/#$+#)(#'#(\"'#&'#"),
            peg$decode("%;D/S#;,/J$2:\"\"6:7;/;$;,.# &;T/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#")
        ];
        var peg$currPos = 0;
        var peg$savedPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if (options.startRule !== undefined) {
            if (!(options.startRule in peg$startRuleIndices)) {
                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
            }
            peg$startRuleIndex = peg$startRuleIndices[options.startRule];
        }
        function text() {
            return input.substring(peg$savedPos, peg$currPos);
        }
        function location() {
            return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function expected(description, location1) {
            location1 = location1 !== undefined
                ? location1
                : peg$computeLocation(peg$savedPos, peg$currPos);
            throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location1);
        }
        function error(message, location1) {
            location1 = location1 !== undefined
                ? location1
                : peg$computeLocation(peg$savedPos, peg$currPos);
            throw peg$buildSimpleError(message, location1);
        }
        function peg$literalExpectation(text1, ignoreCase) {
            return { type: "literal", text: text1, ignoreCase: ignoreCase };
        }
        function peg$classExpectation(parts, inverted, ignoreCase) {
            return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
        }
        function peg$anyExpectation() {
            return { type: "any" };
        }
        function peg$endExpectation() {
            return { type: "end" };
        }
        function peg$otherExpectation(description) {
            return { type: "other", description: description };
        }
        function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
                return details;
            }
            else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                    p--;
                }
                details = peg$posDetailsCache[p];
                details = {
                    line: details.line,
                    column: details.column
                };
                while (p < pos) {
                    if (input.charCodeAt(p) === 10) {
                        details.line++;
                        details.column = 1;
                    }
                    else {
                        details.column++;
                    }
                    p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
            }
        }
        function peg$computeLocation(startPos, endPos) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            return {
                start: {
                    offset: startPos,
                    line: startPosDetails.line,
                    column: startPosDetails.column
                },
                end: {
                    offset: endPos,
                    line: endPosDetails.line,
                    column: endPosDetails.column
                }
            };
        }
        function peg$fail(expected1) {
            if (peg$currPos < peg$maxFailPos) {
                return;
            }
            if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected1);
        }
        function peg$buildSimpleError(message, location1) {
            return new SyntaxError(message, [], "", location1);
        }
        function peg$buildStructuredError(expected1, found, location1) {
            return new SyntaxError(SyntaxError.buildMessage(expected1, found), expected1, found, location1);
        }
        function peg$decode(s) {
            return s.split("").map(function (ch) { return ch.charCodeAt(0) - 32; });
        }
        function peg$parseRule(index) {
            var bc = peg$bytecode[index];
            var ip = 0;
            var ips = [];
            var end = bc.length;
            var ends = [];
            var stack = [];
            var params;
            while (true) {
                while (ip < end) {
                    switch (bc[ip]) {
                        case 0:
                            stack.push(peg$consts[bc[ip + 1]]);
                            ip += 2;
                            break;
                        case 1:
                            stack.push(undefined);
                            ip++;
                            break;
                        case 2:
                            stack.push(null);
                            ip++;
                            break;
                        case 3:
                            stack.push(peg$FAILED);
                            ip++;
                            break;
                        case 4:
                            stack.push([]);
                            ip++;
                            break;
                        case 5:
                            stack.push(peg$currPos);
                            ip++;
                            break;
                        case 6:
                            stack.pop();
                            ip++;
                            break;
                        case 7:
                            peg$currPos = stack.pop();
                            ip++;
                            break;
                        case 8:
                            stack.length -= bc[ip + 1];
                            ip += 2;
                            break;
                        case 9:
                            stack.splice(-2, 1);
                            ip++;
                            break;
                        case 10:
                            stack[stack.length - 2].push(stack.pop());
                            ip++;
                            break;
                        case 11:
                            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
                            ip += 2;
                            break;
                        case 12:
                            stack.push(input.substring(stack.pop(), peg$currPos));
                            ip++;
                            break;
                        case 13:
                            ends.push(end);
                            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                            if (stack[stack.length - 1]) {
                                end = ip + 3 + bc[ip + 1];
                                ip += 3;
                            }
                            else {
                                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                ip += 3 + bc[ip + 1];
                            }
                            break;
                        case 14:
                            ends.push(end);
                            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                            if (stack[stack.length - 1] === peg$FAILED) {
                                end = ip + 3 + bc[ip + 1];
                                ip += 3;
                            }
                            else {
                                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                ip += 3 + bc[ip + 1];
                            }
                            break;
                        case 15:
                            ends.push(end);
                            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                            if (stack[stack.length - 1] !== peg$FAILED) {
                                end = ip + 3 + bc[ip + 1];
                                ip += 3;
                            }
                            else {
                                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                ip += 3 + bc[ip + 1];
                            }
                            break;
                        case 16:
                            if (stack[stack.length - 1] !== peg$FAILED) {
                                ends.push(end);
                                ips.push(ip);
                                end = ip + 2 + bc[ip + 1];
                                ip += 2;
                            }
                            else {
                                ip += 2 + bc[ip + 1];
                            }
                            break;
                        case 17:
                            ends.push(end);
                            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                            if (input.length > peg$currPos) {
                                end = ip + 3 + bc[ip + 1];
                                ip += 3;
                            }
                            else {
                                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                ip += 3 + bc[ip + 1];
                            }
                            break;
                        case 18:
                            ends.push(end);
                            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                                end = ip + 4 + bc[ip + 2];
                                ip += 4;
                            }
                            else {
                                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                                ip += 4 + bc[ip + 2];
                            }
                            break;
                        case 19:
                            ends.push(end);
                            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                                end = ip + 4 + bc[ip + 2];
                                ip += 4;
                            }
                            else {
                                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                                ip += 4 + bc[ip + 2];
                            }
                            break;
                        case 20:
                            ends.push(end);
                            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                            if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                                end = ip + 4 + bc[ip + 2];
                                ip += 4;
                            }
                            else {
                                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                                ip += 4 + bc[ip + 2];
                            }
                            break;
                        case 21:
                            stack.push(input.substr(peg$currPos, bc[ip + 1]));
                            peg$currPos += bc[ip + 1];
                            ip += 2;
                            break;
                        case 22:
                            stack.push(peg$consts[bc[ip + 1]]);
                            peg$currPos += peg$consts[bc[ip + 1]].length;
                            ip += 2;
                            break;
                        case 23:
                            stack.push(peg$FAILED);
                            if (peg$silentFails === 0) {
                                peg$fail(peg$consts[bc[ip + 1]]);
                            }
                            ip += 2;
                            break;
                        case 24:
                            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
                            ip += 2;
                            break;
                        case 25:
                            peg$savedPos = peg$currPos;
                            ip++;
                            break;
                        case 26:
                            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3])
                                .map(function (p) { return stack[stack.length - 1 - p]; });
                            stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));
                            ip += 4 + bc[ip + 3];
                            break;
                        case 27:
                            stack.push(peg$parseRule(bc[ip + 1]));
                            ip += 2;
                            break;
                        case 28:
                            peg$silentFails++;
                            ip++;
                            break;
                        case 29:
                            peg$silentFails--;
                            ip++;
                            break;
                        default:
                            throw new Error("Invalid opcode: " + bc[ip] + ".");
                    }
                }
                if (ends.length > 0) {
                    end = ends.pop();
                    ip = ips.pop();
                }
                else {
                    break;
                }
            }
            return stack[0];
        }
        options.data = {}; // Object to which header attributes will be assigned during parsing
        function list(head, tail) {
            return [head].concat(tail);
        }
        peg$result = peg$parseRule(peg$startRuleIndex);
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
        }
        else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length
                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
    }
    exports.parse = peg$parse;
    
    
    /***/ }),
    
    /***/ "./src/platform/web/index.ts":
    /*!***********************************!*\
      !*** ./src/platform/web/index.ts ***!
      \***********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    tslib_1.__exportStar(__webpack_require__(/*! ./modifiers */ "./src/platform/web/modifiers.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./session-description-handler */ "./src/platform/web/session-description-handler.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./simple-user */ "./src/platform/web/simple-user/index.ts"), exports);
    tslib_1.__exportStar(__webpack_require__(/*! ./transport */ "./src/platform/web/transport.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/platform/web/modifiers.ts":
    /*!***************************************!*\
      !*** ./src/platform/web/modifiers.ts ***!
      \***************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var stripPayload = function (sdp, payload) {
        var mediaDescs = [];
        var lines = sdp.split(/\r\n/);
        var currentMediaDesc;
        for (var i = 0; i < lines.length;) {
            var line = lines[i];
            if (/^m=(?:audio|video)/.test(line)) {
                currentMediaDesc = {
                    index: i,
                    stripped: []
                };
                mediaDescs.push(currentMediaDesc);
            }
            else if (currentMediaDesc) {
                var rtpmap = /^a=rtpmap:(\d+) ([^/]+)\//.exec(line);
                if (rtpmap && payload === rtpmap[2]) {
                    lines.splice(i, 1);
                    currentMediaDesc.stripped.push(rtpmap[1]);
                    continue; // Don't increment 'i'
                }
            }
            i++;
        }
        for (var _i = 0, mediaDescs_1 = mediaDescs; _i < mediaDescs_1.length; _i++) {
            var mediaDesc = mediaDescs_1[_i];
            var mline = lines[mediaDesc.index].split(" ");
            // Ignore the first 3 parameters of the mline. The codec information is after that
            for (var j = 3; j < mline.length;) {
                if (mediaDesc.stripped.indexOf(mline[j]) !== -1) {
                    mline.splice(j, 1);
                    continue;
                }
                j++;
            }
            lines[mediaDesc.index] = mline.join(" ");
        }
        return lines.join("\r\n");
    };
    var stripMediaDescription = function (sdp, description) {
        var descriptionRegExp = new RegExp("m=" + description + ".*$", "gm");
        var groupRegExp = new RegExp("^a=group:.*$", "gm");
        if (descriptionRegExp.test(sdp)) {
            var midLineToRemove_1;
            sdp = sdp.split(/^m=/gm).filter(function (section) {
                if (section.substr(0, description.length) === description) {
                    midLineToRemove_1 = section.match(/^a=mid:.*$/gm);
                    if (midLineToRemove_1) {
                        var step = midLineToRemove_1[0].match(/:.+$/g);
                        if (step) {
                            midLineToRemove_1 = step[0].substr(1);
                        }
                    }
                    return false;
                }
                return true;
            }).join("m=");
            var groupLine = sdp.match(groupRegExp);
            if (groupLine && groupLine.length === 1) {
                var groupLinePortion = groupLine[0];
                var groupRegExpReplace = new RegExp("\ *" + midLineToRemove_1 + "[^\ ]*", "g");
                groupLinePortion = groupLinePortion.replace(groupRegExpReplace, "");
                sdp = sdp.split(groupRegExp).join(groupLinePortion);
            }
        }
        return sdp;
    };
    /**
     * Modifier.
     * @public
     */
    function stripTcpCandidates(description) {
        description.sdp = (description.sdp || "").replace(/^a=candidate:\d+ \d+ tcp .*?\r\n/img, "");
        return Promise.resolve(description);
    }
    exports.stripTcpCandidates = stripTcpCandidates;
    /**
     * Modifier.
     * @public
     */
    function stripTelephoneEvent(description) {
        description.sdp = stripPayload(description.sdp || "", "telephone-event");
        return Promise.resolve(description);
    }
    exports.stripTelephoneEvent = stripTelephoneEvent;
    /**
     * Modifier.
     * @public
     */
    function cleanJitsiSdpImageattr(description) {
        description.sdp = (description.sdp || "").replace(/^(a=imageattr:.*?)(x|y)=\[0-/gm, "$1$2=[1:");
        return Promise.resolve(description);
    }
    exports.cleanJitsiSdpImageattr = cleanJitsiSdpImageattr;
    /**
     * Modifier.
     * @public
     */
    function stripG722(description) {
        description.sdp = stripPayload(description.sdp || "", "G722");
        return Promise.resolve(description);
    }
    exports.stripG722 = stripG722;
    /**
     * Modifier.
     * @public
     */
    function stripRtpPayload(payload) {
        return function (description) {
            description.sdp = stripPayload(description.sdp || "", payload);
            return Promise.resolve(description);
        };
    }
    exports.stripRtpPayload = stripRtpPayload;
    /**
     * Modifier.
     * @public
     */
    function stripVideo(description) {
        description.sdp = stripMediaDescription(description.sdp || "", "video");
        return Promise.resolve(description);
    }
    exports.stripVideo = stripVideo;
    /**
     * Modifier.
     * @public
     */
    function addMidLines(description) {
        var sdp = description.sdp || "";
        if (sdp.search(/^a=mid.*$/gm) === -1) {
            var mlines_1 = sdp.match(/^m=.*$/gm);
            var sdpArray_1 = sdp.split(/^m=.*$/gm);
            if (mlines_1) {
                mlines_1.forEach(function (elem, idx) {
                    mlines_1[idx] = elem + "\na=mid:" + idx;
                });
            }
            sdpArray_1.forEach(function (elem, idx) {
                if (mlines_1 && mlines_1[idx]) {
                    sdpArray_1[idx] = elem + mlines_1[idx];
                }
            });
            sdp = sdpArray_1.join("");
            description.sdp = sdp;
        }
        return Promise.resolve(description);
    }
    exports.addMidLines = addMidLines;
    
    
    /***/ }),
    
    /***/ "./src/platform/web/session-description-handler.ts":
    /*!*********************************************************!*\
      !*** ./src/platform/web/session-description-handler.ts ***!
      \*********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
    var exceptions_1 = __webpack_require__(/*! ../../api/exceptions */ "./src/api/exceptions/index.ts");
    var Modifiers = tslib_1.__importStar(__webpack_require__(/*! ./modifiers */ "./src/platform/web/modifiers.ts"));
    function defer() {
        var deferred = {};
        deferred.promise = new Promise(function (resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        return deferred;
    }
    function reducePromises(arr, val) {
        return arr.reduce(function (acc, fn) {
            acc = acc.then(fn);
            return acc;
        }, Promise.resolve(val));
    }
    /**
     * SessionDescriptionHandler for web browser.
     * @public
     */
    var SessionDescriptionHandler = /** @class */ (function (_super) {
        tslib_1.__extends(SessionDescriptionHandler, _super);
        function SessionDescriptionHandler(logger, options) {
            var _this = _super.call(this) || this;
            // TODO: Validate the options
            _this.options = options || {};
            _this.logger = logger;
            _this.dtmfSender = undefined;
            _this.shouldAcquireMedia = true;
            _this.CONTENT_TYPE = "application/sdp";
            _this.C = {
                DIRECTION: {
                    NULL: null,
                    SENDRECV: "sendrecv",
                    SENDONLY: "sendonly",
                    RECVONLY: "recvonly",
                    INACTIVE: "inactive"
                }
            };
            _this.logger.log("SessionDescriptionHandlerOptions: " + JSON.stringify(_this.options));
            _this.direction = _this.C.DIRECTION.NULL;
            _this.modifiers = _this.options.modifiers || [];
            if (!Array.isArray(_this.modifiers)) {
                _this.modifiers = [_this.modifiers];
            }
            _this.iceGatheringTimeout = false;
            _this.initPeerConnection(_this.options.peerConnectionOptions);
            _this.constraints = _this.checkAndDefaultConstraints(_this.options.constraints);
            return _this;
        }
        SessionDescriptionHandler.defaultFactory = function (session, options) {
            var logger = session.userAgent.getLogger("sip.SessionDescriptionHandler", session.id);
            return new SessionDescriptionHandler(logger, options);
        };
        /**
         * Destructor
         */
        SessionDescriptionHandler.prototype.close = function () {
            this.logger.log("closing PeerConnection");
            // have to check signalingState since this.close() gets called multiple times
            if (this.peerConnection && this.peerConnection.signalingState !== "closed") {
                if (this.peerConnection.getSenders) {
                    this.peerConnection.getSenders().forEach(function (sender) {
                        if (sender.track) {
                            sender.track.stop();
                        }
                    });
                }
                else {
                    this.logger.warn("Using getLocalStreams which is deprecated");
                    this.peerConnection.getLocalStreams().forEach(function (stream) {
                        stream.getTracks().forEach(function (track) {
                            track.stop();
                        });
                    });
                }
                if (this.peerConnection.getReceivers) {
                    this.peerConnection.getReceivers().forEach(function (receiver) {
                        if (receiver.track) {
                            receiver.track.stop();
                        }
                    });
                }
                else {
                    this.logger.warn("Using getRemoteStreams which is deprecated");
                    this.peerConnection.getRemoteStreams().forEach(function (stream) {
                        stream.getTracks().forEach(function (track) {
                            track.stop();
                        });
                    });
                }
                this.resetIceGatheringComplete();
                this.peerConnection.close();
            }
        };
        /**
         * Gets the local description from the underlying media implementation.
         * @remarks
         * Resolves with the local description to be used for the session.
         * @param options - Options object to be used by getDescription
         * @param modifiers - Array with one time use description modifiers
         */
        SessionDescriptionHandler.prototype.getDescription = function (options, modifiers) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (modifiers === void 0) { modifiers = []; }
            if (options.peerConnectionOptions) {
                this.initPeerConnection(options.peerConnectionOptions);
            }
            // Merge passed constraints with saved constraints and save
            var newConstraints = Object.assign({}, this.constraints, options.constraints);
            newConstraints = this.checkAndDefaultConstraints(newConstraints);
            if (JSON.stringify(newConstraints) !== JSON.stringify(this.constraints)) {
                this.constraints = newConstraints;
                this.shouldAcquireMedia = true;
            }
            if (!Array.isArray(modifiers)) {
                modifiers = [modifiers];
            }
            modifiers = modifiers.concat(this.modifiers);
            return Promise.resolve().then(function () {
                if (_this.shouldAcquireMedia) {
                    return _this.acquire(_this.constraints).then(function () {
                        _this.shouldAcquireMedia = false;
                    });
                }
            }).then(function () { return _this.createOfferOrAnswer(options.RTCOfferOptions, modifiers); })
                .then(function (description) {
                if (description.sdp === undefined) {
                    throw new exceptions_1.SessionDescriptionHandlerError("SDP undefined.");
                }
                _this.emit("getDescription", description);
                return {
                    body: description.sdp,
                    contentType: _this.CONTENT_TYPE
                };
            });
        };
        /**
         * Check if the Session Description Handler can handle the Content-Type described by a SIP Message
         * @param contentType - The content type that is in the SIP Message
         */
        SessionDescriptionHandler.prototype.hasDescription = function (contentType) {
            return contentType === this.CONTENT_TYPE;
        };
        /**
         * The modifier that should be used when the session would like to place the call on hold.
         * @remarks
         * Resolves with modified SDP.
         * @param description - The description that will be modified
         */
        SessionDescriptionHandler.prototype.holdModifier = function (description) {
            if (!description.sdp) {
                return Promise.resolve(description);
            }
            if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(description.sdp)) {
                description.sdp = description.sdp.replace(/(m=[^\r]*\r\n)/g, "$1a=sendonly\r\n");
            }
            else {
                description.sdp = description.sdp.replace(/a=sendrecv\r\n/g, "a=sendonly\r\n");
                description.sdp = description.sdp.replace(/a=recvonly\r\n/g, "a=inactive\r\n");
            }
            return Promise.resolve(description);
        };
        /**
         * Set the remote description to the underlying media implementation.
         * @remarks
         * Resolves once the description is set.
         * @param sessionDescription - The description provided by a SIP message to be set on the media implementation.
         * @param options - Options object to be used by getDescription.
         * @param modifiers - Array with one time use description modifiers.
         */
        SessionDescriptionHandler.prototype.setDescription = function (sessionDescription, options, modifiers) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (modifiers === void 0) { modifiers = []; }
            if (options.peerConnectionOptions) {
                this.initPeerConnection(options.peerConnectionOptions);
            }
            if (!Array.isArray(modifiers)) {
                modifiers = [modifiers];
            }
            modifiers = modifiers.concat(this.modifiers);
            var description = {
                type: this.hasOffer("local") ? "answer" : "offer",
                sdp: sessionDescription
            };
            return Promise.resolve().then(function () {
                // Media should be acquired in getDescription unless we need to do it sooner for some reason (FF61+)
                if (_this.shouldAcquireMedia && _this.options.alwaysAcquireMediaFirst) {
                    return _this.acquire(_this.constraints).then(function () {
                        _this.shouldAcquireMedia = false;
                    });
                }
            }).then(function () { return reducePromises(modifiers, description); })
                .catch(function (e) {
                if (e instanceof exceptions_1.SessionDescriptionHandlerError) {
                    throw e;
                }
                var message = "The modifiers did not resolve successfully.";
                if (e.name) {
                    message += " " + e.name;
                }
                if (e.message) {
                    message += " " + e.message;
                }
                var error = new exceptions_1.SessionDescriptionHandlerError(message);
                _this.logger.error(message);
                _this.emit("peerConnection-setRemoteDescriptionFailed", error);
                throw error;
            }).then(function (modifiedDescription) {
                _this.emit("setDescription", modifiedDescription);
                return _this.peerConnection.setRemoteDescription(modifiedDescription);
            }).catch(function (e) {
                // Check the original SDP for video, and ensure that we have want to do audio fallback
                if ((/^m=video.+$/gm).test(sessionDescription) && !options.disableAudioFallback) {
                    // Do not try to audio fallback again
                    options.disableAudioFallback = true;
                    // Remove video first, then do the other modifiers
                    return _this.setDescription(sessionDescription, options, [Modifiers.stripVideo].concat(modifiers));
                }
                if (e instanceof exceptions_1.SessionDescriptionHandlerError) {
                    throw e;
                }
                var message = "The modifiers did not resolve successfully.";
                if (e.name) {
                    message += " " + e.name;
                }
                if (e.message) {
                    message += " " + e.message;
                }
                var error = new exceptions_1.SessionDescriptionHandlerError(message);
                _this.logger.error(message);
                _this.emit("peerConnection-setRemoteDescriptionFailed", error);
                throw error;
            }).then(function () {
                if (_this.peerConnection.getReceivers) {
                    _this.emit("setRemoteDescription", _this.peerConnection.getReceivers());
                }
                else {
                    _this.emit("setRemoteDescription", _this.peerConnection.getRemoteStreams());
                }
                _this.emit("confirmed", _this);
            });
        };
        /**
         * Send DTMF via RTP (RFC 4733).
         * @remarks
         * Returns true if DTMF send is successful, false otherwise.
         * @param tones - A string containing DTMF digits.
         * @param options - Options object to be used by sendDtmf.
         */
        SessionDescriptionHandler.prototype.sendDtmf = function (tones, options) {
            if (options === void 0) { options = {}; }
            if (!this.dtmfSender && this.hasBrowserGetSenderSupport()) {
                var senders = this.peerConnection.getSenders();
                if (senders.length > 0) {
                    this.dtmfSender = senders[0].dtmf;
                }
            }
            if (!this.dtmfSender && this.hasBrowserTrackSupport()) {
                var streams = this.peerConnection.getLocalStreams();
                if (streams.length > 0) {
                    var audioTracks = streams[0].getAudioTracks();
                    if (audioTracks.length > 0) {
                        this.dtmfSender = this.peerConnection.createDTMFSender(audioTracks[0]);
                    }
                }
            }
            if (!this.dtmfSender) {
                return false;
            }
            try {
                this.dtmfSender.insertDTMF(tones, options.duration, options.interToneGap);
            }
            catch (e) {
                if (e.type === "InvalidStateError" || e.type === "InvalidCharacterError") {
                    this.logger.error(e);
                    return false;
                }
                else {
                    throw e;
                }
            }
            this.logger.log("DTMF sent via RTP: " + tones.toString());
            return true;
        };
        /**
         * Get the direction of the session description
         */
        SessionDescriptionHandler.prototype.getDirection = function () {
            return this.direction;
        };
        SessionDescriptionHandler.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
        SessionDescriptionHandler.prototype.getMediaStream = function (constraints) {
            return navigator.mediaDevices.getUserMedia(constraints);
        };
        // Internal functions
        SessionDescriptionHandler.prototype.createOfferOrAnswer = function (RTCOfferOptions, modifiers) {
            var _this = this;
            if (RTCOfferOptions === void 0) { RTCOfferOptions = {}; }
            if (modifiers === void 0) { modifiers = []; }
            var methodName = this.hasOffer("remote") ? "createAnswer" : "createOffer";
            var pc = this.peerConnection;
            this.logger.log(methodName);
            var method = this.hasOffer("remote") ? pc.createAnswer : pc.createOffer;
            return method.apply(pc, RTCOfferOptions).catch(function (e) {
                if (e instanceof exceptions_1.SessionDescriptionHandlerError) {
                    throw e;
                }
                var message = "peerConnection-" + methodName + " failed.";
                if (e.name) {
                    message += " " + e.name;
                }
                if (e.message) {
                    message += " " + e.message;
                }
                var error = new exceptions_1.SessionDescriptionHandlerError(message);
                _this.logger.error(message);
                _this.emit("peerConnection-" + methodName + "Failed", error);
                throw error;
            }).then(function (sdp) {
                return reducePromises(modifiers, _this.createRTCSessionDescriptionInit(sdp));
            }).then(function (sdp) {
                _this.resetIceGatheringComplete();
                _this.logger.log("Setting local sdp.");
                _this.logger.log("sdp is " + sdp.sdp || false);
                return pc.setLocalDescription(sdp);
            }).catch(function (e) {
                if (e instanceof exceptions_1.SessionDescriptionHandlerError) {
                    throw e;
                }
                var message = "peerConnection-" + methodName + " failed.";
                if (e.name) {
                    message += " " + e.name;
                }
                if (e.message) {
                    message += " " + e.message;
                }
                var error = new exceptions_1.SessionDescriptionHandlerError(message);
                _this.logger.error(message);
                _this.emit("peerConnection-SetLocalDescriptionFailed", error);
                throw error;
            }).then(function () { return _this.waitForIceGatheringComplete(); })
                .then(function () {
                if (!_this.peerConnection.localDescription) {
                    throw new exceptions_1.SessionDescriptionHandlerError("Missing local description.");
                }
                var localDescription = _this.createRTCSessionDescriptionInit(_this.peerConnection.localDescription);
                return reducePromises(modifiers, localDescription);
            }).then(function (localDescription) {
                _this.setDirection(localDescription.sdp || "");
                return localDescription;
            }).catch(function (e) {
                if (e instanceof exceptions_1.SessionDescriptionHandlerError) {
                    throw e;
                }
                var message = "Error.";
                if (e.name) {
                    message += " " + e.name;
                }
                if (e.message) {
                    message += " " + e.message;
                }
                var error = new exceptions_1.SessionDescriptionHandlerError(message);
                _this.logger.error(message);
                throw error;
            });
        };
        // Creates an RTCSessionDescriptionInit from an RTCSessionDescription
        SessionDescriptionHandler.prototype.createRTCSessionDescriptionInit = function (RTCSessionDescription) {
            return {
                type: RTCSessionDescription.type,
                sdp: RTCSessionDescription.sdp
            };
        };
        SessionDescriptionHandler.prototype.addDefaultIceCheckingTimeout = function (peerConnectionOptions) {
            if (peerConnectionOptions.iceCheckingTimeout === undefined) {
                peerConnectionOptions.iceCheckingTimeout = 5000;
            }
            return peerConnectionOptions;
        };
        SessionDescriptionHandler.prototype.addDefaultIceServers = function (rtcConfiguration) {
            if (!rtcConfiguration.iceServers) {
                rtcConfiguration.iceServers = [{ urls: "stun:stun.l.google.com:19302" }];
            }
            return rtcConfiguration;
        };
        SessionDescriptionHandler.prototype.checkAndDefaultConstraints = function (constraints) {
            var defaultConstraints = { audio: true, video: !this.options.alwaysAcquireMediaFirst };
            constraints = constraints || defaultConstraints;
            // Empty object check
            if (Object.keys(constraints).length === 0 && constraints.constructor === Object) {
                return defaultConstraints;
            }
            return constraints;
        };
        SessionDescriptionHandler.prototype.hasBrowserTrackSupport = function () {
            return Boolean(this.peerConnection.addTrack);
        };
        SessionDescriptionHandler.prototype.hasBrowserGetSenderSupport = function () {
            return Boolean(this.peerConnection.getSenders);
        };
        SessionDescriptionHandler.prototype.initPeerConnection = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            options = this.addDefaultIceCheckingTimeout(options);
            options.rtcConfiguration = options.rtcConfiguration || {};
            options.rtcConfiguration = this.addDefaultIceServers(options.rtcConfiguration);
            this.logger.log("initPeerConnection");
            if (this.peerConnection) {
                this.logger.log("Already have a peer connection for this session. Tearing down.");
                this.resetIceGatheringComplete();
                this.peerConnection.close();
            }
            this.peerConnection = new RTCPeerConnection(options.rtcConfiguration);
            this.logger.log("New peer connection created");
            if ("ontrack" in this.peerConnection) {
                this.peerConnection.addEventListener("track", function (e) {
                    _this.logger.log("track added");
                    _this.emit("addTrack", e);
                });
            }
            else {
                this.logger.warn("Using onaddstream which is deprecated");
                this.peerConnection.onaddstream = function (e) {
                    _this.logger.log("stream added");
                    _this.emit("addStream", e);
                };
            }
            this.peerConnection.onicecandidate = function (e) {
                _this.emit("iceCandidate", e);
                if (e.candidate) {
                    _this.logger.log("ICE candidate received: " +
                        (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));
                }
                else if (e.candidate === null) {
                    // indicates the end of candidate gathering
                    _this.logger.log("ICE candidate gathering complete");
                    _this.triggerIceGatheringComplete();
                }
            };
            this.peerConnection.onicegatheringstatechange = function () {
                _this.logger.log("RTCIceGatheringState changed: " + _this.peerConnection.iceGatheringState);
                switch (_this.peerConnection.iceGatheringState) {
                    case "gathering":
                        _this.emit("iceGathering", _this);
                        if (!_this.iceGatheringTimer && options.iceCheckingTimeout) {
                            _this.iceGatheringTimeout = false;
                            _this.iceGatheringTimer = setTimeout(function () {
                                _this.logger.log("RTCIceChecking Timeout Triggered after " + options.iceCheckingTimeout + " milliseconds");
                                _this.iceGatheringTimeout = true;
                                _this.triggerIceGatheringComplete();
                            }, options.iceCheckingTimeout);
                        }
                        break;
                    case "complete":
                        _this.triggerIceGatheringComplete();
                        break;
                }
            };
            this.peerConnection.oniceconnectionstatechange = function () {
                var stateEvent;
                switch (_this.peerConnection.iceConnectionState) {
                    case "new":
                        stateEvent = "iceConnection";
                        break;
                    case "checking":
                        stateEvent = "iceConnectionChecking";
                        break;
                    case "connected":
                        stateEvent = "iceConnectionConnected";
                        break;
                    case "completed":
                        stateEvent = "iceConnectionCompleted";
                        break;
                    case "failed":
                        stateEvent = "iceConnectionFailed";
                        break;
                    case "disconnected":
                        stateEvent = "iceConnectionDisconnected";
                        break;
                    case "closed":
                        stateEvent = "iceConnectionClosed";
                        break;
                    default:
                        _this.logger.warn("Unknown iceConnection state: " + _this.peerConnection.iceConnectionState);
                        return;
                }
                _this.logger.log("ICE Connection State changed to " + stateEvent);
                _this.emit(stateEvent, _this);
            };
        };
        SessionDescriptionHandler.prototype.acquire = function (constraints) {
            var _this = this;
            // Default audio & video to true
            constraints = this.checkAndDefaultConstraints(constraints);
            return new Promise(function (resolve, reject) {
                /*
                 * Make the call asynchronous, so that ICCs have a chance
                 * to define callbacks to `userMediaRequest`
                 */
                _this.logger.log("acquiring local media");
                _this.emit("userMediaRequest", constraints);
                if (constraints.audio || constraints.video) {
                    _this.getMediaStream(constraints).then(function (streams) {
                        _this.emit("addTrack");
                        _this.emit("userMedia", streams);
                        resolve(streams);
                    }).catch(function (e) {
                        _this.emit("userMediaFailed", e);
                        reject(e);
                    });
                }
                else {
                    // Local streams were explicitly excluded.
                    resolve([]);
                }
            }).catch(function (e /* DOMException */) {
                if (e instanceof exceptions_1.SessionDescriptionHandlerError) {
                    throw e;
                }
                var message = "Unable to acquire streams.";
                if (e.name) {
                    message += " " + e.name;
                }
                if (e.message) {
                    message += " " + e.message;
                }
                var error = new exceptions_1.SessionDescriptionHandlerError(message);
                _this.logger.error(message);
                throw error;
            }).then(function (streams) {
                _this.logger.log("acquired local media streams");
                // Remove old tracks
                if (_this.peerConnection.removeTrack) {
                    _this.peerConnection.getSenders().forEach(function (sender) {
                        _this.peerConnection.removeTrack(sender);
                    });
                }
                return streams;
            }).catch(function (e) {
                if (e instanceof exceptions_1.SessionDescriptionHandlerError) {
                    throw e;
                }
                var message = "Error removing streams.";
                if (e.name) {
                    message += " " + e.name;
                }
                if (e.message) {
                    message += " " + e.message;
                }
                var error = new exceptions_1.SessionDescriptionHandlerError(message);
                _this.logger.error(message);
                throw error;
            }).then(function (streams) {
                var streamsArr = [].concat(streams);
                streamsArr.forEach(function (stream) {
                    if (_this.peerConnection.addTrack) {
                        stream.getTracks().forEach(function (track) {
                            _this.peerConnection.addTrack(track, stream);
                        });
                    }
                    else {
                        // Chrome 59 does not support addTrack
                        _this.peerConnection.addStream(stream);
                    }
                });
                return Promise.resolve();
            }).catch(function (e) {
                if (e instanceof exceptions_1.SessionDescriptionHandlerError) {
                    throw e;
                }
                var message = "Error adding streams.";
                if (e.name) {
                    message += " " + e.name;
                }
                if (e.message) {
                    message += " " + e.message;
                }
                var error = new exceptions_1.SessionDescriptionHandlerError(message);
                _this.logger.error(message);
                throw error;
            });
        };
        SessionDescriptionHandler.prototype.hasOffer = function (where) {
            var offerState = "have-" + where + "-offer";
            return this.peerConnection.signalingState === offerState;
        };
        // ICE gathering state handling
        SessionDescriptionHandler.prototype.isIceGatheringComplete = function () {
            return this.peerConnection.iceGatheringState === "complete" || this.iceGatheringTimeout;
        };
        SessionDescriptionHandler.prototype.resetIceGatheringComplete = function () {
            this.iceGatheringTimeout = false;
            this.logger.log("resetIceGatheringComplete");
            if (this.iceGatheringTimer) {
                clearTimeout(this.iceGatheringTimer);
                this.iceGatheringTimer = undefined;
            }
            if (this.iceGatheringDeferred) {
                this.iceGatheringDeferred.reject();
                this.iceGatheringDeferred = undefined;
            }
        };
        SessionDescriptionHandler.prototype.setDirection = function (sdp) {
            var match = sdp.match(/a=(sendrecv|sendonly|recvonly|inactive)/);
            if (match === null) {
                this.direction = this.C.DIRECTION.NULL;
                this.emit("directionChanged");
                return;
            }
            var direction = match[1];
            switch (direction) {
                case this.C.DIRECTION.SENDRECV:
                case this.C.DIRECTION.SENDONLY:
                case this.C.DIRECTION.RECVONLY:
                case this.C.DIRECTION.INACTIVE:
                    this.direction = direction;
                    break;
                default:
                    this.direction = this.C.DIRECTION.NULL;
                    break;
            }
            this.emit("directionChanged");
        };
        SessionDescriptionHandler.prototype.triggerIceGatheringComplete = function () {
            if (this.isIceGatheringComplete()) {
                this.emit("iceGatheringComplete", this);
                if (this.iceGatheringTimer) {
                    clearTimeout(this.iceGatheringTimer);
                    this.iceGatheringTimer = undefined;
                }
                if (this.iceGatheringDeferred) {
                    this.iceGatheringDeferred.resolve();
                    this.iceGatheringDeferred = undefined;
                }
            }
        };
        SessionDescriptionHandler.prototype.waitForIceGatheringComplete = function () {
            this.logger.log("waitForIceGatheringComplete");
            if (this.isIceGatheringComplete()) {
                this.logger.log("ICE is already complete. Return resolved.");
                return Promise.resolve();
            }
            else if (!this.iceGatheringDeferred) {
                this.iceGatheringDeferred = defer();
            }
            this.logger.log("ICE is not complete. Returning promise");
            return this.iceGatheringDeferred ? this.iceGatheringDeferred.promise : Promise.resolve();
        };
        return SessionDescriptionHandler;
    }(events_1.EventEmitter));
    exports.SessionDescriptionHandler = SessionDescriptionHandler;
    
    
    /***/ }),
    
    /***/ "./src/platform/web/simple-user/index.ts":
    /*!***********************************************!*\
      !*** ./src/platform/web/simple-user/index.ts ***!
      \***********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    /**
     * A simple SIP user implementation for web browsers.
     * @packageDocumentation
     */
    tslib_1.__exportStar(__webpack_require__(/*! ./simple-user */ "./src/platform/web/simple-user/simple-user.ts"), exports);
    
    
    /***/ }),
    
    /***/ "./src/platform/web/simple-user/simple-user.ts":
    /*!*****************************************************!*\
      !*** ./src/platform/web/simple-user/simple-user.ts ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var api_1 = __webpack_require__(/*! ../../../api */ "./src/api/index.ts");
    var session_description_handler_1 = __webpack_require__(/*! ../session-description-handler */ "./src/platform/web/session-description-handler.ts");
    var transport_1 = __webpack_require__(/*! ../transport */ "./src/platform/web/transport.ts");
    /**
     * A simple SIP user class.
     * @remarks
     * While this class is completely functional for simple use cases, it is not intended
     * to provide an interface which is suitable for most (must less all) applications.
     * While this class has many limitations (for example, it only handles a single concurrent session),
     * it is, however, intended to serve as a simple example of using the SIP.js API.
     * @public
     */
    var SimpleUser = /** @class */ (function () {
        /**
         * Constructs a new instance of the `SimpleUser` class.
         * @param server - SIP WebSocket Server URL.
         * @param options - Options bucket. See {@link SimpleUserOptions} for details.
         */
        function SimpleUser(server, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            this.attemptingReconnection = false;
            this.connectRequested = false;
            this.held = false;
            this.registerer = undefined;
            this.registerRequested = false;
            this.session = undefined;
            // Delegate
            this.delegate = options.delegate;
            // Copy options
            this.options = tslib_1.__assign({}, options);
            // UserAgentOptions
            var userAgentOptions = tslib_1.__assign({}, options.userAgentOptions);
            // Transport
            if (!userAgentOptions.transportConstructor) {
                userAgentOptions.transportConstructor = transport_1.Transport;
            }
            // TransportOptions
            if (!userAgentOptions.transportOptions) {
                userAgentOptions.transportOptions = {
                    server: server
                };
            }
            // URI
            if (!userAgentOptions.uri) {
                // If an AOR was provided, convert it to a URI
                if (options.aor) {
                    var uri = api_1.UserAgent.makeURI(options.aor);
                    if (!uri) {
                        throw new Error("Failed to create valid URI from " + options.aor);
                    }
                    userAgentOptions.uri = uri;
                }
            }
            // UserAgent
            this.userAgent = new api_1.UserAgent(userAgentOptions);
            // UserAgent's delegate
            this.userAgent.delegate = {
                // Handle connection with server established
                onConnect: function () {
                    _this.logger.log("[" + _this.id + "] Connected");
                    if (_this.delegate && _this.delegate.onServerConnect) {
                        _this.delegate.onServerConnect();
                    }
                    if (_this.registerer && _this.registerRequested) {
                        _this.logger.log("[" + _this.id + "] Registering...");
                        _this.registerer.register()
                            .catch(function (e) {
                            _this.logger.error("[" + _this.id + "] An error occured registering after connection with server was obtained.");
                            _this.logger.error(e.toString());
                        });
                    }
                },
                // Handle connection with server lost
                onDisconnect: function (error) {
                    _this.logger.log("[" + _this.id + "] Disconnected");
                    if (_this.delegate && _this.delegate.onServerDisconnect) {
                        _this.delegate.onServerDisconnect(error);
                    }
                    if (_this.session) {
                        _this.logger.log("[" + _this.id + "] Hanging up...");
                        _this.hangup() // will likely fail, but need to cleanup hung calls
                            .catch(function (e) {
                            _this.logger.error("[" + _this.id + "] An error occured hanging up call after connection with server was lost.");
                            _this.logger.error(e.toString());
                        });
                    }
                    if (_this.registerer) {
                        _this.logger.log("[" + _this.id + "] Unregistering...");
                        _this.registerer.unregister() // will likely fail, but need to cleanup invalid registrations
                            .catch(function (e) {
                            _this.logger.error("[" + _this.id + "] An error occured unregistering after connection with server was lost.");
                            _this.logger.error(e.toString());
                        });
                    }
                    // Only attempt to reconnect if network/server dropped the connection.
                    if (error) {
                        _this.attemptReconnection();
                    }
                },
                // Handle incoming invitations
                onInvite: function (invitation) {
                    _this.logger.log("[" + _this.id + "] Received INVITE");
                    // Guard against a pre-existing session. This implementation only supports one session at a time.
                    // However an incoming INVITE request may be received at any time and/or while in the process
                    // of sending an outgoing INVITE request. So we reject any incoming INVITE in those cases.
                    if (_this.session) {
                        _this.logger.warn("[" + _this.id + "] Session already in progress, rejecting INVITE...");
                        invitation.reject()
                            .then(function () {
                            _this.logger.log("[" + _this.id + "] Rejected INVITE");
                        })
                            .catch(function (error) {
                            _this.logger.error("[" + _this.id + "] Failed to reject INVITE");
                            _this.logger.error(error.toString());
                        });
                        return;
                    }
                    // Use our configured constraints as options for any Inviter created as result of a REFER
                    var referralInviterOptions = {
                        sessionDescriptionHandlerOptions: { constraints: _this.constraints }
                    };
                    // Initialize our session
                    _this.initSession(invitation, referralInviterOptions);
                    // Delegate
                    if (_this.delegate && _this.delegate.onCallReceived) {
                        _this.delegate.onCallReceived();
                    }
                    else {
                        _this.logger.warn("[" + _this.id + "] No handler available, rejecting INVITE...");
                        invitation.reject()
                            .then(function () {
                            _this.logger.log("[" + _this.id + "] Rejected INVITE");
                        })
                            .catch(function (error) {
                            _this.logger.error("[" + _this.id + "] Failed to reject INVITE");
                            _this.logger.error(error.toString());
                        });
                    }
                },
                // Handle incoming messages
                onMessage: function (message) {
                    message.accept()
                        .then(function () {
                        if (_this.delegate && _this.delegate.onMessageReceived) {
                            _this.delegate.onMessageReceived(message.request.body);
                        }
                    });
                }
            };
            // Use the SIP.js logger
            this.logger = this.userAgent.getLogger("sip.SimpleUser");
            // Monitor network connectivity and attempt reconnection when we come online
            window.addEventListener("online", function () {
                _this.logger.log("[" + _this.id + "] Online");
                _this.attemptReconnection();
            });
        }
        Object.defineProperty(SimpleUser.prototype, "id", {
            /**
             * Instance identifier.
             * @internal
             */
            get: function () {
                return (this.options.userAgentOptions && this.options.userAgentOptions.displayName) || "Anonymous";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SimpleUser.prototype, "localAudioTrack", {
            /** The local audio track, if available. */
            get: function () {
                return this.getSenderTrack("audio");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SimpleUser.prototype, "localVideoTrack", {
            /** The local video track, if available. */
            get: function () {
                return this.getSenderTrack("video");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SimpleUser.prototype, "remoteAudioTrack", {
            /** The remote audio track, if available. */
            get: function () {
                return this.getReceiverTrack("audio");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SimpleUser.prototype, "remoteVideoTrack", {
            /** The remote video track, if available. */
            get: function () {
                return this.getReceiverTrack("video");
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Connect.
         * @remarks
         * Start the UserAgent's WebSocket Transport.
         */
        SimpleUser.prototype.connect = function () {
            this.logger.log("[" + this.id + "] Connecting UserAgent...");
            this.connectRequested = true;
            if (this.userAgent.state !== api_1.UserAgentState.Started) {
                return this.userAgent.start();
            }
            return this.userAgent.reconnect();
        };
        /**
         * Disconnect.
         * @remarks
         * Stop the UserAgent's WebSocket Transport.
         */
        SimpleUser.prototype.disconnect = function () {
            this.logger.log("[" + this.id + "] Disconnecting UserAgent...");
            this.connectRequested = false;
            return this.userAgent.stop();
        };
        /**
         * Return true if connected.
         */
        SimpleUser.prototype.isConnected = function () {
            return this.userAgent.isConnected();
        };
        /**
         * Start receiving incoming calls.
         * @remarks
         * Send a REGISTER request for the UserAgent's AOR.
         * Resolves when the REGISTER request is sent, otherwise rejects.
         */
        SimpleUser.prototype.register = function (registererOptions, registererRegisterOptions) {
            var _this = this;
            this.logger.log("[" + this.id + "] Registering UserAgent...");
            this.registerRequested = true;
            if (!this.registerer) {
                this.registerer = new api_1.Registerer(this.userAgent, registererOptions);
                this.registerer.stateChange.addListener(function (state) {
                    switch (state) {
                        case api_1.RegistererState.Initial:
                            break;
                        case api_1.RegistererState.Registered:
                            if (_this.delegate && _this.delegate.onRegistered) {
                                _this.delegate.onRegistered();
                            }
                            break;
                        case api_1.RegistererState.Unregistered:
                            if (_this.delegate && _this.delegate.onUnregistered) {
                                _this.delegate.onUnregistered();
                            }
                            break;
                        case api_1.RegistererState.Terminated:
                            _this.registerer = undefined;
                            break;
                        default:
                            throw new Error("Unknown registerer state.");
                    }
                });
            }
            return this.registerer.register(registererRegisterOptions)
                .then(function () { return; });
        };
        /**
         * Stop receiving incoming calls.
         * @remarks
         * Send an un-REGISTER request for the UserAgent's AOR.
         * Resolves when the un-REGISTER request is sent, otherwise rejects.
         */
        SimpleUser.prototype.unregister = function (registererUnregisterOptions) {
            this.logger.log("[" + this.id + "] Unregistering UserAgent...");
            this.registerRequested = false;
            if (!this.registerer) {
                return Promise.resolve();
            }
            return this.registerer.unregister(registererUnregisterOptions)
                .then(function () { return; });
        };
        /**
         * Make an outoing call.
         * @remarks
         * Send an INVITE request to create a new Session.
         * Resolves when the INVITE request is sent, otherwise rejects.
         * Use `onCallAnswered` delegate method to determine if Session is established.
         * @param destination - The target destination to call. A SIP address to send the INVITE to.
         */
        SimpleUser.prototype.call = function (destination, inviterOptions, inviterInviteOptions) {
            this.logger.log("[" + this.id + "] Beginning Session...");
            if (this.session) {
                return Promise.reject(new Error("Session already exists."));
            }
            var target = api_1.UserAgent.makeURI(destination);
            if (!target) {
                return Promise.reject(new Error("Failed to create a valid URI from \"" + destination + "\""));
            }
            // Use our configured constraints as InviterOptions if none provided
            if (!inviterOptions) {
                inviterOptions = {};
            }
            if (!inviterOptions.sessionDescriptionHandlerOptions) {
                inviterOptions.sessionDescriptionHandlerOptions = {};
            }
            if (!inviterOptions.sessionDescriptionHandlerOptions.constraints) {
                inviterOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;
            }
            // Create a new Inviter for the outgoing Session
            var inviter = new api_1.Inviter(this.userAgent, target, inviterOptions);
            // Send INVITE
            return this.sendInvite(inviter, inviterOptions, inviterInviteOptions)
                .then(function () { return; });
        };
        /**
         * Hangup a call.
         * @remarks
         * Send a BYE request, CANCEL request or reject response to end the current Session.
         * Resolves when the request/response is sent, otherwise rejects.
         * Use `onCallTerminated` delegate method to determine if and when call is ended.
         */
        SimpleUser.prototype.hangup = function () {
            this.logger.log("[" + this.id + "] Hangup...");
            return this.terminate();
        };
        /**
         * Answer an incoming call.
         * @remarks
         * Accept an incoming INVITE request creating a new Session.
         * Resolves with the response is sent, otherwise rejects.
         * Use `onCallAnswered` delegate method to determine if and when call is established.
         */
        SimpleUser.prototype.answer = function (invitationAcceptOptions) {
            this.logger.log("[" + this.id + "] Accepting Invitation...");
            if (!this.session) {
                return Promise.reject(new Error("Session does not exist."));
            }
            if (!(this.session instanceof api_1.Invitation)) {
                return Promise.reject(new Error("Session not instance of Invitation."));
            }
            // Use our configured constraints as InvitationAcceptOptions if none provided
            if (!invitationAcceptOptions) {
                invitationAcceptOptions = {};
            }
            if (!invitationAcceptOptions.sessionDescriptionHandlerOptions) {
                invitationAcceptOptions.sessionDescriptionHandlerOptions = {};
            }
            if (!invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints) {
                invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;
            }
            return this.session.accept(invitationAcceptOptions);
        };
        /**
         * Decline an incoming call.
         * @remarks
         * Reject an incoming INVITE request.
         * Resolves with the response is sent, otherwise rejects.
         * Use `onCallTerminated` delegate method to determine if and when call is ended.
         */
        SimpleUser.prototype.decline = function () {
            this.logger.log("[" + this.id + "] rejecting Invitation...");
            if (!this.session) {
                return Promise.reject(new Error("Session does not exist."));
            }
            if (!(this.session instanceof api_1.Invitation)) {
                return Promise.reject(new Error("Session not instance of Invitation."));
            }
            return this.session.reject();
        };
        /**
         * Hold call
         * @remarks
         * Send a re-INVITE with new offer indicating "hold".
         * Resolves when the re-INVITE request is sent, otherwise rejects.
         * Use `onCallHold` delegate method to determine if request is accepted or rejected.
         * See: https://tools.ietf.org/html/rfc6337
         */
        SimpleUser.prototype.hold = function () {
            this.logger.log("[" + this.id + "] holding session...");
            return this.setHold(true);
        };
        /**
         * Unhold call.
         * @remarks
         * Send a re-INVITE with new offer indicating "unhold".
         * Resolves when the re-INVITE request is sent, otherwise rejects.
         * Use `onCallHold` delegate method to determine if request is accepted or rejected.
         * See: https://tools.ietf.org/html/rfc6337
         */
        SimpleUser.prototype.unhold = function () {
            this.logger.log("[" + this.id + "] unholding session...");
            return this.setHold(false);
        };
        /**
         * Hold state.
         * @remarks
         * True if session media is on hold.
         */
        SimpleUser.prototype.isHeld = function () {
            return this.held;
        };
        /**
         * Mute call.
         * @remarks
         * Disable sender's media tracks.
         */
        SimpleUser.prototype.mute = function () {
            this.logger.log("[" + this.id + "] disabling media tracks...");
            this.setMute(true);
        };
        /**
         * Unmute call.
         * @remarks
         * Enable sender's media tracks.
         */
        SimpleUser.prototype.unmute = function () {
            this.logger.log("[" + this.id + "] enabling media tracks...");
            this.setMute(false);
        };
        /**
         * Mute state.
         * @remarks
         * True if sender's media track is disabled.
         */
        SimpleUser.prototype.isMuted = function () {
            var track = this.localAudioTrack || this.localVideoTrack;
            return track ? !track.enabled : false;
        };
        /**
         * Send DTMF.
         * @remarks
         * Send an INFO request with content type application/dtmf-relay.
         * @param tone - Tone to send.
         */
        SimpleUser.prototype.sendDTMF = function (tone) {
            this.logger.log("[" + this.id + "] sending DTMF...");
            // Validate tone
            if (!tone.match(/^[0-9A-D#*,]$/)) {
                return Promise.reject(new Error("Invalid DTMF tone."));
            }
            if (!this.session) {
                return Promise.reject(new Error("Session does not exist."));
            }
            this.logger.log("[" + this.id + "] Sending DTMF tone: " + tone);
            var dtmf = tone;
            var duration = 2000;
            var body = {
                contentDisposition: "render",
                contentType: "application/dtmf-relay",
                content: "Signal=" + dtmf + "\r\nDuration=" + duration
            };
            var requestOptions = { body: body };
            return new api_1.Infoer(this.session).info({ requestOptions: requestOptions })
                .then(function () { return; });
        };
        /**
         * Send a message.
         * @remarks
         * Send a MESSAGE request.
         * @param destination - The target destination for the message. A SIP address to send the MESSAGE to.
         */
        SimpleUser.prototype.message = function (destination, message) {
            this.logger.log("[" + this.id + "] sending message...");
            var target = api_1.UserAgent.makeURI(destination);
            if (!target) {
                return Promise.reject(new Error("Failed to create a valid URI from \"" + destination + "\""));
            }
            return new api_1.Messager(this.userAgent, target, message).message();
        };
        Object.defineProperty(SimpleUser.prototype, "constraints", {
            /** Media constraints. */
            get: function () {
                var constraints = { audio: true, video: false }; // default to audio only calls
                if (this.options.media && this.options.media.constraints) {
                    constraints = tslib_1.__assign({}, this.options.media.constraints);
                    if (!constraints.audio && !constraints.video) {
                        throw new Error("Invalid media constraints - audio and/or video must be true.");
                    }
                }
                return constraints;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Attempt reconnection up to `maxReconnectionAttempts` times.
         * @param reconnectionAttempt - Current attempt number.
         */
        SimpleUser.prototype.attemptReconnection = function (reconnectionAttempt) {
            var _this = this;
            if (reconnectionAttempt === void 0) { reconnectionAttempt = 1; }
            var reconnectionAttempts = this.options.reconnectionAttempts || 3;
            var reconnectionDelay = this.options.reconnectionDelay || 4;
            if (!this.connectRequested) {
                this.logger.log("[" + this.id + "] Reconnection not currently desired");
                return; // If intentionally disconnected, don't reconnect.
            }
            if (this.attemptingReconnection) {
                this.logger.log("[" + this.id + "] Reconnection attempt already in progress");
            }
            if (reconnectionAttempt > reconnectionAttempts) {
                this.logger.log("[" + this.id + "] Reconnection maximum attempts reached");
                return;
            }
            if (reconnectionAttempt === 1) {
                this.logger.log("[" + this.id + "] Reconnection attempt " + reconnectionAttempt + " of " + reconnectionAttempts + " - trying");
            }
            else {
                this.logger.log("[" + this.id + "] Reconnection attempt " + reconnectionAttempt + " of " + reconnectionAttempts + " - trying in " + reconnectionDelay + " seconds");
            }
            this.attemptingReconnection = true;
            setTimeout(function () {
                if (!_this.connectRequested) {
                    _this.logger
                        .log("[" + _this.id + "] Reconnection attempt " + reconnectionAttempt + " of " + reconnectionAttempts + " - aborted");
                    _this.attemptingReconnection = false;
                    return; // If intentionally disconnected, don't reconnect.
                }
                _this.userAgent.reconnect()
                    .then(function () {
                    _this.logger
                        .log("[" + _this.id + "] Reconnection attempt " + reconnectionAttempt + " of " + reconnectionAttempts + " - succeeded");
                    _this.attemptingReconnection = false;
                })
                    .catch(function (error) {
                    _this.logger
                        .log("[" + _this.id + "] Reconnection attempt " + reconnectionAttempt + " of " + reconnectionAttempts + " - failed");
                    _this.logger.error(error.message);
                    _this.attemptingReconnection = false;
                    _this.attemptReconnection(++reconnectionAttempt);
                });
            }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);
        };
        /** Helper function to remove media from html elements. */
        SimpleUser.prototype.cleanupMedia = function () {
            if (this.options.media) {
                if (this.options.media.local) {
                    if (this.options.media.local.video) {
                        this.options.media.local.video.srcObject = null;
                        this.options.media.local.video.pause();
                    }
                }
                if (this.options.media.remote) {
                    if (this.options.media.remote.audio) {
                        this.options.media.remote.audio.srcObject = null;
                        this.options.media.remote.audio.pause();
                    }
                    if (this.options.media.remote.video) {
                        this.options.media.remote.video.srcObject = null;
                        this.options.media.remote.video.pause();
                    }
                }
            }
        };
        /** Helper function to enable/disable media tracks. */
        SimpleUser.prototype.enableSenderTracks = function (enable) {
            if (!this.session) {
                throw new Error("Session does not exist.");
            }
            var sessionDescriptionHandler = this.session.sessionDescriptionHandler;
            if (!(sessionDescriptionHandler instanceof session_description_handler_1.SessionDescriptionHandler)) {
                throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
            }
            var peerConnection = sessionDescriptionHandler.peerConnection;
            peerConnection.getSenders().forEach(function (sender) {
                if (sender.track) {
                    sender.track.enabled = enable;
                }
            });
        };
        /** The receiver media track, if available. */
        SimpleUser.prototype.getReceiverTrack = function (kind) {
            if (!this.session) {
                this.logger.warn("[" + this.id + "] getReceiverTrack - session undefined");
                return undefined;
            }
            var sessionDescriptionHandler = this.session.sessionDescriptionHandler;
            if (!sessionDescriptionHandler) {
                this.logger.warn("[" + this.id + "] getReceiverTrack - session description handler undefined");
                return undefined;
            }
            if (!(sessionDescriptionHandler instanceof session_description_handler_1.SessionDescriptionHandler)) {
                throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
            }
            var peerConnection = sessionDescriptionHandler.peerConnection;
            var rtpReceiver = peerConnection.getReceivers().find(function (receiver) {
                return receiver.track.kind === kind ? true : false;
            });
            return rtpReceiver ? rtpReceiver.track : undefined;
        };
        /** The sender media track, if available. */
        SimpleUser.prototype.getSenderTrack = function (kind) {
            if (!this.session) {
                this.logger.warn("[" + this.id + "] getSenderTrack - session undefined");
                return undefined;
            }
            var sessionDescriptionHandler = this.session.sessionDescriptionHandler;
            if (!sessionDescriptionHandler) {
                this.logger.warn("[" + this.id + "] getSenderTrack - session description handler undefined");
                return undefined;
            }
            if (!(sessionDescriptionHandler instanceof session_description_handler_1.SessionDescriptionHandler)) {
                throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
            }
            var peerConnection = sessionDescriptionHandler.peerConnection;
            var rtpSender = peerConnection.getSenders().find(function (sender) {
                return sender.track && sender.track.kind === kind ? true : false;
            });
            return rtpSender && rtpSender.track ? rtpSender.track : undefined;
        };
        /**
         * Setup session delegate and state change handler.
         * @param session - Session to setup
         * @param referralInviterOptions - Options for any Inviter created as result of a REFER.
         */
        SimpleUser.prototype.initSession = function (session, referralInviterOptions) {
            var _this = this;
            // Set session
            this.session = session;
            // Call session created callback
            if (this.delegate && this.delegate.onCallCreated) {
                this.delegate.onCallCreated();
            }
            // Setup session state change handler
            this.session.stateChange.addListener(function (state) {
                if (_this.session !== session) {
                    return; // if our session has changed, just return
                }
                _this.logger.log("[" + _this.id + "] session state changed to " + state);
                switch (state) {
                    case api_1.SessionState.Initial:
                        break;
                    case api_1.SessionState.Establishing:
                        break;
                    case api_1.SessionState.Established:
                        _this.setupLocalMedia();
                        _this.setupRemoteMedia();
                        if (_this.delegate && _this.delegate.onCallAnswered) {
                            _this.delegate.onCallAnswered();
                        }
                        break;
                    case api_1.SessionState.Terminating:
                    // fall through
                    case api_1.SessionState.Terminated:
                        _this.session = undefined;
                        _this.cleanupMedia();
                        if (_this.delegate && _this.delegate.onCallHangup) {
                            _this.delegate.onCallHangup();
                        }
                        break;
                    default:
                        throw new Error("Unknown session state.");
                }
            });
            // Setup delegate
            this.session.delegate = {
                onRefer: function (referral) {
                    referral
                        .accept()
                        .then(function () { return _this.sendInvite(referral.makeInviter(referralInviterOptions), referralInviterOptions); })
                        .catch(function (error) {
                        _this.logger.error(error.message);
                    });
                }
            };
        };
        /** Helper function to init send then send invite. */
        SimpleUser.prototype.sendInvite = function (inviter, inviterOptions, inviterInviteOptions) {
            var _this = this;
            // Initialize our session
            this.initSession(inviter, inviterOptions);
            // Send the INVITE
            return inviter.invite(inviterInviteOptions)
                .then(function (request) {
                _this.logger.log("[" + _this.id + "] sent INVITE");
            });
        };
        /**
         * Puts Session on hold.
         * @param hold - Hold on if true, off if false.
         */
        SimpleUser.prototype.setHold = function (hold) {
            var _this = this;
            if (!this.session) {
                return Promise.reject(new Error("Session does not exist."));
            }
            // Just resolve if we are already in correct state
            if (this.held === hold) {
                return Promise.resolve();
            }
            var sessionDescriptionHandler = this.session.sessionDescriptionHandler;
            if (!(sessionDescriptionHandler instanceof session_description_handler_1.SessionDescriptionHandler)) {
                throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
            }
            var options = {
                requestDelegate: {
                    onAccept: function () {
                        _this.held = hold;
                        if (_this.delegate && _this.delegate.onCallHold) {
                            _this.delegate.onCallHold(_this.held);
                        }
                    },
                    onReject: function () {
                        _this.logger.warn("[" + _this.id + "] re-invite request was rejected");
                        if (_this.delegate && _this.delegate.onCallHold) {
                            _this.delegate.onCallHold(_this.held);
                        }
                    }
                }
            };
            // Use hold modifier to produce the appropriate SDP offer to place call on hold
            if (hold) {
                options.sessionDescriptionHandlerModifiers = [sessionDescriptionHandler.holdModifier];
            }
            // Send re-INVITE
            return this.session.invite(options)
                .then(function () {
                _this.enableSenderTracks(!hold); // mute/unmute
            })
                .catch(function (error) {
                if (error instanceof api_1.RequestPendingError) {
                    _this.logger.error("[" + _this.id + "] A hold request is already in progress.");
                }
                throw error;
            });
        };
        /**
         * Puts Session on mute.
         * @param mute - Mute on if true, off if false.
         */
        SimpleUser.prototype.setMute = function (mute) {
            if (!this.session) {
                this.logger.warn("[" + this.id + "] A session is required to enabled/disable media tracks");
                return;
            }
            if (this.session.state !== api_1.SessionState.Established) {
                this.logger.warn("[" + this.id + "] An established session is required to enable/disable media tracks");
                return;
            }
            this.enableSenderTracks(!mute);
        };
        /** Helper function to attach local media to html elements. */
        SimpleUser.prototype.setupLocalMedia = function () {
            if (!this.session) {
                throw new Error("Session does not exist.");
            }
            if (this.options.media && this.options.media.local && this.options.media.local.video) {
                var localVideoTrack = this.localVideoTrack;
                if (localVideoTrack) {
                    var localStream = new MediaStream([localVideoTrack]);
                    this.options.media.local.video.srcObject = localStream;
                    this.options.media.local.video.volume = 0;
                    this.options.media.local.video.play();
                }
            }
        };
        /** Helper function to attach remote media to html elements. */
        SimpleUser.prototype.setupRemoteMedia = function () {
            var _this = this;
            if (!this.session) {
                throw new Error("Session does not exist.");
            }
            if (this.options.media && this.options.media.remote) {
                var remoteAudioTrack = this.remoteAudioTrack;
                var remoteVideoTrack = this.remoteVideoTrack;
                var remoteStream = new MediaStream();
                // If there is a video element, both audio and video will be attached that element.
                if (this.options.media.remote.video) {
                    if (remoteAudioTrack) {
                        remoteStream.addTrack(remoteAudioTrack);
                    }
                    if (remoteVideoTrack) {
                        remoteStream.addTrack(remoteVideoTrack);
                    }
                    this.options.media.remote.video.srcObject = remoteStream;
                    this.options.media.remote.video.play()
                        .catch(function (error) {
                        _this.logger.error("[" + _this.id + "] Error playing video");
                        _this.logger.error(error.message);
                    });
                }
                else if (this.options.media.remote.audio) {
                    if (remoteAudioTrack) {
                        remoteStream.addTrack(remoteAudioTrack);
                        this.options.media.remote.audio.srcObject = remoteStream;
                        this.options.media.remote.audio.play()
                            .catch(function (error) {
                            _this.logger.error("[" + _this.id + "] Error playing audio");
                            _this.logger.error(error.message);
                        });
                    }
                }
            }
        };
        /**
         * End a session.
         * @remarks
         * Send a BYE request, CANCEL request or reject response to end the current Session.
         * Resolves when the request/response is sent, otherwise rejects.
         * Use `onCallTerminated` delegate method to determine if and when Session is terminated.
         */
        SimpleUser.prototype.terminate = function () {
            var _this = this;
            this.logger.log("[" + this.id + "] Terminating...");
            if (!this.session) {
                return Promise.reject(new Error("Session does not exist."));
            }
            switch (this.session.state) {
                case api_1.SessionState.Initial:
                    if (this.session instanceof api_1.Inviter) {
                        return this.session.cancel()
                            .then(function () {
                            _this.logger.log("[" + _this.id + "] Inviter never sent INVITE (canceled)");
                        });
                    }
                    else if (this.session instanceof api_1.Invitation) {
                        return this.session.reject()
                            .then(function () {
                            _this.logger.log("[" + _this.id + "] Invitation rejected (sent 480)");
                        });
                    }
                    else {
                        throw new Error("Unknown session type.");
                    }
                case api_1.SessionState.Establishing:
                    if (this.session instanceof api_1.Inviter) {
                        return this.session.cancel()
                            .then(function () {
                            _this.logger.log("[" + _this.id + "] Inviter canceled (sent CANCEL)");
                        });
                    }
                    else if (this.session instanceof api_1.Invitation) {
                        return this.session.reject()
                            .then(function () {
                            _this.logger.log("[" + _this.id + "] Invitation rejected (sent 480)");
                        });
                    }
                    else {
                        throw new Error("Unknown session type.");
                    }
                case api_1.SessionState.Established:
                    return new api_1.Byer(this.session).bye()
                        .then(function () {
                        _this.logger.log("[" + _this.id + "] Session ended (sent BYE)");
                    });
                case api_1.SessionState.Terminating:
                    break;
                case api_1.SessionState.Terminated:
                    break;
                default:
                    throw new Error("Unknown state");
            }
            this.logger.log("[" + this.id + "] Terminating in state " + this.session.state + ", no action taken");
            return Promise.resolve();
        };
        return SimpleUser;
    }());
    exports.SimpleUser = SimpleUser;
    
    
    /***/ }),
    
    /***/ "./src/platform/web/transport.ts":
    /*!***************************************!*\
      !*** ./src/platform/web/transport.ts ***!
      \***************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
    var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
    var emitter_1 = __webpack_require__(/*! ../../api/emitter */ "./src/api/emitter.ts");
    var exceptions_1 = __webpack_require__(/*! ../../api/exceptions */ "./src/api/exceptions/index.ts");
    var transport_state_1 = __webpack_require__(/*! ../../api/transport-state */ "./src/api/transport-state.ts");
    var core_1 = __webpack_require__(/*! ../../core */ "./src/core/index.ts");
    /**
     * Transport for SIP over secure WebSocket (WSS).
     * @public
     */
    var Transport = /** @class */ (function (_super) {
        tslib_1.__extends(Transport, _super);
        function Transport(logger, options) {
            var _this = _super.call(this) || this;
            _this._state = transport_state_1.TransportState.Disconnected;
            _this._stateEventEmitter = new events_1.EventEmitter();
            _this.transitioningState = false;
            // logger
            _this.logger = logger;
            // guard deprecated options (remove this in version 16.x)
            if (options) {
                var optionsDeprecated = options;
                var wsServersDeprecated = optionsDeprecated.wsServers;
                var maxReconnectionAttemptsDeprecated = optionsDeprecated.maxReconnectionAttempts;
                if (wsServersDeprecated !== undefined) {
                    var deprecatedMessage = "The transport option \"wsServers\" as has apparently been specified and has been deprecated. " +
                        "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";
                    _this.logger.warn(deprecatedMessage);
                }
                if (maxReconnectionAttemptsDeprecated !== undefined) {
                    var deprecatedMessage = "The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. " +
                        "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";
                    _this.logger.warn(deprecatedMessage);
                }
                // hack
                if (wsServersDeprecated && !options.server) {
                    if (typeof wsServersDeprecated === "string") {
                        options.server = wsServersDeprecated;
                    }
                    if (wsServersDeprecated instanceof Array) {
                        options.server = wsServersDeprecated[0];
                    }
                }
            }
            // initialize configuration
            _this.configuration = tslib_1.__assign(tslib_1.__assign({}, Transport.defaultOptions), options);
            // validate server URL
            var url = _this.configuration.server;
            var parsed = core_1.Grammar.parse(url, "absoluteURI");
            if (parsed === -1) {
                _this.logger.error("Invalid WebSocket Server URL \"" + url + "\"");
                throw new Error("Invalid WebSocket Server URL");
            }
            if (["wss", "ws", "udp"].indexOf(parsed.scheme) < 0) {
                _this.logger.error("Invalid scheme in WebSocket Server URL \"" + url + "\"");
                throw new Error("Invalid scheme in WebSocket Server URL");
            }
            _this._protocol = parsed.scheme.toUpperCase();
            return _this;
        }
        Transport.prototype.dispose = function () {
            return this.disconnect();
        };
        Object.defineProperty(Transport.prototype, "protocol", {
            /**
             * The protocol.
             *
             * @remarks
             * Formatted as defined for the Via header sent-protocol transport.
             * https://tools.ietf.org/html/rfc3261#section-20.42
             */
            get: function () {
                return this._protocol;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transport.prototype, "server", {
            /**
             * The URL of the WebSocket Server.
             */
            get: function () {
                return this.configuration.server;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transport.prototype, "state", {
            /**
             * Transport state.
             */
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transport.prototype, "stateChange", {
            /**
             * Transport state change emitter.
             */
            get: function () {
                return emitter_1._makeEmitter(this._stateEventEmitter);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transport.prototype, "ws", {
            /**
             * The WebSocket.
             */
            get: function () {
                return this._ws;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Connect to network.
         * Resolves once connected. Otherwise rejects with an Error.
         */
        Transport.prototype.connect = function () {
            return this._connect();
        };
        /**
         * Disconnect from network.
         * Resolves once disconnected. Otherwise rejects with an Error.
         */
        Transport.prototype.disconnect = function () {
            return this._disconnect();
        };
        /**
         * Returns true if the `state` equals "Connected".
         * @remarks
         * This is equivalent to `state === TransportState.Connected`.
         */
        Transport.prototype.isConnected = function () {
            return this.state === transport_state_1.TransportState.Connected;
        };
        /**
         * Sends a message.
         * Resolves once message is sent. Otherwise rejects with an Error.
         * @param message - Message to send.
         */
        Transport.prototype.send = function (message) {
            // Error handling is independent of whether the message was a request or
            // response.
            //
            // If the transport user asks for a message to be sent over an
            // unreliable transport, and the result is an ICMP error, the behavior
            // depends on the type of ICMP error.  Host, network, port or protocol
            // unreachable errors, or parameter problem errors SHOULD cause the
            // transport layer to inform the transport user of a failure in sending.
            // Source quench and TTL exceeded ICMP errors SHOULD be ignored.
            //
            // If the transport user asks for a request to be sent over a reliable
            // transport, and the result is a connection failure, the transport
            // layer SHOULD inform the transport user of a failure in sending.
            // https://tools.ietf.org/html/rfc3261#section-18.4
            return this._send(message);
        };
        /**
         * @internal
         */
        Transport.prototype.on = function (name, callback) {
            var deprecatedMessage = "A listener has been registered for the transport event \"" + name + "\". " +
                "Registering listeners for transport events has been deprecated and will no longer be available starting with SIP.js release 0.16.0. " +
                "Please use the onConnected, onDisconnected, onMessage callbacks and/or the stateChange emitter instead. Please update accordingly.";
            this.logger.warn(deprecatedMessage);
            return _super.prototype.on.call(this, name, callback);
        };
        Transport.prototype._connect = function () {
            var _this = this;
            this.logger.log("Connecting " + this.server);
            switch (this.state) {
                case transport_state_1.TransportState.Connecting:
                    // If `state` is "Connecting", `state` MUST NOT transition before returning.
                    if (this.transitioningState) {
                        return Promise.reject(this.transitionLoopDetectedError(transport_state_1.TransportState.Connecting));
                    }
                    if (!this.connectPromise) {
                        throw new Error("Connect promise must be defined.");
                    }
                    return this.connectPromise; // Already connecting
                case transport_state_1.TransportState.Connected:
                    // If `state` is "Connected", `state` MUST NOT transition before returning.
                    if (this.transitioningState) {
                        return Promise.reject(this.transitionLoopDetectedError(transport_state_1.TransportState.Connecting));
                    }
                    if (this.connectPromise) {
                        throw new Error("Connect promise must not be defined.");
                    }
                    return Promise.resolve(); // Already connected
                case transport_state_1.TransportState.Disconnecting:
                    // If `state` is "Disconnecting", `state` MUST transition to "Connecting" before returning
                    if (this.connectPromise) {
                        throw new Error("Connect promise must not be defined.");
                    }
                    try {
                        this.transitionState(transport_state_1.TransportState.Connecting);
                    }
                    catch (e) {
                        if (e instanceof exceptions_1.StateTransitionError) {
                            return Promise.reject(e); // Loop detected
                        }
                        throw e;
                    }
                    break;
                case transport_state_1.TransportState.Disconnected:
                    // If `state` is "Disconnected" `state` MUST transition to "Connecting" before returning
                    if (this.connectPromise) {
                        throw new Error("Connect promise must not be defined.");
                    }
                    try {
                        this.transitionState(transport_state_1.TransportState.Connecting);
                    }
                    catch (e) {
                        if (e instanceof exceptions_1.StateTransitionError) {
                            return Promise.reject(e); // Loop detected
                        }
                        throw e;
                    }
                    break;
                default:
                    throw new Error("Unknown state");
            }
            var ws;
            try {
                // WebSocket()
                // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket
                ws = new WebSocket(this.server, "sip");
                ws.addEventListener("close", function (ev) { return _this.onWebSocketClose(ev, ws); });
                ws.addEventListener("error", function (ev) { return _this.onWebSocketError(ev, ws); });
                ws.addEventListener("open", function (ev) { return _this.onWebSocketOpen(ev, ws); });
                ws.addEventListener("message", function (ev) { return _this.onWebSocketMessage(ev, ws); });
                this._ws = ws;
            }
            catch (error) {
                this._ws = undefined;
                this.logger.error("WebSocket construction failed.");
                return Promise.resolve()
                    .then(function () {
                    // The `state` MUST transition to "Disconnecting" or "Disconnected" before rejecting
                    _this.transitionState(transport_state_1.TransportState.Disconnected, error);
                    throw error;
                });
            }
            this.connectPromise = new Promise(function (resolve, reject) {
                _this.connectResolve = resolve;
                _this.connectReject = reject;
                _this.connectTimeout = setTimeout(function () {
                    _this.logger.warn("Connect timed out. " +
                        "Exceeded time set in configuration.connectionTimeout: " + _this.configuration.connectionTimeout + "s.");
                    ws.close(1000); // careful here to use a local reference instead of this._ws
                }, _this.configuration.connectionTimeout * 1000);
            });
            return this.connectPromise;
        };
        Transport.prototype._disconnect = function () {
            var _this = this;
            this.logger.log("Disconnecting " + this.server);
            switch (this.state) {
                case transport_state_1.TransportState.Connecting:
                    // If `state` is "Connecting", `state` MUST transition to "Disconnecting" before returning.
                    if (this.disconnectPromise) {
                        throw new Error("Disconnect promise must not be defined.");
                    }
                    try {
                        this.transitionState(transport_state_1.TransportState.Disconnecting);
                    }
                    catch (e) {
                        if (e instanceof exceptions_1.StateTransitionError) {
                            return Promise.reject(e); // Loop detected
                        }
                        throw e;
                    }
                    break;
                case transport_state_1.TransportState.Connected:
                    // If `state` is "Connected", `state` MUST transition to "Disconnecting" before returning.
                    if (this.disconnectPromise) {
                        throw new Error("Disconnect promise must not be defined.");
                    }
                    try {
                        this.transitionState(transport_state_1.TransportState.Disconnecting);
                    }
                    catch (e) {
                        if (e instanceof exceptions_1.StateTransitionError) {
                            return Promise.reject(e); // Loop detected
                        }
                        throw e;
                    }
                    break;
                case transport_state_1.TransportState.Disconnecting:
                    // If `state` is "Disconnecting", `state` MUST NOT transition before returning.
                    if (this.transitioningState) {
                        return Promise.reject(this.transitionLoopDetectedError(transport_state_1.TransportState.Disconnecting));
                    }
                    if (!this.disconnectPromise) {
                        throw new Error("Disconnect promise must be defined.");
                    }
                    return this.disconnectPromise; // Already disconnecting
                case transport_state_1.TransportState.Disconnected:
                    // If `state` is "Disconnected", `state` MUST NOT transition before returning.
                    if (this.transitioningState) {
                        return Promise.reject(this.transitionLoopDetectedError(transport_state_1.TransportState.Disconnecting));
                    }
                    if (this.disconnectPromise) {
                        throw new Error("Disconnect promise must not be defined.");
                    }
                    return Promise.resolve(); // Already disconnected
                default:
                    throw new Error("Unknown state");
            }
            if (!this._ws) {
                throw new Error("WebSocket must be defined.");
            }
            var ws = this._ws;
            this.disconnectPromise = new Promise(function (resolve, reject) {
                _this.disconnectResolve = resolve;
                _this.disconnectReject = reject;
                try {
                    // WebSocket.close()
                    // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close
                    ws.close(1000); // careful here to use a local reference instead of this._ws
                }
                catch (error) {
                    // Treating this as a coding error as it apparently can only happen
                    // if you pass close() invalid parameters (so it should never happen)
                    _this.logger.error("WebSocket close failed.");
                    _this.logger.error(error);
                    throw error;
                }
            });
            return this.disconnectPromise;
        };
        Transport.prototype._send = function (message) {
            if (this.configuration.traceSip === true) {
                this.logger.log("Sending WebSocket message:\n\n" + message + "\n");
            }
            if (this._state !== transport_state_1.TransportState.Connected) {
                return Promise.reject(new Error("Not connected."));
            }
            if (!this._ws) {
                throw new Error("WebSocket undefined.");
            }
            try {
                // WebSocket.send()
                // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
                this._ws.send(message);
            }
            catch (error) {
                if (error instanceof Error) {
                    return Promise.reject(error);
                }
                return Promise.reject(new Error("WebSocket send failed."));
            }
            return Promise.resolve();
        };
        /**
         * WebSocket "onclose" event handler.
         * @param ev - Event.
         */
        Transport.prototype.onWebSocketClose = function (ev, ws) {
            if (ws !== this._ws) {
                return;
            }
            var message = "WebSocket closed " + this.server + " (code: " + ev.code + ")";
            var error = !this.disconnectPromise ? new Error(message) : undefined;
            if (error) {
                this.logger.warn("WebSocket closed unexpectedly");
            }
            this.logger.log(message);
            // We are about to transition to disconnected, so clear our web socket
            this._ws = undefined;
            // The `state` MUST transition to "Disconnected" before resolving (assuming `state` is not already "Disconnected").
            this.transitionState(transport_state_1.TransportState.Disconnected, error);
        };
        /**
         * WebSocket "onerror" event handler.
         * @param ev - Event.
         */
        Transport.prototype.onWebSocketError = function (ev, ws) {
            if (ws !== this._ws) {
                return;
            }
            this.logger.error("WebSocket error occurred.");
        };
        /**
         * WebSocket "onmessage" event handler.
         * @param ev - Event.
         */
        Transport.prototype.onWebSocketMessage = function (ev, ws) {
            if (ws !== this._ws) {
                return;
            }
            var data = ev.data;
            var finishedData;
            // CRLF Keep Alive response from server. Clear our keep alive timeout.
            if (/^(\r\n)+$/.test(data)) {
                this.clearKeepAliveTimeout();
                if (this.configuration.traceSip === true) {
                    this.logger.log("Received WebSocket message with CRLF Keep Alive response");
                }
                return;
            }
            if (!data) {
                this.logger.warn("Received empty message, discarding...");
                return;
            }
            if (typeof data !== "string") { // WebSocket binary message.
                try {
                    // TODO: UInt8Array is not an Array<number>, so this should be fixed. (It was ported as is.)
                    finishedData = String.fromCharCode.apply(null, new Uint8Array(data));
                }
                catch (err) {
                    this.logger.warn("Received WebSocket binary message failed to be converted into string, message discarded");
                    return;
                }
                if (this.configuration.traceSip === true) {
                    this.logger.log("Received WebSocket binary message:\n\n" + data + "\n");
                }
            }
            else { // WebSocket text message.
                if (this.configuration.traceSip === true) {
                    this.logger.log("Received WebSocket text message:\n\n" + data + "\n");
                }
                finishedData = data;
            }
            if (this.state !== transport_state_1.TransportState.Connected) {
                this.logger.warn("Received message while not connected, discarding...");
                return;
            }
            if (this.onMessage) {
                try {
                    this.onMessage(finishedData);
                }
                catch (e) {
                    this.logger.error(e);
                    this.logger.error("Exception thrown by onMessage callback");
                    throw e; // rethrow unhandled exception
                }
            }
            this.emit("message", finishedData);
        };
        /**
         * WebSocket "onopen" event handler.
         * @param ev - Event.
         */
        Transport.prototype.onWebSocketOpen = function (ev, ws) {
            if (ws !== this._ws) {
                return;
            }
            if (this._state === transport_state_1.TransportState.Connecting) {
                this.logger.log("WebSocket opened " + this.server);
                this.transitionState(transport_state_1.TransportState.Connected);
            }
        };
        /**
         * Helper function to generate an Error.
         * @param state State transitioning to.
         */
        Transport.prototype.transitionLoopDetectedError = function (state) {
            var message = "A state transition loop has been detected.";
            message += " An attempt to transition from " + this._state + " to " + state + " before the prior transition completed.";
            message += " Perhaps you are synchronously calling connect() or disconnect() from a callback or state change handler?";
            this.logger.error(message);
            return new exceptions_1.StateTransitionError("Loop detected.");
        };
        /**
         * Transition transport state.
         * @internal
         */
        Transport.prototype.transitionState = function (newState, error) {
            var _this = this;
            var invalidTransition = function () {
                throw new Error("Invalid state transition from " + _this._state + " to " + newState);
            };
            if (this.transitioningState) {
                throw this.transitionLoopDetectedError(newState);
            }
            this.transitioningState = true;
            // Validate state transition
            switch (this._state) {
                case transport_state_1.TransportState.Connecting:
                    if (newState !== transport_state_1.TransportState.Connected &&
                        newState !== transport_state_1.TransportState.Disconnecting &&
                        newState !== transport_state_1.TransportState.Disconnected) {
                        invalidTransition();
                    }
                    break;
                case transport_state_1.TransportState.Connected:
                    if (newState !== transport_state_1.TransportState.Disconnecting &&
                        newState !== transport_state_1.TransportState.Disconnected) {
                        invalidTransition();
                    }
                    break;
                case transport_state_1.TransportState.Disconnecting:
                    if (newState !== transport_state_1.TransportState.Connecting &&
                        newState !== transport_state_1.TransportState.Disconnected) {
                        invalidTransition();
                    }
                    break;
                case transport_state_1.TransportState.Disconnected:
                    if (newState !== transport_state_1.TransportState.Connecting) {
                        invalidTransition();
                    }
                    break;
                default:
                    throw new Error("Unknown state.");
            }
            // Update state
            var oldState = this._state;
            this._state = newState;
            // Local copies of connect promises (guarding against callbacks changing them indirectly)
            var connectPromise = this.connectPromise;
            var connectResolve = this.connectResolve;
            var connectReject = this.connectReject;
            // Reset connect promises if no longer connecting
            if (oldState === transport_state_1.TransportState.Connecting) {
                this.connectPromise = undefined;
                this.connectResolve = undefined;
                this.connectReject = undefined;
            }
            // Local copies of disconnect promises (guarding against callbacks changing them indirectly)
            var disconnectPromise = this.disconnectPromise;
            var disconnectResolve = this.disconnectResolve;
            var disconnectReject = this.disconnectReject;
            // Reset disconnect promises if no longer disconnecting
            if (oldState === transport_state_1.TransportState.Disconnecting) {
                this.disconnectPromise = undefined;
                this.disconnectResolve = undefined;
                this.disconnectReject = undefined;
            }
            // Clear any outstanding connect timeout
            if (this.connectTimeout) {
                clearTimeout(this.connectTimeout);
                this.connectTimeout = undefined;
            }
            this.logger.log("Transitioned from " + oldState + " to " + this._state);
            this._stateEventEmitter.emit("event", this._state);
            //  Transition to Connected
            if (newState === transport_state_1.TransportState.Connected) {
                this.startSendingKeepAlives();
                if (this.onConnect) {
                    try {
                        this.onConnect();
                    }
                    catch (e) {
                        this.logger.error(e);
                        this.logger.error("Exception thrown by onConnect callback");
                        throw e; // rethrow unhandled exception
                    }
                }
            }
            //  Transition from Connected
            if (oldState === transport_state_1.TransportState.Connected) {
                this.stopSendingKeepAlives();
                if (this.onDisconnect) {
                    try {
                        if (error) {
                            this.onDisconnect(error);
                        }
                        else {
                            this.onDisconnect();
                        }
                    }
                    catch (e) {
                        this.logger.error(e);
                        this.logger.error("Exception thrown by onDisconnect callback");
                        throw e; // rethrow unhandled exception
                    }
                }
            }
            // Legacy transport behavior (or at least what I believe the legacy transport was shooting for)
            switch (newState) {
                case transport_state_1.TransportState.Connecting:
                    this.emit("connecting");
                    break;
                case transport_state_1.TransportState.Connected:
                    this.emit("connected");
                    break;
                case transport_state_1.TransportState.Disconnecting:
                    this.emit("disconnecting");
                    break;
                case transport_state_1.TransportState.Disconnected:
                    this.emit("disconnected");
                    break;
                default:
                    throw new Error("Unknown state.");
            }
            // Complete connect promise
            if (oldState === transport_state_1.TransportState.Connecting) {
                if (!connectResolve) {
                    throw new Error("Connect resolve undefined.");
                }
                if (!connectReject) {
                    throw new Error("Connect reject undefined.");
                }
                newState === transport_state_1.TransportState.Connected ? connectResolve() : connectReject(error || new Error("Connect aborted."));
            }
            // Complete disconnect promise
            if (oldState === transport_state_1.TransportState.Disconnecting) {
                if (!disconnectResolve) {
                    throw new Error("Disconnect resolve undefined.");
                }
                if (!disconnectReject) {
                    throw new Error("Disconnect reject undefined.");
                }
                newState === transport_state_1.TransportState.Disconnected ? disconnectResolve() : disconnectReject(error || new Error("Disconnect aborted."));
            }
            this.transitioningState = false;
        };
        // TODO: Review "KeepAlive Stuff".
        // It is not clear if it works and there are no tests for it.
        // It was blindly lifted the keep alive code unchanged from earlier transport code.
        //
        // From the RFC...
        //
        // SIP WebSocket Clients and Servers may keep their WebSocket
        // connections open by sending periodic WebSocket "Ping" frames as
        // described in [RFC6455], Section 5.5.2.
        // ...
        // The indication and use of the CRLF NAT keep-alive mechanism defined
        // for SIP connection-oriented transports in [RFC5626], Section 3.5.1 or
        // [RFC6223] are, of course, usable over the transport defined in this
        // specification.
        // https://tools.ietf.org/html/rfc7118#section-6
        //
        // and...
        //
        // The Ping frame contains an opcode of 0x9.
        // https://tools.ietf.org/html/rfc6455#section-5.5.2
        //
        // ==============================
        // KeepAlive Stuff
        // ==============================
        Transport.prototype.clearKeepAliveTimeout = function () {
            if (this.keepAliveDebounceTimeout) {
                clearTimeout(this.keepAliveDebounceTimeout);
            }
            this.keepAliveDebounceTimeout = undefined;
        };
        /**
         * Send a keep-alive (a double-CRLF sequence).
         */
        Transport.prototype.sendKeepAlive = function () {
            var _this = this;
            if (this.keepAliveDebounceTimeout) {
                // We already have an outstanding keep alive, do not send another.
                return Promise.resolve();
            }
            this.keepAliveDebounceTimeout = setTimeout(function () {
                _this.clearKeepAliveTimeout();
            }, this.configuration.keepAliveDebounce * 1000);
            return this.send("\r\n\r\n");
        };
        /**
         * Start sending keep-alives.
         */
        Transport.prototype.startSendingKeepAlives = function () {
            var _this = this;
            // Compute an amount of time in seconds to wait before sending another keep-alive.
            var computeKeepAliveTimeout = function (upperBound) {
                var lowerBound = upperBound * 0.8;
                return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
            };
            if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {
                this.keepAliveInterval = setInterval(function () {
                    _this.sendKeepAlive();
                    _this.startSendingKeepAlives();
                }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));
            }
        };
        /**
         * Stop sending keep-alives.
         */
        Transport.prototype.stopSendingKeepAlives = function () {
            if (this.keepAliveInterval) {
                clearInterval(this.keepAliveInterval);
            }
            if (this.keepAliveDebounceTimeout) {
                clearTimeout(this.keepAliveDebounceTimeout);
            }
            this.keepAliveInterval = undefined;
            this.keepAliveDebounceTimeout = undefined;
        };
        Transport.defaultOptions = {
            server: "",
            connectionTimeout: 5,
            keepAliveInterval: 0,
            keepAliveDebounce: 10,
            traceSip: true
        };
        return Transport;
    }(events_1.EventEmitter));
    exports.Transport = Transport;
    
    
    /***/ }),
    
    /***/ "./src/version.ts":
    /*!************************!*\
      !*** ./src/version.ts ***!
      \************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LIBRARY_VERSION = "0.15.10";
    
    
    /***/ })
    
    /******/ });
    //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vZGVtby9kZW1vLTEudHMiLCJ3ZWJwYWNrOi8vLy4vZGVtby9kZW1vLXV0aWxzLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21kNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvYnllci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2VtaXR0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9leGNlcHRpb25zL2NvbnRlbnQtdHlwZS11bnN1cHBvcnRlZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2V4Y2VwdGlvbnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9leGNlcHRpb25zL3JlcXVlc3QtcGVuZGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2V4Y2VwdGlvbnMvc2Vzc2lvbi1kZXNjcmlwdGlvbi1oYW5kbGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvZXhjZXB0aW9ucy9zZXNzaW9uLXRlcm1pbmF0ZWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9leGNlcHRpb25zL3N0YXRlLXRyYW5zaXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2luZm8udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9pbmZvZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9pbnZpdGF0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvaW52aXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL21lc3NhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9tZXNzYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL25vdGlmaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3B1Ymxpc2hlci1zdGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3B1Ymxpc2hlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3JlZmVycmFsLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvcmVmZXJyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9yZWdpc3RlcmVyLXN0YXRlLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvcmVnaXN0ZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3Nlc3Npb24tc3RhdGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9zZXNzaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvc3Vic2NyaWJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3N1YnNjcmlwdGlvbi1zdGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3N1YnNjcmlwdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3RyYW5zcG9ydC1zdGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3VzZXItYWdlbnQtb3B0aW9ucy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3VzZXItYWdlbnQtc3RhdGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS91c2VyLWFnZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL2RpYWxvZ3MvZGlhbG9nLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL2RpYWxvZ3MvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvZGlhbG9ncy9zZXNzaW9uLWRpYWxvZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9kaWFsb2dzL3N1YnNjcmlwdGlvbi1kaWFsb2cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvZXhjZXB0aW9ucy9leGNlcHRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvZXhjZXB0aW9ucy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9leGNlcHRpb25zL3RyYW5zYWN0aW9uLXN0YXRlLWVycm9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL2V4Y2VwdGlvbnMvdHJhbnNwb3J0LWVycm9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL2xvZy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9sb2cvbGV2ZWxzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL2xvZy9sb2dnZXItZmFjdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9sb2cvbG9nZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL21lc3NhZ2VzL2JvZHkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvbWVzc2FnZXMvZGlnZXN0LWF1dGhlbnRpY2F0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL21lc3NhZ2VzL2dyYW1tYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvbWVzc2FnZXMvaW5jb21pbmctbWVzc2FnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9tZXNzYWdlcy9pbmNvbWluZy1yZXF1ZXN0LW1lc3NhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvbWVzc2FnZXMvaW5jb21pbmctcmVzcG9uc2UtbWVzc2FnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9tZXNzYWdlcy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9tZXNzYWdlcy9tZXRob2RzL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9tZXNzYWdlcy9tZXRob2RzL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL21lc3NhZ2VzL25hbWUtYWRkci1oZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvbWVzc2FnZXMvb3V0Z29pbmctcmVxdWVzdC1tZXNzYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL21lc3NhZ2VzL291dGdvaW5nLXJlc3BvbnNlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL21lc3NhZ2VzL3BhcmFtZXRlcnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvbWVzc2FnZXMvcGFyc2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL21lc3NhZ2VzL3VyaS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9tZXNzYWdlcy91dGlscy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9zZXNzaW9uL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3Nlc3Npb24vc2Vzc2lvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9zdWJzY3JpcHRpb24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS90aW1lcnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdHJhbnNhY3Rpb25zL2NsaWVudC10cmFuc2FjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS90cmFuc2FjdGlvbnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdHJhbnNhY3Rpb25zL2ludml0ZS1jbGllbnQtdHJhbnNhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdHJhbnNhY3Rpb25zL2ludml0ZS1zZXJ2ZXItdHJhbnNhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdHJhbnNhY3Rpb25zL25vbi1pbnZpdGUtY2xpZW50LXRyYW5zYWN0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3RyYW5zYWN0aW9ucy9ub24taW52aXRlLXNlcnZlci10cmFuc2FjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS90cmFuc2FjdGlvbnMvc2VydmVyLXRyYW5zYWN0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3RyYW5zYWN0aW9ucy90cmFuc2FjdGlvbi1zdGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS90cmFuc2FjdGlvbnMvdHJhbnNhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdXNlci1hZ2VudC1jb3JlL2FsbG93ZWQtbWV0aG9kcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50LWNvcmUvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdXNlci1hZ2VudC1jb3JlL3VzZXItYWdlbnQtY29yZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9ieWUtdXNlci1hZ2VudC1jbGllbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdXNlci1hZ2VudHMvYnllLXVzZXItYWdlbnQtc2VydmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3VzZXItYWdlbnRzL2NhbmNlbC11c2VyLWFnZW50LWNsaWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9pbmZvLXVzZXItYWdlbnQtY2xpZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3VzZXItYWdlbnRzL2luZm8tdXNlci1hZ2VudC1zZXJ2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdXNlci1hZ2VudHMvaW52aXRlLXVzZXItYWdlbnQtY2xpZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3VzZXItYWdlbnRzL2ludml0ZS11c2VyLWFnZW50LXNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9tZXNzYWdlLXVzZXItYWdlbnQtY2xpZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3VzZXItYWdlbnRzL21lc3NhZ2UtdXNlci1hZ2VudC1zZXJ2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdXNlci1hZ2VudHMvbm90aWZ5LXVzZXItYWdlbnQtY2xpZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3VzZXItYWdlbnRzL25vdGlmeS11c2VyLWFnZW50LXNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9wcmFjay11c2VyLWFnZW50LWNsaWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9wcmFjay11c2VyLWFnZW50LXNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9wdWJsaXNoLXVzZXItYWdlbnQtY2xpZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3VzZXItYWdlbnRzL3JlLWludml0ZS11c2VyLWFnZW50LWNsaWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9yZS1pbnZpdGUtdXNlci1hZ2VudC1zZXJ2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdXNlci1hZ2VudHMvcmUtc3Vic2NyaWJlLXVzZXItYWdlbnQtY2xpZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3VzZXItYWdlbnRzL3JlLXN1YnNjcmliZS11c2VyLWFnZW50LXNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9yZWZlci11c2VyLWFnZW50LWNsaWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9yZWZlci11c2VyLWFnZW50LXNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9yZWdpc3Rlci11c2VyLWFnZW50LWNsaWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9yZWdpc3Rlci11c2VyLWFnZW50LXNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91c2VyLWFnZW50cy9zdWJzY3JpYmUtdXNlci1hZ2VudC1jbGllbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdXNlci1hZ2VudHMvc3Vic2NyaWJlLXVzZXItYWdlbnQtc2VydmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3VzZXItYWdlbnRzL3VzZXItYWdlbnQtY2xpZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3VzZXItYWdlbnRzL3VzZXItYWdlbnQtc2VydmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9ncmFtbWFyL2Rpc3QvZ3JhbW1hci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcGxhdGZvcm0vd2ViL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9wbGF0Zm9ybS93ZWIvbW9kaWZpZXJzLnRzIiwid2VicGFjazovLy8uL3NyYy9wbGF0Zm9ybS93ZWIvc2Vzc2lvbi1kZXNjcmlwdGlvbi1oYW5kbGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9wbGF0Zm9ybS93ZWIvc2ltcGxlLXVzZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsYXRmb3JtL3dlYi9zaW1wbGUtdXNlci9zaW1wbGUtdXNlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcGxhdGZvcm0vd2ViL3RyYW5zcG9ydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVyc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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QUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxD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SUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3JHLENBQUM7UUFDdkIsUUFBUTtRQUNSLHNCQUFzQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUM7UUFDdEMsT0FBTztRQUNQLHNCQUFzQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUM7UUFDckMsVUFBUyxLQUFVLElBQVMsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDM0YsUUFBUTtRQUNSLHNCQUFzQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUM7UUFDdEMsT0FBTztRQUNQLHNCQUFzQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUM7UUFDckMsVUFBUyxLQUFVLElBQVMsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDekYsUUFBUTtRQUNSLHNCQUFzQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUM7UUFDdEMsVUFBUyxNQUFXLElBQVMsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDNUYsT0FBTztRQUNQLHNCQUFzQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUM7UUFDckMsTUFBTTtRQUNOLHNCQUFzQixDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUM7UUFDcEMsY0FBa0IsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFD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Q0FBQyxDQUFDLENBQUM7d0JBQzNCLEVBQUUsSUFBSSxDQUFDLENBQUM7d0JBQ1IsTUFBTTtvQkFFUixLQUFLLENBQUM7d0JBQ0osS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzt3QkFDcEIsRUFBRSxFQUFFLENBQUM7d0JBQ0wsTUFBTTtvQkFFUixLQUFLLEVBQUU7d0JBQ0wsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO3dCQUMxQyxFQUFFLEVBQUUsQ0FBQzt3QkFDTCxNQUFNO29CQUVSLEtBQUssRUFBRTt3QkFDTCxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNoRSxFQUFFLElBQUksQ0FBQyxDQUFDO3dCQUNSLE1BQU07b0JBRVIsS0FBSyxFQUFFO3dCQUNMLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQzt3QkFDdEQsRUFBRSxFQUFFLENBQUM7d0JBQ0wsTUFBTTtvQkFFUixLQUFLLEVBQUU7d0JBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDZixHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBRTNDLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUU7NEJBQzNCLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7NEJBQzFCLEVBQUUsSUFBSSxDQUFDLENBQUM7eUJBQ1Q7NkJBQU07NEJBQ0wsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDOzRCQUN2QyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7eUJBQ3RCO3dCQUVELE1BQU07b0JBRVIsS0FBSyxFQUFFO3dCQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQ2YsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUUzQyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLFVBQVUsRUFBRTs0QkFDMUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQzs0QkFDMUIsRUFBRSxJQUFJLENBQUMsQ0FBQzt5QkFDVDs2QkFBTTs0QkFDTCxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7NEJBQ3ZDLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQzt5QkFDdEI7d0JBRUQsTUFBTTtvQkFFUixLQUFLLEVBQUU7d0JBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDZixHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBRTNDLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEtBQUssVUFBVSxFQUFFOzRCQUMxQyxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDOzRCQUMxQixFQUFFLElBQUksQ0FBQyxDQUFDO3lCQUNUOzZCQUFNOzRCQUNMLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQzs0QkFDdkMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO3lCQUN0Qjt3QkFFRCxNQUFNO29CQUVSLEtBQUssRUFBRTt3QkFDTCxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLFVBQVUsRUFBRTs0QkFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzs0QkFDZixHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDOzRCQUViLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7NEJBQzFCLEVBQUUsSUFBSSxDQUFDLENBQUM7eUJBQ1Q7NkJBQU07NEJBQ0wsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO3lCQUN0Qjt3QkFFRCxNQUFNO29CQUVSLEtBQUssRUFBRTt3QkFDTCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUNmLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFFM0MsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLFdBQVcsRUFBRTs0QkFDOUIsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQzs0QkFDMUIsRUFBRSxJQUFJLENBQUMsQ0FBQzt5QkFDVDs2QkFBTTs0QkFDTCxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7NEJBQ3ZDLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQzt5QkFDdEI7d0JBRUQsTUFBTTtvQkFFUixLQUFLLEVBQUU7d0JBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDZixHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBRTNDLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUcsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFOzRCQUNuRyxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDOzRCQUMxQixFQUFFLElBQUksQ0FBQyxDQUFDO3lCQUNUOzZCQUFNOzRCQUNMLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FB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O0FDL0NULHVCQUFlLEdBQUcsU0FBUyxDQUFDIiwiZmlsZSI6ImRlbW8tMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vZGVtby9kZW1vLTEudHNcIik7XG4iLCIvLyB0c2xpbnQ6ZGlzYWJsZTogbm8tY29uc29sZVxuaW1wb3J0IHsgU2ltcGxlVXNlciwgU2ltcGxlVXNlckRlbGVnYXRlLCBTaW1wbGVVc2VyT3B0aW9ucyB9IGZyb20gXCIuLi9zcmMvcGxhdGZvcm0vd2ViXCI7XG5pbXBvcnQgeyBnZXRBdWRpbywgZ2V0QnV0dG9uLCAgZ2V0QnV0dG9ucywgZ2V0SW5wdXQsIGdldFNwYW4gfSBmcm9tIFwiLi9kZW1vLXV0aWxzXCI7XG5cbmNvbnN0IHNlcnZlclNwYW4gPSBnZXRTcGFuKFwic2VydmVyXCIpO1xuY29uc3QgdGFyZ2V0U3BhbiA9IGdldFNwYW4oXCJ0YXJnZXRcIik7XG5jb25zdCBjb25uZWN0QnV0dG9uID0gZ2V0QnV0dG9uKFwiY29ubmVjdFwiKTtcbmNvbnN0IGNhbGxCdXR0b24gPSBnZXRCdXR0b24oXCJjYWxsXCIpO1xuY29uc3QgaGFuZ3VwQnV0dG9uID0gZ2V0QnV0dG9uKFwiaGFuZ3VwXCIpO1xuY29uc3QgZGlzY29ubmVjdEJ1dHRvbiA9IGdldEJ1dHRvbihcImRpc2Nvbm5lY3RcIik7XG5jb25zdCBhdWRpb0VsZW1lbnQgPSBnZXRBdWRpbyhcInJlbW90ZUF1ZGlvXCIpO1xuY29uc3Qga2V5cGFkID0gZ2V0QnV0dG9ucyhcImtleXBhZFwiKTtcbmNvbnN0IGR0bWZTcGFuID0gZ2V0U3BhbihcImR0bWZcIik7XG5jb25zdCBob2xkQ2hlY2tib3ggPSBnZXRJbnB1dChcImhvbGRcIik7XG5jb25zdCBtdXRlQ2hlY2tib3ggPSBnZXRJbnB1dChcIm11dGVcIik7XG5cbi8vIFdlYlNvY2tldCBTZXJ2ZXIgVVJMXG5jb25zdCB3ZWJTb2NrZXRTZXJ2ZXIgPSBcIndzczovL2VkZ2Uuc2lwLm9uc2lwLmNvbVwiO1xuc2VydmVyU3Bhbi5pbm5lckhUTUwgPSB3ZWJTb2NrZXRTZXJ2ZXI7XG5cbi8vIERlc3RpbmF0aW9uIFVSSVxuY29uc3QgdGFyZ2V0ID0gXCJzaXA6d2VsY29tZUBvbnNpcC5jb21cIjtcbnRhcmdldFNwYW4uaW5uZXJIVE1MID0gdGFyZ2V0O1xuXG4vLyBOYW1lIGZvciBkZW1vIHVzZXJcbmNvbnN0IGRpc3BsYXlOYW1lID0gXCJTSVAuanMgRGVtb1wiO1xuXG4vLyBTaW1wbGVVc2VyIGRlbGVnYXRlXG5jb25zdCBzaW1wbGVVc2VyRGVsZWdhdGU6IFNpbXBsZVVzZXJEZWxlZ2F0ZSA9IHtcbiAgb25DYWxsQ3JlYXRlZDogKCk6IHZvaWQgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBbJHtkaXNwbGF5TmFtZX1dIENhbGwgY3JlYXRlZGApO1xuICAgIGNhbGxCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgIGhhbmd1cEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIGtleXBhZERpc2FibGVkKHRydWUpO1xuICAgIGhvbGRDaGVja2JveERpc2FibGVkKHRydWUpO1xuICAgIG11dGVDaGVja2JveERpc2FibGVkKHRydWUpO1xuICB9LFxuICBvbkNhbGxBbnN3ZXJlZDogKCk6IHZvaWQgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBbJHtkaXNwbGF5TmFtZX1dIENhbGwgYW5zd2VyZWRgKTtcbiAgICBrZXlwYWREaXNhYmxlZChmYWxzZSk7XG4gICAgaG9sZENoZWNrYm94RGlzYWJsZWQoZmFsc2UpO1xuICAgIG11dGVDaGVja2JveERpc2FibGVkKGZhbHNlKTtcbiAgfSxcbiAgb25DYWxsSGFuZ3VwOiAoKTogdm9pZCA9PiB7XG4gICAgY29uc29sZS5sb2coYFske2Rpc3BsYXlOYW1lfV0gQ2FsbCBoYW5ndXBgKTtcbiAgICBjYWxsQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgaGFuZ3VwQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICBrZXlwYWREaXNhYmxlZCh0cnVlKTtcbiAgICBob2xkQ2hlY2tib3hEaXNhYmxlZCh0cnVlKTtcbiAgICBtdXRlQ2hlY2tib3hEaXNhYmxlZCh0cnVlKTtcbiAgfSxcbiAgb25DYWxsSG9sZDogKGhlbGQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICBjb25zb2xlLmxvZyhgWyR7ZGlzcGxheU5hbWV9XSBDYWxsIGhvbGQgJHtoZWxkfWApO1xuICAgIGhvbGRDaGVja2JveC5jaGVja2VkID0gaGVsZDtcbiAgfVxufTtcblxuLy8gU2ltcGxlVXNlciBvcHRpb25zXG5jb25zdCBzaW1wbGVVc2VyT3B0aW9uczogU2ltcGxlVXNlck9wdGlvbnMgPSB7XG4gIGRlbGVnYXRlOiBzaW1wbGVVc2VyRGVsZWdhdGUsXG4gIG1lZGlhOiB7XG4gICAgcmVtb3RlOiB7XG4gICAgICBhdWRpbzogYXVkaW9FbGVtZW50XG4gICAgfVxuICB9LFxuICB1c2VyQWdlbnRPcHRpb25zOiB7XG4gICAgZGlzcGxheU5hbWVcbiAgfVxufTtcblxuLy8gU2ltcGxlVXNlciBjb25zdHJ1Y3Rpb25cbmNvbnN0IHNpbXBsZVVzZXIgPSBuZXcgU2ltcGxlVXNlcih3ZWJTb2NrZXRTZXJ2ZXIsIHNpbXBsZVVzZXJPcHRpb25zKTtcblxuLy8gQWRkIGNsaWNrIGxpc3RlbmVyIHRvIGNvbm5lY3QgYnV0dG9uXG5jb25uZWN0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gIGNvbm5lY3RCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICBkaXNjb25uZWN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgY2FsbEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gIGhhbmd1cEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gIHNpbXBsZVVzZXIuY29ubmVjdCgpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgY29ubmVjdEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICBkaXNjb25uZWN0QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICBjYWxsQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICBoYW5ndXBCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgIH0pXG4gICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgIGNvbm5lY3RCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFske3NpbXBsZVVzZXIuaWR9XSBmYWlsZWQgdG8gY29ubmVjdGApO1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICBhbGVydChcIkZhaWxlZCB0byBjb25uZWN0LlxcblwiICsgZXJyb3IpO1xuICAgIH0pO1xufSk7XG5cbi8vIEFkZCBjbGljayBsaXN0ZW5lciB0byBjYWxsIGJ1dHRvblxuY2FsbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICBjYWxsQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgaGFuZ3VwQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgc2ltcGxlVXNlci5jYWxsKHRhcmdldClcbiAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihgWyR7c2ltcGxlVXNlci5pZH1dIGZhaWxlZCB0byBwbGFjZSBjYWxsYCk7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHBsYWNlIGNhbGwuXFxuXCIgKyBlcnJvcik7XG4gICAgfSk7XG59KTtcblxuLy8gQWRkIGNsaWNrIGxpc3RlbmVyIHRvIGhhbmd1cCBidXR0b25cbmhhbmd1cEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICBjYWxsQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgaGFuZ3VwQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgc2ltcGxlVXNlci5oYW5ndXAoKVxuICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbJHtzaW1wbGVVc2VyLmlkfV0gZmFpbGVkIHRvIGhhbmd1cCBjYWxsYCk7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIGhhbmd1cCBjYWxsLlxcblwiICsgZXJyb3IpO1xuICAgIH0pO1xufSk7XG5cbi8vIEFkZCBjbGljayBsaXN0ZW5lciB0byBkaXNjb25uZWN0IGJ1dHRvblxuZGlzY29ubmVjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICBjb25uZWN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgZGlzY29ubmVjdEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gIGNhbGxCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICBoYW5ndXBCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICBzaW1wbGVVc2VyLmRpc2Nvbm5lY3QoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGNvbm5lY3RCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIGRpc2Nvbm5lY3RCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgY2FsbEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICBoYW5ndXBCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgIH0pXG4gICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFske3NpbXBsZVVzZXIuaWR9XSBmYWlsZWQgdG8gZGlzY29ubmVjdGApO1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICBhbGVydChcIkZhaWxlZCB0byBkaXNjb25uZWN0LlxcblwiICsgZXJyb3IpO1xuICAgIH0pO1xufSk7XG5cbi8vIEFkZCBjbGljayBsaXN0ZW5lcnMgdG8ga2V5cGFkIGJ1dHRvbnNcbmtleXBhZC5mb3JFYWNoKChidXR0b24pID0+IHtcbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgY29uc3QgdG9uZSA9IGJ1dHRvbi50ZXh0Q29udGVudDtcbiAgICBpZiAodG9uZSkge1xuICAgICAgc2ltcGxlVXNlci5zZW5kRFRNRih0b25lKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgZHRtZlNwYW4uaW5uZXJIVE1MICs9IHRvbmU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KTtcblxuLy8gS2V5cGFkIGhlbHBlciBmdW5jdGlvblxuY29uc3Qga2V5cGFkRGlzYWJsZWQgPSAoZGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAga2V5cGFkLmZvckVhY2goKGJ1dHRvbikgPT4gYnV0dG9uLmRpc2FibGVkID0gZGlzYWJsZWQpO1xuICBkdG1mU3Bhbi5pbm5lckhUTUwgPSBcIlwiO1xufTtcblxuLy8gQWRkIGNoYW5nZSBsaXN0ZW5lciB0byBob2xkIGNoZWNrYm94XG5ob2xkQ2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiB7XG4gIGlmIChob2xkQ2hlY2tib3guY2hlY2tlZCkge1xuICAgIC8vIENoZWNrYm94IGlzIGNoZWNrZWQuLlxuICAgIHNpbXBsZVVzZXIuaG9sZCgpXG4gICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICBob2xkQ2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtzaW1wbGVVc2VyLmlkfV0gZmFpbGVkIHRvIGhvbGQgY2FsbGApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgYWxlcnQoXCJGYWlsZWQgdG8gaG9sZCBjYWxsLlxcblwiICsgZXJyb3IpO1xuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hlY2tib3ggaXMgbm90IGNoZWNrZWQuLlxuICAgIHNpbXBsZVVzZXIudW5ob2xkKClcbiAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgIGhvbGRDaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgWyR7c2ltcGxlVXNlci5pZH1dIGZhaWxlZCB0byB1bmhvbGQgY2FsbGApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgYWxlcnQoXCJGYWlsZWQgdG8gdW5ob2xkIGNhbGwuXFxuXCIgKyBlcnJvcik7XG4gICAgICB9KTtcbiAgfVxufSk7XG5cbi8vIEhvbGQgaGVscGVyIGZ1bmN0aW9uXG5jb25zdCBob2xkQ2hlY2tib3hEaXNhYmxlZCA9IChkaXNhYmxlZDogYm9vbGVhbik6IHZvaWQgPT4ge1xuICBob2xkQ2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICBob2xkQ2hlY2tib3guZGlzYWJsZWQgPSBkaXNhYmxlZDtcbn07XG5cbi8vIEFkZCBjaGFuZ2UgbGlzdGVuZXIgdG8gbXV0ZSBjaGVja2JveFxubXV0ZUNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICBpZiAobXV0ZUNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAvLyBDaGVja2JveCBpcyBjaGVja2VkLi5cbiAgICBzaW1wbGVVc2VyLm11dGUoKTtcbiAgICBpZiAoIXNpbXBsZVVzZXIuaXNNdXRlZCkge1xuICAgICAgbXV0ZUNoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFske3NpbXBsZVVzZXIuaWR9XSBmYWlsZWQgdG8gbXV0ZSBjYWxsYCk7XG4gICAgICBhbGVydChcIkZhaWxlZCB0byBtdXRlIGNhbGwuXFxuXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBDaGVja2JveCBpcyBub3QgY2hlY2tlZC4uXG4gICAgc2ltcGxlVXNlci51bm11dGUoKTtcbiAgICBpZiAoIXNpbXBsZVVzZXIuaXNNdXRlZCkge1xuICAgICAgbXV0ZUNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcihgWyR7c2ltcGxlVXNlci5pZH1dIGZhaWxlZCB0byB1bm11dGUgY2FsbGApO1xuICAgICAgYWxlcnQoXCJGYWlsZWQgdG8gdW5tdXRlIGNhbGwuXFxuXCIpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIE11dGUgaGVscGVyIGZ1bmN0aW9uXG5jb25zdCBtdXRlQ2hlY2tib3hEaXNhYmxlZCA9IChkaXNhYmxlZDogYm9vbGVhbik6IHZvaWQgPT4ge1xuICBtdXRlQ2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICBtdXRlQ2hlY2tib3guZGlzYWJsZWQgPSBkaXNhYmxlZDtcbn07XG5cbi8vIEVuYWJsZSB0aGUgY29ubmVjdCBidXR0b25cbmNvbm5lY3RCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRBdWRpbyhpZDogc3RyaW5nKTogSFRNTEF1ZGlvRWxlbWVudCB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICBpZiAoIShlbCBpbnN0YW5jZW9mIEhUTUxBdWRpb0VsZW1lbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFbGVtZW50IFwiJHtpZH1cIiBub3QgZm91bmQgb3Igbm90IGFuIGF1ZGlvIGVsZW1lbnQuYCk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnV0dG9uKGlkOiBzdHJpbmcpOiBIVE1MQnV0dG9uRWxlbWVudCB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICBpZiAoIShlbCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRWxlbWVudCBcIiR7aWR9XCIgbm90IGZvdW5kIG9yIG5vdCBhIGJ1dHRvbiBlbGVtZW50LmApO1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1dHRvbnMoaWQ6IHN0cmluZyk6IEFycmF5PEhUTUxCdXR0b25FbGVtZW50PiB7XG4gIGNvbnN0IGVscyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaWQpO1xuICBpZiAoIWVscy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVsZW1lbnRzIFwiJHtpZH1cIiBub3QgZm91bmQuYCk7XG4gIH1cbiAgY29uc3QgYnV0dG9uczogQXJyYXk8SFRNTEJ1dHRvbkVsZW1lbnQ+ID0gW107XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwcmVmZXItZm9yLW9mXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZWwgPSBlbHNbaV07XG4gICAgaWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRWxlbWVudCAke2l9IG9mIFwiJHtpZH1cIiBub3QgYSBidXR0b24gZWxlbWVudC5gKTtcbiAgICB9XG4gICAgYnV0dG9ucy5wdXNoKGVsKTtcbiAgfVxuICByZXR1cm4gYnV0dG9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldElucHV0KGlkOiBzdHJpbmcpOiBIVE1MSW5wdXRFbGVtZW50IHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gIGlmICghKGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVsZW1lbnQgXCIke2lkfVwiIG5vdCBmb3VuZCBvciBub3QgYW4gaW5wdXQgZWxlbWVudC5gKTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcGFuKGlkOiBzdHJpbmcpOiBIVE1MU3BhbkVsZW1lbnQge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgaWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MU3BhbkVsZW1lbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFbGVtZW50IFwiJHtpZH1cIiBub3QgZm91bmQgb3Igbm90IGEgc3BhbiBlbGVtZW50LmApO1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZGVvKGlkOiBzdHJpbmcpOiBIVE1MVmlkZW9FbGVtZW50IHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gIGlmICghKGVsIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVsZW1lbnQgXCIke2lkfVwiIG5vdCBmb3VuZCBvciBub3QgYSB2aWRlbyBlbGVtZW50LmApO1xuICB9XG4gIHJldHVybiBlbDtcbn1cbiIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0dmFyIENyeXB0b0pTID0gQ3J5cHRvSlMgfHwgKGZ1bmN0aW9uIChNYXRoLCB1bmRlZmluZWQpIHtcblx0ICAgIC8qXG5cdCAgICAgKiBMb2NhbCBwb2x5ZmlsIG9mIE9iamVjdC5jcmVhdGVcblx0ICAgICAqL1xuXHQgICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBGKCkge307XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcblxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSlcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGlicmFyeSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2xpYiA9IEMubGliID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZSBvYmplY3QgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XG5cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTcGF3blxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBjcmVhdGUodGhpcyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEF1Z21lbnRcblx0ICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSB8fCB0aGlzLmluaXQgPT09IHN1YnR5cGUuaW5pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBzdXBlcnR5cGVcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuXHQgICAgICAgICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXG5cdCAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29uY2F0XG5cdCAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcFxuXHQgICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblxuXHQgICAgICAgICAgICB2YXIgciA9IChmdW5jdGlvbiAobV93KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbV93ID0gbV93O1xuXHQgICAgICAgICAgICAgICAgdmFyIG1feiA9IDB4M2FkZTY4YjE7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFzayA9IDB4ZmZmZmZmZmY7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbV96ID0gKDB4OTA2OSAqIChtX3ogJiAweEZGRkYpICsgKG1feiA+PiAweDEwKSkgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIG1fdyA9ICgweDQ2NTAgKiAobV93ICYgMHhGRkZGKSArIChtX3cgPj4gMHgxMCkpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gKChtX3ogPDwgMHgxMCkgKyBtX3cpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgLz0gMHgxMDAwMDAwMDA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IDAuNTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAuNSA/IDEgOiAtMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByY2FjaGU7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9yID0gcigocmNhY2hlIHx8IE1hdGgucmFuZG9tKCkpICogMHgxMDAwMDAwMDApO1xuXG5cdCAgICAgICAgICAgICAgICByY2FjaGUgPSBfcigpICogMHgzYWRlNjdiNztcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5jb2RlciBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcblx0ICAgICAqL1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDUxMi8zMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xuXG5cdCAgICByZXR1cm4gQztcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIFJlZmxlY3RBcHBseSh0aGlzLmxpc3RlbmVyLCB0aGlzLnRhcmdldCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgTG9nZ2VyLCBPdXRnb2luZ0J5ZVJlcXVlc3QgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgQnllckJ5ZU9wdGlvbnMgfSBmcm9tIFwiLi9ieWVyLWJ5ZS1vcHRpb25zXCI7XG5pbXBvcnQgeyBCeWVyT3B0aW9ucyB9IGZyb20gXCIuL2J5ZXItb3B0aW9uc1wiO1xuaW1wb3J0IHsgSW52aXRhdGlvbiB9IGZyb20gXCIuL2ludml0YXRpb25cIjtcbmltcG9ydCB7IEludml0ZXIgfSBmcm9tIFwiLi9pbnZpdGVyXCI7XG5pbXBvcnQgeyBTZXNzaW9uIH0gZnJvbSBcIi4vc2Vzc2lvblwiO1xuaW1wb3J0IHsgU2Vzc2lvblN0YXRlIH0gZnJvbSBcIi4vc2Vzc2lvbi1zdGF0ZVwiO1xuXG4vKipcbiAqIEEgYnllciBlbmRzIGEge0BsaW5rIFNlc3Npb259IChvdXRnb2luZyBCWUUpLlxuICogQHJlbWFya3NcbiAqIFNlbmRzIGFuIG91dGdvaW5nIGluIGRpYWxvZyBCWUUgcmVxdWVzdC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEJ5ZXIge1xuICAvKiogVGhlIGxvZ2dlci4gKi9cbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcbiAgLyoqIFRoZSBieWVyIHNlc3Npb24uICovXG4gIHByaXZhdGUgX3Nlc3Npb246IFNlc3Npb247XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBCeWVyYCBjbGFzcy5cbiAgICogQHBhcmFtIHNlc3Npb24gLSBUaGUgc2Vzc2lvbiB0aGUgQllFIHdpbGwgYmUgc2VudCBmcm9tLiBTZWUge0BsaW5rIFNlc3Npb259IGZvciBkZXRhaWxzLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgYnVja2V0LiBTZWUge0BsaW5rIEJ5ZXJPcHRpb25zfSBmb3IgZGV0YWlscy5cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzZXNzaW9uOiBTZXNzaW9uLCBvcHRpb25zPzogQnllck9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IHNlc3Npb24udXNlckFnZW50LmdldExvZ2dlcihcInNpcC5CeWVyXCIpO1xuICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uO1xuICB9XG5cbiAgLyoqIFRoZSBieWVyIHNlc3Npb24uICovXG4gIHB1YmxpYyBnZXQgc2Vzc2lvbigpOiBTZXNzaW9uIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgQllFIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIEJ5ZXJCeWVPcHRpb25zfSBvcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHB1YmxpYyBieWUob3B0aW9uczogQnllckJ5ZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8T3V0Z29pbmdCeWVSZXF1ZXN0PiB7XG4gICAgbGV0IG1lc3NhZ2UgPSBcIkJ5ZXIuYnllKCkgbWF5IG9ubHkgYmUgY2FsbGVkIGlmIGVzdGFibGlzaGVkIHNlc3Npb24uXCI7XG5cbiAgICBzd2l0Y2ggKHRoaXMuc2Vzc2lvbi5zdGF0ZSkge1xuICAgICAgY2FzZSBTZXNzaW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiBpbnN0YW5jZW9mIEludml0ZXIpIHtcbiAgICAgICAgICBtZXNzYWdlICs9IFwiIEhvd2V2ZXIgSW52aXRlci5pbnZpdGUoKSBoYXMgbm90IHlldCBiZWVuIGNhbGxlZC5cIjtcbiAgICAgICAgICBtZXNzYWdlICs9IFwiIFBlcmhhcHMgeW91IHNob3VsZCBoYXZlIGNhbGxlZCBJbnZpdGVyLmNhbmNlbCgpP1wiO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2Vzc2lvbiBpbnN0YW5jZW9mIEludml0YXRpb24pIHtcbiAgICAgICAgICBtZXNzYWdlICs9IFwiIEhvd2V2ZXIgSW52aXRhdGlvbi5hY2NlcHQoKSBoYXMgbm90IHlldCBiZWVuIGNhbGxlZC5cIjtcbiAgICAgICAgICBtZXNzYWdlICs9IFwiIFBlcmhhcHMgeW91IHNob3VsZCBoYXZlIGNhbGxlZCBJbnZpdGF0aW9uLnJlamVjdCgpP1wiO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoaW5nOlxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uIGluc3RhbmNlb2YgSW52aXRlcikge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgSG93ZXZlciBhIGRpYWxvZyBkb2VzIG5vdCB5ZXQgZXhpc3QuXCI7XG4gICAgICAgICAgbWVzc2FnZSArPSBcIiBQZXJoYXBzIHlvdSBzaG91bGQgaGF2ZSBjYWxsZWQgSW52aXRlci5jYW5jZWwoKT9cIjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlc3Npb24gaW5zdGFuY2VvZiBJbnZpdGF0aW9uKSB7XG4gICAgICAgICAgbWVzc2FnZSArPSBcIiBIb3dldmVyIEludml0YXRpb24uYWNjZXB0KCkgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQgKG9yIG5vdCB5ZXQgcmVzb2x2ZWQpLlwiO1xuICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgUGVyaGFwcyB5b3Ugc2hvdWxkIGhhdmUgY2FsbGVkIEludml0YXRpb24ucmVqZWN0KCk/XCI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZDpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5fYnllKG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLCBvcHRpb25zLnJlcXVlc3RPcHRpb25zKTtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLlRlcm1pbmF0aW5nOlxuICAgICAgICBtZXNzYWdlICs9IFwiIEhvd2V2ZXIgdGhpcyBzZXNzaW9uIGlzIGFscmVhZHkgdGVybWluYXRpbmcuXCI7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24gaW5zdGFuY2VvZiBJbnZpdGVyKSB7XG4gICAgICAgICAgbWVzc2FnZSArPSBcIiBQZXJoYXBzIHlvdSBoYXZlIGFscmVhZHkgY2FsbGVkIEludml0ZXIuY2FuY2VsKCk/XCI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXNzaW9uIGluc3RhbmNlb2YgSW52aXRhdGlvbikge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgUGVyaGFwcyB5b3UgaGF2ZSBhbHJlYWR5IGNhbGxlZCBCeWVyLmJ5ZSgpP1wiO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTZXNzaW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgbWVzc2FnZSArPSBcIiBIb3dldmVyIHRoaXMgc2Vzc2lvbiBpcyBhbHJlYWR5IHRlcm1pbmF0ZWQuXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBJbnZhbGlkIHNlc3Npb24gc3RhdGUgJHt0aGlzLnNlc3Npb24uc3RhdGV9YCkpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRzXCI7XG5cbi8qKlxuICogR2VuZXJpYyBvYnNlcnZhYmxlLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEVtaXR0ZXI8VD4ge1xuICAvKipcbiAgICogU2V0cyB1cCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHRhcmdldCBjaGFuZ2VzLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0aGF0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXQgdGhlIGxpc3RlbmVyLlxuICAgKiAgICAgICAgICAgICAgICAgIElmIG9uY2UgdHJ1ZSwgaW5kaWNhdGVzIHRoYXQgdGhlIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC5cbiAgICogICAgICAgICAgICAgICAgICBJZiBvbmNlIHRydWUsIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKi9cbiAgYWRkTGlzdGVuZXIobGlzdGVuZXI6IChkYXRhOiBUKSA9PiB2b2lkLCBvcHRpb25zPzogeyBvbmNlPzogYm9vbGVhbiB9KTogdm9pZDtcbiAgLyoqXG4gICAqIFJlbW92ZXMgZnJvbSB0aGUgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkTGlzdGVuZXIuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXI6IChkYXRhOiBUKSA9PiB2b2lkKTogdm9pZDtcbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFkZExpc3RlbmVyLlxuICAgKi9cbiAgb24obGlzdGVuZXI6IChkYXRhOiBUKSA9PiB2b2lkKTogdm9pZDtcbiAgLyoqXG4gICAqIFVucmVnaXN0ZXJzIGEgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVtb3ZlTGlzdGVuZXIuXG4gICAqL1xuICBvZmYobGlzdGVuZXI6IChkYXRhOiBUKSA9PiB2b2lkKTogdm9pZDtcbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoZW4gdW5yZWdpc3RlcnMgdGhlIGxpc3RlbmVyIGFmdGVyIG9uZSBldmVudCBlbWlzc2lvbi5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEBkZXByZWNhdGVkIFVzZSBhZGRMaXN0ZW5lci5cbiAgICovXG4gIG9uY2UobGlzdGVuZXI6IChkYXRhOiBUKSA9PiB2b2lkKTogdm9pZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIHtAbGluayBFbWl0dGVyfS5cbiAqIEBwYXJhbSBldmVudEVtaXR0ZXIgLSBBbiBldmVudCBlbWl0dGVyLlxuICogQHBhcmFtIGV2ZW50TmFtZSAtIEV2ZW50IG5hbWUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tYWtlRW1pdHRlcjxUPihldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlciwgZXZlbnROYW1lOiBzdHJpbmcgPSBcImV2ZW50XCIpOiBFbWl0dGVyPFQ+IHtcbiAgcmV0dXJuIHtcbiAgICBhZGRMaXN0ZW5lcjogKGxpc3RlbmVyOiAoZGF0YTogVCkgPT4gdm9pZCwgb3B0aW9uczogeyBvbmNlPzogYm9vbGVhbiB9ID0ge30pOiB2b2lkID0+IHtcbiAgICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgICAgZXZlbnRFbWl0dGVyLm9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudEVtaXR0ZXIuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcjogKGxpc3RlbmVyOiAoZGF0YTogVCkgPT4gdm9pZCk6IHZvaWQgPT4ge1xuICAgICAgZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgb246IChsaXN0ZW5lcjogKGRhdGE6IFQpID0+IHZvaWQpOiB2b2lkID0+IHtcbiAgICAgIGV2ZW50RW1pdHRlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIG9mZjogKGxpc3RlbmVyOiAoZGF0YTogVCkgPT4gdm9pZCk6IHZvaWQgPT4ge1xuICAgICAgZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgb25jZTogKGxpc3RlbmVyOiAoZGF0YTogVCkgPT4gdm9pZCk6IHZvaWQgPT4ge1xuICAgICAgZXZlbnRFbWl0dGVyLm9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IHsgRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcblxuLyoqXG4gKiBBbiBleGNlcHRpb24gaW5kaWNhdGluZyBhbiB1bnN1cHBvcnRlZCBjb250ZW50IHR5cGUgcHJldmVudGVkIGV4ZWN1dGlvbi5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRlbnRUeXBlVW5zdXBwb3J0ZWRFcnJvciBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSA/IG1lc3NhZ2UgOiBcIlVuc3VwcG9ydGVkIGNvbnRlbnQgdHlwZS5cIik7XG4gIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gXCIuL2NvbnRlbnQtdHlwZS11bnN1cHBvcnRlZFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmVxdWVzdC1wZW5kaW5nXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXNzaW9uLWRlc2NyaXB0aW9uLWhhbmRsZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Nlc3Npb24tdGVybWluYXRlZFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3RhdGUtdHJhbnNpdGlvblwiO1xuIiwiaW1wb3J0IHsgRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcblxuLyoqXG4gKiBBbiBleGNlcHRpb24gaW5kaWNhdGluZyBhbiBvdXRzdGFuZGluZyBwcmlvciByZXF1ZXN0IHByZXZlbnRlZCBleGVjdXRpb24uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXF1ZXN0UGVuZGluZ0Vycm9yIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UgPyBtZXNzYWdlIDogXCJSZXF1ZXN0IHBlbmRpbmcuXCIpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBFeGNlcHRpb24gfSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuXG4vKipcbiAqIEFuIGV4Y2VwdGlvbiBpbmRpY2F0aW5nIGEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGVycm9yIG9jY3VyZWQuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IgZXh0ZW5kcyBFeGNlcHRpb24ge1xuICBwdWJsaWMgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UgPyBtZXNzYWdlIDogXCJVbnNwZWNpZmllZCBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgZXJyb3IuXCIpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBFeGNlcHRpb24gfSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuXG4vKipcbiAqIEFuIGV4Y2VwdGlvbiBpbmRpY2F0aW5nIHRoZSBzZXNzaW9uIHRlcm1pbmF0ZWQgYmVmb3JlIHRoZSBhY3Rpb24gY29tcGxldGVkLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgU2Vzc2lvblRlcm1pbmF0ZWRFcnJvciBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoZSBzZXNzaW9uIGhhcyB0ZXJtaW5hdGVkLlwiKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcblxuLyoqXG4gKiBBbiBleGNlcHRpb24gaW5kaWNhdGluZyBhbiBpbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gZXJyb3Igb2NjdXJlZC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRlVHJhbnNpdGlvbkVycm9yIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlID8gbWVzc2FnZSA6IFwiQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHN0YXRlIHRyYW5zaXRpb24uXCIpO1xuICB9XG59XG4iLCIvKipcbiAqIEEgc2ltcGxlIHlldCBwb3dlcmZ1bCBBUEkgd2hpY2ggdGFrZXMgY2FyZSBvZiBTSVAgc2lnbmFsaW5nIGFuZCBXZWJSVEMgbWVkaWEgc2Vzc2lvbnMgZm9yIHlvdS5cbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5leHBvcnQgKiBmcm9tIFwiLi9leGNlcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ieWVyLWJ5ZS1vcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ieWVyLW9wdGlvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2J5ZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2VtaXR0ZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2luZm9cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2luZm9lci1pbmZvLW9wdGlvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2luZm9lci1vcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbmZvZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2ludml0YXRpb24tYWNjZXB0LW9wdGlvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2ludml0YXRpb24tcHJvZ3Jlc3Mtb3B0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW52aXRhdGlvbi1yZWplY3Qtb3B0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW52aXRhdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW52aXRlci1jYW5jZWwtb3B0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW52aXRlci1pbnZpdGUtb3B0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW52aXRlci1vcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbnZpdGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tZXNzYWdlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tZXNzYWdlci1vcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tZXNzYWdlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbm90aWZpY2F0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wdWJsaXNoZXItb3B0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vcHVibGlzaGVyLXB1Ymxpc2gtb3B0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vcHVibGlzaGVyLXN0YXRlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wdWJsaXNoZXItdW5wdWJsaXNoLW9wdGlvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3B1Ymxpc2hlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmVmZXJyYWxcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3JlZmVycmVyLWRlbGVnYXRlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZWZlcnJlci1vcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZWZlcnJlci1yZWZlci1vcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZWZlcnJlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmVnaXN0ZXJlci1vcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZWdpc3RlcmVyLXJlZ2lzdGVyLW9wdGlvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3JlZ2lzdGVyZXItc3RhdGVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3JlZ2lzdGVyZXItdW5yZWdpc3Rlci1vcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZWdpc3RlcmVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXNzaW9uLWRlbGVnYXRlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXNzaW9uLWRlc2NyaXB0aW9uLWhhbmRsZXItZmFjdG9yeVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2Vzc2lvbi1kZXNjcmlwdGlvbi1oYW5kbGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXNzaW9uLWludml0ZS1vcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXNzaW9uLW9wdGlvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Nlc3Npb24tc3RhdGVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Nlc3Npb25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N1YnNjcmliZXItb3B0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3Vic2NyaWJlci1zdWJzY3JpYmUtb3B0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3Vic2NyaWJlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3Vic2NyaXB0aW9uLWRlbGVnYXRlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zdWJzY3JpcHRpb24tb3B0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3Vic2NyaXB0aW9uLXN0YXRlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zdWJzY3JpcHRpb24tc3Vic2NyaWJlLW9wdGlvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N1YnNjcmlwdGlvbi11bnN1YnNjcmliZS1vcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zdWJzY3JpcHRpb25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RyYW5zcG9ydFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHJhbnNwb3J0LXN0YXRlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91c2VyLWFnZW50LWRlbGVnYXRlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91c2VyLWFnZW50LW9wdGlvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3VzZXItYWdlbnQtc3RhdGVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3VzZXItYWdlbnRcIjtcbiIsImltcG9ydCB7XG4gIEluY29taW5nSW5mb1JlcXVlc3QsXG4gIEluY29taW5nUmVxdWVzdE1lc3NhZ2UsXG4gIFJlc3BvbnNlT3B0aW9uc1xufSBmcm9tIFwiLi4vY29yZVwiO1xuXG4vKipcbiAqIEFuIGV4Y2hhbmdlIG9mIGluZm9ybWF0aW9uIChpbmNvbWluZyBJTkZPKS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEluZm8ge1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5jb21pbmdJbmZvUmVxdWVzdDogSW5jb21pbmdJbmZvUmVxdWVzdCkge1xuICB9XG5cbiAgLyoqIEluY29taW5nIE1FU1NBR0UgcmVxdWVzdCBtZXNzYWdlLiAqL1xuICBwdWJsaWMgZ2V0IHJlcXVlc3QoKTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSB7XG4gICAgcmV0dXJuIHRoaXMuaW5jb21pbmdJbmZvUmVxdWVzdC5tZXNzYWdlO1xuICB9XG5cbiAgLyoqIEFjY2VwdCB0aGUgcmVxdWVzdC4gKi9cbiAgcHVibGljIGFjY2VwdChvcHRpb25zPzogUmVzcG9uc2VPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pbmNvbWluZ0luZm9SZXF1ZXN0LmFjY2VwdChvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvKiogUmVqZWN0IHRoZSByZXF1ZXN0LiAqL1xuICBwdWJsaWMgcmVqZWN0KG9wdGlvbnM/OiBSZXNwb25zZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmluY29taW5nSW5mb1JlcXVlc3QucmVqZWN0KG9wdGlvbnMpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTG9nZ2VyLCBPdXRnb2luZ0luZm9SZXF1ZXN0IH0gZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCB7IEluZm9lckluZm9PcHRpb25zIH0gZnJvbSBcIi4vaW5mb2VyLWluZm8tb3B0aW9uc1wiO1xuaW1wb3J0IHsgSW5mb2VyT3B0aW9ucyB9IGZyb20gXCIuL2luZm9lci1vcHRpb25zXCI7XG5pbXBvcnQgeyBTZXNzaW9uIH0gZnJvbSBcIi4vc2Vzc2lvblwiO1xuaW1wb3J0IHsgU2Vzc2lvblN0YXRlIH0gZnJvbSBcIi4vc2Vzc2lvbi1zdGF0ZVwiO1xuXG4vKipcbiAqIEFuIEluZm9lciBzZW5kcyB7QGxpbmsgSW5mb30gKG91dGdvaW5nIElORk8pLlxuICogQHJlbWFya3NcbiAqIFNlbmRzIGFuIG91dGdvaW5nIGluIGRpYWxvZyBJTkZPIHJlcXVlc3QuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmZvZXIge1xuICAvKiogVGhlIGxvZ2dlci4gKi9cbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcbiAgLyoqIFRoZSBJbmZvZXIgc2Vzc2lvbi4gKi9cbiAgcHJpdmF0ZSBfc2Vzc2lvbjogU2Vzc2lvbjtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYEluZm9lcmAgY2xhc3MuXG4gICAqIEBwYXJhbSBzZXNzaW9uIC0gVGhlIHNlc3Npb24gdGhlIElORk8gd2lsbCBiZSBzZW50IGZyb20uIFNlZSB7QGxpbmsgU2Vzc2lvbn0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2Vzc2lvbjogU2Vzc2lvbiwgb3B0aW9ucz86IEluZm9lck9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IHNlc3Npb24udXNlckFnZW50LmdldExvZ2dlcihcInNpcC5JbmZvZXJcIik7XG4gICAgdGhpcy5fc2Vzc2lvbiA9IHNlc3Npb247XG4gIH1cblxuICAvKiogVGhlIEluZm9lciBzZXNzaW9uLiAqL1xuICBwdWJsaWMgZ2V0IHNlc3Npb24oKTogU2Vzc2lvbiB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgdGhlIElORk8gcmVxdWVzdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSW5mb2VySW5mb09wdGlvbnN9IG9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgcHVibGljIGluZm8ob3B0aW9uczogSW5mb2VySW5mb09wdGlvbnMgPSB7fSk6IFByb21pc2U8T3V0Z29pbmdJbmZvUmVxdWVzdD4ge1xuICAgIC8vIGd1YXJkIHNlc3Npb24gc3RhdGVcbiAgICBpZiAodGhpcy5zZXNzaW9uLnN0YXRlICE9PSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIkluZm9lci5pbmZvKCkgbWF5IG9ubHkgYmUgY2FsbGVkIGlmIGVzdGFibGlzaGVkIHNlc3Npb24uXCI7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYEludmFsaWQgc2Vzc2lvbiBzdGF0ZSAke3RoaXMuc2Vzc2lvbi5zdGF0ZX1gKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5faW5mbyhvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEJvZHksXG4gIGZyb21Cb2R5TGVnYWN5LFxuICBnZXRCb2R5LFxuICBHcmFtbWFyLFxuICBJbmNvbWluZ0ludml0ZVJlcXVlc3QsXG4gIEluY29taW5nUHJhY2tSZXF1ZXN0LFxuICBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIsXG4gIExvZ2dlcixcbiAgTmFtZUFkZHJIZWFkZXIsXG4gIE91dGdvaW5nUmVzcG9uc2UsXG4gIE91dGdvaW5nUmVzcG9uc2VXaXRoU2Vzc2lvbixcbiAgU2lnbmFsaW5nU3RhdGUsXG4gIFRpbWVycyxcbiAgVHJhbnNhY3Rpb25TdGF0ZUVycm9yXG59IGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBnZXRSZWFzb25QaHJhc2UgfSBmcm9tIFwiLi4vY29yZS9tZXNzYWdlcy91dGlsc1wiO1xuaW1wb3J0IHsgQ29udGVudFR5cGVVbnN1cHBvcnRlZEVycm9yLCBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IsIFNlc3Npb25UZXJtaW5hdGVkRXJyb3IgfSBmcm9tIFwiLi9leGNlcHRpb25zXCI7XG5pbXBvcnQgeyBJbnZpdGF0aW9uQWNjZXB0T3B0aW9ucyB9IGZyb20gXCIuL2ludml0YXRpb24tYWNjZXB0LW9wdGlvbnNcIjtcbmltcG9ydCB7IEludml0YXRpb25Qcm9ncmVzc09wdGlvbnMgfSBmcm9tIFwiLi9pbnZpdGF0aW9uLXByb2dyZXNzLW9wdGlvbnNcIjtcbmltcG9ydCB7IEludml0YXRpb25SZWplY3RPcHRpb25zIH0gZnJvbSBcIi4vaW52aXRhdGlvbi1yZWplY3Qtb3B0aW9uc1wiO1xuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gXCIuL3Nlc3Npb25cIjtcbmltcG9ydCB7XG4gIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcixcbiAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnNcbn0gZnJvbSBcIi4vc2Vzc2lvbi1kZXNjcmlwdGlvbi1oYW5kbGVyXCI7XG5pbXBvcnQgeyBTZXNzaW9uU3RhdGUgfSBmcm9tIFwiLi9zZXNzaW9uLXN0YXRlXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnQgfSBmcm9tIFwiLi91c2VyLWFnZW50XCI7XG5pbXBvcnQgeyBTSVBFeHRlbnNpb24gfSBmcm9tIFwiLi91c2VyLWFnZW50LW9wdGlvbnNcIjtcblxudHlwZSBSZXNvbHZlRnVuY3Rpb24gPSAoKSA9PiB2b2lkO1xudHlwZSBSZWplY3RGdW5jdGlvbiA9IChyZWFzb246IEVycm9yKSA9PiB2b2lkO1xuXG4vKipcbiAqIEFuIGludml0YXRpb24gaXMgYW4gb2ZmZXIgdG8gZXN0YWJsaXNoIGEge0BsaW5rIFNlc3Npb259IChpbmNvbWluZyBJTlZJVEUpLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSW52aXRhdGlvbiBleHRlbmRzIFNlc3Npb24ge1xuXG4gIC8qKlxuICAgKiBMb2dnZXIuXG4gICAqL1xuICBwcm90ZWN0ZWQgbG9nZ2VyOiBMb2dnZXI7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQgX2lkOiBzdHJpbmc7XG5cbiAgLyoqIFRydWUgaWYgZGlzcG9zZSgpIGhhcyBiZWVuIGNhbGxlZC4gKi9cbiAgcHJpdmF0ZSBkaXNwb3NlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAvKiogSU5WSVRFIHdpbGwgYmUgcmVqZWN0ZWQgaWYgbm90IGFjY2VwdGVkIHdpdGhpbiBhIGNlcnRhaW4gcGVyaW9kIHRpbWUuICovXG4gIHByaXZhdGUgZXhwaXJlc1RpbWVyOiBhbnkgPSB1bmRlZmluZWQ7XG4gIC8qKiBUcnVlIGlmIHRoaXMgU2Vzc2lvbiBoYXMgYmVlbiBUZXJtaW5hdGVkIGR1ZSB0byBhIENBTkNFTCByZXF1ZXN0LiAqL1xuICBwcml2YXRlIGlzQ2FuY2VsZWQgPSBmYWxzZTtcbiAgLyoqIEFyZSByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZXMgcmVxdWlyZWQgb3Igc3VwcG9ydGVkLiAqL1xuICBwcml2YXRlIHJlbDEwMDogXCJub25lXCIgfCBcInJlcXVpcmVkXCIgfCBcInN1cHBvcnRlZFwiID0gXCJub25lXCI7XG4gIC8qKiBUaGUgY3VycmVudCBSU2VxIGhlYWRlciB2YWx1ZS4gKi9cbiAgcHJpdmF0ZSByc2VxID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAvKiogSU5WSVRFIHdpbGwgYmUgcmVqZWN0ZWQgaWYgZmluYWwgcmVzcG9uc2Ugbm90IHNlbnQgaW4gYSBjZXJ0YWluIHBlcmlvZCB0aW1lLiAqL1xuICBwcml2YXRlIHVzZXJOb0Fuc3dlclRpbWVyOiBhbnkgPSB1bmRlZmluZWQ7XG4gIC8qKiBUcnVlIGlmIHdhaXRpbmcgZm9yIGEgUFJBQ0sgYmVmb3JlIHNlbmRpbmcgYSAyMDAgT2suICovXG4gIHByaXZhdGUgd2FpdGluZ0ZvclByYWNrOiBib29sZWFuID0gZmFsc2U7XG4gIC8qKiBBIFByb21pc2UgcHJvdmlkaW5nIGEgZGVmZXIgd2hlbiB3YWl0aW5nIGZvciBhIFBSQUNLLiAqL1xuICBwcml2YXRlIHdhaXRpbmdGb3JQcmFja1Byb21pc2U6IFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWQ7XG4gIC8qKiBGdW5jdGlvbiB0byByZXNvbHZlIHdoZW4gUFJBQ0sgYXJyaXZlcy4gKi9cbiAgcHJpdmF0ZSB3YWl0aW5nRm9yUHJhY2tSZXNvbHZlOiBSZXNvbHZlRnVuY3Rpb24gfCB1bmRlZmluZWQ7XG4gIC8qKiBGdW5jdGlvbiB0byByZWplY3Qgd2hlbiBQUkFDSyBuZXZlciBhcnJpdmVzLiAqL1xuICBwcml2YXRlIHdhaXRpbmdGb3JQcmFja1JlamVjdDogUmVqZWN0RnVuY3Rpb24gfCB1bmRlZmluZWQ7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IodXNlckFnZW50OiBVc2VyQWdlbnQsIHByaXZhdGUgaW5jb21pbmdJbnZpdGVSZXF1ZXN0OiBJbmNvbWluZ0ludml0ZVJlcXVlc3QpIHtcbiAgICBzdXBlcih1c2VyQWdlbnQpO1xuXG4gICAgdGhpcy5sb2dnZXIgPSB1c2VyQWdlbnQuZ2V0TG9nZ2VyKFwic2lwLkludml0YXRpb25cIik7XG5cbiAgICBjb25zdCBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlID0gdGhpcy5pbmNvbWluZ0ludml0ZVJlcXVlc3QubWVzc2FnZTtcblxuICAgIC8vIFNldCAxMDByZWwgaWYgbmVjZXNzYXJ5XG4gICAgY29uc3QgcmVxdWlyZUhlYWRlciA9IGluY29taW5nUmVxdWVzdE1lc3NhZ2UuZ2V0SGVhZGVyKFwicmVxdWlyZVwiKTtcbiAgICBpZiAocmVxdWlyZUhlYWRlciAmJiByZXF1aXJlSGVhZGVyLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIjEwMHJlbFwiKSA+PSAwKSB7XG4gICAgICB0aGlzLnJlbDEwMCA9IFwicmVxdWlyZWRcIjtcbiAgICB9XG4gICAgY29uc3Qgc3VwcG9ydGVkSGVhZGVyID0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS5nZXRIZWFkZXIoXCJzdXBwb3J0ZWRcIik7XG4gICAgaWYgKHN1cHBvcnRlZEhlYWRlciAmJiBzdXBwb3J0ZWRIZWFkZXIudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiMTAwcmVsXCIpID49IDApIHtcbiAgICAgIHRoaXMucmVsMTAwID0gXCJzdXBwb3J0ZWRcIjtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIHRvVGFnIG9uIHRoZSBpbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UgdG8gdGhlIHRvVGFnIHdoaWNoXG4gICAgLy8gd2lsbCBiZSB1c2VkIGluIHRoZSByZXNwb25zZSB0byB0aGUgaW5jb21pbmcgcmVxdWVzdCEhIVxuICAgIC8vIEZJWE1FOiBIQUNLOiBUaGlzIGlzIGEgaGFjayB0byBwb3J0IGFuIGV4aXN0aW5nIGJlaGF2aW9yLlxuICAgIC8vIFRoZSBiZWhhdmlvciBiZWluZyBwb3J0ZWQgYXBwZWFycyB0byBiZSBhIGhhY2sgaXRzZWxmLFxuICAgIC8vIHNvIHRoaXMgaXMgYSBoYWNrIHRvIHBvcnQgYSBoYWNrLiBBdCBsZWFzdCBvbmUgdGVzdCBzcGVjXG4gICAgLy8gcmVsaWVzIG9uIGl0ICh3aGljaCBpcyB5ZXQgYW5vdGhlciBoYWNrKS5cbiAgICBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlLnRvVGFnID0gKGluY29taW5nSW52aXRlUmVxdWVzdCBhcyBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIgYXMgYW55KS50b1RhZztcbiAgICBpZiAodHlwZW9mIGluY29taW5nUmVxdWVzdE1lc3NhZ2UudG9UYWcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0b1RhZyBzaG91bGQgaGF2ZSBiZWVuIGEgc3RyaW5nLlwiKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIG1hcHBpbmcgdmFsdWVzIGFyZSBSRUNPTU1FTkRFRDpcbiAgICAvLyAuLi5cbiAgICAvLyAxOSBubyBhbnN3ZXIgZnJvbSB0aGUgdXNlciAgICAgICAgICAgICAgNDgwIFRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzOTgjc2VjdGlvbi03LjIuNC4xXG4gICAgdGhpcy51c2VyTm9BbnN3ZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaW5jb21pbmdJbnZpdGVSZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4MCB9KTtcbiAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICB9LCB0aGlzLnVzZXJBZ2VudC5jb25maWd1cmF0aW9uLm5vQW5zd2VyVGltZW91dCA/IHRoaXMudXNlckFnZW50LmNvbmZpZ3VyYXRpb24ubm9BbnN3ZXJUaW1lb3V0ICogMTAwMCA6IDYwMDAwKTtcblxuICAgIC8vIDEuIElmIHRoZSByZXF1ZXN0IGlzIGFuIElOVklURSB0aGF0IGNvbnRhaW5zIGFuIEV4cGlyZXMgaGVhZGVyXG4gICAgLy8gZmllbGQsIHRoZSBVQVMgY29yZSBzZXRzIGEgdGltZXIgZm9yIHRoZSBudW1iZXIgb2Ygc2Vjb25kc1xuICAgIC8vIGluZGljYXRlZCBpbiB0aGUgaGVhZGVyIGZpZWxkIHZhbHVlLiAgV2hlbiB0aGUgdGltZXIgZmlyZXMsIHRoZVxuICAgIC8vIGludml0YXRpb24gaXMgY29uc2lkZXJlZCB0byBiZSBleHBpcmVkLiAgSWYgdGhlIGludml0YXRpb25cbiAgICAvLyBleHBpcmVzIGJlZm9yZSB0aGUgVUFTIGhhcyBnZW5lcmF0ZWQgYSBmaW5hbCByZXNwb25zZSwgYSA0ODdcbiAgICAvLyAoUmVxdWVzdCBUZXJtaW5hdGVkKSByZXNwb25zZSBTSE9VTEQgYmUgZ2VuZXJhdGVkLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xXG4gICAgaWYgKGluY29taW5nUmVxdWVzdE1lc3NhZ2UuaGFzSGVhZGVyKFwiZXhwaXJlc1wiKSkge1xuICAgICAgY29uc3QgZXhwaXJlczogbnVtYmVyID0gTnVtYmVyKGluY29taW5nUmVxdWVzdE1lc3NhZ2UuZ2V0SGVhZGVyKFwiZXhwaXJlc1wiKSB8fCAwKSAqIDEwMDA7XG4gICAgICB0aGlzLmV4cGlyZXNUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2Vzc2lvblN0YXRlLkluaXRpYWwpIHtcbiAgICAgICAgICBpbmNvbWluZ0ludml0ZVJlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogNDg3IH0pO1xuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgfVxuICAgICAgfSwgZXhwaXJlcyk7XG4gICAgfVxuXG4gICAgLy8gU2Vzc2lvbiBwYXJlbnQgcHJvcGVydGllc1xuICAgIGNvbnN0IGFzc2VydGVkSWRlbnRpdHkgPSB0aGlzLnJlcXVlc3QuZ2V0SGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKTtcbiAgICBpZiAoYXNzZXJ0ZWRJZGVudGl0eSkge1xuICAgICAgdGhpcy5fYXNzZXJ0ZWRJZGVudGl0eSA9IEdyYW1tYXIubmFtZUFkZHJIZWFkZXJQYXJzZShhc3NlcnRlZElkZW50aXR5KTtcbiAgICB9XG4gICAgdGhpcy5fY29udGFjdCA9IHRoaXMudXNlckFnZW50LmNvbnRhY3QudG9TdHJpbmcoKTtcbiAgICBjb25zdCBjb250ZW50RGlzcG9zaXRpb24gPSBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlLnBhcnNlSGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcbiAgICBpZiAoY29udGVudERpc3Bvc2l0aW9uICYmIGNvbnRlbnREaXNwb3NpdGlvbi50eXBlID09PSBcInJlbmRlclwiKSB7XG4gICAgICB0aGlzLl9yZW5kZXJib2R5ID0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS5ib2R5O1xuICAgICAgdGhpcy5fcmVuZGVydHlwZSA9IGluY29taW5nUmVxdWVzdE1lc3NhZ2UuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZpZXJcbiAgICB0aGlzLl9pZCA9IGluY29taW5nUmVxdWVzdE1lc3NhZ2UuY2FsbElkICsgaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS5mcm9tVGFnO1xuXG4gICAgLy8gQWRkIHRvIHRoZSB1c2VyIGFnZW50J3Mgc2Vzc2lvbiBjb2xsZWN0aW9uLlxuICAgIHRoaXMudXNlckFnZW50Ll9zZXNzaW9uc1t0aGlzLl9pZF0gPSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3RydWN0b3IuXG4gICAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBPbmx5IHJ1biB0aHJvdWdoIHRoaXMgb25jZS4gSXQgY2FuIGFuZCBkb2VzIGdldCBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgICAvLyBkZXBlbmRpbmcgb24gdGhlIHdoYXQgdGhlIHNlc3Npb25zIHN0YXRlIGlzIHdoZW4gZmlyc3QgY2FsbGVkLlxuICAgIC8vIEZvciBleGFtcGxlLCBpZiBjYWxsZWQgd2hlbiBcImVzdGFibGlzaGluZ1wiIGl0IHdpbGwgYmUgY2FsbGVkIGFnYWluXG4gICAgLy8gYXQgbGVhc3Qgb25jZSB3aGVuIHRoZSBzZXNzaW9uIHRyYW5zaXRpb25zIHRvIFwidGVybWluYXRlZFwiLlxuICAgIC8vIFJlZ2FyZGxlc3MsIHJ1bm5pbmcgdGhyb3VnaCB0aGlzIG1vcmUgdGhhbiBvbmNlIGlzIHBvaW50bGVzcy5cbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcblxuICAgIC8vIENsZWFyIHRpbWVyc1xuICAgIGlmICh0aGlzLmV4cGlyZXNUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXhwaXJlc1RpbWVyKTtcbiAgICAgIHRoaXMuZXhwaXJlc1RpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy51c2VyTm9BbnN3ZXJUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudXNlck5vQW5zd2VyVGltZXIpO1xuICAgICAgdGhpcy51c2VyTm9BbnN3ZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBJZiBhY2NlcHQoKSBpcyBzdGlsbCB3YWl0aW5nIGZvciBhIFBSQUNLLCBtYWtlIHN1cmUgaXQgcmVqZWN0c1xuICAgIHRoaXMucHJhY2tOZXZlckFycml2ZWQoKTtcblxuICAgIC8vIElmIHRoZSBmaW5hbCByZXNwb25zZSBmb3IgdGhlIGluaXRpYWwgSU5WSVRFIG5vdCB5ZXQgYmVlbiBzZW50LCByZWplY3QgaXRcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLkluaXRpYWw6XG4gICAgICAgIHJldHVybiB0aGlzLnJlamVjdCgpLnRoZW4oKCkgPT4gc3VwZXIuZGlzcG9zZSgpKTtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLkVzdGFibGlzaGluZzpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVqZWN0KCkudGhlbigoKSA9PiBzdXBlci5kaXNwb3NlKCkpO1xuICAgICAgY2FzZSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQ6XG4gICAgICAgIHJldHVybiBzdXBlci5kaXNwb3NlKCk7XG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZzpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgIHJldHVybiBzdXBlci5kaXNwb3NlKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHN0YXRlLlwiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgdHJ1ZSwgYSBmaXJzdCBwcm92aXNpb25hbCByZXNwb25zZSBhZnRlciB0aGUgMTAwIFRyeWluZ1xuICAgKiB3aWxsIGJlIHNlbnQgYXV0b21hdGljYWxseS4gVGhpcyBpcyBmYWxzZSBpdCB0aGUgVUFDIHJlcXVpcmVkXG4gICAqIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyAoMTAwcmVsIGluIFJlcXVpcmUgaGVhZGVyKSxcbiAgICogb3RoZXJ3aXNlIGl0IGlzIHRydWUuIFRoZSBwcm92aXNpb25hbCBpcyBzZW50IGJ5IGNhbGxpbmdcbiAgICogYHByb2dyZXNzKClgIHdpdGhvdXQgYW55IG9wdGlvbnMuXG4gICAqXG4gICAqIEZJWE1FOiBUT0RPOiBJdCBzZWVtcyByZWFzb25hYmxlIHRoYXQgdGhlIElTQyB1c2VyIHNob3VsZFxuICAgKiBiZSBhYmxlIHRvIG9wdGlvbmFsbHkgZGlzYWJsZSB0aGlzIGJlaGF2aW9yLiBBcyB0aGUgcHJvdmlzaW9uYWxcbiAgICogaXMgc2VudCBwcmlvciB0byB0aGUgXCJpbnZpdGVcIiBldmVudCBiZWluZyBlbWl0dGVkLCBpdCdzIGEga25vd25cbiAgICogaXNzdWUgdGhhdCB0aGUgSVNDIHVzZXIgY2Fubm90IHJlZ2lzdGVyIGxpc3RlbmVycyBvciBkbyBhbnkgb3RoZXJcbiAgICogc2V0dXAgcHJpb3IgdG8gdGhlIGNhbGwgdG8gYHByb2dyZXNzKClgLiBBcyBhbiBleGFtcGxlIHdoeSB0aGlzIGlzXG4gICAqIGFuIGlzc3VlLCBzZXR0aW5nIGB1YS5jb25maWd1cmF0aW9uLnJlbDEwMGAgdG8gUkVRVUlSRUQgd2lsbCByZXN1bHRcbiAgICogaW4gYW4gYXR0ZW1wdCBieSBgcHJvZ3Jlc3MoKWAgdG8gc2VuZCBhIDE4MyB3aXRoIFNEUCBwcm9kdWNlZCBieVxuICAgKiBjYWxsaW5nIGBnZXREZXNjcmlwdGlvbigpYCBvbiBhIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciwgYnV0XG4gICAqIHRoZSBJU0MgdXNlciBjYW5ub3QgcGVyZm9ybSBhbnkgcG90ZW50aWFsbHkgcmVxdWlyZWQgc2Vzc2lvbiBkZXNjcmlwdGlvblxuICAgKiBoYW5kbGVyIGluaXRpYWxpemF0aW9uICh0aHVzIHByZXZlbnRpbmcgdGhlIHV0aWxpemF0aW9uIG9mIHNldHRpbmdcbiAgICogYHVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwYCB0byBSRVFVSVJFRCkuIFRoYXQgYmVncyB0aGUgcXVlc3Rpb24gb2ZcbiAgICogd2h5IHRoaXMgYmVoYXZpb3IgaXMgZGlzYWJsZWQgd2hlbiB0aGUgVUFDIHJlcXVpcmVzIDEwMHJlbCBidXQgbm90XG4gICAqIHdoZW4gdGhlIFVBUyByZXF1aXJlcyAxMDByZWw/IEJ1dCBpZ25vcmluZyB0aGF0LCBpdCdzIGp1c3Qgb25lIGV4YW1wbGVcbiAgICogb2YgYSBjbGFzcyBvZiBjYXNlcyB3aGVyZSB0aGUgSVNDIHVzZXIgbmVlZHMgdG8gZG8gc29tZXRoaW5nIHByaW9yXG4gICAqIHRvIHRoZSBmaXJzdCBjYWxsIHRvIGBwcm9ncmVzcygpYCBhbmQgaXMgdW5hYmxlIHRvIGRvIHNvLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBnZXQgYXV0b1NlbmRBbkluaXRpYWxQcm92aXNpb25hbFJlc3BvbnNlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnJlbDEwMCA9PT0gXCJyZXF1aXJlZFwiID8gZmFsc2UgOiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWwgaW5jb21pbmcgSU5WSVRFIHJlcXVlc3QgbWVzc2FnZSBib2R5LlxuICAgKi9cbiAgcHVibGljIGdldCBib2R5KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuaW5jb21pbmdJbnZpdGVSZXF1ZXN0Lm1lc3NhZ2UuYm9keTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpdHkgb2YgdGhlIGxvY2FsIHVzZXIuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGxvY2FsSWRlbnRpdHkoKTogTmFtZUFkZHJIZWFkZXIge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QudG87XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlkZW50aXR5IG9mIHRoZSByZW1vdGUgdXNlci5cbiAgICovXG4gIHB1YmxpYyBnZXQgcmVtb3RlSWRlbnRpdHkoKTogTmFtZUFkZHJIZWFkZXIge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QuZnJvbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsIGluY29taW5nIElOVklURSByZXF1ZXN0IG1lc3NhZ2UuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHJlcXVlc3QoKTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSB7XG4gICAgcmV0dXJuIHRoaXMuaW5jb21pbmdJbnZpdGVSZXF1ZXN0Lm1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IHRoZSBpbnZpdGF0aW9uLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBBY2NlcHQgdGhlIGluY29taW5nIElOVklURSByZXF1ZXN0IHRvIHN0YXJ0IGEgU2Vzc2lvbi5cbiAgICogUmVwbGllcyB0byB0aGUgSU5WSVRFIHJlcXVlc3Qgd2l0aCBhIDIwMCBPayByZXNwb25zZS5cbiAgICogUmVzb2x2ZXMgb25jZSB0aGUgcmVzcG9uc2Ugc2VudCwgb3RoZXJ3aXNlIHJlamVjdHMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIG1heSByZWplY3QgZm9yIGEgdmFyaWV0eSBvZiByZWFzb25zIGluY2x1ZGluZ1xuICAgKiB0aGUgcmVjZWlwdCBvZiBhIENBTkNFTCByZXF1ZXN0IGJlZm9yZSBgYWNjZXB0YCBpcyBhYmxlXG4gICAqIHRvIGNvbnN0cnVjdCBhIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgcHVibGljIGFjY2VwdChvcHRpb25zOiBJbnZpdGF0aW9uQWNjZXB0T3B0aW9ucyA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiSW52aXRhdGlvbi5hY2NlcHRcIik7XG5cbiAgICAvLyB2YWxpZGF0ZSBzdGF0ZVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTZXNzaW9uU3RhdGUuSW5pdGlhbCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEludmFsaWQgc2Vzc2lvbiBzdGF0ZSAke3RoaXMuc3RhdGV9YCk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gdHJhbnNpdGlvbiBzdGF0ZVxuICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmcpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2VuZEFjY2VwdChvcHRpb25zKVxuICAgICAgLnRoZW4oKHsgbWVzc2FnZSwgc2Vzc2lvbiB9KSA9PiB7XG4gICAgICAgIHNlc3Npb24uZGVsZWdhdGUgPSB7XG4gICAgICAgICAgb25BY2s6IChhY2tSZXF1ZXN0KTogdm9pZCA9PiB0aGlzLm9uQWNrUmVxdWVzdChhY2tSZXF1ZXN0KSxcbiAgICAgICAgICBvbkFja1RpbWVvdXQ6ICgpOiB2b2lkID0+IHRoaXMub25BY2tUaW1lb3V0KCksXG4gICAgICAgICAgb25CeWU6IChieWVSZXF1ZXN0KTogdm9pZCA9PiB0aGlzLm9uQnllUmVxdWVzdChieWVSZXF1ZXN0KSxcbiAgICAgICAgICBvbkluZm86IChpbmZvUmVxdWVzdCk6IHZvaWQgPT4gdGhpcy5vbkluZm9SZXF1ZXN0KGluZm9SZXF1ZXN0KSxcbiAgICAgICAgICBvbkludml0ZTogKGludml0ZVJlcXVlc3QpOiB2b2lkID0+IHRoaXMub25JbnZpdGVSZXF1ZXN0KGludml0ZVJlcXVlc3QpLFxuICAgICAgICAgIG9uTm90aWZ5OiAobm90aWZ5UmVxdWVzdCk6IHZvaWQgPT4gdGhpcy5vbk5vdGlmeVJlcXVlc3Qobm90aWZ5UmVxdWVzdCksXG4gICAgICAgICAgb25QcmFjazogKHByYWNrUmVxdWVzdCk6IHZvaWQgPT4gdGhpcy5vblByYWNrUmVxdWVzdChwcmFja1JlcXVlc3QpLFxuICAgICAgICAgIG9uUmVmZXI6IChyZWZlclJlcXVlc3QpOiB2b2lkID0+IHRoaXMub25SZWZlclJlcXVlc3QocmVmZXJSZXF1ZXN0KVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaWFsb2cgPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpO1xuXG4gICAgICAgIC8vIFRPRE86IFJlY29uc2lkZXIgdGhpcyBcImF1dG9tYWdpY1wiIHNlbmQgb2YgYSBCWUUgdG8gcmVwbGFjZWUgYmVoYXZpb3IuXG4gICAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaGFzIGJlZW4gcG9ydGVkIGZvcndhcmQgZnJvbSBsZWdhY3kgdmVyc2lvbnMuXG4gICAgICAgIGlmICh0aGlzLl9yZXBsYWNlZSkge1xuICAgICAgICAgIHRoaXMuX3JlcGxhY2VlLl9ieWUoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHRoaXMuaGFuZGxlUmVzcG9uc2VFcnJvcihlcnJvcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHByb2dyZXNzIHByb2Nlc3NpbmcgdGhlIGludml0YXRpb24uXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFJlcG9ydCBwcm9ncmVzcyB0byB0aGUgdGhlIGNhbGxlci5cbiAgICogUmVwbGllcyB0byB0aGUgSU5WSVRFIHJlcXVlc3Qgd2l0aCBhIDF4eCBwcm92aXNpb25hbCByZXNwb25zZS5cbiAgICogUmVzb2x2ZXMgb25jZSB0aGUgcmVzcG9uc2Ugc2VudCwgb3RoZXJ3aXNlIHJlamVjdHMuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBwdWJsaWMgcHJvZ3Jlc3Mob3B0aW9uczogSW52aXRhdGlvblByb2dyZXNzT3B0aW9ucyA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiSW52aXRhdGlvbi5wcm9ncmVzc1wiKTtcblxuICAgIC8vIHZhbGlkYXRlIHN0YXRlXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Jbml0aWFsKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgSW52YWxpZCBzZXNzaW9uIHN0YXRlICR7dGhpcy5zdGF0ZX1gKTtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBQb3J0ZWRcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDE4MDtcbiAgICBpZiAoc3RhdHVzQ29kZSA8IDEwMCB8fCBzdGF0dXNDb2RlID4gMTk5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIHN0YXR1c0NvZGUpO1xuICAgIH1cblxuICAgIC8vIEFmdGVyIHRoZSBmaXJzdCByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSBmb3IgYSByZXF1ZXN0IGhhcyBiZWVuXG4gICAgLy8gYWNrbm93bGVkZ2VkLCB0aGUgVUFTIE1BWSBzZW5kIGFkZGl0aW9uYWwgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAvLyByZXNwb25zZXMuICBUaGUgVUFTIE1VU1QgTk9UIHNlbmQgYSBzZWNvbmQgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAvLyByZXNwb25zZSB1bnRpbCB0aGUgZmlyc3QgaXMgYWNrbm93bGVkZ2VkLiAgQWZ0ZXIgdGhlIGZpcnN0LCBpdCBpc1xuICAgIC8vIFJFQ09NTUVOREVEIHRoYXQgdGhlIFVBUyBub3Qgc2VuZCBhbiBhZGRpdGlvbmFsIHJlbGlhYmxlIHByb3Zpc2lvbmFsXG4gICAgLy8gcmVzcG9uc2UgdW50aWwgdGhlIHByZXZpb3VzIGlzIGFja25vd2xlZGdlZC4gIFRoZSBmaXJzdCByZWxpYWJsZVxuICAgIC8vIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHJlY2VpdmVzIHNwZWNpYWwgdHJlYXRtZW50IGJlY2F1c2UgaXQgY29udmV5c1xuICAgIC8vIHRoZSBpbml0aWFsIHNlcXVlbmNlIG51bWJlci4gIElmIGFkZGl0aW9uYWwgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAvLyByZXNwb25zZXMgd2VyZSBzZW50IGJlZm9yZSB0aGUgZmlyc3Qgd2FzIGFja25vd2xlZGdlZCwgdGhlIFVBUyBjb3VsZFxuICAgIC8vIG5vdCBiZSBjZXJ0YWluIHRoZXNlIHdlcmUgcmVjZWl2ZWQgaW4gb3JkZXIuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi0zXG4gICAgaWYgKHRoaXMud2FpdGluZ0ZvclByYWNrKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVW5leHBlY3RlZCBjYWxsIGZvciBwcm9ncmVzcyB3aGlsZSB3YWl0aW5nIGZvciBwcmFjaywgaWdub3JpbmdcIik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgLy8gVHJ5aW5nIHByb3Zpc2lvbmFsIHJlc3BvbnNlXG4gICAgaWYgKG9wdGlvbnMuc3RhdHVzQ29kZSA9PT0gMTAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZW5kUHJvZ3Jlc3NUcnlpbmcoKVxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHsgcmV0dXJuOyB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB0aGlzLmhhbmRsZVJlc3BvbnNlRXJyb3IoZXJyb3IpKTtcbiAgICB9XG5cbiAgICAvLyBTdGFuZGFyZCBwcm92aXNpb25hbCByZXNwb25zZVxuICAgIGlmIChcbiAgICAgICEodGhpcy5yZWwxMDAgPT09IFwicmVxdWlyZWRcIikgJiZcbiAgICAgICEodGhpcy5yZWwxMDAgPT09IFwic3VwcG9ydGVkXCIgJiYgb3B0aW9ucy5yZWwxMDApICYmXG4gICAgICAhKFxuICAgICAgICB0aGlzLnJlbDEwMCA9PT0gXCJzdXBwb3J0ZWRcIiAmJlxuICAgICAgICB0aGlzLnVzZXJBZ2VudC5jb25maWd1cmF0aW9uLnNpcEV4dGVuc2lvbjEwMHJlbCA9PT0gU0lQRXh0ZW5zaW9uLlJlcXVpcmVkXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZW5kUHJvZ3Jlc3Mob3B0aW9ucylcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7IHJldHVybjsgfSlcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gdGhpcy5oYW5kbGVSZXNwb25zZUVycm9yKGVycm9yKSk7XG4gICAgfVxuXG4gICAgLy8gUmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2VcbiAgICByZXR1cm4gdGhpcy5zZW5kUHJvZ3Jlc3NSZWxpYWJsZVdhaXRGb3JQcmFjayhvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7IHJldHVybjsgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHRoaXMuaGFuZGxlUmVzcG9uc2VFcnJvcihlcnJvcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlamVjdCB0aGUgaW52aXRhdGlvbi5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogUmVwbGllcyB0byB0aGUgSU5WSVRFIHJlcXVlc3Qgd2l0aCBhIDR4eCwgNXh4LCBvciA2eHggZmluYWwgcmVzcG9uc2UuXG4gICAqIFJlc29sdmVzIG9uY2UgdGhlIHJlc3BvbnNlIHNlbnQsIG90aGVyd2lzZSByZWplY3RzLlxuICAgKlxuICAgKiBUaGUgZXhwZWN0YXRpb24gaXMgdGhhdCB0aGlzIG1ldGhvZCBpcyB1c2VkIHRvIHJlamVjdCBhbiBJTlZJVEUgcmVxdWVzdC5cbiAgICogVGhhdCBpcyBpbmRlZWQgdGhlIGNhc2UgLSBhIGNhbGwgdG8gYHByb2dyZXNzYCBmb2xsb3dlZCBieSBgcmVqZWN0YCBpc1xuICAgKiBhIHR5cGljYWwgd2F5IHRvIFwiZGVjbGluZVwiIGFuIGluY29taW5nIElOVklURSByZXF1ZXN0LiBIb3dldmVyIGl0IG1heVxuICAgKiBhbHNvIGJlIGNhbGxlZCBhZnRlciBjYWxsaW5nIGBhY2NlcHRgIChidXQgb25seSBiZWZvcmUgaXQgY29tcGxldGVzKVxuICAgKiB3aGljaCB3aWxsIHJlamVjdCB0aGUgY2FsbCBhbmQgY2F1c2UgYGFjY2VwdGAgdG8gcmVqZWN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgcHVibGljIHJlamVjdChvcHRpb25zOiBJbnZpdGF0aW9uUmVqZWN0T3B0aW9ucyA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiSW52aXRhdGlvbi5yZWplY3RcIik7XG5cbiAgICAvLyB2YWxpZGF0ZSBzdGF0ZVxuICAgIGlmIChcbiAgICAgIHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Jbml0aWFsICYmXG4gICAgICB0aGlzLnN0YXRlICE9PSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoaW5nXG4gICAgKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgSW52YWxpZCBzZXNzaW9uIHN0YXRlICR7dGhpcy5zdGF0ZX1gKTtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDQ4MDtcblxuICAgIGNvbnN0IHJlYXNvblBocmFzZSA9IG9wdGlvbnMucmVhc29uUGhyYXNlID8gb3B0aW9ucy5yZWFzb25QaHJhc2UgIDogZ2V0UmVhc29uUGhyYXNlKHN0YXR1c0NvZGUpO1xuICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdO1xuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAzMDAgfHwgc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBzdGF0dXNDb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5ID8gZnJvbUJvZHlMZWdhY3kob3B0aW9ucy5ib2R5KSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIEZJWE1FOiBOZWVkIHRvIHJlZGlyZWN0IHRvIHNvbWVwbGFjZVxuICAgIGNvbnN0IHJlc3BvbnNlID0gc3RhdHVzQ29kZSA8IDQwMCA/XG4gICAgICB0aGlzLmluY29taW5nSW52aXRlUmVxdWVzdC5yZWRpcmVjdChbXSwgeyBzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVycywgYm9keSB9KSA6XG4gICAgICB0aGlzLmluY29taW5nSW52aXRlUmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVycywgYm9keSB9KTtcblxuICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgQ0FOQ0VMIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gQ0FOQ0VMIG1lc3NhZ2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF9vbkNhbmNlbChtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiSW52aXRhdGlvbi5fb25DYW5jZWxcIik7XG5cbiAgICAvLyB2YWxpZGF0ZSBzdGF0ZVxuICAgIGlmIChcbiAgICAgIHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Jbml0aWFsICYmXG4gICAgICB0aGlzLnN0YXRlICE9PSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoaW5nXG4gICAgKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgQ0FOQ0VMIHJlY2VpdmVkIHdoaWxlIGluIHN0YXRlICR7dGhpcy5zdGF0ZX0sIGRyb3BwaW5nIHJlcXVlc3RgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBmbGFnIGNhbmNlbGVkXG4gICAgdGhpcy5pc0NhbmNlbGVkID0gdHJ1ZTtcblxuICAgIC8vIHJlamVjdCBJTlZJVEUgd2l0aCA0ODcgc3RhdHVzIGNvZGVcbiAgICB0aGlzLmluY29taW5nSW52aXRlUmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODcgfSk7XG5cbiAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBvZmZlci9hbnN3ZXIgaW4gYSBQUkFDSy5cbiAgICovXG4gIHByaXZhdGUgaGFuZGxlUHJhY2tPZmZlckFuc3dlcihcbiAgICByZXF1ZXN0OiBJbmNvbWluZ1ByYWNrUmVxdWVzdCxcbiAgICBvcHRpb25zOiB7XG4gICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucz86IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLFxuICAgICAgbW9kaWZpZXJzPzogQXJyYXk8U2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyPlxuICAgIH1cbiAgKTogUHJvbWlzZTxCb2R5IHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIFBSQUNLIGRvZXNuJ3QgaGF2ZSBhbiBvZmZlci9hbnN3ZXIsIG5vdGhpbmcgdG8gYmUgZG9uZS5cbiAgICBjb25zdCBib2R5ID0gZ2V0Qm9keShyZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgIGlmICghYm9keSB8fCBib2R5LmNvbnRlbnREaXNwb3NpdGlvbiAhPT0gXCJzZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgVUFDIHJlY2VpdmVzIGEgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2Ugd2l0aCBhbiBvZmZlclxuICAgIC8vICh0aGlzIHdvdWxkIG9jY3VyIGlmIHRoZSBVQUMgc2VudCBhbiBJTlZJVEUgd2l0aG91dCBhbiBvZmZlciwgaW5cbiAgICAvLyB3aGljaCBjYXNlIHRoZSBmaXJzdCByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSB3aWxsIGNvbnRhaW4gdGhlXG4gICAgLy8gb2ZmZXIpLCBpdCBNVVNUIGdlbmVyYXRlIGFuIGFuc3dlciBpbiB0aGUgUFJBQ0suICBJZiB0aGUgVUFDIHJlY2VpdmVzXG4gICAgLy8gYSByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSB3aXRoIGFuIGFuc3dlciwgaXQgTUFZIGdlbmVyYXRlIGFuXG4gICAgLy8gYWRkaXRpb25hbCBvZmZlciBpbiB0aGUgUFJBQ0suICBJZiB0aGUgVUFTIHJlY2VpdmVzIGEgUFJBQ0sgd2l0aCBhblxuICAgIC8vIG9mZmVyLCBpdCBNVVNUIHBsYWNlIHRoZSBhbnN3ZXIgaW4gdGhlIDJ4eCB0byB0aGUgUFJBQ0suXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi01XG4gICAgc3dpdGNoICh0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5Jbml0aWFsOlxuICAgICAgICAvLyBTdGF0ZSBzaG91bGQgbmV2ZXIgYmUgcmVhY2hlZCBhcyBmaXJzdCByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSBtdXN0IGhhdmUgYW5zd2VyL29mZmVyLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmFsaW5nIHN0YXRlICR7dGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGV9LmApO1xuICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5TdGFibGU6XG4gICAgICAgIC8vIFJlY2V2ZWQgYW5zd2VyLlxuICAgICAgICByZXR1cm4gdGhpcy5zZXRBbnN3ZXIoYm9keSwgb3B0aW9ucykudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjpcbiAgICAgICAgLy8gU3RhdGUgc2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQgYXMgbG9jYWwgb2ZmZXIgd291bGQgYmUgYW5zd2VyZWQgYnkgdGhpcyBQUkFDS1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmFsaW5nIHN0YXRlICR7dGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGV9LmApO1xuICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXI6XG4gICAgICAgIC8vIFJlY2VpdmVkIG9mZmVyLCBnZW5lcmF0ZSBhbnN3ZXIuXG4gICAgICAgIHJldHVybiB0aGlzLnNldE9mZmVyQW5kR2V0QW5zd2VyKGJvZHksIG9wdGlvbnMpO1xuICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5DbG9zZWQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgJHt0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZX0uYCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmFsaW5nIHN0YXRlICR7dGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGV9LmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhhbmRsZXIgZm9yIGVycm9ycyB3aGljaCBvY2N1ciB3aGlsZSBhdHRlbXB0aW5nIHRvIHNlbmQgMXh4IGFuZCAyeHggcmVzcG9uc2VzLlxuICAgKiBJbiBhbGwgY2FzZXMsIGFuIGF0dGVtcHQgaXMgbWFkZSB0byByZWplY3QgdGhlIHJlcXVlc3QgaWYgaXQgaXMgc3RpbGwgb3V0c3RhbmRpbmcuXG4gICAqIEFuZCB3aGlsZSB0aGVyZSBhcmUgYSB2YXJpZXR5IG9mIHRoaW5ncyB3aGljaCBjYW4gZ28gd3JvbmcgYW5kIHdlIGxvZyBzb21ldGhpbmcgaGVyZVxuICAgKiBmb3IgYWxsIGVycm9ycywgdGhlcmUgYXJlIGEgaGFuZGZ1bCBvZiBjb21tb24gZXhjZXB0aW9ucyB3ZSBwYXkgc29tZSBleHRyYSBhdHRlbnRpb24gdG8uXG4gICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB3aGljaCBvY2N1cnJlZC5cbiAgICovXG4gIHByaXZhdGUgaGFuZGxlUmVzcG9uc2VFcnJvcihlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgICBsZXQgc3RhdHVzQ29kZSA9IDQ4MDsgLy8gXCJUZW1wb3JhcmlseSBVbmF2YWlsYWJsZVwiXG5cbiAgICAvLyBMb2cgRXJyb3IgbWVzc2FnZVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkga25vdyB3aGF0IGEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGltcGxlbWVudGF0aW9uIG1pZ2h0IHRocm93IG91ciB3YXksXG4gICAgICAvLyBhbmQgbW9yZSBnZW5lcmFsbHkgYXMgYSBsYXN0IHJlc29ydCBjYXRjaCBhbGwsIGp1c3QgYXNzdW1lIHdlIGFyZSBnZXR0aW5nIGFuIFwiYW55XCIgYW5kIGxvZyBpdC5cbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yIGFzIGFueSk7XG4gICAgfVxuXG4gICAgLy8gTG9nIEV4Y2VwdGlvbiBtZXNzYWdlXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29udGVudFR5cGVVbnN1cHBvcnRlZEVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIG9jY3VycmVkIHdoaWxlIHNlbmRpbmcgcmVzcG9uc2UgKGNvbnRlbnQgdHlwZSB1bnN1cHBvcnRlZFwiKTtcbiAgICAgIHN0YXR1c0NvZGUgPSA0MTU7IC8vIFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiXG4gICAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJBIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBvY2N1cnJlZCB3aGlsZSBzZW5kaW5nIHJlc3BvbnNlXCIpO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTZXNzaW9uVGVybWluYXRlZEVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24gZW5kZWQgYmVmb3JlIHJlc3BvbnNlIGNvdWxkIGJlIGZvcm11bGF0ZWQgYW5kIHNlbnQgKHdoaWxlIHdhaXRpbmcgZm9yIFBSQUNLKVwiKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgVHJhbnNhY3Rpb25TdGF0ZUVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24gY2hhbmdlZCBzdGF0ZSBiZWZvcmUgcmVzcG9uc2UgY291bGQgYmUgZm9ybXVsYXRlZCBhbmQgc2VudFwiKTtcbiAgICB9XG5cbiAgICAvLyBSZWplY3QgaWYgc3RpbGwgaW4gXCJpbml0aWFsXCIgb3IgXCJlc3RhYmxpc2hpbmdcIiBzdGF0ZS5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2Vzc2lvblN0YXRlLkluaXRpYWwgfHwgdGhpcy5zdGF0ZSA9PT0gU2Vzc2lvblN0YXRlLkVzdGFibGlzaGluZykge1xuICAgICB0cnkge1xuICAgICAgICB0aGlzLmluY29taW5nSW52aXRlUmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlIH0pO1xuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgYXR0ZW1wdGluZyB0byByZWplY3QgdGhlIHJlcXVlc3Qgd2hpbGUgaGFuZGxpbmcgYW5vdGhlciBlcnJvclwiKTtcbiAgICAgICAgdGhyb3cgZTsgLy8gVGhpcyBpcyBub3QgYSBnb29kIHBsYWNlIHRvIGJlLi4uXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IFRPRE86XG4gICAgLy8gSGVyZSB3ZSBhcmUgc3F1ZWxjaGluZyB0aGUgdGhyb3dpbmcgb2YgZXJyb3JzIGR1ZSB0byBhbiByYWNlIGNvbmRpdGlvbi5cbiAgICAvLyBXZSBoYXZlIGFuIGludGVybmFsIHJhY2UgYmV0d2VlbiBjYWxsaW5nIGBhY2NlcHQoKWAgYW5kIGhhbmRsaW5nIGFuIGluY29taW5nXG4gICAgLy8gQ0FOQ0VMIHJlcXVlc3QuIEFzIHRoZXJlIGlzIG5vIGdvb2Qgd2F5IGN1cnJlbnRseSB0byBkZWxlZ2F0ZSB0aGUgaGFuZGxpbmcgb2ZcbiAgICAvLyB0aGVzZSByYWNlIGVycm9ycyB0byB0aGUgY2FsbGVyIG9mIGBhY2NlcHQoKWAsIHdlIGFyZSBzcXVlbGNoaW5nIHRoZSB0aHJvd2luZ1xuICAgIC8vIG9mIEFMTCBlcnJvcnMgd2hlbi9pZiB0aGV5IG9jY3VyIGFmdGVyIHJlY2VpdmluZyBhIENBTkNFTCB0byBjYXRjaCB0aGUgT05FIHdlIGtub3dcbiAgICAvLyBpcyBhIFwibm9ybWFsXCIgZXhjZXB0aW9uYWwgY29uZGl0aW9uLiBXaGlsZSB0aGlzIGlzIGEgY29tcGxldGVseSByZWFzb25hYmxlIGFwcHJvYWNoLFxuICAgIC8vIHRoZSBkZWNpc2lvbiBzaG91bGQgYmUgbGVmdCB1cCB0byB0aGUgbGlicmFyeSB1c2VyLiBGdXJ0aGVybW9yZSwgYXMgd2UgYXJlIGVhdGluZ1xuICAgIC8vIEFMTCBlcnJvcnMgaW4gdGhpcyBjYXNlLCB3ZSBhcmUgcG90ZW50aWFsbHkgKGxpa2VseSkgaGlkaW5nIFwicmVhbFwiIGVycm9ycyB3aGljaCBvY2N1ci5cbiAgICAvL1xuICAgIC8vIE9ubHkgcmV0aHJvdyBlcnJvciBpZiB0aGUgc2Vzc2lvbiBoYXMgbm90IGJlZW4gY2FuY2VsZWQuXG4gICAgaWYgKHRoaXMuaXNDYW5jZWxlZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgXCJBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBhdHRlbXB0aW5nIHRvIGZvcm11bGF0ZSBhbmQgc2VuZCBhIHJlc3BvbnNlIHRvIGFuIGluY29taW5nIElOVklURS5cIiArXG4gICAgICAgIFwiIEhvd2V2ZXIgYSBDQU5DRUwgd2FzIHJlY2VpdmVkIGFuZCBwcm9jZXNzZWQgd2hpbGUgZG9pbmcgc28gd2hpY2ggY2FuIChhbmQgb2Z0ZW4gZG9lcykgcmVzdWx0XCIgK1xuICAgICAgICBcIiBpbiBlcnJvcnMgb2NjdXJyaW5nIGFzIHRoZSBzZXNzaW9uIHRlcm1pbmF0ZXMgaW4gdGhlIG1lYW50aW1lLiBTYWlkIGVycm9yIGlzIGJlaW5nIGlnbm9yZWQuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIHdoZW4gQUNLIGZvciBhIDJ4eCByZXNwb25zZSBpcyBuZXZlciByZWNlaXZlZC5cbiAgICogQHBhcmFtIHNlc3Npb24gLSBTZXNzaW9uIHRoZSBBQ0sgbmV2ZXIgYXJyaXZlZCBmb3IuXG4gICAqL1xuICBwcml2YXRlIG9uQWNrVGltZW91dCgpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJJbnZpdGF0aW9uLm9uQWNrVGltZW91dFwiKTtcbiAgICBpZiAoIXRoaXMuZGlhbG9nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiTm8gQUNLIHJlY2VpdmVkIGZvciBhbiBleHRlbmRlZCBwZXJpb2Qgb2YgdGltZSwgdGVybWluYXRpbmcgc2Vzc2lvblwiKTtcbiAgICB0aGlzLmRpYWxvZy5ieWUoKTtcbiAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gIH1cblxuICAvKipcbiAgICogQSB2ZXJzaW9uIG9mIGBhY2NlcHRgIHdoaWNoIHJlc29sdmVzIGEgc2Vzc2lvbiB3aGVuIHRoZSAyMDAgT2sgcmVzcG9uc2UgaXMgc2VudC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHByaXZhdGUgc2VuZEFjY2VwdChvcHRpb25zOiBJbnZpdGF0aW9uQWNjZXB0T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxPdXRnb2luZ1Jlc3BvbnNlV2l0aFNlc3Npb24+IHtcblxuICAgIC8vIFRoZSBVQVMgTUFZIHNlbmQgYSBmaW5hbCByZXNwb25zZSB0byB0aGUgaW5pdGlhbCByZXF1ZXN0IGJlZm9yZVxuICAgIC8vIGhhdmluZyByZWNlaXZlZCBQUkFDS3MgZm9yIGFsbCB1bmFja25vd2xlZGdlZCByZWxpYWJsZSBwcm92aXNpb25hbFxuICAgIC8vIHJlc3BvbnNlcywgdW5sZXNzIHRoZSBmaW5hbCByZXNwb25zZSBpcyAyeHggYW5kIGFueSBvZiB0aGVcbiAgICAvLyB1bmFja25vd2xlZGdlZCByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZXMgY29udGFpbmVkIGEgc2Vzc2lvblxuICAgIC8vIGRlc2NyaXB0aW9uLiAgSW4gdGhhdCBjYXNlLCBpdCBNVVNUIE5PVCBzZW5kIGEgZmluYWwgcmVzcG9uc2UgdW50aWxcbiAgICAvLyB0aG9zZSBwcm92aXNpb25hbCByZXNwb25zZXMgYXJlIGFja25vd2xlZGdlZC4gIElmIHRoZSBVQVMgZG9lcyBzZW5kIGFcbiAgICAvLyBmaW5hbCByZXNwb25zZSB3aGVuIHJlbGlhYmxlIHJlc3BvbnNlcyBhcmUgc3RpbGwgdW5hY2tub3dsZWRnZWQsIGl0XG4gICAgLy8gU0hPVUxEIE5PVCBjb250aW51ZSB0byByZXRyYW5zbWl0IHRoZSB1bmFja25vd2xlZGdlZCByZWxpYWJsZVxuICAgIC8vIHByb3Zpc2lvbmFsIHJlc3BvbnNlcywgYnV0IGl0IE1VU1QgYmUgcHJlcGFyZWQgdG8gcHJvY2VzcyBQUkFDS1xuICAgIC8vIHJlcXVlc3RzIGZvciB0aG9zZSBvdXRzdGFuZGluZyByZXNwb25zZXMuICBBIFVBUyBNVVNUIE5PVCBzZW5kIG5ld1xuICAgIC8vIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyAoYXMgb3Bwb3NlZCB0byByZXRyYW5zbWlzc2lvbnMgb2ZcbiAgICAvLyB1bmFja25vd2xlZGdlZCBvbmVzKSBhZnRlciBzZW5kaW5nIGEgZmluYWwgcmVzcG9uc2UgdG8gYSByZXF1ZXN0LlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tM1xuICAgIGlmICh0aGlzLndhaXRpbmdGb3JQcmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMud2FpdEZvckFycml2YWxPZlByYWNrKClcbiAgICAgICAgLnRoZW4oKCkgPT4gY2xlYXJUaW1lb3V0KHRoaXMudXNlck5vQW5zd2VyVGltZXIpKSAvLyBQb3J0ZWRcbiAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXIodGhpcy5pbmNvbWluZ0ludml0ZVJlcXVlc3QsIG9wdGlvbnMpKVxuICAgICAgICAudGhlbigoYm9keSkgPT4gdGhpcy5pbmNvbWluZ0ludml0ZVJlcXVlc3QuYWNjZXB0KHsgc3RhdHVzQ29kZTogMjAwLCBib2R5IH0pKTtcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy51c2VyTm9BbnN3ZXJUaW1lcik7IC8vIFBvcnRlZFxuICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUmVzcG9uc2VPZmZlckFuc3dlcih0aGlzLmluY29taW5nSW52aXRlUmVxdWVzdCwgb3B0aW9ucylcbiAgICAgIC50aGVuKChib2R5KSA9PiB0aGlzLmluY29taW5nSW52aXRlUmVxdWVzdC5hY2NlcHQoeyBzdGF0dXNDb2RlOiAyMDAsIGJvZHkgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdmVyc2lvbiBvZiBgcHJvZ3Jlc3NgIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGlzIHNlbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBwcml2YXRlIHNlbmRQcm9ncmVzcyhvcHRpb25zOiBJbnZpdGF0aW9uUHJvZ3Jlc3NPcHRpb25zID0ge30pOiBQcm9taXNlPE91dGdvaW5nUmVzcG9uc2VXaXRoU2Vzc2lvbj4ge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTgwO1xuICAgIGNvbnN0IHJlYXNvblBocmFzZSA9IG9wdGlvbnMucmVhc29uUGhyYXNlO1xuICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5ID8gZnJvbUJvZHlMZWdhY3kob3B0aW9ucy5ib2R5KSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIFRoZSAxODMgKFNlc3Npb24gUHJvZ3Jlc3MpIHJlc3BvbnNlIGlzIHVzZWQgdG8gY29udmV5IGluZm9ybWF0aW9uXG4gICAgLy8gYWJvdXQgdGhlIHByb2dyZXNzIG9mIHRoZSBjYWxsIHRoYXQgaXMgbm90IG90aGVyd2lzZSBjbGFzc2lmaWVkLiAgVGhlXG4gICAgLy8gUmVhc29uLVBocmFzZSwgaGVhZGVyIGZpZWxkcywgb3IgbWVzc2FnZSBib2R5IE1BWSBiZSB1c2VkIHRvIGNvbnZleVxuICAgIC8vIG1vcmUgZGV0YWlscyBhYm91dCB0aGUgY2FsbCBwcm9ncmVzcy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTIxLjEuNVxuXG4gICAgLy8gSXQgaXMgdGhlIGRlIGZhY3RvIGluZHVzdHJ5IHN0YW5kYXJkIHRvIHV0aWxpemUgMTgzIHdpdGggU0RQIHRvIHByb3ZpZGUgXCJlYXJseSBtZWRpYVwiLlxuICAgIC8vIFdoaWxlIGl0IGlzIHVubGlrZWx5IHNvbWVvbmUgd291bGQgd2FudCB0byBzZW5kIGEgMTgzIHdpdGhvdXQgU0RQLCBzbyBpdCBzaG91bGQgYmUgYW4gb3B0aW9uLlxuICAgIGlmIChzdGF0dXNDb2RlID09PSAxODMgJiYgIWJvZHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbmRQcm9ncmVzc1dpdGhTRFAob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb2dyZXNzUmVzcG9uc2UgPSB0aGlzLmluY29taW5nSW52aXRlUmVxdWVzdC5wcm9ncmVzcyh7IHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzLCBib2R5IH0pO1xuICAgICAgdGhpcy5fZGlhbG9nID0gcHJvZ3Jlc3NSZXNwb25zZS5zZXNzaW9uO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9ncmVzc1Jlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSB2ZXJzaW9uIG9mIGBwcm9ncmVzc2Agd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgcHJvdmlzaW9uYWwgcmVzcG9uc2Ugd2l0aCBzZHAgaXMgc2VudC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHByaXZhdGUgc2VuZFByb2dyZXNzV2l0aFNEUChvcHRpb25zOiBJbnZpdGF0aW9uUHJvZ3Jlc3NPcHRpb25zID0ge30pOiBQcm9taXNlPE91dGdvaW5nUmVzcG9uc2VXaXRoU2Vzc2lvbj4ge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTgzO1xuICAgIGNvbnN0IHJlYXNvblBocmFzZSA9IG9wdGlvbnMucmVhc29uUGhyYXNlO1xuICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICAgIC8vIEdldCBhbiBvZmZlci9hbnN3ZXIgYW5kIHNlbmQgYSByZXBseS5cbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXIodGhpcy5pbmNvbWluZ0ludml0ZVJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICAudGhlbigoYm9keSkgPT4gdGhpcy5pbmNvbWluZ0ludml0ZVJlcXVlc3QucHJvZ3Jlc3MoeyBzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVycywgYm9keSB9KSlcbiAgICAgIC50aGVuKChwcm9ncmVzc1Jlc3BvbnNlKSA9PiB7XG4gICAgICAgIHRoaXMuX2RpYWxvZyA9IHByb2dyZXNzUmVzcG9uc2Uuc2Vzc2lvbjtcbiAgICAgICAgcmV0dXJuIHByb2dyZXNzUmVzcG9uc2U7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHZlcnNpb24gb2YgYHByb2dyZXNzYCB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSBpcyBzZW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgcHJpdmF0ZSBzZW5kUHJvZ3Jlc3NSZWxpYWJsZShvcHRpb25zOiBJbnZpdGF0aW9uUHJvZ3Jlc3NPcHRpb25zID0ge30pOiBQcm9taXNlPE91dGdvaW5nUmVzcG9uc2VXaXRoU2Vzc2lvbj4ge1xuICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goXCJSZXF1aXJlOiAxMDByZWxcIik7XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIlJTZXE6IFwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kUHJvZ3Jlc3NXaXRoU0RQKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdmVyc2lvbiBvZiBgcHJvZ3Jlc3NgIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGlzIGFja25vd2xlZGdlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHByaXZhdGUgc2VuZFByb2dyZXNzUmVsaWFibGVXYWl0Rm9yUHJhY2sob3B0aW9uczogSW52aXRhdGlvblByb2dyZXNzT3B0aW9ucyA9IHt9KTogUHJvbWlzZTx7XG4gICAgcHJhY2tSZXF1ZXN0OiBJbmNvbWluZ1ByYWNrUmVxdWVzdCxcbiAgICBwcmFja1Jlc3BvbnNlOiBPdXRnb2luZ1Jlc3BvbnNlLFxuICAgIHByb2dyZXNzUmVzcG9uc2U6IE91dGdvaW5nUmVzcG9uc2VXaXRoU2Vzc2lvbixcbiAgfT4ge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTgzO1xuICAgIGNvbnN0IHJlYXNvblBocmFzZSA9IG9wdGlvbnMucmVhc29uUGhyYXNlO1xuICAgIGNvbnN0IGV4dHJhSGVhZGVyczogQXJyYXk8c3RyaW5nPiA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlcXVpcmU6IDEwMHJlbFwiKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaChcIlJTZXE6IFwiICsgdGhpcy5yc2VxKyspO1xuICAgIGxldCBib2R5OiBCb2R5IHwgdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMud2FpdGluZ0ZvclByYWNrID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ2VuZXJhdGVSZXNwb25zZU9mZmVyQW5zd2VyKHRoaXMuaW5jb21pbmdJbnZpdGVSZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgICAudGhlbigob2ZmZXJBbnN3ZXIpID0+IHtcbiAgICAgICAgICBib2R5ID0gb2ZmZXJBbnN3ZXI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5jb21pbmdJbnZpdGVSZXF1ZXN0LnByb2dyZXNzKHsgc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlLCBleHRyYUhlYWRlcnMsIGJvZHkgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKChwcm9ncmVzc1Jlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgdGhpcy5fZGlhbG9nID0gcHJvZ3Jlc3NSZXNwb25zZS5zZXNzaW9uO1xuXG4gICAgICAgICAgbGV0IHByYWNrUmVxdWVzdDogSW5jb21pbmdQcmFja1JlcXVlc3Q7XG4gICAgICAgICAgbGV0IHByYWNrUmVzcG9uc2U6IE91dGdvaW5nUmVzcG9uc2U7XG4gICAgICAgICAgcHJvZ3Jlc3NSZXNwb25zZS5zZXNzaW9uLmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgb25QcmFjazogKHJlcXVlc3QpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgcHJhY2tSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHByYWNrV2FpdFRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZWwxeHhSZXRyYW5zbWlzc2lvblRpbWVyKTtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLndhaXRpbmdGb3JQcmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLndhaXRpbmdGb3JQcmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZVByYWNrT2ZmZXJBbnN3ZXIocHJhY2tSZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIC50aGVuKChwcmFja1Jlc3BvbnNlQm9keSkgPT4ge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHJhY2tSZXNwb25zZSA9IHByYWNrUmVxdWVzdC5hY2NlcHQoeyBzdGF0dXNDb2RlOiAyMDAsIGJvZHk6IHByYWNrUmVzcG9uc2VCb2R5IH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByYWNrQXJyaXZlZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgcHJhY2tSZXF1ZXN0LCBwcmFja1Jlc3BvbnNlLCBwcm9ncmVzc1Jlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiByZWplY3QoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi0zXG4gICAgICAgICAgY29uc3QgcHJhY2tXYWl0VGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy53YWl0aW5nRm9yUHJhY2spIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJObyBQUkFDSyByZWNlaXZlZCwgcmVqZWN0aW5nIElOVklURS5cIik7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocmVsMXh4UmV0cmFuc21pc3Npb25UaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCh7IHN0YXR1c0NvZGU6IDUwNCB9KVxuICAgICAgICAgICAgICAudGhlbigoKSA9PiByZWplY3QobmV3IFNlc3Npb25UZXJtaW5hdGVkRXJyb3IoKSkpXG4gICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiByZWplY3QoZXJyb3IpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHByYWNrV2FpdFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQocHJhY2tXYWl0VGltZW91dCwgVGltZXJzLlQxICogNjQpO1xuXG4gICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi0zXG4gICAgICAgICAgY29uc3QgcmVsMXh4UmV0cmFuc21pc3Npb24gPSAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLmluY29taW5nSW52aXRlUmVxdWVzdC5wcm9ncmVzcyh7IHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzLCBib2R5IH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVsMXh4UmV0cmFuc21pc3Npb25UaW1lciA9IHNldFRpbWVvdXQocmVsMXh4UmV0cmFuc21pc3Npb24sIHRpbWVvdXQgKj0gMik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBsZXQgdGltZW91dCA9IFRpbWVycy5UMTtcbiAgICAgICAgICBsZXQgcmVsMXh4UmV0cmFuc21pc3Npb25UaW1lciA9IHNldFRpbWVvdXQocmVsMXh4UmV0cmFuc21pc3Npb24sIHRpbWVvdXQpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICAgIHRoaXMud2FpdGluZ0ZvclByYWNrID0gZmFsc2U7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSB2ZXJzaW9uIG9mIGBwcm9ncmVzc2Agd2hpY2ggcmVzb2x2ZXMgd2hlbiBhIDEwMCBUcnlpbmcgcHJvdmlzaW9uYWwgcmVzcG9uc2UgaXMgc2VudC5cbiAgICovXG4gIHByaXZhdGUgc2VuZFByb2dyZXNzVHJ5aW5nKCk6IFByb21pc2U8T3V0Z29pbmdSZXNwb25zZT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwcm9ncmVzc1Jlc3BvbnNlID0gdGhpcy5pbmNvbWluZ0ludml0ZVJlcXVlc3QudHJ5aW5nKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvZ3Jlc3NSZXNwb25zZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYXR0ZW1wdGluZyB0byBhY2NlcHQgdGhlIElOVklURSwgYW4gaW52aXRhdGlvbiB3YWl0c1xuICAgKiBmb3IgYW55IG91dHN0YW5kaW5nIFBSQUNLIHRvIGFycml2ZSBiZWZvcmUgc2VuZGluZyB0aGUgMjAwIE9rLlxuICAgKiBJdCB3aWxsIGJlIHdhaXRpbmcgb24gdGhpcyBQcm9taXNlIHRvIHJlc29sdmUgd2hpY2ggbGV0cyBpdCBrbm93XG4gICAqIHRoZSBQUkFDSyBoYXMgYXJyaXZlZCBhbmQgaXQgbWF5IHByb2NlZWQgdG8gc2VuZCB0aGUgMjAwIE9rLlxuICAgKi9cbiAgcHJpdmF0ZSB3YWl0Rm9yQXJyaXZhbE9mUHJhY2soKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0ZvclByYWNrUHJvbWlzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSB3YWl0aW5nIGZvciBQUkFDS1wiKTtcbiAgICB9XG4gICAgdGhpcy53YWl0aW5nRm9yUHJhY2tQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2tSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMud2FpdGluZ0ZvclByYWNrUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLndhaXRpbmdGb3JQcmFja1Byb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogSGVyZSB3ZSBhcmUgcmVzb2x2aW5nIHRoZSBwcm9taXNlIHdoaWNoIGluIHR1cm4gd2lsbCBjYXVzZVxuICAgKiB0aGUgYWNjZXB0IHRvIHByb2NlZWQgKGl0IG1heSBzdGlsbCBmYWlsIGZvciBvdGhlciByZWFzb25zLCBidXQuLi4pLlxuICAgKi9cbiAgcHJpdmF0ZSBwcmFja0Fycml2ZWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0ZvclByYWNrUmVzb2x2ZSkge1xuICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2tSZXNvbHZlKCk7XG4gICAgfVxuICAgIHRoaXMud2FpdGluZ0ZvclByYWNrUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndhaXRpbmdGb3JQcmFja1Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53YWl0aW5nRm9yUHJhY2tSZWplY3QgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogSGVyZSB3ZSBhcmUgcmVqZWN0aW5nIHRoZSBwcm9taXNlIHdoaWNoIGluIHR1cm4gd2lsbCBjYXVzZVxuICAgKiB0aGUgYWNjZXB0IHRvIGZhaWwgYW5kIHRoZSBzZXNzaW9uIHRvIHRyYW5zaXRpb24gdG8gXCJ0ZXJtaW5hdGVkXCIuXG4gICAqL1xuICBwcml2YXRlIHByYWNrTmV2ZXJBcnJpdmVkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLndhaXRpbmdGb3JQcmFja1JlamVjdCkge1xuICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2tSZWplY3QobmV3IFNlc3Npb25UZXJtaW5hdGVkRXJyb3IoKSk7XG4gICAgfVxuICAgIHRoaXMud2FpdGluZ0ZvclByYWNrUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndhaXRpbmdGb3JQcmFja1Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53YWl0aW5nRm9yUHJhY2tSZWplY3QgPSB1bmRlZmluZWQ7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEFja2FibGVJbmNvbWluZ1Jlc3BvbnNlV2l0aFNlc3Npb24sXG4gIEJvZHksXG4gIEMsXG4gIEdyYW1tYXIsXG4gIEluY29taW5nUmVzcG9uc2UsXG4gIExvZ2dlcixcbiAgTmFtZUFkZHJIZWFkZXIsXG4gIE91dGdvaW5nSW52aXRlUmVxdWVzdCxcbiAgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZU9wdGlvbnMsXG4gIFByYWNrYWJsZUluY29taW5nUmVzcG9uc2VXaXRoU2Vzc2lvbixcbiAgUmVxdWVzdE9wdGlvbnMsXG4gIFNlc3Npb24gYXMgU2Vzc2lvbkRpYWxvZyxcbiAgU2lnbmFsaW5nU3RhdGUsXG4gIFVSSVxufSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgZ2V0UmVhc29uUGhyYXNlLCBuZXdUYWcgfSBmcm9tIFwiLi4vY29yZS9tZXNzYWdlcy91dGlsc1wiO1xuaW1wb3J0IHsgSW52aXRlckNhbmNlbE9wdGlvbnMgfSBmcm9tIFwiLi9pbnZpdGVyLWNhbmNlbC1vcHRpb25zXCI7XG5pbXBvcnQgeyBJbnZpdGVySW52aXRlT3B0aW9ucyB9IGZyb20gXCIuL2ludml0ZXItaW52aXRlLW9wdGlvbnNcIjtcbmltcG9ydCB7IEludml0ZXJPcHRpb25zIH0gZnJvbSBcIi4vaW52aXRlci1vcHRpb25zXCI7XG5pbXBvcnQgeyBTZXNzaW9uIH0gZnJvbSBcIi4vc2Vzc2lvblwiO1xuaW1wb3J0IHsgQm9keUFuZENvbnRlbnRUeXBlLCBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIH0gZnJvbSBcIi4vc2Vzc2lvbi1kZXNjcmlwdGlvbi1oYW5kbGVyXCI7XG5pbXBvcnQgeyBTZXNzaW9uU3RhdGUgfSBmcm9tIFwiLi9zZXNzaW9uLXN0YXRlXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnQgfSBmcm9tIFwiLi91c2VyLWFnZW50XCI7XG5pbXBvcnQgeyBTSVBFeHRlbnNpb24gfSBmcm9tIFwiLi91c2VyLWFnZW50LW9wdGlvbnNcIjtcblxuLyoqXG4gKiBBbiBpbnZpdGVyIG9mZmVycyB0byBlc3RhYmxpc2ggYSB7QGxpbmsgU2Vzc2lvbn0gKG91dGdvaW5nIElOVklURSkuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZpdGVyIGV4dGVuZHMgU2Vzc2lvbiB7XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgSW52aXRlciB3YXMgY3JlYXRlZCBhcyBhIHJlc3VsdCBvZiBhIFJFRkVSLCB0aGUgcmVmZXJyZWQgU2Vzc2lvbi4gT3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3JlZmVycmVkOiBTZXNzaW9uIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBMb2dnZXIuXG4gICAqL1xuICBwcm90ZWN0ZWQgbG9nZ2VyOiBMb2dnZXI7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQgX2lkOiBzdHJpbmc7XG5cbiAgLyoqIFRydWUgaWYgZGlzcG9zZSgpIGhhcyBiZWVuIGNhbGxlZC4gKi9cbiAgcHJpdmF0ZSBkaXNwb3NlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAvKiogVHJ1ZSBpZiBlYXJseSBtZWRpYSB1c2UgaXMgZW5hYmxlZC4gKi9cbiAgcHJpdmF0ZSBlYXJseU1lZGlhOiBib29sZWFuID0gZmFsc2U7XG4gIC8qKiBUaGUgZWFybHkgbWVkaWEgc2Vzc2lvbi4gKi9cbiAgcHJpdmF0ZSBlYXJseU1lZGlhRGlhbG9nOiBTZXNzaW9uRGlhbG9nIHwgdW5kZWZpbmVkO1xuICAvKiogVGhlIGVhcmx5IG1lZGlhIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlcnMuICovXG4gIHByaXZhdGUgZWFybHlNZWRpYVNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI+KCk7XG4gIC8qKiBPdXIgRnJvbSB0YWcuICovXG4gIHByaXZhdGUgZnJvbVRhZzogc3RyaW5nO1xuICAvKiogVHJ1ZSBpZiBjYW5jZWwoKSB3YXMgY2FsbGVkLiAqL1xuICBwcml2YXRlIGlzQ2FuY2VsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgLyoqIFRydWUgaWYgaW5pdGlhbCBJTlZJVEUgd2l0aG91dCBTRFAuICovXG4gIHByaXZhdGUgaW52aXRlV2l0aG91dFNkcDogYm9vbGVhbiA9IGZhbHNlO1xuICAvKiogSW5pdGlhbCBJTlZJVEUgcmVxdWVzdCBzZW50IGJ5IGNvcmUuIFVuZGVmaW5lZCB1bnRpbCBzZW50LiAqL1xuICBwcml2YXRlIG91dGdvaW5nSW52aXRlUmVxdWVzdDogT3V0Z29pbmdJbnZpdGVSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogSW5pdGlhbCBJTlZJVEUgbWVzc2FnZSBwcm92aWRlZCB0byBjb3JlIHRvIHNlbmQuICovXG4gIHByaXZhdGUgb3V0Z29pbmdSZXF1ZXN0TWVzc2FnZTogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYEludml0ZXJgIGNsYXNzLlxuICAgKiBAcGFyYW0gdXNlckFnZW50IC0gVXNlciBhZ2VudC4gU2VlIHtAbGluayBVc2VyQWdlbnR9IGZvciBkZXRhaWxzLlxuICAgKiBAcGFyYW0gdGFyZ2V0VVJJIC0gUmVxdWVzdCBVUkkgaWRlbnRpZnlpbmcgdGhlIHRhcmdldCBvZiB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC4gU2VlIHtAbGluayBJbnZpdGVyT3B0aW9uc30gZm9yIGRldGFpbHMuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgdXNlckFnZW50OiBVc2VyQWdlbnQsXG4gICAgdGFyZ2V0VVJJOiBVUkksXG4gICAgb3B0aW9uczogSW52aXRlck9wdGlvbnMgPSB7fVxuICApIHtcbiAgICBzdXBlcih1c2VyQWdlbnQsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5sb2dnZXIgPSB1c2VyQWdlbnQuZ2V0TG9nZ2VyKFwic2lwLkludml0ZXJcIik7XG5cbiAgICAvLyBFYXJseSBtZWRpYVxuICAgIHRoaXMuZWFybHlNZWRpYSA9IG9wdGlvbnMuZWFybHlNZWRpYSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5lYXJseU1lZGlhIDogdGhpcy5lYXJseU1lZGlhO1xuXG4gICAgLy8gRnJvbSB0YWdcbiAgICB0aGlzLmZyb21UYWcgPSBuZXdUYWcoKTtcblxuICAgIC8vIEludml0ZSB3aXRob3V0IFNEUFxuICAgIHRoaXMuaW52aXRlV2l0aG91dFNkcCA9IG9wdGlvbnMuaW52aXRlV2l0aG91dFNkcCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbnZpdGVXaXRob3V0U2RwIDogdGhpcy5pbnZpdGVXaXRob3V0U2RwO1xuXG4gICAgLy8gSW52aXRlciBvcHRpb25zIChjb3VsZCBkbyBiZXR0ZXIgY29weWluZyB0aGVzZSBvcHRpb25zKVxuICAgIGNvbnN0IGludml0ZXJPcHRpb25zOiBJbnZpdGVyT3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIGludml0ZXJPcHRpb25zLnBhcmFtcyA9IHsgLi4ub3B0aW9ucy5wYXJhbXMgfTtcblxuICAgIC8vIEFub255bW91cyBjYWxsXG4gICAgY29uc3QgYW5vbnltb3VzID0gb3B0aW9ucy5hbm9ueW1vdXMgfHwgZmFsc2U7XG5cbiAgICAvLyBDb250YWN0XG4gICAgY29uc3QgY29udGFjdCA9IHVzZXJBZ2VudC5jb250YWN0LnRvU3RyaW5nKHtcbiAgICAgIGFub255bW91cyxcbiAgICAgIC8vIERvIG5vdCBhZGQgO29iIGluIGluaXRpYWwgZm9ybWluZyBkaWFsb2cgcmVxdWVzdHMgaWYgdGhlXG4gICAgICAvLyByZWdpc3RyYXRpb24gb3ZlciB0aGUgY3VycmVudCBjb25uZWN0aW9uIGdvdCBhIEdSVVUgVVJJLlxuICAgICAgb3V0Ym91bmQ6IGFub255bW91cyA/ICF1c2VyQWdlbnQuY29udGFjdC50ZW1wR3J1dSA6ICF1c2VyQWdlbnQuY29udGFjdC5wdWJHcnV1XG4gICAgfSk7XG5cbiAgICAvLyBGSVhNRTogVE9ETzogV2Ugc2hvdWxkIG5vdCBiZSBwYXJzaW5nIFVSSXMgaGVyZSBhcyBpZiBpdCBmYWlscyB3ZSBoYXZlIHRvIHRocm93IGFuIGV4Y2VwdGlvblxuICAgIC8vIHdoaWNoIGlzIG5vdCBzb21ldGhpbmcgd2Ugd2FudCBvdXIgY29uc3RydWN0b3IgdG8gZG8uIFVSSXMgc2hvdWxkIGJlIHBhc3NlZCBpbiBhcyBwYXJhbXMuXG4gICAgLy8gVVJJc1xuICAgIGlmIChhbm9ueW1vdXMgJiYgdXNlckFnZW50LmNvbmZpZ3VyYXRpb24udXJpKSB7XG4gICAgICBpbnZpdGVyT3B0aW9ucy5wYXJhbXMuZnJvbURpc3BsYXlOYW1lID0gXCJBbm9ueW1vdXNcIjtcbiAgICAgIGludml0ZXJPcHRpb25zLnBhcmFtcy5mcm9tVXJpID0gXCJzaXA6YW5vbnltb3VzQGFub255bW91cy5pbnZhbGlkXCI7XG4gICAgfVxuICAgIGxldCBmcm9tVVJJOiBVUkkgfCB1bmRlZmluZWQgPSB1c2VyQWdlbnQudXNlckFnZW50Q29yZS5jb25maWd1cmF0aW9uLmFvcjtcbiAgICBpZiAoaW52aXRlck9wdGlvbnMucGFyYW1zLmZyb21VcmkpIHtcbiAgICAgIGZyb21VUkkgPVxuICAgICAgICAodHlwZW9mIGludml0ZXJPcHRpb25zLnBhcmFtcy5mcm9tVXJpID09PSBcInN0cmluZ1wiKSA/XG4gICAgICAgICAgR3JhbW1hci5VUklQYXJzZShpbnZpdGVyT3B0aW9ucy5wYXJhbXMuZnJvbVVyaSkgOlxuICAgICAgICAgIGludml0ZXJPcHRpb25zLnBhcmFtcy5mcm9tVXJpO1xuICAgIH1cbiAgICBpZiAoIWZyb21VUkkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGZyb20gVVJJOiBcIiArIGludml0ZXJPcHRpb25zLnBhcmFtcy5mcm9tVXJpKTtcbiAgICB9XG4gICAgbGV0IHRvVVJJOiBVUkkgfCB1bmRlZmluZWQgPSB0YXJnZXRVUkk7XG4gICAgaWYgKGludml0ZXJPcHRpb25zLnBhcmFtcy50b1VyaSkge1xuICAgICAgdG9VUkkgPVxuICAgICAgICAodHlwZW9mIGludml0ZXJPcHRpb25zLnBhcmFtcy50b1VyaSA9PT0gXCJzdHJpbmdcIikgP1xuICAgICAgICAgIEdyYW1tYXIuVVJJUGFyc2UoaW52aXRlck9wdGlvbnMucGFyYW1zLnRvVXJpKSA6XG4gICAgICAgICAgaW52aXRlck9wdGlvbnMucGFyYW1zLnRvVXJpO1xuICAgIH1cbiAgICBpZiAoIXRvVVJJKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0byBVUkk6IFwiICsgaW52aXRlck9wdGlvbnMucGFyYW1zLnRvVXJpKTtcbiAgICB9XG5cbiAgICAvLyBQYXJhbXNcbiAgICBjb25zdCBtZXNzYWdlT3B0aW9uczogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZU9wdGlvbnMgPSB7IC4uLmludml0ZXJPcHRpb25zLnBhcmFtcyB9O1xuICAgIG1lc3NhZ2VPcHRpb25zLmZyb21UYWcgPSB0aGlzLmZyb21UYWc7XG5cbiAgICAvLyBFeHRyYSBoZWFkZXJzXG4gICAgY29uc3QgZXh0cmFIZWFkZXJzOiBBcnJheTxzdHJpbmc+ID0gKGludml0ZXJPcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICBpZiAoYW5vbnltb3VzICYmIHVzZXJBZ2VudC5jb25maWd1cmF0aW9uLnVyaSkge1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJQLVByZWZlcnJlZC1JZGVudGl0eTogXCIgKyB1c2VyQWdlbnQuY29uZmlndXJhdGlvbi51cmkudG9TdHJpbmcoKSk7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaChcIlByaXZhY3k6IGlkXCIpO1xuICAgIH1cbiAgICBleHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgY29udGFjdCk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goXCJBbGxvdzogXCIgKyBbXG4gICAgICBcIkFDS1wiLFxuICAgICAgXCJDQU5DRUxcIixcbiAgICAgIFwiSU5WSVRFXCIsXG4gICAgICBcIk1FU1NBR0VcIixcbiAgICAgIFwiQllFXCIsXG4gICAgICBcIk9QVElPTlNcIixcbiAgICAgIFwiSU5GT1wiLFxuICAgICAgXCJOT1RJRllcIixcbiAgICAgIFwiUkVGRVJcIlxuICAgIF0udG9TdHJpbmcoKSk7XG4gICAgaWYgKHVzZXJBZ2VudC5jb25maWd1cmF0aW9uLnNpcEV4dGVuc2lvbjEwMHJlbCA9PT0gU0lQRXh0ZW5zaW9uLlJlcXVpcmVkKSB7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlcXVpcmU6IDEwMHJlbFwiKTtcbiAgICB9XG4gICAgaWYgKHVzZXJBZ2VudC5jb25maWd1cmF0aW9uLnNpcEV4dGVuc2lvblJlcGxhY2VzID09PSBTSVBFeHRlbnNpb24uUmVxdWlyZWQpIHtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVxdWlyZTogcmVwbGFjZXNcIik7XG4gICAgfVxuICAgIGludml0ZXJPcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcblxuICAgIC8vIEJvZHlcbiAgICBjb25zdCBib2R5OiBCb2R5IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gTWFrZSBpbml0aWFsIG91dGdvaW5nIHJlcXVlc3QgbWVzc2FnZVxuICAgIHRoaXMub3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSA9IHVzZXJBZ2VudC51c2VyQWdlbnRDb3JlLm1ha2VPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKFxuICAgICAgQy5JTlZJVEUsXG4gICAgICB0YXJnZXRVUkksXG4gICAgICBmcm9tVVJJLFxuICAgICAgdG9VUkksXG4gICAgICBtZXNzYWdlT3B0aW9ucyxcbiAgICAgIGV4dHJhSGVhZGVycyxcbiAgICAgIGJvZHlcbiAgICApO1xuXG4gICAgLy8gU2Vzc2lvbiBwYXJlbnQgcHJvcGVydGllc1xuICAgIHRoaXMuX2NvbnRhY3QgPSBjb250YWN0O1xuICAgIHRoaXMuX3JlZmVycmFsSW52aXRlck9wdGlvbnMgPSBpbnZpdGVyT3B0aW9ucztcbiAgICB0aGlzLl9yZW5kZXJib2R5ID0gb3B0aW9ucy5yZW5kZXJib2R5O1xuICAgIHRoaXMuX3JlbmRlcnR5cGUgPSBvcHRpb25zLnJlbmRlcnR5cGU7XG4gICAgdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVycyA9IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVycztcbiAgICB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyA9IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM7XG5cbiAgICAvLyBJZGVudGlmaWVyXG4gICAgdGhpcy5faWQgPSB0aGlzLm91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuY2FsbElkICsgdGhpcy5mcm9tVGFnO1xuXG4gICAgLy8gQWRkIHRvIHRoZSB1c2VyIGFnZW50J3Mgc2Vzc2lvbiBjb2xsZWN0aW9uLlxuICAgIHRoaXMudXNlckFnZW50Ll9zZXNzaW9uc1t0aGlzLl9pZF0gPSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3RydWN0b3IuXG4gICAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBPbmx5IHJ1biB0aHJvdWdoIHRoaXMgb25jZS4gSXQgY2FuIGFuZCBkb2VzIGdldCBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgICAvLyBkZXBlbmRpbmcgb24gdGhlIHdoYXQgdGhlIHNlc3Npb25zIHN0YXRlIGlzIHdoZW4gZmlyc3QgY2FsbGVkLlxuICAgIC8vIEZvciBleGFtcGxlLCBpZiBjYWxsZWQgd2hlbiBcImVzdGFibGlzaGluZ1wiIGl0IHdpbGwgYmUgY2FsbGVkIGFnYWluXG4gICAgLy8gYXQgbGVhc3Qgb25jZSB3aGVuIHRoZSBzZXNzaW9uIHRyYW5zaXRpb25zIHRvIFwidGVybWluYXRlZFwiLlxuICAgIC8vIFJlZ2FyZGxlc3MsIHJ1bm5pbmcgdGhyb3VnaCB0aGlzIG1vcmUgdGhhbiBvbmNlIGlzIHBvaW50bGVzcy5cbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcblxuICAgIC8vIERpc3Bvc2Ugb2YgZWFybHkgZGlhbG9nIG1lZGlhXG4gICAgdGhpcy5kaXNwb3NlRWFybHlNZWRpYSgpO1xuXG4gICAgLy8gSWYgdGhlIGZpbmFsIHJlc3BvbnNlIGZvciB0aGUgaW5pdGlhbCBJTlZJVEUgbm90IHlldCBiZWVuIHJlY2VpdmVkLCBjYW5jZWwgaXRcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLkluaXRpYWw6XG4gICAgICAgIHJldHVybiB0aGlzLmNhbmNlbCgpLnRoZW4oKCkgPT4gc3VwZXIuZGlzcG9zZSgpKTtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLkVzdGFibGlzaGluZzpcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsKCkudGhlbigoKSA9PiBzdXBlci5kaXNwb3NlKCkpO1xuICAgICAgY2FzZSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQ6XG4gICAgICAgIHJldHVybiBzdXBlci5kaXNwb3NlKCk7XG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZzpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgIHJldHVybiBzdXBlci5kaXNwb3NlKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHN0YXRlLlwiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbCBvdXRnb2luZyBJTlZJVEUgcmVxdWVzdCBtZXNzYWdlIGJvZHkuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGJvZHkoKTogQm9keUFuZENvbnRlbnRUeXBlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5vdXRnb2luZ1JlcXVlc3RNZXNzYWdlLmJvZHk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlkZW50aXR5IG9mIHRoZSBsb2NhbCB1c2VyLlxuICAgKi9cbiAgcHVibGljIGdldCBsb2NhbElkZW50aXR5KCk6IE5hbWVBZGRySGVhZGVyIHtcbiAgICByZXR1cm4gdGhpcy5vdXRnb2luZ1JlcXVlc3RNZXNzYWdlLmZyb207XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlkZW50aXR5IG9mIHRoZSByZW1vdGUgdXNlci5cbiAgICovXG4gIHB1YmxpYyBnZXQgcmVtb3RlSWRlbnRpdHkoKTogTmFtZUFkZHJIZWFkZXIge1xuICAgIHJldHVybiB0aGlzLm91dGdvaW5nUmVxdWVzdE1lc3NhZ2UudG87XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbCBvdXRnb2luZyBJTlZJVEUgcmVxdWVzdCBtZXNzYWdlLlxuICAgKi9cbiAgcHVibGljIGdldCByZXF1ZXN0KCk6IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2Uge1xuICAgIHJldHVybiB0aGlzLm91dGdvaW5nUmVxdWVzdE1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgSU5WSVRFIHJlcXVlc3QuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFNlbmRzIGEgQ0FOQ0VMIHJlcXVlc3QuXG4gICAqIFJlc29sdmVzIG9uY2UgdGhlIHJlc3BvbnNlIHNlbnQsIG90aGVyd2lzZSByZWplY3RzLlxuICAgKlxuICAgKiBBZnRlciBzZW5kaW5nIGEgQ0FOQ0VMIHJlcXVlc3QgdGhlIGV4cGVjdGF0aW9uIGlzIHRoYXQgYSA0ODcgZmluYWwgcmVzcG9uc2VcbiAgICogd2lsbCBiZSByZWNlaXZlZCBmb3IgdGhlIElOVklURS4gSG93ZXZlciBhIDIwMCBmaW5hbCByZXNwb25zZSB0byB0aGUgSU5WSVRFXG4gICAqIG1heSBub25ldGhlbGVzcyBhcnJpdmUgKGl0J3MgYSByYWNlIGJldHdlZW4gdGhlIENBTkNFTCByZWFjaGluZyB0aGUgVUFTIGJlZm9yZVxuICAgKiB0aGUgVUFTIHNlbmRzIGEgMjAwKSBpbiB3aGljaCBjYXNlIGFuIEFDSyAmIEJZRSB3aWxsIGJlIHNlbnQuIFRoZSBuZXQgZWZmZWN0XG4gICAqIGlzIHRoYXQgdGhpcyBtZXRob2Qgd2lsbCB0ZXJtaW5hdGUgdGhlIHNlc3Npb24gcmVnYXJkbGVzcyBvZiB0aGUgcmFjZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHB1YmxpYyBjYW5jZWwob3B0aW9uczogSW52aXRlckNhbmNlbE9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIkludml0ZXIuY2FuY2VsXCIpO1xuXG4gICAgLy8gdmFsaWRhdGUgc3RhdGVcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2Vzc2lvblN0YXRlLkluaXRpYWwgJiYgdGhpcy5zdGF0ZSAhPT0gU2Vzc2lvblN0YXRlLkVzdGFibGlzaGluZykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEludmFsaWQgc2Vzc2lvbiBzdGF0ZSAke3RoaXMuc3RhdGV9YCk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gZmxhZyBjYW5jZWxlZFxuICAgIHRoaXMuaXNDYW5jZWxlZCA9IHRydWU7XG5cbiAgICAvLyB0cmFuc2l0aW9uIHN0YXRlXG4gICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU2Vzc2lvblN0YXRlLlRlcm1pbmF0aW5nKTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvblxuICAgIGZ1bmN0aW9uIGdldENhbmNlbFJlYXNvbihjb2RlOiBudW1iZXIsIHJlYXNvbjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAgIGlmIChjb2RlICYmIGNvZGUgPCAyMDAgfHwgY29kZSA+IDY5OSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIGNvZGUpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlKSB7XG4gICAgICAgIGNvbnN0IGNhdXNlID0gY29kZTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGdldFJlYXNvblBocmFzZShjb2RlKSB8fCByZWFzb247XG4gICAgICAgIHJldHVybiBcIlNJUDtjYXVzZT1cIiArIGNhdXNlICsgJzt0ZXh0PVwiJyArIHRleHQgKyAnXCInO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm91dGdvaW5nSW52aXRlUmVxdWVzdCkge1xuICAgICAgLy8gdGhlIENBTkNFTCBtYXkgbm90IGJlIHJlc3BlY3RlZCBieSBwZWVyKHMpLCBzbyBkb24ndCB0cmFuc2l0aW9uIHRvIHRlcm1pbmF0ZWRcbiAgICAgIGxldCBjYW5jZWxSZWFzb246IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgIGlmIChvcHRpb25zLnN0YXR1c0NvZGUgJiYgb3B0aW9ucy5yZWFzb25QaHJhc2UpIHtcbiAgICAgICAgY2FuY2VsUmVhc29uID0gZ2V0Q2FuY2VsUmVhc29uKG9wdGlvbnMuc3RhdHVzQ29kZSwgb3B0aW9ucy5yZWFzb25QaHJhc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5vdXRnb2luZ0ludml0ZVJlcXVlc3QuY2FuY2VsKGNhbmNlbFJlYXNvbiwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJDYW5jZWxlZCBzZXNzaW9uIGJlZm9yZSBJTlZJVEUgd2FzIHNlbnRcIik7XG4gICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBJTlZJVEUgcmVxdWVzdC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVExEUi4uLlxuICAgKiAgMSkgT25seSBvbmUgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlIHBlcm1pdHRlZCBkdXJpbmcgaW5pdGlhbCBJTlZJVEUuXG4gICAqICAyKSBObyBcImVhcmx5IG1lZGlhXCIgaWYgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gYW4gSU5WSVRFIChkZWZhdWx0IGJlaGF2aW9yKS5cbiAgICogIDMpIElmIFwiZWFybHkgbWVkaWFcIiBhbmQgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gYW4gSU5WSVRFLCBubyBJTlZJVEUgZm9ya2luZy5cbiAgICpcbiAgICogMSkgT25seSBvbmUgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlIHBlcm1pdHRlZCBkdXJpbmcgaW5pdGlhbCBJTlZJVEUuXG4gICAqXG4gICAqIE91ciBpbXBsZW1lbnRhdGlvbiByZXBsYWNlcyB0aGUgZm9sbG93aW5nIGJ1bGxldCBwb2ludC4uLlxuICAgKlxuICAgKiBvICBBZnRlciBoYXZpbmcgc2VudCBvciByZWNlaXZlZCBhbiBhbnN3ZXIgdG8gdGhlIGZpcnN0IG9mZmVyLCB0aGVcbiAgICogICAgVUFDIE1BWSBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiByZXF1ZXN0cyBiYXNlZCBvbiBydWxlc1xuICAgKiAgICBzcGVjaWZpZWQgZm9yIHRoYXQgbWV0aG9kLCBidXQgb25seSBpZiBpdCBoYXMgcmVjZWl2ZWQgYW5zd2Vyc1xuICAgKiAgICB0byBhbnkgcHJldmlvdXMgb2ZmZXJzLCBhbmQgaGFzIG5vdCBzZW50IGFueSBvZmZlcnMgdG8gd2hpY2ggaXRcbiAgICogICAgaGFzbid0IGdvdHRlbiBhbiBhbnN3ZXIuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAqXG4gICAqIC4uLndpdGguLi5cbiAgICpcbiAgICogbyAgQWZ0ZXIgaGF2aW5nIHNlbnQgb3IgcmVjZWl2ZWQgYW4gYW5zd2VyIHRvIHRoZSBmaXJzdCBvZmZlciwgdGhlXG4gICAqICAgIFVBQyBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiByZXF1ZXN0cyBiYXNlZCBvbiBydWxlc1xuICAgKiAgICBzcGVjaWZpZWQgZm9yIHRoYXQgbWV0aG9kLlxuICAgKlxuICAgKiAuLi53aGljaCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoaXMgYnVsbGV0IHBvaW50Li4uXG4gICAqXG4gICAqIG8gIE9uY2UgdGhlIFVBUyBoYXMgc2VudCBvciByZWNlaXZlZCBhbiBhbnN3ZXIgdG8gdGhlIGluaXRpYWxcbiAgICogICAgb2ZmZXIsIGl0IE1VU1QgTk9UIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIGluIGFueSByZXNwb25zZXNcbiAgICogICAgdG8gdGhlIGluaXRpYWwgSU5WSVRFLiAgVGhpcyBtZWFucyB0aGF0IGEgVUFTIGJhc2VkIG9uIHRoaXNcbiAgICogICAgc3BlY2lmaWNhdGlvbiBhbG9uZSBjYW4gbmV2ZXIgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgdW50aWxcbiAgICogICAgY29tcGxldGlvbiBvZiB0aGUgaW5pdGlhbCB0cmFuc2FjdGlvbi5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICpcbiAgICogLi4uZW5zdXJlcyB0aGF0IEVYQUNUTFkgT05FIG9mZmVyL2Fuc3dlciBleGNoYW5nZSB3aWxsIG9jY3VyXG4gICAqIGR1cmluZyBhbiBpbml0aWFsIG91dCBvZiBkaWFsb2cgSU5WSVRFIHJlcXVlc3QgbWFkZSBieSBvdXIgVUFDLlxuICAgKlxuICAgKlxuICAgKiAyKSBObyBcImVhcmx5IG1lZGlhXCIgaWYgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gYW4gSU5WSVRFIChkZWZhdWx0IGJlaGF2aW9yKS5cbiAgICpcbiAgICogV2hpbGUgb3VyIGltcGxlbWVudGF0aW9uIGFkaGVyZXMgdG8gdGhlIGZvbGxvd2luZyBidWxsZXQgcG9pbnQuLi5cbiAgICpcbiAgICogbyAgSWYgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gYW4gSU5WSVRFLCB0aGUgYW5zd2VyIE1VU1QgYmUgaW4gYVxuICAgKiAgICByZWxpYWJsZSBub24tZmFpbHVyZSBtZXNzYWdlIGZyb20gVUFTIGJhY2sgdG8gVUFDIHdoaWNoIGlzXG4gICAqICAgIGNvcnJlbGF0ZWQgdG8gdGhhdCBJTlZJVEUuICBGb3IgdGhpcyBzcGVjaWZpY2F0aW9uLCB0aGF0IGlzXG4gICAqICAgIG9ubHkgdGhlIGZpbmFsIDJ4eCByZXNwb25zZSB0byB0aGF0IElOVklURS4gIFRoYXQgc2FtZSBleGFjdFxuICAgKiAgICBhbnN3ZXIgTUFZIGFsc28gYmUgcGxhY2VkIGluIGFueSBwcm92aXNpb25hbCByZXNwb25zZXMgc2VudFxuICAgKiAgICBwcmlvciB0byB0aGUgYW5zd2VyLiAgVGhlIFVBQyBNVVNUIHRyZWF0IHRoZSBmaXJzdCBzZXNzaW9uXG4gICAqICAgIGRlc2NyaXB0aW9uIGl0IHJlY2VpdmVzIGFzIHRoZSBhbnN3ZXIsIGFuZCBNVVNUIGlnbm9yZSBhbnlcbiAgICogICAgc2Vzc2lvbiBkZXNjcmlwdGlvbnMgaW4gc3Vic2VxdWVudCByZXNwb25zZXMgdG8gdGhlIGluaXRpYWxcbiAgICogICAgSU5WSVRFLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgKlxuICAgKiBXZSBoYXZlIG1hZGUgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBkZWNpc2lvbiB3aXRoIHJlZ2FyZCB0byBlYXJseSBtZWRpYS4uLlxuICAgKlxuICAgKiBvICBJZiB0aGUgaW5pdGlhbCBvZmZlciBpcyBpbiB0aGUgSU5WSVRFLCB0aGUgYW5zd2VyIGZyb20gdGhlXG4gICAqICAgIFVBUyBiYWNrIHRvIHRoZSBVQUMgd2lsbCBlc3RhYmxpc2ggYSBtZWRpYSBzZXNzaW9uIG9ubHlcbiAgICogICAgb25seSBhZnRlciB0aGUgZmluYWwgMnh4IHJlc3BvbnNlIHRvIHRoYXQgSU5WSVRFIGlzIHJlY2VpdmVkLlxuICAgKlxuICAgKiBUaGUgcmVhc29uIGZvciB0aGlzIGRlY2lzaW9uIGlzIHJvb3RlZCBpbiBhIHJlc3RyaWN0aW9uIGN1cnJlbnRseVxuICAgKiBpbmhlcmVudCBpbiBXZWJSVEMuIFNwZWNpZmljYWxseSwgd2hpbGUgYSBTSVAgSU5WSVRFIHJlcXVlc3Qgd2l0aCBhblxuICAgKiBpbml0aWFsIG9mZmVyIG1heSBmb3JrIHJlc3VsdGluZyBpbiBtb3JlIHRoYW4gb25lIHByb3Zpc2lvbmFsIGFuc3dlcixcbiAgICogdGhlcmUgaXMgY3VycmVudGx5IG5vIGVhc3kvZ29vZCB3YXkgdG8gdG8gXCJmb3JrXCIgYW4gb2ZmZXIgZ2VuZXJhdGVkXG4gICAqIGJ5IGEgcGVlciBjb25uZWN0aW9uLiBJbiBwYXJ0aWN1bGFyLCBhIFdlYlJUQyBvZmZlciBjdXJyZW50bHkgbWF5IG9ubHlcbiAgICogYmUgbWF0Y2hlZCB3aXRoIG9uZSBhbnN3ZXIgYW5kIHdlIGhhdmUgbm8gZ29vZCB3YXkgdG8ga25vdyB3aGljaFxuICAgKiBcInByb3Zpc2lvbmFsIGFuc3dlclwiIGlzIGdvaW5nIHRvIGJlIHRoZSBcImZpbmFsIGFuc3dlclwiLiBTbyB3ZSBoYXZlXG4gICAqIGRlY2lkZWQgdG8gcHVudCBhbmQgbm90IGNyZWF0ZSBhbnkgXCJlYXJseSBtZWRpYVwiIHNlc3Npb25zIGluIHRoaXMgY2FzZS5cbiAgICpcbiAgICogVGhlIHVwc2hvdCBpcyB0aGF0IGlmIHlvdSB3YW50IFwiZWFybHkgbWVkaWFcIiwgeW91IG11c3Qgbm90IHB1dCB0aGVcbiAgICogaW5pdGlhbCBvZmZlciBpbiB0aGUgSU5WSVRFLiBJbnN0ZWFkLCBmb3JjZSB0aGUgVUFTIHRvIHByb3ZpZGUgdGhlXG4gICAqIGluaXRpYWwgb2ZmZXIgYnkgc2VuZGluZyBhbiBJTlZJVEUgd2l0aG91dCBhbiBvZmZlci4gSW4gdGhlIFdlYlJUQ1xuICAgKiBjYXNlIHRoaXMgYWxsb3dzIHVzIHRvIGNyZWF0ZSBhIHVuaXF1ZSBwZWVyIGNvbm5lY3Rpb24gd2l0aCBhIHVuaXF1ZVxuICAgKiBhbnN3ZXIgZm9yIGV2ZXJ5IHByb3Zpc2lvbmFsIG9mZmVyIHdpdGggXCJlYXJseSBtZWRpYVwiIG9uIGFsbCBvZiB0aGVtLlxuICAgKlxuICAgKlxuICAgKiAzKSBJZiBcImVhcmx5IG1lZGlhXCIgYW5kIHRoZSBpbml0aWFsIG9mZmVyIGlzIGluIGFuIElOVklURSwgbm8gSU5WSVRFIGZvcmtpbmcuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGJlaGF2aW9yIG1heSBiZSBhbHRlcmVkIGFuZCBcImVhcmx5IG1lZGlhXCIgdXRpbGl6ZWQgaWYgdGhlXG4gICAqIGluaXRpYWwgb2ZmZXIgaXMgaW4gdGhlIGFuIElOVklURSBieSBzZXR0aW5nIHRoZSBgZWFybHlNZWRpYWAgb3B0aW9ucy5cbiAgICogSG93ZXZlciBpbiB0aGF0IGNhc2UgdGhlIElOVklURSByZXF1ZXN0IE1VU1QgTk9UIGZvcmsuIFRoaXMgYWxsb3dzIGZvclxuICAgKiBcImVhcmx5IG1lZGlhXCIgaW4gZW52aXJvbm1lbnRzIHdoZXJlIHRoZSBmb3JraW5nIGJlaGF2aW9yIG9mIHRoZSBTSVBcbiAgICogc2VydmVycyBiZWluZyB1dGlsaXplZCBpcyBjb25maWd1cmVkIHRvIGRpc2FsbG93IGZvcmtpbmcuXG4gICAqL1xuICBwdWJsaWMgaW52aXRlKG9wdGlvbnM6IEludml0ZXJJbnZpdGVPcHRpb25zID0ge30pOiBQcm9taXNlPE91dGdvaW5nSW52aXRlUmVxdWVzdD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIkludml0ZXIuaW52aXRlXCIpO1xuXG4gICAgLy8gdmFsaWRhdGUgc3RhdGVcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2Vzc2lvblN0YXRlLkluaXRpYWwpIHtcbiAgICAgIC8vIHJlLWludml0ZVxuICAgICAgcmV0dXJuIHN1cGVyLmludml0ZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBqdXN0IHNlbmQgYW4gSU5WSVRFIHdpdGggbm8gc2RwLi4uXG4gICAgaWYgKG9wdGlvbnMud2l0aG91dFNkcCB8fCB0aGlzLmludml0ZVdpdGhvdXRTZHApIHtcbiAgICAgIGlmICh0aGlzLl9yZW5kZXJib2R5ICYmIHRoaXMuX3JlbmRlcnR5cGUpIHtcbiAgICAgICAgdGhpcy5vdXRnb2luZ1JlcXVlc3RNZXNzYWdlLmJvZHkgPSB7IGNvbnRlbnRUeXBlOiB0aGlzLl9yZW5kZXJ0eXBlLCBib2R5OiB0aGlzLl9yZW5kZXJib2R5IH07XG4gICAgICB9XG5cbiAgICAgIC8vIHRyYW5zaXRpb24gc3RhdGVcbiAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmcpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2VuZEludml0ZShvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGFuIG9mZmVyIGFuZCBzZW5kIGl0IGluIGFuIElOVklURVxuICAgIGNvbnN0IG9mZmVyT3B0aW9ucyA9IHtcbiAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyxcbiAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM6IHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnNcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmdldE9mZmVyKG9mZmVyT3B0aW9ucylcbiAgICAgIC50aGVuKChib2R5KSA9PiB7XG4gICAgICAgIHRoaXMub3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5ib2R5ID0geyBib2R5OiBib2R5LmNvbnRlbnQsIGNvbnRlbnRUeXBlOiBib2R5LmNvbnRlbnRUeXBlIH07XG5cbiAgICAgICAgLy8gdHJhbnNpdGlvbiBzdGF0ZVxuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuRXN0YWJsaXNoaW5nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kSW52aXRlKG9wdGlvbnMpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogMTMuMi4xIENyZWF0aW5nIHRoZSBJbml0aWFsIElOVklURVxuICAgKlxuICAgKiBTaW5jZSB0aGUgaW5pdGlhbCBJTlZJVEUgcmVwcmVzZW50cyBhIHJlcXVlc3Qgb3V0c2lkZSBvZiBhIGRpYWxvZyxcbiAgICogaXRzIGNvbnN0cnVjdGlvbiBmb2xsb3dzIHRoZSBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gOC4xLjEuICBBZGRpdGlvbmFsXG4gICAqIHByb2Nlc3NpbmcgaXMgcmVxdWlyZWQgZm9yIHRoZSBzcGVjaWZpYyBjYXNlIG9mIElOVklURS5cbiAgICpcbiAgICogQW4gQWxsb3cgaGVhZGVyIGZpZWxkIChTZWN0aW9uIDIwLjUpIFNIT1VMRCBiZSBwcmVzZW50IGluIHRoZSBJTlZJVEUuXG4gICAqIEl0IGluZGljYXRlcyB3aGF0IG1ldGhvZHMgY2FuIGJlIGludm9rZWQgd2l0aGluIGEgZGlhbG9nLCBvbiB0aGUgVUFcbiAgICogc2VuZGluZyB0aGUgSU5WSVRFLCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkaWFsb2cuICBGb3IgZXhhbXBsZSwgYVxuICAgKiBVQSBjYXBhYmxlIG9mIHJlY2VpdmluZyBJTkZPIHJlcXVlc3RzIHdpdGhpbiBhIGRpYWxvZyBbMzRdIFNIT1VMRFxuICAgKiBpbmNsdWRlIGFuIEFsbG93IGhlYWRlciBmaWVsZCBsaXN0aW5nIHRoZSBJTkZPIG1ldGhvZC5cbiAgICpcbiAgICogQSBTdXBwb3J0ZWQgaGVhZGVyIGZpZWxkIChTZWN0aW9uIDIwLjM3KSBTSE9VTEQgYmUgcHJlc2VudCBpbiB0aGVcbiAgICogSU5WSVRFLiAgSXQgZW51bWVyYXRlcyBhbGwgdGhlIGV4dGVuc2lvbnMgdW5kZXJzdG9vZCBieSB0aGUgVUFDLlxuICAgKlxuICAgKiBBbiBBY2NlcHQgKFNlY3Rpb24gMjAuMSkgaGVhZGVyIGZpZWxkIE1BWSBiZSBwcmVzZW50IGluIHRoZSBJTlZJVEUuXG4gICAqIEl0IGluZGljYXRlcyB3aGljaCBDb250ZW50LVR5cGVzIGFyZSBhY2NlcHRhYmxlIHRvIHRoZSBVQSwgaW4gYm90aFxuICAgKiB0aGUgcmVzcG9uc2UgcmVjZWl2ZWQgYnkgaXQsIGFuZCBpbiBhbnkgc3Vic2VxdWVudCByZXF1ZXN0cyBzZW50IHRvXG4gICAqIGl0IHdpdGhpbiBkaWFsb2dzIGVzdGFibGlzaGVkIGJ5IHRoZSBJTlZJVEUuICBUaGUgQWNjZXB0IGhlYWRlciBmaWVsZFxuICAgKiBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgaW5kaWNhdGluZyBzdXBwb3J0IG9mIHZhcmlvdXMgc2Vzc2lvblxuICAgKiBkZXNjcmlwdGlvbiBmb3JtYXRzLlxuICAgKlxuICAgKiBUaGUgVUFDIE1BWSBhZGQgYW4gRXhwaXJlcyBoZWFkZXIgZmllbGQgKFNlY3Rpb24gMjAuMTkpIHRvIGxpbWl0IHRoZVxuICAgKiB2YWxpZGl0eSBvZiB0aGUgaW52aXRhdGlvbi4gIElmIHRoZSB0aW1lIGluZGljYXRlZCBpbiB0aGUgRXhwaXJlc1xuICAgKiBoZWFkZXIgZmllbGQgaXMgcmVhY2hlZCBhbmQgbm8gZmluYWwgYW5zd2VyIGZvciB0aGUgSU5WSVRFIGhhcyBiZWVuXG4gICAqIHJlY2VpdmVkLCB0aGUgVUFDIGNvcmUgU0hPVUxEIGdlbmVyYXRlIGEgQ0FOQ0VMIHJlcXVlc3QgZm9yIHRoZVxuICAgKiBJTlZJVEUsIGFzIHBlciBTZWN0aW9uIDkuXG4gICAqXG4gICAqIEEgVUFDIE1BWSBhbHNvIGZpbmQgaXQgdXNlZnVsIHRvIGFkZCwgYW1vbmcgb3RoZXJzLCBTdWJqZWN0IChTZWN0aW9uXG4gICAqIDIwLjM2KSwgT3JnYW5pemF0aW9uIChTZWN0aW9uIDIwLjI1KSBhbmQgVXNlci1BZ2VudCAoU2VjdGlvbiAyMC40MSlcbiAgICogaGVhZGVyIGZpZWxkcy4gIFRoZXkgYWxsIGNvbnRhaW4gaW5mb3JtYXRpb24gcmVsYXRlZCB0byB0aGUgSU5WSVRFLlxuICAgKlxuICAgKiBUaGUgVUFDIE1BWSBjaG9vc2UgdG8gYWRkIGEgbWVzc2FnZSBib2R5IHRvIHRoZSBJTlZJVEUuICBTZWN0aW9uXG4gICAqIDguMS4xLjEwIGRlYWxzIHdpdGggaG93IHRvIGNvbnN0cnVjdCB0aGUgaGVhZGVyIGZpZWxkcyAtLSBDb250ZW50LVxuICAgKiBUeXBlIGFtb25nIG90aGVycyAtLSBuZWVkZWQgdG8gZGVzY3JpYmUgdGhlIG1lc3NhZ2UgYm9keS5cbiAgICpcbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICovXG4gIHByaXZhdGUgc2VuZEludml0ZShvcHRpb25zOiBJbnZpdGVySW52aXRlT3B0aW9ucyA9IHt9KTogT3V0Z29pbmdJbnZpdGVSZXF1ZXN0IHtcbiAgICAvLyAgICBUaGVyZSBhcmUgc3BlY2lhbCBydWxlcyBmb3IgbWVzc2FnZSBib2RpZXMgdGhhdCBjb250YWluIGEgc2Vzc2lvblxuICAgIC8vICAgIGRlc2NyaXB0aW9uIC0gdGhlaXIgY29ycmVzcG9uZGluZyBDb250ZW50LURpc3Bvc2l0aW9uIGlzIFwic2Vzc2lvblwiLlxuICAgIC8vICAgIFNJUCB1c2VzIGFuIG9mZmVyL2Fuc3dlciBtb2RlbCB3aGVyZSBvbmUgVUEgc2VuZHMgYSBzZXNzaW9uXG4gICAgLy8gICAgZGVzY3JpcHRpb24sIGNhbGxlZCB0aGUgb2ZmZXIsIHdoaWNoIGNvbnRhaW5zIGEgcHJvcG9zZWQgZGVzY3JpcHRpb25cbiAgICAvLyAgICBvZiB0aGUgc2Vzc2lvbi4gIFRoZSBvZmZlciBpbmRpY2F0ZXMgdGhlIGRlc2lyZWQgY29tbXVuaWNhdGlvbnMgbWVhbnNcbiAgICAvLyAgICAoYXVkaW8sIHZpZGVvLCBnYW1lcyksIHBhcmFtZXRlcnMgb2YgdGhvc2UgbWVhbnMgKHN1Y2ggYXMgY29kZWNcbiAgICAvLyAgICB0eXBlcykgYW5kIGFkZHJlc3NlcyBmb3IgcmVjZWl2aW5nIG1lZGlhIGZyb20gdGhlIGFuc3dlcmVyLiAgVGhlXG4gICAgLy8gICAgb3RoZXIgVUEgcmVzcG9uZHMgd2l0aCBhbm90aGVyIHNlc3Npb24gZGVzY3JpcHRpb24sIGNhbGxlZCB0aGVcbiAgICAvLyAgICBhbnN3ZXIsIHdoaWNoIGluZGljYXRlcyB3aGljaCBjb21tdW5pY2F0aW9ucyBtZWFucyBhcmUgYWNjZXB0ZWQsIHRoZVxuICAgIC8vICAgIHBhcmFtZXRlcnMgdGhhdCBhcHBseSB0byB0aG9zZSBtZWFucywgYW5kIGFkZHJlc3NlcyBmb3IgcmVjZWl2aW5nXG4gICAgLy8gICAgbWVkaWEgZnJvbSB0aGUgb2ZmZXJlci4gQW4gb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlIGlzIHdpdGhpbiB0aGVcbiAgICAvLyAgICBjb250ZXh0IG9mIGEgZGlhbG9nLCBzbyB0aGF0IGlmIGEgU0lQIElOVklURSByZXN1bHRzIGluIG11bHRpcGxlXG4gICAgLy8gICAgZGlhbG9ncywgZWFjaCBpcyBhIHNlcGFyYXRlIG9mZmVyL2Fuc3dlciBleGNoYW5nZS4gIFRoZSBvZmZlci9hbnN3ZXJcbiAgICAvLyAgICBtb2RlbCBkZWZpbmVzIHJlc3RyaWN0aW9ucyBvbiB3aGVuIG9mZmVycyBhbmQgYW5zd2VycyBjYW4gYmUgbWFkZVxuICAgIC8vICAgIChmb3IgZXhhbXBsZSwgeW91IGNhbm5vdCBtYWtlIGEgbmV3IG9mZmVyIHdoaWxlIG9uZSBpcyBpbiBwcm9ncmVzcykuXG4gICAgLy8gICAgVGhpcyByZXN1bHRzIGluIHJlc3RyaWN0aW9ucyBvbiB3aGVyZSB0aGUgb2ZmZXJzIGFuZCBhbnN3ZXJzIGNhblxuICAgIC8vICAgIGFwcGVhciBpbiBTSVAgbWVzc2FnZXMuICBJbiB0aGlzIHNwZWNpZmljYXRpb24sIG9mZmVycyBhbmQgYW5zd2Vyc1xuICAgIC8vICAgIGNhbiBvbmx5IGFwcGVhciBpbiBJTlZJVEUgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcywgYW5kIEFDSy4gIFRoZSB1c2FnZVxuICAgIC8vICAgIG9mIG9mZmVycyBhbmQgYW5zd2VycyBpcyBmdXJ0aGVyIHJlc3RyaWN0ZWQuICBGb3IgdGhlIGluaXRpYWwgSU5WSVRFXG4gICAgLy8gICAgdHJhbnNhY3Rpb24sIHRoZSBydWxlcyBhcmU6XG4gICAgLy9cbiAgICAvLyAgICAgICBvICBUaGUgaW5pdGlhbCBvZmZlciBNVVNUIGJlIGluIGVpdGhlciBhbiBJTlZJVEUgb3IsIGlmIG5vdCB0aGVyZSxcbiAgICAvLyAgICAgICAgICBpbiB0aGUgZmlyc3QgcmVsaWFibGUgbm9uLWZhaWx1cmUgbWVzc2FnZSBmcm9tIHRoZSBVQVMgYmFjayB0b1xuICAgIC8vICAgICAgICAgIHRoZSBVQUMuICBJbiB0aGlzIHNwZWNpZmljYXRpb24sIHRoYXQgaXMgdGhlIGZpbmFsIDJ4eFxuICAgIC8vICAgICAgICAgIHJlc3BvbnNlLlxuICAgIC8vXG4gICAgLy8gICAgICAgbyAgSWYgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gYW4gSU5WSVRFLCB0aGUgYW5zd2VyIE1VU1QgYmUgaW4gYVxuICAgIC8vICAgICAgICAgIHJlbGlhYmxlIG5vbi1mYWlsdXJlIG1lc3NhZ2UgZnJvbSBVQVMgYmFjayB0byBVQUMgd2hpY2ggaXNcbiAgICAvLyAgICAgICAgICBjb3JyZWxhdGVkIHRvIHRoYXQgSU5WSVRFLiAgRm9yIHRoaXMgc3BlY2lmaWNhdGlvbiwgdGhhdCBpc1xuICAgIC8vICAgICAgICAgIG9ubHkgdGhlIGZpbmFsIDJ4eCByZXNwb25zZSB0byB0aGF0IElOVklURS4gIFRoYXQgc2FtZSBleGFjdFxuICAgIC8vICAgICAgICAgIGFuc3dlciBNQVkgYWxzbyBiZSBwbGFjZWQgaW4gYW55IHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBzZW50XG4gICAgLy8gICAgICAgICAgcHJpb3IgdG8gdGhlIGFuc3dlci4gIFRoZSBVQUMgTVVTVCB0cmVhdCB0aGUgZmlyc3Qgc2Vzc2lvblxuICAgIC8vICAgICAgICAgIGRlc2NyaXB0aW9uIGl0IHJlY2VpdmVzIGFzIHRoZSBhbnN3ZXIsIGFuZCBNVVNUIGlnbm9yZSBhbnlcbiAgICAvLyAgICAgICAgICBzZXNzaW9uIGRlc2NyaXB0aW9ucyBpbiBzdWJzZXF1ZW50IHJlc3BvbnNlcyB0byB0aGUgaW5pdGlhbFxuICAgIC8vICAgICAgICAgIElOVklURS5cbiAgICAvL1xuICAgIC8vICAgICAgIG8gIElmIHRoZSBpbml0aWFsIG9mZmVyIGlzIGluIHRoZSBmaXJzdCByZWxpYWJsZSBub24tZmFpbHVyZVxuICAgIC8vICAgICAgICAgIG1lc3NhZ2UgZnJvbSB0aGUgVUFTIGJhY2sgdG8gVUFDLCB0aGUgYW5zd2VyIE1VU1QgYmUgaW4gdGhlXG4gICAgLy8gICAgICAgICAgYWNrbm93bGVkZ2VtZW50IGZvciB0aGF0IG1lc3NhZ2UgKGluIHRoaXMgc3BlY2lmaWNhdGlvbiwgQUNLXG4gICAgLy8gICAgICAgICAgZm9yIGEgMnh4IHJlc3BvbnNlKS5cbiAgICAvL1xuICAgIC8vICAgICAgIG8gIEFmdGVyIGhhdmluZyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgZmlyc3Qgb2ZmZXIsIHRoZVxuICAgIC8vICAgICAgICAgIFVBQyBNQVkgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgaW4gcmVxdWVzdHMgYmFzZWQgb24gcnVsZXNcbiAgICAvLyAgICAgICAgICBzcGVjaWZpZWQgZm9yIHRoYXQgbWV0aG9kLCBidXQgb25seSBpZiBpdCBoYXMgcmVjZWl2ZWQgYW5zd2Vyc1xuICAgIC8vICAgICAgICAgIHRvIGFueSBwcmV2aW91cyBvZmZlcnMsIGFuZCBoYXMgbm90IHNlbnQgYW55IG9mZmVycyB0byB3aGljaCBpdFxuICAgIC8vICAgICAgICAgIGhhc24ndCBnb3R0ZW4gYW4gYW5zd2VyLlxuICAgIC8vXG4gICAgLy8gICAgICAgbyAgT25jZSB0aGUgVUFTIGhhcyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgaW5pdGlhbFxuICAgIC8vICAgICAgICAgIG9mZmVyLCBpdCBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiBhbnkgcmVzcG9uc2VzXG4gICAgLy8gICAgICAgICAgdG8gdGhlIGluaXRpYWwgSU5WSVRFLiAgVGhpcyBtZWFucyB0aGF0IGEgVUFTIGJhc2VkIG9uIHRoaXNcbiAgICAvLyAgICAgICAgICBzcGVjaWZpY2F0aW9uIGFsb25lIGNhbiBuZXZlciBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyB1bnRpbFxuICAgIC8vICAgICAgICAgIGNvbXBsZXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24uXG4gICAgLy9cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuXG4gICAgLy8gNSBUaGUgT2ZmZXIvQW5zd2VyIE1vZGVsIGFuZCBQUkFDS1xuICAgIC8vXG4gICAgLy8gICAgUkZDIDMyNjEgZGVzY3JpYmVzIGd1aWRlbGluZXMgZm9yIHRoZSBzZXRzIG9mIG1lc3NhZ2VzIGluIHdoaWNoXG4gICAgLy8gICAgb2ZmZXJzIGFuZCBhbnN3ZXJzIFszXSBjYW4gYXBwZWFyLiAgQmFzZWQgb24gdGhvc2UgZ3VpZGVsaW5lcywgdGhpc1xuICAgIC8vICAgIGV4dGVuc2lvbiBwcm92aWRlcyBhZGRpdGlvbmFsIG9wcG9ydHVuaXRpZXMgZm9yIG9mZmVyL2Fuc3dlclxuICAgIC8vICAgIGV4Y2hhbmdlcy5cblxuICAgIC8vICAgIElmIHRoZSBJTlZJVEUgY29udGFpbmVkIGFuIG9mZmVyLCB0aGUgVUFTIE1BWSBnZW5lcmF0ZSBhbiBhbnN3ZXIgaW4gYVxuICAgIC8vICAgIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIChhc3N1bWluZyB0aGVzZSBhcmUgc3VwcG9ydGVkIGJ5IHRoZVxuICAgIC8vICAgIFVBQykuICBUaGF0IHJlc3VsdHMgaW4gdGhlIGVzdGFibGlzaG1lbnQgb2YgdGhlIHNlc3Npb24gYmVmb3JlXG4gICAgLy8gICAgY29tcGxldGlvbiBvZiB0aGUgY2FsbC4gIFNpbWlsYXJseSwgaWYgYSByZWxpYWJsZSBwcm92aXNpb25hbFxuICAgIC8vICAgIHJlc3BvbnNlIGlzIHRoZSBmaXJzdCByZWxpYWJsZSBtZXNzYWdlIHNlbnQgYmFjayB0byB0aGUgVUFDLCBhbmQgdGhlXG4gICAgLy8gICAgSU5WSVRFIGRpZCBub3QgY29udGFpbiBhbiBvZmZlciwgb25lIE1VU1QgYXBwZWFyIGluIHRoYXQgcmVsaWFibGVcbiAgICAvLyAgICBwcm92aXNpb25hbCByZXNwb25zZS5cblxuICAgIC8vICAgIElmIHRoZSBVQUMgcmVjZWl2ZXMgYSByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSB3aXRoIGFuIG9mZmVyXG4gICAgLy8gICAgKHRoaXMgd291bGQgb2NjdXIgaWYgdGhlIFVBQyBzZW50IGFuIElOVklURSB3aXRob3V0IGFuIG9mZmVyLCBpblxuICAgIC8vICAgIHdoaWNoIGNhc2UgdGhlIGZpcnN0IHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdpbGwgY29udGFpbiB0aGVcbiAgICAvLyAgICBvZmZlciksIGl0IE1VU1QgZ2VuZXJhdGUgYW4gYW5zd2VyIGluIHRoZSBQUkFDSy4gIElmIHRoZSBVQUMgcmVjZWl2ZXNcbiAgICAvLyAgICBhIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdpdGggYW4gYW5zd2VyLCBpdCBNQVkgZ2VuZXJhdGUgYW5cbiAgICAvLyAgICBhZGRpdGlvbmFsIG9mZmVyIGluIHRoZSBQUkFDSy4gIElmIHRoZSBVQVMgcmVjZWl2ZXMgYSBQUkFDSyB3aXRoIGFuXG4gICAgLy8gICAgb2ZmZXIsIGl0IE1VU1QgcGxhY2UgdGhlIGFuc3dlciBpbiB0aGUgMnh4IHRvIHRoZSBQUkFDSy5cblxuICAgIC8vICAgIE9uY2UgYW4gYW5zd2VyIGhhcyBiZWVuIHNlbnQgb3IgcmVjZWl2ZWQsIHRoZSBVQSBTSE9VTEQgZXN0YWJsaXNoIHRoZVxuICAgIC8vICAgIHNlc3Npb24gYmFzZWQgb24gdGhlIHBhcmFtZXRlcnMgb2YgdGhlIG9mZmVyIGFuZCBhbnN3ZXIsIGV2ZW4gaWYgdGhlXG4gICAgLy8gICAgb3JpZ2luYWwgSU5WSVRFIGl0c2VsZiBoYXMgbm90IGJlZW4gcmVzcG9uZGVkIHRvLlxuXG4gICAgLy8gICAgSWYgdGhlIFVBUyBoYWQgcGxhY2VkIGEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBpbiBhbnkgcmVsaWFibGVcbiAgICAvLyAgICBwcm92aXNpb25hbCByZXNwb25zZSB0aGF0IGlzIHVuYWNrbm93bGVkZ2VkIHdoZW4gdGhlIElOVklURSBpc1xuICAgIC8vICAgIGFjY2VwdGVkLCB0aGUgVUFTIE1VU1QgZGVsYXkgc2VuZGluZyB0aGUgMnh4IHVudGlsIHRoZSBwcm92aXNpb25hbFxuICAgIC8vICAgIHJlc3BvbnNlIGlzIGFja25vd2xlZGdlZC4gIE90aGVyd2lzZSwgdGhlIHJlbGlhYmlsaXR5IG9mIHRoZSAxeHhcbiAgICAvLyAgICBjYW5ub3QgYmUgZ3VhcmFudGVlZCwgYW5kIHJlbGlhYmlsaXR5IGlzIG5lZWRlZCBmb3IgcHJvcGVyIG9wZXJhdGlvblxuICAgIC8vICAgIG9mIHRoZSBvZmZlci9hbnN3ZXIgZXhjaGFuZ2UuXG5cbiAgICAvLyAgICBBbGwgdXNlciBhZ2VudHMgdGhhdCBzdXBwb3J0IHRoaXMgZXh0ZW5zaW9uIE1VU1Qgc3VwcG9ydCBhbGxcbiAgICAvLyAgICBvZmZlci9hbnN3ZXIgZXhjaGFuZ2VzIHRoYXQgYXJlIHBvc3NpYmxlIGJhc2VkIG9uIHRoZSBydWxlcyBpblxuICAgIC8vICAgIFNlY3Rpb24gMTMuMiBvZiBSRkMgMzI2MSwgYmFzZWQgb24gdGhlIGV4aXN0ZW5jZSBvZiBJTlZJVEUgYW5kIFBSQUNLXG4gICAgLy8gICAgYXMgcmVxdWVzdHMsIGFuZCAyeHggYW5kIHJlbGlhYmxlIDF4eCBhcyBub24tZmFpbHVyZSByZWxpYWJsZVxuICAgIC8vICAgIHJlc3BvbnNlcy5cbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNVxuXG4gICAgLy8vL1xuICAgIC8vIFRoZSBPZmZlci9BbnN3ZXIgTW9kZWwgSW1wbGVtZW50YXRpb25cbiAgICAvL1xuICAgIC8vIFRoZSBvZmZlci9hbnN3ZXIgbW9kZWwgaXMgc3RyYWlnaHQgZm9yd2FyZCwgYnV0IG9uZSBNVVNUIFJFQUQgdGhlIHNwZWNpZmljYXRpb25zLi4uXG4gICAgLy9cbiAgICAvLyAxMy4yLjEgQ3JlYXRpbmcgdGhlIEluaXRpYWwgSU5WSVRFIChwYXJhZ3JhcGggOCBpbiBwYXJ0aWN1bGFyKVxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgLy9cbiAgICAvLyA1IFRoZSBPZmZlci9BbnN3ZXIgTW9kZWwgYW5kIFBSQUNLXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi01XG4gICAgLy9cbiAgICAvLyBTZXNzaW9uIEluaXRpYXRpb24gUHJvdG9jb2wgKFNJUCkgVXNhZ2Ugb2YgdGhlIE9mZmVyL0Fuc3dlciBNb2RlbFxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MzM3XG4gICAgLy8vL1xuXG4gICAgLy8vL1xuICAgIC8vIFRPRE86IFRoZSBPZmZlci9BbnN3ZXIgTW9kZWwgSW1wbGVtZW50YXRpb25cbiAgICAvL1xuICAgIC8vIEN1cnJlbnRseSBpZiBgZWFybHlNZWRpYWAgaXMgZW5hYmxlZCBhbmQgdGhlIElOVklURSByZXF1ZXN0IGZvcmtzLFxuICAgIC8vIHRoZSBzZXNzaW9uIGlzIHRlcm1pbmF0ZWQgaWYgdGhlIGVhcmx5IGRpYWxvZyBkb2VzIG5vdCBtYXRjaCB0aGVcbiAgICAvLyBjb25maXJtZWQgZGlhbG9nLiBUaGlzIHJlc3RyaWN0aW9uIG1ha2Ugc2Vuc2UgaW4gYSBXZWJSVEMgZW52aXJvbm1lbnQsXG4gICAgLy8gYnV0IHRoZXJlIGFyZSBvdGhlciBlbnZpcm9ubWVudHMgd2hlcmUgdGhpcyByZXN0cmljdGlvbiBkb2VzIG5vdCBob2xkLlxuICAgIC8vXG4gICAgLy8gU28gd2hpbGUgd2UgY3VycmVudGx5IGNhbm5vdCBtYWtlIHRoZSBvZmZlciBpbiBJTlZJVEUrZm9ya2luZyt3ZWJydGNcbiAgICAvLyBjYXNlIHdvcmssIHdlIHByb3Bvc2UgZG9pbmcgdGhlIGZvbGxvd2luZy4uLlxuICAgIC8vXG4gICAgLy8gT1BUSU9OIDFcbiAgICAvLyAtIGFkZCBhIGBlYXJseU1lZGlhRm9ya2luZ2Agb3B0aW9uIGFuZFxuICAgIC8vIC0gcmVxdWlyZSBTREguc2V0RGVzY3JpcHRpb24oKSB0byBiZSBjYWxsYWJsZSBtdWx0aXBsZSB0aW1lcy5cbiAgICAvL1xuICAgIC8vIE9QVElPTiAyXG4gICAgLy8gMSkgbW9kaWZ5IFNESCBGYWN0b3J5IHRvIHByb3ZpZGUgYW4gaW5pdGlhbCBvZmZlciB3aXRob3V0IGdpdmluZyB1cyB0aGUgU0RILCBhbmQgdGhlbi4uLlxuICAgIC8vIDIpIHN0aWNrIHRoYXQgb2ZmZXIgaW4gdGhlIGluaXRpYWwgSU5WSVRFLCBhbmQgd2hlbiAxODMgd2l0aCBpbml0aWFsIGFuc3dlciBpcyByZWNlaXZlZC4uLlxuICAgIC8vIDMpIGFzayBTREggRmFjdG9yeSBpZiBpdCBzdXBwb3J0cyBcImVhcmx5UmVtb3RlQW5zd2VyXCJcbiAgICAvLyAgIGEpIGlmIHRydWUsIGFzayBTREggRmFjdG9yeSB0byBjcmVhdGVTREgobG9jYWxPZmZlcikudGhlbigoc2RoKSA9PiBzZGguc2V0RGVzY3JpcHRpb24ocmVtb3RlQW5zd2VyKVxuICAgIC8vICAgYikgaWYgZmFsc2UsIGRlZmVyIGdldHRpbmcgYSBTREggdW50aWwgMnh4IHJlc3BvbnNlIGlzIHJlY2VpdmVkXG4gICAgLy9cbiAgICAvLyBPdXIgc3VwcGxpZWQgV2ViUlRDIFNESCB3aWxsIGRlZmF1bHQgdG8gYmVoYXZpb3IgM2Igd2hpY2ggd29ya3MgaW4gZm9ya2luZyBlbnZpcm9ubWVudCAod2l0aG91dClcbiAgICAvLyBlYXJseSBtZWRpYSBpZiBpbml0aWFsIG9mZmVyIGlzIGluIHRoZSBJTlZJVEUpLiBXZSB3aWxsLCBob3dldmVyLCBwcm92aWRlIGFuIFwiaW52aXRlV2lsbE5vdEZvcmtcIlxuICAgIC8vIG9wdGlvbiB3aGljaCBpZiBzZXQgdG8gXCJ0cnVlXCIgd2lsbCBoYXZlIG91ciBzdXBwbGllZCBXZWJSVEMgU0RIIGJlaGF2ZSBpbiB0aGUgM2EgbWFubmVyLlxuICAgIC8vIFRoYXQgd2lsbCByZXN1bHQgaW5cbiAgICAvLyAgLSBlYXJseSBtZWRpYSB3b3JraW5nIHdpdGggaW5pdGlhbCBvZmZlciBpbiB0aGUgSU5WSVRFLCBhbmQuLi5cbiAgICAvLyAgLSBpZiB0aGUgSU5WSVRFIGZvcmtzLCB0aGUgc2Vzc2lvbiB0ZXJtaW5hdGluZyB3aXRoIGFuIEVSUk9SIHRoYXQgcmVhZHMgbGlrZVxuICAgIC8vICAgIFwiWW91IHNldCAnaW52aXRlV2lsbE5vdEZvcmsnIHRvIHRydWUgYnV0IHRoZSBJTlZJVEUgZm9ya2VkLiBZb3UgY2FuJ3QgZWF0IHlvdXIgY2FrZSwgYW5kIGhhdmUgaXQgdG9vLlwiXG4gICAgLy8gIC0gZnVydGhlcm1vcmUsIHdlIGFjY2VwdCB0aGF0IHVzZXJzIHdpbGwgcmVwb3J0IHRoYXQgZXJyb3IgdG8gdXMgYXMgXCJidWdcIiByZWdhcmRsZXNzXG4gICAgLy9cbiAgICAvLyBTbywgU0RIIEZhY3RvcnkgaXMgZ29pbmcgdG8gZW5kIHVwIHdpdGggYSBuZXcgaW50ZXJmYWNlIGFsb25nIHRoZSBsaW5lcyBvZi4uLlxuICAgIC8vXG4gICAgLy8gaW50ZXJmYWNlIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5IHtcbiAgICAvLyAgIG1ha2VMb2NhbE9mZmVyKCk6IFByb21pc2U8Q29udGVudFR5cGVBbmRCb2R5PjtcbiAgICAvLyAgIG1ha2VTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKFxuICAgIC8vICAgICBpbml0aWFsT2ZmZXI6IENvbnRlbnRUeXBlQW5kQm9keSwgb2ZmZXJUeXBlOiBcImxvY2FsXCIgfCBcInJlbW90ZVwiXG4gICAgLy8gICApOiBQcm9taXNlPFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI+O1xuICAgIC8vICAgc3VwcG9ydHNFYXJseVJlbW90ZUFuc3dlcjogYm9vbGVhbjtcbiAgICAvLyAgIHN1cHBvcnRzQ29udGVudFR5cGUoY29udGVudFR5cGU6IHN0cmluZyk6IGJvb2xlYW47XG4gICAgLy8gICBnZXREZXNjcmlwdGlvbihkZXNjcmlwdGlvbjogQ29udGVudFR5cGVBbmRCb2R5KTogUHJvbWlzZTxDb250ZW50VHlwZUFuZEJvZHk+XG4gICAgLy8gICBzZXREZXNjcmlwdGlvbihkZXNjcmlwdGlvbjogQ29udGVudFR5cGVBbmRCb2R5KTogUHJvbWlzZTx2b2lkPlxuICAgIC8vIH1cbiAgICAvLy8vXG5cbiAgICAvLyBTZW5kIHRoZSBJTlZJVEUgcmVxdWVzdC5cbiAgICB0aGlzLm91dGdvaW5nSW52aXRlUmVxdWVzdCA9IHRoaXMudXNlckFnZW50LnVzZXJBZ2VudENvcmUuaW52aXRlKHRoaXMub3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSwge1xuICAgICAgb25BY2NlcHQ6IChpbnZpdGVSZXNwb25zZSkgPT4ge1xuICAgICAgICAvLyBPdXIgdHJhbnNhY3Rpb24gbGF5ZXIgaXMgXCJub24tc3RhbmRhcmRcIiBpbiB0aGF0IGl0IHdpbGwgb25seVxuICAgICAgICAvLyBwYXNzIHVzIGEgMnh4IHJlc3BvbnNlIG9uY2UgcGVyIGJyYW5jaCwgc28gdGhlcmUgaXMgbm8gbmVlZCB0b1xuICAgICAgICAvLyB3b3JyeSBhYm91dCBkZWFsaW5nIHdpdGggMnh4IHJldHJhbnNtaXNzaW9ucy4gSG93ZXZlciwgd2UgY2FuXG4gICAgICAgIC8vIGFuZCBkbyBzdGlsbCBnZXQgMnh4IHJlc3BvbnNlcyBmb3IgbXVsdGlwbGUgYnJhbmNoZXMgKHdoZW4gYW5cbiAgICAgICAgLy8gSU5WSVRFIGlzIGZvcmtlZCkgd2hpY2ggbWF5IGNyZWF0ZSBtdWx0aXBsZSBjb25maXJtZWQgZGlhbG9ncy5cbiAgICAgICAgLy8gSGVyZWluIHdlIGFyZSBhY2tpbmcgYW5kIHNlbmRpbmcgYSBieWUgdG8gYW55IGNvbmZpcm1lZCBkaWFsb2dzXG4gICAgICAgIC8vIHdoaWNoIGFycml2ZSBiZXlvbmQgdGhlIGZpcnN0IG9uZS4gVGhpcyBpcyB0aGUgZGVzaXJlZCBiZWhhdmlvclxuICAgICAgICAvLyBmb3IgbW9zdCBhcHBsaWNhdGlvbnMgKGJ1dCBjZXJ0YWlubHkgbm90IGFsbCkuXG5cbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSByZWNlaXZlZCBhIGNvbmZpcm1lZCBkaWFsb2csIGFjayAmIGJ5ZSB0aGlzIGFkZGl0aW9uYWwgY29uZmlybWVkIHNlc3Npb24uXG4gICAgICAgIGlmICh0aGlzLmRpYWxvZykge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkFkZGl0aW9uYWwgY29uZmlybWVkIGRpYWxvZywgc2VuZGluZyBBQ0sgYW5kIEJZRVwiKTtcbiAgICAgICAgICB0aGlzLmFja0FuZEJ5ZShpbnZpdGVSZXNwb25zZSk7XG4gICAgICAgICAgLy8gV2UgZG8gTk9UIHRyYW5zaXRpb24gc3RhdGUgaW4gdGhpcyBjYXNlICh0aGlzIGlzIGFuIFwiZXh0cmFcIiBkaWFsb2cpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgcmVxdWVzdGVkIGNhbmNlbGxhdGlvbiwgYWNrICYgYnllIHRoaXMgc2Vzc2lvbi5cbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxlZCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkNhbmNlbGVkIHNlc3Npb24gYWNjZXB0ZWQsIHNlbmRpbmcgQUNLIGFuZCBCWUVcIik7XG4gICAgICAgICAgdGhpcy5hY2tBbmRCeWUoaW52aXRlUmVzcG9uc2UpO1xuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vdGlmeVJlZmVyZXIoaW52aXRlUmVzcG9uc2UpO1xuICAgICAgICB0aGlzLm9uQWNjZXB0KGludml0ZVJlc3BvbnNlKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZUVhcmx5TWVkaWEoKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VFYXJseU1lZGlhKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUgJiYgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25BY2NlcHQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25BY2NlcHQoaW52aXRlUmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3M6IChpbnZpdGVSZXNwb25zZSkgPT4ge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciByZXF1ZXN0ZWQgY2FuY2VsbGF0aW9uLCBpZ25vcmUgcmVzcG9uc2UuXG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlSZWZlcmVyKGludml0ZVJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5vblByb2dyZXNzKGludml0ZVJlc3BvbnNlKVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VFYXJseU1lZGlhKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUgJiYgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblByb2dyZXNzKGludml0ZVJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvblJlZGlyZWN0OiAoaW52aXRlUmVzcG9uc2UpID0+IHtcbiAgICAgICAgdGhpcy5ub3RpZnlSZWZlcmVyKGludml0ZVJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5vblJlZGlyZWN0KGludml0ZVJlc3BvbnNlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVxdWVzdERlbGVnYXRlICYmIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uUmVkaXJlY3QpIHtcbiAgICAgICAgICBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblJlZGlyZWN0KGludml0ZVJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUmVqZWN0OiAoaW52aXRlUmVzcG9uc2UpID0+IHtcbiAgICAgICAgdGhpcy5ub3RpZnlSZWZlcmVyKGludml0ZVJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5vblJlamVjdChpbnZpdGVSZXNwb25zZSk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblJlamVjdCkge1xuICAgICAgICAgIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uUmVqZWN0KGludml0ZVJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVHJ5aW5nOiAoaW52aXRlUmVzcG9uc2UpID0+IHtcbiAgICAgICAgdGhpcy5ub3RpZnlSZWZlcmVyKGludml0ZVJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5vblRyeWluZyhpbnZpdGVSZXNwb25zZSk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblRyeWluZykge1xuICAgICAgICAgIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uVHJ5aW5nKGludml0ZVJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMub3V0Z29pbmdJbnZpdGVSZXF1ZXN0O1xuICB9XG5cbiAgcHJpdmF0ZSBkaXNwb3NlRWFybHlNZWRpYSgpOiB2b2lkIHtcbiAgICB0aGlzLmVhcmx5TWVkaWFTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVycy5mb3JFYWNoKChzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSA9PiB7XG4gICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5lYXJseU1lZGlhU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcnMuY2xlYXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgbm90aWZ5UmVmZXJlcihyZXNwb25zZTogSW5jb21pbmdSZXNwb25zZSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fcmVmZXJyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodGhpcy5fcmVmZXJyZWQgaW5zdGFuY2VvZiBTZXNzaW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVmZXJyZWQgc2Vzc2lvbiBub3QgaW5zdGFuY2Ugb2Ygc2Vzc2lvblwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9yZWZlcnJlZC5kaWFsb2cpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5tZXNzYWdlLnN0YXR1c0NvZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXR1cyBjb2RlIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UubWVzc2FnZS5yZWFzb25QaHJhc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYXNvbiBwaHJhc2UgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZTtcbiAgICBjb25zdCByZWFzb25QaHJhc2UgPSByZXNwb25zZS5tZXNzYWdlLnJlYXNvblBocmFzZTtcbiAgICBjb25zdCBib2R5ID0gYFNJUC8yLjAgJHtzdGF0dXNDb2RlfSAke3JlYXNvblBocmFzZX1gLnRyaW0oKTtcblxuICAgIGNvbnN0IG91dGdvaW5nTm90aWZ5UmVxdWVzdCA9IHRoaXMuX3JlZmVycmVkLmRpYWxvZy5ub3RpZnkodW5kZWZpbmVkLCB7XG4gICAgICBleHRyYUhlYWRlcnM6IFtcbiAgICAgICAgXCJFdmVudDogcmVmZXJcIixcbiAgICAgICAgXCJTdWJzY3JpcHRpb24tU3RhdGU6IHRlcm1pbmF0ZWRcIixcbiAgICAgIF0sXG4gICAgICBib2R5OiB7XG4gICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogXCJyZW5kZXJcIixcbiAgICAgICAgY29udGVudFR5cGU6IFwibWVzc2FnZS9zaXBmcmFnXCIsXG4gICAgICAgIGNvbnRlbnQ6IGJvZHlcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRoZSBpbXBsaWNpdCBzdWJzY3JpcHRpb24gY3JlYXRlZCBieSBhIFJFRkVSIGlzIHRoZSBzYW1lIGFzIGFcbiAgICAvLyBzdWJzY3JpcHRpb24gY3JlYXRlZCB3aXRoIGEgU1VCU0NSSUJFIHJlcXVlc3QuICBUaGUgYWdlbnQgaXNzdWluZyB0aGVcbiAgICAvLyBSRUZFUiBjYW4gdGVybWluYXRlIHRoaXMgc3Vic2NyaXB0aW9uIHByZW1hdHVyZWx5IGJ5IHVuc3Vic2NyaWJpbmdcbiAgICAvLyB1c2luZyB0aGUgbWVjaGFuaXNtcyBkZXNjcmliZWQgaW4gWzJdLiAgVGVybWluYXRpbmcgYSBzdWJzY3JpcHRpb24sXG4gICAgLy8gZWl0aGVyIGJ5IGV4cGxpY2l0bHkgdW5zdWJzY3JpYmluZyBvciByZWplY3RpbmcgTk9USUZZLCBpcyBub3QgYW5cbiAgICAvLyBpbmRpY2F0aW9uIHRoYXQgdGhlIHJlZmVyZW5jZWQgcmVxdWVzdCBzaG91bGQgYmUgd2l0aGRyYXduIG9yXG4gICAgLy8gYWJhbmRvbmVkLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTE1I3NlY3Rpb24tMi40LjRcblxuICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCBiZSBkb25lIGluIGEgc3Vic2NyaWJlIGRpYWxvZyB0byBzYXRpc2Z5IHRoZSBhYm92ZS5cbiAgICAvLyBJZiB0aGUgbm90aWZ5IGlzIHJlamVjdGVkLCBzdG9wIHNlbmRpbmcgTk9USUZZIHJlcXVlc3RzLlxuICAgIG91dGdvaW5nTm90aWZ5UmVxdWVzdC5kZWxlZ2F0ZSA9IHtcbiAgICAgIG9uUmVqZWN0OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlZmVycmVkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGZpbmFsIHJlc3BvbnNlIHRvIGluaXRpYWwgSU5WSVRFLlxuICAgKiBAcGFyYW0gaW52aXRlUmVzcG9uc2UgLSAyeHggcmVzcG9uc2UuXG4gICAqL1xuICBwcml2YXRlIG9uQWNjZXB0KGludml0ZVJlc3BvbnNlOiBBY2thYmxlSW5jb21pbmdSZXNwb25zZVdpdGhTZXNzaW9uKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiSW52aXRlci5vbkFjY2VwdFwiKTtcblxuICAgIC8vIHZhbGlkYXRlIHN0YXRlXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBBY2NlcHQgcmVjZWl2ZWQgd2hpbGUgaW4gc3RhdGUgJHt0aGlzLnN0YXRlfSwgZHJvcHBpbmcgcmVzcG9uc2VgKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYEludmFsaWQgc2Vzc2lvbiBzdGF0ZSAke3RoaXMuc3RhdGV9YCkpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gaW52aXRlUmVzcG9uc2UubWVzc2FnZTtcbiAgICBjb25zdCBzZXNzaW9uID0gaW52aXRlUmVzcG9uc2Uuc2Vzc2lvbjtcblxuICAgIC8vIFBvcnRlZCBiZWhhdmlvci5cbiAgICBpZiAocmVzcG9uc2UuaGFzSGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKSkge1xuICAgICAgdGhpcy5fYXNzZXJ0ZWRJZGVudGl0eSA9IEdyYW1tYXIubmFtZUFkZHJIZWFkZXJQYXJzZShyZXNwb25zZS5nZXRIZWFkZXIoXCJQLUFzc2VydGVkLUlkZW50aXR5XCIpIGFzIHN0cmluZyk7XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSBhIGNvbmZpcm1lZCBkaWFsb2cuXG4gICAgc2Vzc2lvbi5kZWxlZ2F0ZSA9IHtcbiAgICAgIG9uQWNrOiAoYWNrUmVxdWVzdCk6IHZvaWQgPT4gdGhpcy5vbkFja1JlcXVlc3QoYWNrUmVxdWVzdCksXG4gICAgICBvbkJ5ZTogKGJ5ZVJlcXVlc3QpOiB2b2lkID0+IHRoaXMub25CeWVSZXF1ZXN0KGJ5ZVJlcXVlc3QpLFxuICAgICAgb25JbmZvOiAoaW5mb1JlcXVlc3QpOiB2b2lkID0+IHRoaXMub25JbmZvUmVxdWVzdChpbmZvUmVxdWVzdCksXG4gICAgICBvbkludml0ZTogKGludml0ZVJlcXVlc3QpOiB2b2lkID0+IHRoaXMub25JbnZpdGVSZXF1ZXN0KGludml0ZVJlcXVlc3QpLFxuICAgICAgb25Ob3RpZnk6IChub3RpZnlSZXF1ZXN0KTogdm9pZCA9PiB0aGlzLm9uTm90aWZ5UmVxdWVzdChub3RpZnlSZXF1ZXN0KSxcbiAgICAgIG9uUHJhY2s6IChwcmFja1JlcXVlc3QpOiB2b2lkID0+IHRoaXMub25QcmFja1JlcXVlc3QocHJhY2tSZXF1ZXN0KSxcbiAgICAgIG9uUmVmZXI6IChyZWZlclJlcXVlc3QpOiB2b2lkID0+IHRoaXMub25SZWZlclJlcXVlc3QocmVmZXJSZXF1ZXN0KVxuICAgIH07XG4gICAgdGhpcy5fZGlhbG9nID0gc2Vzc2lvbjtcblxuICAgIGNvbnN0IHNkaE9wdGlvbnMgPSB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucztcbiAgICBjb25zdCBzZGhNb2RpZmllcnMgPSB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzO1xuXG4gICAgc3dpdGNoIChzZXNzaW9uLnNpZ25hbGluZ1N0YXRlKSB7XG4gICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkluaXRpYWw6XG4gICAgICAgIC8vIElOVklURSB3aXRob3V0IG9mZmVyLCBzbyBNVVNUIGhhdmUgb2ZmZXIgYXQgdGhpcyBwb2ludCwgc28gaW52YWxpZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJSZWNlaXZlZCAyeHggcmVzcG9uc2UgdG8gSU5WSVRFIHdpdGhvdXQgYSBzZXNzaW9uIGRlc2NyaXB0aW9uXCIpO1xuICAgICAgICB0aGlzLmFja0FuZEJ5ZShpbnZpdGVSZXNwb25zZSwgNDAwLCBcIk1pc3Npbmcgc2Vzc2lvbiBkZXNjcmlwdGlvblwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQmFkIE1lZGlhIERlc2NyaXB0aW9uXCIpKTtcbiAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXI6XG4gICAgICAgIC8vIElOVklURSB3aXRoIG9mZmVyLCBzbyBNVVNUIGhhdmUgYW5zd2VyIGF0IHRoaXMgcG9pbnQsIHNvIGludmFsaWQgc3RhdGUuXG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiUmVjZWl2ZWQgMnh4IHJlc3BvbnNlIHRvIElOVklURSB3aXRob3V0IGEgc2Vzc2lvbiBkZXNjcmlwdGlvblwiKTtcbiAgICAgICAgdGhpcy5hY2tBbmRCeWUoaW52aXRlUmVzcG9uc2UsIDQwMCwgXCJNaXNzaW5nIHNlc3Npb24gZGVzY3JpcHRpb25cIik7XG4gICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkJhZCBNZWRpYSBEZXNjcmlwdGlvblwiKSk7XG4gICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjoge1xuICAgICAgICAvLyBJTlZJVEUgd2l0aG91dCBvZmZlciwgcmVjZWl2ZWQgb2ZmZXIgaW4gMnh4LCBzbyBNVVNUIHNlbmQgYW5zd2VyIGluIEFDSy5cbiAgICAgICAgaWYgKCF0aGlzLl9kaWFsb2cub2ZmZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlc3Npb24gb2ZmZXIgdW5kZWZpbmVkIGluIHNpZ25hbGluZyBzdGF0ZSAke3RoaXMuX2RpYWxvZy5zaWduYWxpbmdTdGF0ZX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9uczogc2RoT3B0aW9ucyxcbiAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzOiBzZGhNb2RpZmllcnNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0T2ZmZXJBbmRHZXRBbnN3ZXIodGhpcy5fZGlhbG9nLm9mZmVyLCBvcHRpb25zKVxuICAgICAgICAgIC50aGVuKChib2R5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY2tSZXF1ZXN0ID0gaW52aXRlUmVzcG9uc2UuYWNrKHsgYm9keSB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY2tBbmRCeWUoaW52aXRlUmVzcG9uc2UsIDQ4OCwgXCJJbnZhbGlkIHNlc3Npb24gZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuU3RhYmxlOiB7XG4gICAgICAgIC8vIElmIElOVklURSB3aXRob3V0IG9mZmVyIGFuZCB3ZSBoYXZlIGFscmVhZHkgY29tcGxldGVkIHRoZSBpbml0aWFsIGV4Y2hhbmdlLlxuICAgICAgICBpZiAodGhpcy5lYXJseU1lZGlhU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICBjb25zdCBzZGggPSB0aGlzLmVhcmx5TWVkaWFTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVycy5nZXQoc2Vzc2lvbi5pZCk7XG4gICAgICAgICAgaWYgKCFzZGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIoc2RoKTtcbiAgICAgICAgICB0aGlzLmVhcmx5TWVkaWFTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVycy5kZWxldGUoc2Vzc2lvbi5pZCk7XG4gICAgICAgICAgY29uc3QgYWNrUmVxdWVzdCA9IGludml0ZVJlc3BvbnNlLmFjaygpO1xuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgSU5WSVRFIHdpdGggb2ZmZXIgYW5kIHdlIHVzZWQgYW4gXCJlYXJseVwiIGFuc3dlciBpbiBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGZvciBtZWRpYVxuICAgICAgICBpZiAodGhpcy5lYXJseU1lZGlhRGlhbG9nKSB7XG4gICAgICAgICAgLy8gSWYgZWFybHkgbWVkaWEgZGlhbG9nIGRvZXNuJ3QgbWF0Y2ggY29uZmlybWVkIGRpYWxvZywgd2UgbXVzdCB1bmZvcnR1bmF0ZWx5IGZhaWwuXG4gICAgICAgICAgLy8gVGhpcyBsaW1pdGF0aW9uIHN0ZW1zIGZyb20gaG93IFdlYlJUQyBjdXJyZW50bHkgaW1wbGVtZW50cyBpdHMgb2ZmZXIvYW5zd2VyIG1vZGVsLlxuICAgICAgICAgIC8vIFRoZXJlIGFyZSBkZXRhaWxzIGVsc2V3aGVyZSwgYnV0IGluIHNob3J0IGEgV2ViUlRDIG9mZmVyIGNhbm5vdCBiZSBmb3JrZWQuXG4gICAgICAgICAgaWYgKHRoaXMuZWFybHlNZWRpYURpYWxvZyAhPT0gc2Vzc2lvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWFybHlNZWRpYSkge1xuICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICBcIllvdSBoYXZlIHNldCB0aGUgJ2Vhcmx5TWVkaWEnIG9wdGlvbiB0byAndHJ1ZScgd2hpY2ggcmVxdWlyZXMgdGhhdCB5b3VyIElOVklURSByZXF1ZXN0cyBcIiArXG4gICAgICAgICAgICAgICAgXCJkbyBub3QgZm9yayBhbmQgeWV0IHRoaXMgSU5WSVRFIHJlcXVlc3QgZGlkIGluIGZhY3QgZm9yay4gQ29uc2VxdWVudGlhbGx5IGFuZCBub3Qgc3VycHJpc2luZ2x5IFwiICtcbiAgICAgICAgICAgICAgICBcInRoZSBlbmQgcG9pbnQgd2hpY2ggYWNjZXB0ZWQgdGhlIElOVklURSAoY29uZmlybWVkIGRpYWxvZykgZG9lcyBub3QgbWF0Y2ggdGhlIGVuZCBwb2ludCB3aXRoIFwiICtcbiAgICAgICAgICAgICAgICBcIndoaWNoIGVhcmx5IG1lZGlhIGhhcyBiZWVuIHNldHVwIChlYXJseSBkaWFsb2cpIGFuZCB0aHVzIHRoaXMgc2Vzc2lvbiBpcyB1bmFibGUgdG8gcHJvY2VlZC4gXCIgK1xuICAgICAgICAgICAgICAgIFwiSW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBTSVAgc3BlY2lmaWNhdGlvbnMsIHRoZSBTSVAgc2VydmVycyB5b3VyIGVuZCBwb2ludCBpcyBjb25uZWN0ZWQgdG8gXCIgK1xuICAgICAgICAgICAgICAgIFwiZGV0ZXJtaW5lIGlmIGFuIElOVklURSBmb3JrcyBhbmQgdGhlIGZvcmtpbmcgYmVoYXZpb3Igb2YgdGhvc2Ugc2VydmVycyBjYW5ub3QgYmUgY29udHJvbGxlZCBcIiArXG4gICAgICAgICAgICAgICAgXCJieSB0aGlzIGxpYnJhcnkuIElmIHlvdSB3aXNoIHRvIHVzZSBlYXJseSBtZWRpYSB3aXRoIHRoaXMgbGlicmFyeSB5b3UgbXVzdCBjb25maWd1cmUgdGhvc2UgXCIgK1xuICAgICAgICAgICAgICAgIFwic2VydmVycyBhY2NvcmRpbmdseS4gQWx0ZXJuYXRpdmVseSB5b3UgbWF5IHNldCB0aGUgJ2Vhcmx5TWVkaWEnIHRvICdmYWxzZScgd2hpY2ggd2lsbCBhbGxvdyBcIiArXG4gICAgICAgICAgICAgICAgXCJ0aGlzIGxpYnJhcnkgdG8gZnVuY3Rpb24gd2l0aCBhbnkgSU5WSVRFIHJlcXVlc3RzIHdoaWNoIGRvIGZvcmsuXCI7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJFYXJseSBtZWRpYSBkaWFsb2cgZG9lcyBub3QgZXF1YWwgY29uZmlybWVkIGRpYWxvZywgdGVybWluYXRpbmcgc2Vzc2lvblwiKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5hY2tBbmRCeWUoaW52aXRlUmVzcG9uc2UsIDQ4OCwgXCJOb3QgQWNjZXB0YWJsZSBIZXJlXCIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGFyZSBnb29kIHRvIGdvLlxuICAgICAgICAgIGNvbnN0IGFja1JlcXVlc3QgPSBpbnZpdGVSZXNwb25zZS5hY2soKTtcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIElOVklURSB3aXRoIG9mZmVyIGFuZCB3ZSBoYXZlIGJlZW4gd2FpdGluZyB0aWxsIG5vdyB0byBhcHBseSB0aGUgYW5zd2VyLlxuICAgICAgICBjb25zdCBhbnN3ZXIgPSBzZXNzaW9uLmFuc3dlcjtcbiAgICAgICAgaWYgKCFhbnN3ZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbnN3ZXIgaXMgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiBzZGhPcHRpb25zLFxuICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM6IHNkaE1vZGlmaWVyc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRBbnN3ZXIoYW5zd2VyLCBvcHRpb25zKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2Vzc2lvbiBoYXMgY29tcGxldGVkIGFuIGluaXRpYWwgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlLi4uXG4gICAgICAgICAgICBsZXQgYWNrT3B0aW9uczogUmVxdWVzdE9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyYm9keSAmJiB0aGlzLl9yZW5kZXJ0eXBlKSB7XG4gICAgICAgICAgICAgIGFja09wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogeyBjb250ZW50RGlzcG9zaXRpb246IFwicmVuZGVyXCIsIGNvbnRlbnRUeXBlOiB0aGlzLl9yZW5kZXJ0eXBlLCBjb250ZW50OiB0aGlzLl9yZW5kZXJib2R5IH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFja1JlcXVlc3QgPSBpbnZpdGVSZXNwb25zZS5hY2soYWNrT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5hY2tBbmRCeWUoaW52aXRlUmVzcG9uc2UsIDQ4OCwgXCJOb3QgQWNjZXB0YWJsZSBIZXJlXCIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkNsb3NlZDpcbiAgICAgICAgLy8gRGlhbG9nIGhhcyB0ZXJtaW5hdGVkLlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiVGVybWluYXRlZC5cIikpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzZXNzaW9uIHNpZ25hbGluZyBzdGF0ZS5cIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwcm92aXNpb25hbCByZXNwb25zZSB0byBpbml0aWFsIElOVklURS5cbiAgICogQHBhcmFtIGludml0ZVJlc3BvbnNlIC0gMXh4IHJlc3BvbnNlLlxuICAgKi9cbiAgcHJpdmF0ZSBvblByb2dyZXNzKGludml0ZVJlc3BvbnNlOiBQcmFja2FibGVJbmNvbWluZ1Jlc3BvbnNlV2l0aFNlc3Npb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJJbnZpdGVyLm9uUHJvZ3Jlc3NcIik7XG5cbiAgICAvLyB2YWxpZGF0ZSBzdGF0ZVxuICAgIGlmIChcbiAgICAgIHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmdcbiAgICApIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBQcm9ncmVzcyByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSAke3RoaXMuc3RhdGV9LCBkcm9wcGluZyByZXNwb25zZWApO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgSW52YWxpZCBzZXNzaW9uIHN0YXRlICR7dGhpcy5zdGF0ZX1gKSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm91dGdvaW5nSW52aXRlUmVxdWVzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3V0Z29pbmcgSU5WSVRFIHJlcXVlc3QgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGludml0ZVJlc3BvbnNlLm1lc3NhZ2U7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGludml0ZVJlc3BvbnNlLnNlc3Npb247XG5cbiAgICAvLyBQb3J0ZWQgLSBTZXQgYXNzZXJ0ZWRJZGVudGl0eS5cbiAgICBpZiAocmVzcG9uc2UuaGFzSGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKSkge1xuICAgICAgdGhpcy5fYXNzZXJ0ZWRJZGVudGl0eSA9IEdyYW1tYXIubmFtZUFkZHJIZWFkZXJQYXJzZShyZXNwb25zZS5nZXRIZWFkZXIoXCJQLUFzc2VydGVkLUlkZW50aXR5XCIpIGFzIHN0cmluZyk7XG4gICAgfVxuXG4gICAgLy8gSWYgYSBwcm92aXNpb25hbCByZXNwb25zZSBpcyByZWNlaXZlZCBmb3IgYW4gaW5pdGlhbCByZXF1ZXN0LCBhbmRcbiAgICAvLyB0aGF0IHJlc3BvbnNlIGNvbnRhaW5zIGEgUmVxdWlyZSBoZWFkZXIgZmllbGQgY29udGFpbmluZyB0aGUgb3B0aW9uXG4gICAgLy8gdGFnIDEwMHJlbCwgdGhlIHJlc3BvbnNlIGlzIHRvIGJlIHNlbnQgcmVsaWFibHkuICBJZiB0aGUgcmVzcG9uc2UgaXNcbiAgICAvLyBhIDEwMCAoVHJ5aW5nKSAoYXMgb3Bwb3NlZCB0byAxMDEgdG8gMTk5KSwgdGhpcyBvcHRpb24gdGFnIE1VU1QgYmVcbiAgICAvLyBpZ25vcmVkLCBhbmQgdGhlIHByb2NlZHVyZXMgYmVsb3cgTVVTVCBOT1QgYmUgdXNlZC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTRcbiAgICBjb25zdCByZXF1aXJlSGVhZGVyID0gcmVzcG9uc2UuZ2V0SGVhZGVyKFwicmVxdWlyZVwiKTtcbiAgICBjb25zdCByc2VxSGVhZGVyID0gcmVzcG9uc2UuZ2V0SGVhZGVyKFwicnNlcVwiKTtcbiAgICBjb25zdCByc2VxID0gcmVxdWlyZUhlYWRlciAmJiByZXF1aXJlSGVhZGVyLmluY2x1ZGVzKFwiMTAwcmVsXCIpICYmIHJzZXFIZWFkZXIgPyBOdW1iZXIocnNlcUhlYWRlcikgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVzcG9uc2VSZWxpYWJsZSA9ICEhcnNlcTtcblxuICAgIGNvbnN0IGV4dHJhSGVhZGVyczogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgIGlmIChyZXNwb25zZVJlbGlhYmxlKSB7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJBY2s6IFwiICsgcmVzcG9uc2UuZ2V0SGVhZGVyKFwicnNlcVwiKSArIFwiIFwiICsgcmVzcG9uc2UuZ2V0SGVhZGVyKFwiY3NlcVwiKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2RoT3B0aW9ucyA9IHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zO1xuICAgIGNvbnN0IHNkaE1vZGlmaWVycyA9IHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM7XG5cbiAgICBzd2l0Y2ggKHNlc3Npb24uc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgLy8gSU5WSVRFIHdpdGhvdXQgb2ZmZXIgYW5kIHNlc3Npb24gc3RpbGwgaGFzIG5vIG9mZmVyIChhbmQgbm8gYW5zd2VyKS5cbiAgICAgICAgaWYgKHJlc3BvbnNlUmVsaWFibGUpIHtcbiAgICAgICAgICAvLyBTaW1pbGFybHksIGlmIGEgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAgICAgICAvLyByZXNwb25zZSBpcyB0aGUgZmlyc3QgcmVsaWFibGUgbWVzc2FnZSBzZW50IGJhY2sgdG8gdGhlIFVBQywgYW5kIHRoZVxuICAgICAgICAgIC8vIElOVklURSBkaWQgbm90IGNvbnRhaW4gYW4gb2ZmZXIsIG9uZSBNVVNUIGFwcGVhciBpbiB0aGF0IHJlbGlhYmxlXG4gICAgICAgICAgLy8gcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi01XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICAgIFwiRmlyc3QgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgcmVjZWl2ZWQgTVVTVCBjb250YWluIGFuIG9mZmVyIHdoZW4gSU5WSVRFIGRvZXMgbm90IGNvbnRhaW4gYW4gb2ZmZXIuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vIEZJWE1FOiBLbm93biBwb3B1bGFyIFVBJ3MgY3VycmVudGx5IGVuZCB1cCBoZXJlLi4uXG4gICAgICAgICAgaW52aXRlUmVzcG9uc2UucHJhY2soeyBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjpcbiAgICAgICAgLy8gSU5WSVRFIHdpdGggb2ZmZXIgYW5kIHNlc3Npb24gb25seSBoYXMgdGhhdCBpbml0aWFsIGxvY2FsIG9mZmVyLlxuICAgICAgICBpZiAocmVzcG9uc2VSZWxpYWJsZSkge1xuICAgICAgICAgIGludml0ZVJlc3BvbnNlLnByYWNrKHsgZXh0cmFIZWFkZXJzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyOlxuICAgICAgICBpZiAoIXJlc3BvbnNlUmVsaWFibGUpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbCBvZmZlciBNVVNUIGJlIGluIGVpdGhlciBhbiBJTlZJVEUgb3IsIGlmIG5vdCB0aGVyZSxcbiAgICAgICAgICAvLyBpbiB0aGUgZmlyc3QgcmVsaWFibGUgbm9uLWZhaWx1cmUgbWVzc2FnZSBmcm9tIHRoZSBVQVMgYmFjayB0b1xuICAgICAgICAgIC8vIHRoZSBVQUMuXG4gICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcblxuICAgICAgICAgIC8vIEFjY29yZGluZyB0byBTZWN0aW9uIDEzLjIuMSBvZiBbUkZDMzI2MV0sICdUaGUgZmlyc3QgcmVsaWFibGVcbiAgICAgICAgICAvLyBub24tZmFpbHVyZSBtZXNzYWdlJyBtdXN0IGhhdmUgYW4gb2ZmZXIgaWYgdGhlcmUgaXMgbm8gb2ZmZXIgaW4gdGhlXG4gICAgICAgICAgLy8gSU5WSVRFIHJlcXVlc3QuICBUaGlzIG1lYW5zIHRoYXQgdGhlIFVzZXIgQWdlbnQgKFVBKSB0aGF0IHJlY2VpdmVzXG4gICAgICAgICAgLy8gdGhlIElOVklURSByZXF1ZXN0IHdpdGhvdXQgYW4gb2ZmZXIgbXVzdCBpbmNsdWRlIGFuIG9mZmVyIGluIHRoZVxuICAgICAgICAgIC8vIGZpcnN0IHJlbGlhYmxlIHJlc3BvbnNlIHdpdGggMTAwcmVsIGV4dGVuc2lvbi4gIElmIG5vIHJlbGlhYmxlXG4gICAgICAgICAgLy8gcHJvdmlzaW9uYWwgcmVzcG9uc2UgaGFzIGJlZW4gc2VudCwgdGhlIFVzZXIgQWdlbnQgU2VydmVyIChVQVMpIG11c3RcbiAgICAgICAgICAvLyBpbmNsdWRlIGFuIG9mZmVyIHdoZW4gc2VuZGluZyAyeHggcmVzcG9uc2UuXG4gICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYzMzcjc2VjdGlvbi0yLjJcblxuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJOb24tcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgTVVTVCBOT1QgY29udGFpbiBhbiBpbml0aWFsIG9mZmVyLCBkaXNjYXJkaW5nIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gdGhlIGZpcnN0IHJlbGlhYmxlIG5vbi1mYWlsdXJlXG4gICAgICAgIC8vIG1lc3NhZ2UgZnJvbSB0aGUgVUFTIGJhY2sgdG8gVUFDLCB0aGUgYW5zd2VyIE1VU1QgYmUgaW4gdGhlXG4gICAgICAgIC8vIGFja25vd2xlZGdlbWVudCBmb3IgdGhhdCBtZXNzYWdlXG4gICAgICAgIGNvbnN0IHNkaCA9IHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICB0aGlzLnVzZXJBZ2VudC5jb25maWd1cmF0aW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5T3B0aW9ucyB8fCB7fVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVhcmx5TWVkaWFTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVycy5zZXQoc2Vzc2lvbi5pZCwgc2RoKTtcbiAgICAgICAgcmV0dXJuIHNkaFxuICAgICAgICAgIC5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5LCBzZGhPcHRpb25zLCBzZGhNb2RpZmllcnMpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gc2RoLmdldERlc2NyaXB0aW9uKHNkaE9wdGlvbnMsIHNkaE1vZGlmaWVycykpXG4gICAgICAgICAgLnRoZW4oKGRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBib2R5OiBCb2R5ID0ge1xuICAgICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IFwic2Vzc2lvblwiLCBjb250ZW50VHlwZTogZGVzY3JpcHRpb24uY29udGVudFR5cGUsIGNvbnRlbnQ6IGRlc2NyaXB0aW9uLmJvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbnZpdGVSZXNwb25zZS5wcmFjayh7IGV4dHJhSGVhZGVycywgYm9keSB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH0pO1xuICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5TdGFibGU6XG4gICAgICAgIC8vIFRoaXMgc2Vzc2lvbiBoYXMgY29tcGxldGVkIGFuIGluaXRpYWwgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlLCBzby4uLlxuICAgICAgICAvLyAtIElOVklURSB3aXRoIFNEUCBhbmQgdGhpcyBwcm92aXNpb25hbCByZXNwb25zZSBNQVkgYmUgcmVsaWFibGVcbiAgICAgICAgLy8gLSBJTlZJVEUgd2l0aG91dCBTRFAgYW5kIHRoaXMgcHJvdmlzaW9uYWwgcmVzcG9uc2UgTUFZIGJlIHJlbGlhYmxlXG4gICAgICAgIGlmIChyZXNwb25zZVJlbGlhYmxlKSB7XG4gICAgICAgICAgaW52aXRlUmVzcG9uc2UucHJhY2soeyBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWFybHlNZWRpYSAmJiAhdGhpcy5lYXJseU1lZGlhRGlhbG9nKSB7XG4gICAgICAgICAgdGhpcy5lYXJseU1lZGlhRGlhbG9nID0gc2Vzc2lvbjtcbiAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBzZXNzaW9uLmFuc3dlcjtcbiAgICAgICAgICBpZiAoIWFuc3dlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW5zd2VyIGlzIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9uczogc2RoT3B0aW9ucyxcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM6IHNkaE1vZGlmaWVyc1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0QW5zd2VyKGFuc3dlciwgb3B0aW9ucylcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkNsb3NlZDpcbiAgICAgICAgLy8gRGlhbG9nIGhhcyB0ZXJtaW5hdGVkLlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiVGVybWluYXRlZC5cIikpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzZXNzaW9uIHNpZ25hbGluZyBzdGF0ZS5cIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBmaW5hbCByZXNwb25zZSB0byBpbml0aWFsIElOVklURS5cbiAgICogQHBhcmFtIGludml0ZVJlc3BvbnNlIC0gM3h4IHJlc3BvbnNlLlxuICAgKi9cbiAgcHJpdmF0ZSBvblJlZGlyZWN0KGludml0ZVJlc3BvbnNlOiBJbmNvbWluZ1Jlc3BvbnNlKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiSW52aXRlci5vblJlZGlyZWN0XCIpO1xuXG4gICAgLy8gdmFsaWRhdGUgc3RhdGVcbiAgICBpZiAoXG4gICAgICB0aGlzLnN0YXRlICE9PSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoaW5nICYmXG4gICAgICB0aGlzLnN0YXRlICE9PSBTZXNzaW9uU3RhdGUuVGVybWluYXRpbmdcbiAgICApIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBSZWRpcmVjdCByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSAke3RoaXMuc3RhdGV9LCBkcm9wcGluZyByZXNwb25zZWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHRyYW5zaXRpb24gc3RhdGVcbiAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGZpbmFsIHJlc3BvbnNlIHRvIGluaXRpYWwgSU5WSVRFLlxuICAgKiBAcGFyYW0gaW52aXRlUmVzcG9uc2UgLSA0eHgsIDV4eCwgb3IgNnh4IHJlc3BvbnNlLlxuICAgKi9cbiAgcHJpdmF0ZSBvblJlamVjdChpbnZpdGVSZXNwb25zZTogSW5jb21pbmdSZXNwb25zZSk6IHZvaWQge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIkludml0ZXIub25SZWplY3RcIik7XG5cbiAgICAvLyB2YWxpZGF0ZSBzdGF0ZVxuICAgIGlmIChcbiAgICAgIHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmcgJiZcbiAgICAgIHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZ1xuICAgICkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYFJlamVjdCByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSAke3RoaXMuc3RhdGV9LCBkcm9wcGluZyByZXNwb25zZWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHRyYW5zaXRpb24gc3RhdGVcbiAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGZpbmFsIHJlc3BvbnNlIHRvIGluaXRpYWwgSU5WSVRFLlxuICAgKiBAcGFyYW0gaW52aXRlUmVzcG9uc2UgLSAxMDAgcmVzcG9uc2UuXG4gICAqL1xuICBwcml2YXRlIG9uVHJ5aW5nKGludml0ZVJlc3BvbnNlOiBJbmNvbWluZ1Jlc3BvbnNlKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiSW52aXRlci5vblRyeWluZ1wiKTtcblxuICAgIC8vIHZhbGlkYXRlIHN0YXRlXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBUcnlpbmcgcmVjZWl2ZWQgd2hpbGUgaW4gc3RhdGUgJHt0aGlzLnN0YXRlfSwgZHJvcHBpbmcgcmVzcG9uc2VgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEluY29taW5nTWVzc2FnZVJlcXVlc3QsXG4gIEluY29taW5nUmVxdWVzdE1lc3NhZ2UsXG4gIFJlc3BvbnNlT3B0aW9uc1xufSBmcm9tIFwiLi4vY29yZVwiO1xuXG4vKipcbiAqIEEgcmVjZWl2ZWQgbWVzc2FnZSAoaW5jb21pbmcgTUVTU0FHRSkuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlIHtcblxuICAvKiogQGludGVybmFsICovXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIGluY29taW5nTWVzc2FnZVJlcXVlc3Q6IEluY29taW5nTWVzc2FnZVJlcXVlc3QpIHtcbiAgfVxuXG4gIC8qKiBJbmNvbWluZyBNRVNTQUdFIHJlcXVlc3QgbWVzc2FnZS4gKi9cbiAgcHVibGljIGdldCByZXF1ZXN0KCk6IEluY29taW5nUmVxdWVzdE1lc3NhZ2Uge1xuICAgIHJldHVybiB0aGlzLmluY29taW5nTWVzc2FnZVJlcXVlc3QubWVzc2FnZTtcbiAgfVxuXG4gIC8qKiBBY2NlcHQgdGhlIHJlcXVlc3QuICovXG4gIHB1YmxpYyBhY2NlcHQob3B0aW9ucz86IFJlc3BvbnNlT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuaW5jb21pbmdNZXNzYWdlUmVxdWVzdC5hY2NlcHQob3B0aW9ucyk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqIFJlamVjdCB0aGUgcmVxdWVzdC4gKi9cbiAgcHVibGljIHJlamVjdChvcHRpb25zPzogUmVzcG9uc2VPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pbmNvbWluZ01lc3NhZ2VSZXF1ZXN0LnJlamVjdChvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEJvZHksXG4gIEMsXG4gIEdyYW1tYXIsXG4gIExvZ2dlcixcbiAgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgVVJJXG59IGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBNZXNzYWdlck1lc3NhZ2VPcHRpb25zIH0gZnJvbSBcIi4vbWVzc2FnZXItbWVzc2FnZS1vcHRpb25zXCI7XG5pbXBvcnQgeyBNZXNzYWdlck9wdGlvbnMgfSBmcm9tIFwiLi9tZXNzYWdlci1vcHRpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnQgfSBmcm9tIFwiLi91c2VyLWFnZW50XCI7XG5cbi8qKlxuICogQSBtZXNzYWdlciBzZW5kcyBhIHtAbGluayBNZXNzYWdlfSAob3V0Z29pbmcgTUVTU0FHRSkuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlciB7XG4gIHByaXZhdGUgbG9nZ2VyOiBMb2dnZXI7XG4gIHByaXZhdGUgcmVxdWVzdDogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZTtcbiAgcHJpdmF0ZSB1c2VyQWdlbnQ6IFVzZXJBZ2VudDtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYE1lc3NhZ2VyYCBjbGFzcy5cbiAgICogQHBhcmFtIHVzZXJBZ2VudCAtIFVzZXIgYWdlbnQuIFNlZSB7QGxpbmsgVXNlckFnZW50fSBmb3IgZGV0YWlscy5cbiAgICogQHBhcmFtIHRhcmdldFVSSSAtIFJlcXVlc3QgVVJJIGlkZW50aWZ5aW5nIHRoZSB0YXJnZXQgb2YgdGhlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSBjb250ZW50IC0gQ29udGVudCBmb3IgdGhlIGJvZHkgb2YgdGhlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSBjb250ZW50VHlwZSAtIENvbnRlbnQgdHlwZSBvZiB0aGUgYm9keSBvZiB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC4gU2VlIHtAbGluayBNZXNzYWdlck9wdGlvbnN9IGZvciBkZXRhaWxzLlxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHVzZXJBZ2VudDogVXNlckFnZW50LFxuICAgIHRhcmdldFVSSTogVVJJLFxuICAgIGNvbnRlbnQ6IHN0cmluZyxcbiAgICBjb250ZW50VHlwZTogc3RyaW5nID0gXCJ0ZXh0L3BsYWluXCIsXG4gICAgb3B0aW9uczogTWVzc2FnZXJPcHRpb25zID0ge31cbiAgKSB7XG5cbiAgICAvLyBMb2dnZXJcbiAgICB0aGlzLmxvZ2dlciA9IHVzZXJBZ2VudC5nZXRMb2dnZXIoXCJzaXAuTWVzc2FnZXJcIik7XG5cbiAgICAvLyBEZWZhdWx0IG9wdGlvbnMgcGFyYW1zXG4gICAgb3B0aW9ucy5wYXJhbXMgPSBvcHRpb25zLnBhcmFtcyB8fCB7fTtcblxuICAgIC8vIFVSSXNcbiAgICBsZXQgZnJvbVVSSTogVVJJIHwgdW5kZWZpbmVkID0gdXNlckFnZW50LnVzZXJBZ2VudENvcmUuY29uZmlndXJhdGlvbi5hb3I7XG4gICAgaWYgKG9wdGlvbnMucGFyYW1zLmZyb21VcmkpIHtcbiAgICAgIGZyb21VUkkgPVxuICAgICAgICAodHlwZW9mIG9wdGlvbnMucGFyYW1zLmZyb21VcmkgPT09IFwic3RyaW5nXCIpID9cbiAgICAgICAgICBHcmFtbWFyLlVSSVBhcnNlKG9wdGlvbnMucGFyYW1zLmZyb21VcmkpIDpcbiAgICAgICAgICBvcHRpb25zLnBhcmFtcy5mcm9tVXJpO1xuICAgIH1cbiAgICBpZiAoIWZyb21VUkkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGZyb20gVVJJOiBcIiArIG9wdGlvbnMucGFyYW1zLmZyb21VcmkpO1xuICAgIH1cbiAgICBsZXQgdG9VUkk6IFVSSSB8IHVuZGVmaW5lZCA9IHRhcmdldFVSSTtcbiAgICBpZiAob3B0aW9ucy5wYXJhbXMudG9VcmkpIHtcbiAgICAgIHRvVVJJID1cbiAgICAgICAgKHR5cGVvZiBvcHRpb25zLnBhcmFtcy50b1VyaSA9PT0gXCJzdHJpbmdcIikgP1xuICAgICAgICAgIEdyYW1tYXIuVVJJUGFyc2Uob3B0aW9ucy5wYXJhbXMudG9VcmkpIDpcbiAgICAgICAgICBvcHRpb25zLnBhcmFtcy50b1VyaTtcbiAgICB9XG4gICAgaWYgKCF0b1VSSSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdG8gVVJJOiBcIiArIG9wdGlvbnMucGFyYW1zLnRvVXJpKTtcbiAgICB9XG5cbiAgICAvLyBNZXNzYWdlIHBhcmFtc1xuICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMucGFyYW1zID8geyAuLi5vcHRpb25zLnBhcmFtcyB9IDoge307XG5cbiAgICAvLyBFeHRyYSBoZWFkZXJzXG4gICAgY29uc3QgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuXG4gICAgLy8gQm9keVxuICAgIGNvbnN0IGNvbnRlbnREaXNwb3NpdGlvbiA9IFwicmVuZGVyXCI7XG4gICAgY29uc3QgYm9keTogQm9keSA9IHtcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgY29udGVudFxuICAgIH07XG5cbiAgICAvLyBCdWlsZCB0aGUgcmVxdWVzdFxuICAgIHRoaXMucmVxdWVzdCA9IHVzZXJBZ2VudC51c2VyQWdlbnRDb3JlLm1ha2VPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKFxuICAgICAgQy5NRVNTQUdFLFxuICAgICAgdGFyZ2V0VVJJLFxuICAgICAgZnJvbVVSSSxcbiAgICAgIHRvVVJJLFxuICAgICAgcGFyYW1zLFxuICAgICAgZXh0cmFIZWFkZXJzLFxuICAgICAgYm9keVxuICAgICk7XG5cbiAgICAvLyBVc2VyIGFnZW50XG4gICAgdGhpcy51c2VyQWdlbnQgPSB1c2VyQWdlbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0aGUgbWVzc2FnZS5cbiAgICovXG4gIHB1YmxpYyBtZXNzYWdlKG9wdGlvbnM6IE1lc3NhZ2VyTWVzc2FnZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMudXNlckFnZW50LnVzZXJBZ2VudENvcmUucmVxdWVzdCh0aGlzLnJlcXVlc3QsIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEluY29taW5nTm90aWZ5UmVxdWVzdCxcbiAgSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgUmVzcG9uc2VPcHRpb25zXG59IGZyb20gXCIuLi9jb3JlXCI7XG5cbi8qKlxuICogQSBub3RpZmljYXRpb24gb2YgYW4gZXZlbnQgKGluY29taW5nIE5PVElGWSkuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb24ge1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5jb21pbmdOb3RpZnlSZXF1ZXN0OiBJbmNvbWluZ05vdGlmeVJlcXVlc3QpIHtcbiAgfVxuXG4gIC8qKiBJbmNvbWluZyBOT1RJRlkgcmVxdWVzdCBtZXNzYWdlLiAqL1xuICBwdWJsaWMgZ2V0IHJlcXVlc3QoKTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSB7XG4gICAgcmV0dXJuIHRoaXMuaW5jb21pbmdOb3RpZnlSZXF1ZXN0Lm1lc3NhZ2U7XG4gIH1cblxuICAvKiogQWNjZXB0IHRoZSByZXF1ZXN0LiAqL1xuICBwdWJsaWMgYWNjZXB0KG9wdGlvbnM/OiBSZXNwb25zZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmluY29taW5nTm90aWZ5UmVxdWVzdC5hY2NlcHQob3B0aW9ucyk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqIFJlamVjdCB0aGUgcmVxdWVzdC4gKi9cbiAgcHVibGljIHJlamVjdChvcHRpb25zPzogUmVzcG9uc2VPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pbmNvbWluZ05vdGlmeVJlcXVlc3QucmVqZWN0KG9wdGlvbnMpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiB7QGxpbmsgUHVibGlzaGVyfSBzdGF0ZS5cbiAqIEByZW1hcmtzXG4gKiBUaGUge0BsaW5rIFB1Ymxpc2hlcn0gYmVoYXZlcyBpbiBhIGRldGVybWluaXN0aWMgbWFubmVyIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nXG4gKiBGaW5pdGUgU3RhdGUgTWFjaGluZSAoRlNNKS5cbiAqIGBgYHR4dFxuICogICAgICAgICAgICAgICAgICBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cbiAqICAgICAgICAgICAgICAgICB8ICBfX19fX19fX19fX19fX19fX19fX19fX19fXyAgICAgICAgICAgICAgfFxuICogUHVibGlzaGVyICAgICAgIHwgfCAgICAgICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgICAgICB2XG4gKiBDb25zdHJ1Y3RlZCAtPiBJbml0aWFsIC0+IFB1Ymxpc2hlZCAtPiBVbnB1Ymxpc2hlZCAtPiBUZXJtaW5hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBeX19fX19fX19fX19ffCAgICAgICAgICAgICBeXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGVudW0gUHVibGlzaGVyU3RhdGUge1xuICBJbml0aWFsID0gXCJJbml0aWFsXCIsXG4gIFB1Ymxpc2hlZCA9ICBcIlB1Ymxpc2hlZFwiLFxuICBVbnB1Ymxpc2hlZCA9IFwiVW5wdWJsaXNoZWRcIixcbiAgVGVybWluYXRlZCA9IFwiVGVybWluYXRlZFwiXG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRzXCI7XG5cbmltcG9ydCB7XG4gIEJvZHksXG4gIEMsXG4gIGZyb21Cb2R5TGVnYWN5LFxuICBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSxcbiAgTG9nZ2VyLFxuICBPdXRnb2luZ1B1Ymxpc2hSZXF1ZXN0LFxuICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICBVUklcbn0gZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCB7IGdldFJlYXNvblBocmFzZSB9IGZyb20gXCIuLi9jb3JlL21lc3NhZ2VzL3V0aWxzXCI7XG5pbXBvcnQgeyBfbWFrZUVtaXR0ZXIsIEVtaXR0ZXIgfSBmcm9tIFwiLi9lbWl0dGVyXCI7XG5pbXBvcnQgeyBQdWJsaXNoZXJPcHRpb25zIH0gZnJvbSBcIi4vcHVibGlzaGVyLW9wdGlvbnNcIjtcbmltcG9ydCB7IFB1Ymxpc2hlclB1Ymxpc2hPcHRpb25zIH0gZnJvbSBcIi4vcHVibGlzaGVyLXB1Ymxpc2gtb3B0aW9uc1wiO1xuaW1wb3J0IHsgUHVibGlzaGVyU3RhdGUgfSBmcm9tIFwiLi9wdWJsaXNoZXItc3RhdGVcIjtcbmltcG9ydCB7IFB1Ymxpc2hlclVucHVibGlzaE9wdGlvbnMgfSBmcm9tIFwiLi9wdWJsaXNoZXItdW5wdWJsaXNoLW9wdGlvbnNcIjtcbmltcG9ydCB7IEJvZHlBbmRDb250ZW50VHlwZSB9IGZyb20gXCIuL3Nlc3Npb24tZGVzY3JpcHRpb24taGFuZGxlclwiO1xuaW1wb3J0IHsgVXNlckFnZW50IH0gZnJvbSBcIi4vdXNlci1hZ2VudFwiO1xuXG4vKipcbiAqIEEgcHVibGlzaGVyIHB1Ymxpc2hlcyBhIHB1YmxpY2F0aW9uIChvdXRnb2luZyBQVUJMSVNIKS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFB1Ymxpc2hlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgZXZlbnQ6IHN0cmluZztcbiAgcHJpdmF0ZSBvcHRpb25zOiBhbnk7XG4gIHByaXZhdGUgdGFyZ2V0OiBVUkk7XG4gIHByaXZhdGUgcHViUmVxdWVzdEJvZHk6IGFueTtcbiAgcHJpdmF0ZSBwdWJSZXF1ZXN0RXhwaXJlczogbnVtYmVyO1xuICBwcml2YXRlIHB1YlJlcXVlc3RFdGFnOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgcHVibGlzaFJlZnJlc2hUaW1lcjogYW55IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgZGlzcG9zZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBpZDogc3RyaW5nO1xuICBwcml2YXRlIGxvZ2dlcjogTG9nZ2VyO1xuICBwcml2YXRlIHJlcXVlc3Q6IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2U7XG4gIHByaXZhdGUgdXNlckFnZW50OiBVc2VyQWdlbnQ7XG5cbiAgLyoqIFRoZSBwdWJsaWNhdGlvbiBzdGF0ZS4gKi9cbiAgcHJpdmF0ZSBfc3RhdGU6IFB1Ymxpc2hlclN0YXRlID0gUHVibGlzaGVyU3RhdGUuSW5pdGlhbDtcbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHJlZ2lzdHJhdGlvbiBzdGF0ZSBjaGFuZ2VzLiAqL1xuICBwcml2YXRlIF9zdGF0ZUV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFB1Ymxpc2hlcmAgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyQWdlbnQgLSBVc2VyIGFnZW50LiBTZWUge0BsaW5rIFVzZXJBZ2VudH0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB0YXJnZXRVUkkgLSBSZXF1ZXN0IFVSSSBpZGVudGlmeWluZyB0aGUgdGFyZ2V0IG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gVGhlIGV2ZW50IHR5cGUgaWRlbnRpZnlpbmcgdGhlIHB1Ymxpc2hlZCBkb2N1bWVudC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC4gU2VlIHtAbGluayBQdWJsaXNoZXJPcHRpb25zfSBmb3IgZGV0YWlscy5cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcih1c2VyQWdlbnQ6IFVzZXJBZ2VudCwgdGFyZ2V0VVJJOiBVUkksIGV2ZW50VHlwZTogc3RyaW5nLCBvcHRpb25zOiBQdWJsaXNoZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudXNlckFnZW50ID0gdXNlckFnZW50O1xuXG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgb3B0aW9ucy5jb250ZW50VHlwZSA9IChvcHRpb25zLmNvbnRlbnRUeXBlIHx8IFwidGV4dC9wbGFpblwiKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5leHBpcmVzICE9PSBcIm51bWJlclwiIHx8IChvcHRpb25zLmV4cGlyZXMgJSAxKSAhPT0gMCkge1xuICAgICAgb3B0aW9ucy5leHBpcmVzID0gMzYwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5leHBpcmVzID0gTnVtYmVyKG9wdGlvbnMuZXhwaXJlcyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZihvcHRpb25zLnVucHVibGlzaE9uQ2xvc2UpICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgb3B0aW9ucy51bnB1Ymxpc2hPbkNsb3NlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldFVSSTtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnRUeXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IHRoaXMub3B0aW9ucy5leHBpcmVzO1xuXG4gICAgdGhpcy5sb2dnZXIgPSB1c2VyQWdlbnQuZ2V0TG9nZ2VyKFwic2lwLlB1Ymxpc2hlclwiKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMucGFyYW1zIHx8IHt9O1xuICAgIGNvbnN0IGZyb21VUkkgPSBwYXJhbXMuZnJvbVVyaSA/IHBhcmFtcy5mcm9tVXJpIDogdXNlckFnZW50LnVzZXJBZ2VudENvcmUuY29uZmlndXJhdGlvbi5hb3I7XG4gICAgY29uc3QgdG9VUkkgPSBwYXJhbXMudG9VcmkgPyBwYXJhbXMudG9VcmkgOiB0YXJnZXRVUkk7XG4gICAgbGV0IGJvZHk6IEJvZHkgfCB1bmRlZmluZWQ7XG4gICAgaWYgKG9wdGlvbnMuYm9keSAmJiBvcHRpb25zLmNvbnRlbnRUeXBlKSB7XG4gICAgICBjb25zdCBjb250ZW50RGlzcG9zaXRpb24gPSBcInJlbmRlclwiO1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSBvcHRpb25zLmNvbnRlbnRUeXBlIGFzIHN0cmluZztcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBvcHRpb25zLmJvZHkgYXMgc3RyaW5nO1xuICAgICAgYm9keSA9IHtcbiAgICAgICAgY29udGVudERpc3Bvc2l0aW9uLFxuICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgY29udGVudCxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICAgIC8vIEJ1aWxkIHRoZSByZXF1ZXN0XG4gICAgdGhpcy5yZXF1ZXN0ID0gdXNlckFnZW50LnVzZXJBZ2VudENvcmUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoXG4gICAgICBDLlBVQkxJU0gsXG4gICAgICB0YXJnZXRVUkksXG4gICAgICBmcm9tVVJJLFxuICAgICAgdG9VUkksXG4gICAgICBwYXJhbXMsXG4gICAgICBleHRyYUhlYWRlcnMsXG4gICAgICBib2R5XG4gICAgKTtcblxuICAgIC8vIElkZW50aWZpZXJcbiAgICB0aGlzLmlkID0gdGhpcy50YXJnZXQudG9TdHJpbmcoKSArIFwiOlwiICsgdGhpcy5ldmVudDtcblxuICAgIC8vIEFkZCB0byB0aGUgdXNlciBhZ2VudCdzIHB1Ymxpc2hlciBjb2xsZWN0aW9uLlxuICAgIHRoaXMudXNlckFnZW50Ll9wdWJsaXNoZXJzW3RoaXMuaWRdID0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cnVjdG9yLlxuICAgKi9cbiAgcHVibGljIGRpc3Bvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBQdWJsaXNoZXIgJHt0aGlzLmlkfSBpbiBzdGF0ZSAke3RoaXMuc3RhdGV9IGlzIGJlaW5nIGRpc3Bvc2VkYCk7XG5cbiAgICAvLyBSZW1vdmUgZnJvbSB0aGUgdXNlciBhZ2VudCdzIHB1Ymxpc2hlciBjb2xsZWN0aW9uXG4gICAgZGVsZXRlIHRoaXMudXNlckFnZW50Ll9wdWJsaXNoZXJzW3RoaXMuaWRdO1xuXG4gICAgLy8gU2VuZCB1bnB1Ymxpc2gsIGlmIHJlcXVlc3RlZFxuICAgIGlmICh0aGlzLm9wdGlvbnMudW5wdWJsaXNoT25DbG9zZSAmJiB0aGlzLnN0YXRlID09PSBQdWJsaXNoZXJTdGF0ZS5QdWJsaXNoZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnVucHVibGlzaCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpO1xuICAgICAgdGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMucHViUmVxdWVzdEJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IDA7XG4gICAgdGhpcy5wdWJSZXF1ZXN0RXRhZyA9IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKiBUaGUgcHVibGljYXRpb24gc3RhdGUuICovXG4gIHB1YmxpYyBnZXQgc3RhdGUoKTogUHVibGlzaGVyU3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBwdWJsaXNoZXIgc3RhdGUgY2hhbmdlcy4gKi9cbiAgcHVibGljIGdldCBzdGF0ZUNoYW5nZSgpOiBFbWl0dGVyPFB1Ymxpc2hlclN0YXRlPiB7XG4gICAgcmV0dXJuIF9tYWtlRW1pdHRlcih0aGlzLl9zdGF0ZUV2ZW50RW1pdHRlcik7XG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaC5cbiAgICogQHBhcmFtIGNvbnRlbnQgLSBCb2R5IHRvIHB1Ymxpc2hcbiAgICovXG4gIHB1YmxpYyBwdWJsaXNoKGNvbnRlbnQ6IHN0cmluZywgb3B0aW9uczogUHVibGlzaGVyUHVibGlzaE9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIENsZWFuIHVwIGJlZm9yZSB0aGUgcnVuXG4gICAgaWYgKHRoaXMucHVibGlzaFJlZnJlc2hUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucHVibGlzaFJlZnJlc2hUaW1lcik7XG4gICAgICB0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gaXMgSW5pdGlhbCBvciBNb2RpZnkgcmVxdWVzdFxuICAgIHRoaXMub3B0aW9ucy5ib2R5ID0gY29udGVudDtcbiAgICB0aGlzLnB1YlJlcXVlc3RCb2R5ID0gdGhpcy5vcHRpb25zLmJvZHk7XG5cbiAgICBpZiAodGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9PT0gMCkge1xuICAgICAgLy8gVGhpcyBpcyBJbml0aWFsIHJlcXVlc3QgYWZ0ZXIgdW5wdWJsaXNoXG4gICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gdGhpcy5vcHRpb25zLmV4cGlyZXM7XG4gICAgICB0aGlzLnB1YlJlcXVlc3RFdGFnID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuc2VuZFB1Ymxpc2hSZXF1ZXN0KCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvKipcbiAgICogVW5wdWJsaXNoLlxuICAgKi9cbiAgcHVibGljIHVucHVibGlzaChvcHRpb25zOiBQdWJsaXNoZXJVbnB1Ymxpc2hPcHRpb25zID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBDbGVhbiB1cCBiZWZvcmUgdGhlIHJ1blxuICAgIGlmICh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpO1xuICAgICAgdGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMucHViUmVxdWVzdEJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IDA7XG5cbiAgICBpZiAodGhpcy5wdWJSZXF1ZXN0RXRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNlbmRQdWJsaXNoUmVxdWVzdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJvdGVjdGVkIHJlY2VpdmVSZXNwb25zZShyZXNwb25zZTogSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpOiB2b2lkIHtcbiAgICBjb25zdCBzdGF0dXNDb2RlOiBudW1iZXIgPSByZXNwb25zZS5zdGF0dXNDb2RlIHx8IDA7XG4gICAgY29uc3QgY2F1c2U6IHN0cmluZyA9IGdldFJlYXNvblBocmFzZShzdGF0dXNDb2RlKTtcblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZS50b1N0cmluZygpKTpcbiAgICAgICAgdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlLnRvU3RyaW5nKCkpOlxuICAgICAgICAvLyBTZXQgU0lQLUV0YWdcbiAgICAgICAgaWYgKHJlc3BvbnNlLmhhc0hlYWRlcihcIlNJUC1FVGFnXCIpKSB7XG4gICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXRhZyA9IHJlc3BvbnNlLmdldEhlYWRlcihcIlNJUC1FVGFnXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJTSVAtRVRhZyBoZWFkZXIgbWlzc2luZyBpbiBhIDIwMC1jbGFzcyByZXNwb25zZSB0byBQVUJMSVNIXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIEV4cGlyZVxuICAgICAgICBpZiAocmVzcG9uc2UuaGFzSGVhZGVyKFwiRXhwaXJlc1wiKSkge1xuICAgICAgICAgIGNvbnN0IGV4cGlyZXM6IG51bWJlciA9IE51bWJlcihyZXNwb25zZS5nZXRIZWFkZXIoXCJFeHBpcmVzXCIpKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGV4cGlyZXMgPT09IFwibnVtYmVyXCIgJiYgZXhwaXJlcyA+PSAwICYmIGV4cGlyZXMgPD0gdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcykge1xuICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IGV4cGlyZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJCYWQgRXhwaXJlcyBoZWFkZXIgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gUFVCTElTSFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkV4cGlyZXMgaGVhZGVyIG1pc3NpbmcgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gUFVCTElTSFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnB1YlJlcXVlc3RFeHBpcmVzICE9PSAwKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgcmVmcmVzaFxuICAgICAgICAgIHRoaXMucHVibGlzaFJlZnJlc2hUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWZyZXNoUmVxdWVzdCgpLCB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzICogOTAwKTtcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihQdWJsaXNoZXJTdGF0ZS5QdWJsaXNoZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFB1Ymxpc2hlclN0YXRlLlVucHVibGlzaGVkKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgL140MTIkLy50ZXN0KHN0YXR1c0NvZGUudG9TdHJpbmcoKSk6XG4gICAgICAgIC8vIDQxMiBjb2RlIG1lYW5zIG5vIG1hdGNoaW5nIEVUYWcgLSBwb3NzaWJseSB0aGUgUFVCTElTSCBleHBpcmVkXG4gICAgICAgIC8vIFJlc3VibWl0IGFzIG5ldyByZXF1ZXN0LCBpZiB0aGUgY3VycmVudCByZXF1ZXN0IGlzIG5vdCBhIFwicmVtb3ZlXCJcblxuICAgICAgICBpZiAodGhpcy5wdWJSZXF1ZXN0RXRhZyAhPT0gdW5kZWZpbmVkICYmIHRoaXMucHViUmVxdWVzdEV4cGlyZXMgIT09IDApIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiNDEyIHJlc3BvbnNlIHRvIFBVQkxJU0gsIHJlY292ZXJpbmdcIik7XG4gICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXRhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLm9wdGlvbnMuYm9keSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIjQxMiByZXNwb25zZSB0byBQVUJMSVNILCByZWNvdmVyeSBmYWlsZWRcIik7XG4gICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IDA7XG4gICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oUHVibGlzaGVyU3RhdGUuVW5wdWJsaXNoZWQpO1xuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFB1Ymxpc2hlclN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAvXjQyMyQvLnRlc3Qoc3RhdHVzQ29kZS50b1N0cmluZygpKTpcbiAgICAgICAgLy8gNDIzIGNvZGUgbWVhbnMgd2UgbmVlZCB0byBhZGp1c3QgdGhlIEV4cGlyZXMgaW50ZXJ2YWwgdXBcbiAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEV4cGlyZXMgIT09IDAgJiYgcmVzcG9uc2UuaGFzSGVhZGVyKFwiTWluLUV4cGlyZXNcIikpIHtcbiAgICAgICAgICBjb25zdCBtaW5FeHBpcmVzOiBudW1iZXIgPSBOdW1iZXIocmVzcG9uc2UuZ2V0SGVhZGVyKFwiTWluLUV4cGlyZXNcIikpO1xuICAgICAgICAgIGlmICh0eXBlb2YgbWluRXhwaXJlcyA9PT0gXCJudW1iZXJcIiB8fCBtaW5FeHBpcmVzID4gdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIjQyMyBjb2RlIGluIHJlc3BvbnNlIHRvIFBVQkxJU0gsIGFkanVzdGluZyB0aGUgRXhwaXJlcyB2YWx1ZSBhbmQgdHJ5aW5nIHRvIHJlY292ZXJcIik7XG4gICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gbWluRXhwaXJlcztcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInByb2dyZXNzXCIsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5vcHRpb25zLmJvZHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQmFkIDQyMyByZXNwb25zZSBNaW4tRXhwaXJlcyBoZWFkZXIgcmVjZWl2ZWQgZm9yIFBVQkxJU0hcIik7XG4gICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFB1Ymxpc2hlclN0YXRlLlVucHVibGlzaGVkKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFB1Ymxpc2hlclN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiNDIzIHJlc3BvbnNlIHRvIFBVQkxJU0gsIHJlY292ZXJ5IGZhaWxlZFwiKTtcbiAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gMDtcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihQdWJsaXNoZXJTdGF0ZS5VbnB1Ymxpc2hlZCk7XG4gICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oUHVibGlzaGVyU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gMDtcbiAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oUHVibGlzaGVyU3RhdGUuVW5wdWJsaXNoZWQpO1xuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihQdWJsaXNoZXJTdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRG8gdGhlIGNsZWFudXBcbiAgICBpZiAodGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMucHVibGlzaFJlZnJlc2hUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyKTtcbiAgICAgICAgdGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnB1YlJlcXVlc3RCb2R5ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5wdWJSZXF1ZXN0RXRhZyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCBzZW5kKCk6IE91dGdvaW5nUHVibGlzaFJlcXVlc3Qge1xuICAgIHJldHVybiB0aGlzLnVzZXJBZ2VudC51c2VyQWdlbnRDb3JlLnB1Ymxpc2godGhpcy5yZXF1ZXN0LCB7XG4gICAgICBvbkFjY2VwdDogKHJlc3BvbnNlKTogdm9pZCA9PiB0aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IChyZXNwb25zZSk6IHZvaWQgPT4gdGhpcy5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UubWVzc2FnZSksXG4gICAgICBvblJlZGlyZWN0OiAocmVzcG9uc2UpOiB2b2lkID0+IHRoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpLFxuICAgICAgb25SZWplY3Q6IChyZXNwb25zZSk6IHZvaWQgPT4gdGhpcy5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UubWVzc2FnZSksXG4gICAgICBvblRyeWluZzogKHJlc3BvbnNlKTogdm9pZCA9PiB0aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSByZWZyZXNoUmVxdWVzdCgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBiZWZvcmUgdGhlIHJ1blxuICAgIGlmICh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpO1xuICAgICAgdGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgUmVmcmVzaCByZXF1ZXN0XG4gICAgdGhpcy5wdWJSZXF1ZXN0Qm9keSA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLnB1YlJlcXVlc3RFdGFnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0YWcgdW5kZWZpbmVkXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBpcmVzIHplcm9cIik7XG4gICAgfVxuXG4gICAgdGhpcy5zZW5kUHVibGlzaFJlcXVlc3QoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2VuZFB1Ymxpc2hSZXF1ZXN0KCk6IE91dGdvaW5nUHVibGlzaFJlcXVlc3Qge1xuICAgIGNvbnN0IHJlcU9wdGlvbnM6IGFueSA9IE9iamVjdC5jcmVhdGUodGhpcy5vcHRpb25zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHJlcU9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKHRoaXMub3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgICByZXFPcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiRXZlbnQ6IFwiICsgdGhpcy5ldmVudCk7XG4gICAgcmVxT3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkV4cGlyZXM6IFwiICsgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyk7XG5cbiAgICBpZiAodGhpcy5wdWJSZXF1ZXN0RXRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXFPcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiU0lQLUlmLU1hdGNoOiBcIiArIHRoaXMucHViUmVxdWVzdEV0YWcpO1xuICAgIH1cblxuICAgIGNvbnN0IHJ1cmkgPSB0aGlzLnRhcmdldDtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLm9wdGlvbnMucGFyYW1zIHx8IHt9O1xuICAgIGxldCBib2R5QW5kQ29udGVudFR5cGU6IEJvZHlBbmRDb250ZW50VHlwZSB8IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5wdWJSZXF1ZXN0Qm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBib2R5QW5kQ29udGVudFR5cGUgPSB7XG4gICAgICAgIGJvZHk6IHRoaXMucHViUmVxdWVzdEJvZHksXG4gICAgICAgIGNvbnRlbnRUeXBlOiB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBib2R5OiBCb2R5IHwgdW5kZWZpbmVkO1xuICAgIGlmIChib2R5QW5kQ29udGVudFR5cGUpIHtcbiAgICAgIGJvZHkgPSBmcm9tQm9keUxlZ2FjeShib2R5QW5kQ29udGVudFR5cGUpO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdCA9IHRoaXMudXNlckFnZW50LnVzZXJBZ2VudENvcmUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoXG4gICAgICBDLlBVQkxJU0gsXG4gICAgICBydXJpLFxuICAgICAgcGFyYW1zLmZyb21VcmkgPyBwYXJhbXMuZnJvbVVyaSA6IHRoaXMudXNlckFnZW50LnVzZXJBZ2VudENvcmUuY29uZmlndXJhdGlvbi5hb3IsXG4gICAgICBwYXJhbXMudG9VcmkgPyBwYXJhbXMudG9VcmkgOiB0aGlzLnRhcmdldCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJlcU9wdGlvbnMuZXh0cmFIZWFkZXJzLFxuICAgICAgYm9keVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5zZW5kKCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNpdGlvbiBwdWJsaWNhdGlvbiBzdGF0ZS5cbiAgICovXG4gIHByaXZhdGUgc3RhdGVUcmFuc2l0aW9uKG5ld1N0YXRlOiBQdWJsaXNoZXJTdGF0ZSk6IHZvaWQge1xuICAgIGNvbnN0IGludmFsaWRUcmFuc2l0aW9uID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gZnJvbSAke3RoaXMuX3N0YXRlfSB0byAke25ld1N0YXRlfWApO1xuICAgIH07XG5cbiAgICAvLyBWYWxpZGF0ZSB0cmFuc2l0aW9uXG4gICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgY2FzZSBQdWJsaXNoZXJTdGF0ZS5Jbml0aWFsOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgbmV3U3RhdGUgIT09IFB1Ymxpc2hlclN0YXRlLlB1Ymxpc2hlZCAmJlxuICAgICAgICAgIG5ld1N0YXRlICE9PSBQdWJsaXNoZXJTdGF0ZS5VbnB1Ymxpc2hlZCAmJlxuICAgICAgICAgIG5ld1N0YXRlICE9PSBQdWJsaXNoZXJTdGF0ZS5UZXJtaW5hdGVkXG4gICAgICAgICkge1xuICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFB1Ymxpc2hlclN0YXRlLlB1Ymxpc2hlZDpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5ld1N0YXRlICE9PSBQdWJsaXNoZXJTdGF0ZS5VbnB1Ymxpc2hlZCAmJlxuICAgICAgICAgIG5ld1N0YXRlICE9PSBQdWJsaXNoZXJTdGF0ZS5UZXJtaW5hdGVkXG4gICAgICAgICkge1xuICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFB1Ymxpc2hlclN0YXRlLlVucHVibGlzaGVkOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgbmV3U3RhdGUgIT09IFB1Ymxpc2hlclN0YXRlLlB1Ymxpc2hlZCAmJlxuICAgICAgICAgIG5ld1N0YXRlICE9PSBQdWJsaXNoZXJTdGF0ZS5UZXJtaW5hdGVkXG4gICAgICAgICkge1xuICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFB1Ymxpc2hlclN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHN0YXRlLlwiKTtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2l0aW9uXG4gICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB0aGlzLmxvZ2dlci5sb2coYFB1YmxpY2F0aW9uIHRyYW5zaXRpb25lZCB0byBzdGF0ZSAke3RoaXMuX3N0YXRlfWApO1xuICAgIHRoaXMuX3N0YXRlRXZlbnRFbWl0dGVyLmVtaXQoXCJldmVudFwiLCB0aGlzLl9zdGF0ZSk7XG5cbiAgICAvLyBEaXNwb3NlXG4gICAgaWYgKG5ld1N0YXRlID09PSBQdWJsaXNoZXJTdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEluY29taW5nUmVmZXJSZXF1ZXN0LFxuICBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICBOYW1lQWRkckhlYWRlcixcbiAgUmVzcG9uc2VPcHRpb25zXG59IGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBJbnZpdGVyIH0gZnJvbSBcIi4vaW52aXRlclwiO1xuaW1wb3J0IHsgSW52aXRlck9wdGlvbnMgfSBmcm9tIFwiLi9pbnZpdGVyLW9wdGlvbnNcIjtcbmltcG9ydCB7IFNlc3Npb24gfSBmcm9tIFwiLi9zZXNzaW9uXCI7XG5cbi8qKlxuICogQSByZXF1ZXN0IHRvIGVzdGFibGlzaCBhIHtAbGluayBTZXNzaW9ufSBlbHNld2hlcmUgKGluY29taW5nIFJFRkVSKS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZmVycmFsIHtcblxuICBwcml2YXRlIGludml0ZXI6IEludml0ZXIgfCB1bmRlZmluZWQ7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBpbmNvbWluZ1JlZmVyUmVxdWVzdDogSW5jb21pbmdSZWZlclJlcXVlc3QsIHByaXZhdGUgc2Vzc2lvbjogU2Vzc2lvbikge1xuICB9XG5cbiAgcHVibGljIGdldCByZWZlclRvKCk6IE5hbWVBZGRySGVhZGVyIHtcbiAgICBjb25zdCByZWZlclRvID0gdGhpcy5pbmNvbWluZ1JlZmVyUmVxdWVzdC5tZXNzYWdlLnBhcnNlSGVhZGVyKFwicmVmZXItdG9cIik7XG4gICAgaWYgKCEocmVmZXJUbyBpbnN0YW5jZW9mIE5hbWVBZGRySGVhZGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIFJlZmVyLVRvIGhlYWRlci5cIik7XG4gICAgfVxuICAgIHJldHVybiByZWZlclRvO1xuICB9XG5cbiAgcHVibGljIGdldCByZWZlcnJlZEJ5KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuaW5jb21pbmdSZWZlclJlcXVlc3QubWVzc2FnZS5nZXRIZWFkZXIoXCJyZWZlcnJlZC1ieVwiKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgcmVwbGFjZXMoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5yZWZlclRvLnVyaS5nZXRIZWFkZXIoXCJyZXBsYWNlc1wiKTtcbiAgfVxuXG4gIC8qKiBJbmNvbWluZyBSRUZFUiByZXF1ZXN0IG1lc3NhZ2UuICovXG4gIHB1YmxpYyBnZXQgcmVxdWVzdCgpOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlIHtcbiAgICByZXR1cm4gdGhpcy5pbmNvbWluZ1JlZmVyUmVxdWVzdC5tZXNzYWdlO1xuICB9XG5cbiAgLyoqIEFjY2VwdCB0aGUgcmVxdWVzdC4gKi9cbiAgcHVibGljIGFjY2VwdChvcHRpb25zOiBSZXNwb25zZU9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDIwMiB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pbmNvbWluZ1JlZmVyUmVxdWVzdC5hY2NlcHQob3B0aW9ucyk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqIFJlamVjdCB0aGUgcmVxdWVzdC4gKi9cbiAgcHVibGljIHJlamVjdChvcHRpb25zPzogUmVzcG9uc2VPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pbmNvbWluZ1JlZmVyUmVxdWVzdC5yZWplY3Qob3B0aW9ucyk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW52aXRlciB3aGljaCBtYXkgYmUgdXNlZCB0byBzZW5kIGFuIG91dCBvZiBkaWFsb2cgSU5WSVRFIHJlcXVlc3QuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoaXMgYSBoZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhbiBJbnZpdGVyIHdoaWNoIHdpbGwgZXhlY3V0ZSB0aGUgcmVmZXJyYWxcbiAgICogb2YgdGhlIGBTZXNzaW9uYCB3aGljaCB3YXMgcmVmZXJyZWQuIFRoZSBhcHByb3ByaWF0ZSBoZWFkZXJzIGFyZSBzZXQgYW5kXG4gICAqIHRoZSByZWZlcnJlZCBgU2Vzc2lvbmAgaXMgbGlua2VkIHRvIHRoZSBuZXcgYFNlc3Npb25gLiBOb3RlIHRoYXQgb25seSBhXG4gICAqIHNpbmdsZSBpbnN0YW5jZSBvZiB0aGUgYEludml0ZXJgIHdpbGwgYmUgY3JlYXRlZCBhbmQgcmV0dXJuZWQgKGlmIGNhbGxlZFxuICAgKiBtb3JlIHRoYW4gb25jZSBhIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBgSW52aXRlcmAgd2lsbCBiZSByZXR1cm5lZCBldmVyeSB0aW1lKS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICogQHBhcmFtIG1vZGlmaWVycyAtIFNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBtb2RpZmllcnMuXG4gICAqL1xuICBwdWJsaWMgbWFrZUludml0ZXIoXG4gICAgb3B0aW9ucz86IEludml0ZXJPcHRpb25zXG4gICk6IEludml0ZXIge1xuICAgIGlmICh0aGlzLmludml0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmludml0ZXI7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFVSSSA9IHRoaXMucmVmZXJUby51cmkuY2xvbmUoKTtcbiAgICB0YXJnZXRVUkkuY2xlYXJIZWFkZXJzKCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgIGNvbnN0IHJlcGxhY2VzID0gdGhpcy5yZXBsYWNlcztcbiAgICBpZiAocmVwbGFjZXMpIHtcbiAgICAgIC8vIGRlY29kZVVSSUNvbXBvbmVudCBpcyBhIGhvbGRvdmVyIGZyb20gMmMwODZlYjQuIE5vdCBzdXJlIHRoYXQgaXQgaXMgYWN0dWFsbHkgbmVjZXNzYXJ5XG4gICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlcGxhY2VzOiBcIiArIGRlY29kZVVSSUNvbXBvbmVudChyZXBsYWNlcykpO1xuICAgIH1cbiAgICBjb25zdCByZWZlcnJlZEJ5ID0gdGhpcy5yZWZlcnJlZEJ5O1xuICAgIGlmIChyZWZlcnJlZEJ5KSB7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlZmVycmVkLUJ5OiBcIiArIHJlZmVycmVkQnkpO1xuICAgIH1cbiAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcbiAgICB0aGlzLmludml0ZXIgPSB0aGlzLnNlc3Npb24udXNlckFnZW50Ll9tYWtlSW52aXRlcih0YXJnZXRVUkksIG9wdGlvbnMpO1xuICAgIHRoaXMuaW52aXRlci5fcmVmZXJyZWQgPSB0aGlzLnNlc3Npb247XG4gICAgdGhpcy5zZXNzaW9uLl9yZWZlcnJhbCA9IHRoaXMuaW52aXRlcjtcbiAgICByZXR1cm4gdGhpcy5pbnZpdGVyO1xuICB9XG59XG4iLCJpbXBvcnQgeyBMb2dnZXIsIE91dGdvaW5nUmVmZXJSZXF1ZXN0LCBVUkkgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgUmVmZXJyZXJEZWxlZ2F0ZSB9IGZyb20gXCIuL3JlZmVycmVyLWRlbGVnYXRlXCI7XG5pbXBvcnQgeyBSZWZlcnJlck9wdGlvbnMgfSBmcm9tIFwiLi9yZWZlcnJlci1vcHRpb25zXCI7XG5pbXBvcnQgeyBSZWZlcnJlclJlZmVyT3B0aW9ucyB9IGZyb20gXCIuL3JlZmVycmVyLXJlZmVyLW9wdGlvbnNcIjtcbmltcG9ydCB7IFNlc3Npb24gfSBmcm9tIFwiLi9zZXNzaW9uXCI7XG5pbXBvcnQgeyBTZXNzaW9uU3RhdGUgfSBmcm9tIFwiLi9zZXNzaW9uLXN0YXRlXCI7XG5cbi8qKlxuICogQSByZWZlcnJlciBzZW5kcyBhIHtAbGluayBSZWZlcnJhbH0gKG91dGdvaW5nIFJFRkVSKS5cbiAqIEByZW1hcmtzXG4gKiBTZW5kcyBhbiBvdXRnb2luZyBpbiBkaWFsb2cgUkVGRVIgcmVxdWVzdC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZmVycmVyIHtcbiAgLyoqIFRoZSByZWZlcnJlciBkZWxlZ2F0ZS4gKi9cbiAgcHVibGljIGRlbGVnYXRlOiBSZWZlcnJlckRlbGVnYXRlIHwgdW5kZWZpbmVkO1xuXG4gIC8qKiBUaGUgbG9nZ2VyLiAqL1xuICBwcml2YXRlIGxvZ2dlcjogTG9nZ2VyO1xuICAvKiogVGhlIHJlZmVyVG8uICovXG4gIHByaXZhdGUgX3JlZmVyVG86IFVSSSB8IFNlc3Npb247XG4gIC8qKiBUaGUgcmVmZXJyZXIgc2Vzc2lvbi4gKi9cbiAgcHJpdmF0ZSBfc2Vzc2lvbjogU2Vzc2lvbjtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFJlZmVycmVyYCBjbGFzcy5cbiAgICogQHBhcmFtIHNlc3Npb24gLSBUaGUgc2Vzc2lvbiB0aGUgUkVGRVIgd2lsbCBiZSBzZW50IGZyb20uIFNlZSB7QGxpbmsgU2Vzc2lvbn0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSByZWZlclRvIC0gVGhlIHJlZmVycmFsIHRhcmdldC4gSWYgYSBgU2Vzc2lvbmAsIGEgUkVGRVIgdy9SZXBsYWNlcyBpcyBzZW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgYnVja2V0LiBTZWUge0BsaW5rIFJlZmVycmVyT3B0aW9uc30gZm9yIGRldGFpbHMuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioc2Vzc2lvbjogU2Vzc2lvbiwgcmVmZXJUbzogVVJJIHwgU2Vzc2lvbiwgb3B0aW9ucz86IFJlZmVycmVyT3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyID0gc2Vzc2lvbi51c2VyQWdlbnQuZ2V0TG9nZ2VyKFwic2lwLlJlZmVycmVyXCIpO1xuICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uO1xuICAgIHRoaXMuX3JlZmVyVG8gID0gcmVmZXJUbztcbiAgfVxuXG4gIC8qKiBUaGUgcmVmZXJyZXIgc2Vzc2lvbi4gKi9cbiAgcHVibGljIGdldCBzZXNzaW9uKCk6IFNlc3Npb24ge1xuICAgIHJldHVybiB0aGlzLl9zZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBSRUZFUiByZXF1ZXN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgIHB1YmxpYyByZWZlcihvcHRpb25zOiBSZWZlcnJlclJlZmVyT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxPdXRnb2luZ1JlZmVyUmVxdWVzdD4ge1xuICAgIC8vIGd1YXJkIHNlc3Npb24gc3RhdGVcbiAgICBpZiAodGhpcy5zZXNzaW9uLnN0YXRlICE9PSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIlJlZmVycmVyLnJlZmVyKCkgbWF5IG9ubHkgYmUgY2FsbGVkIGlmIGVzdGFibGlzaGVkIHNlc3Npb24uXCI7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYEludmFsaWQgc2Vzc2lvbiBzdGF0ZSAke3RoaXMuc2Vzc2lvbi5zdGF0ZX1gKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdERlbGVnYXRlID0gb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGU7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBvcHRpb25zLnJlcXVlc3RPcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnModGhpcy5yZWZlclRvU3RyaW5nKHRoaXMuX3JlZmVyVG8pKTtcbiAgICByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMgPSByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG4gICAgcmVxdWVzdE9wdGlvbnMuZXh0cmFIZWFkZXJzID0gcmVxdWVzdE9wdGlvbnMuZXh0cmFIZWFkZXJzLmNvbmNhdChleHRyYUhlYWRlcnMpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5yZWZlcih0aGlzLCByZXF1ZXN0RGVsZWdhdGUsIHJlcXVlc3RPcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFIZWFkZXJzKHJlZmVyVG86IHN0cmluZyk6IEFycmF5PHN0cmluZz4ge1xuICAgIGNvbnN0IGV4dHJhSGVhZGVyczogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVmZXJyZWQtQnk6IDxcIiArIHRoaXMuX3Nlc3Npb24udXNlckFnZW50LmNvbmZpZ3VyYXRpb24udXJpICsgXCI+XCIpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQ29udGFjdDogXCIgKyB0aGlzLl9zZXNzaW9uLl9jb250YWN0KTtcbiAgICBleHRyYUhlYWRlcnMucHVzaChcIkFsbG93OiBcIiArIFtcbiAgICAgIFwiQUNLXCIsXG4gICAgICBcIkNBTkNFTFwiLFxuICAgICAgXCJJTlZJVEVcIixcbiAgICAgIFwiTUVTU0FHRVwiLFxuICAgICAgXCJCWUVcIixcbiAgICAgIFwiT1BUSU9OU1wiLFxuICAgICAgXCJJTkZPXCIsXG4gICAgICBcIk5PVElGWVwiLFxuICAgICAgXCJSRUZFUlwiXG4gICAgXS50b1N0cmluZygpKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlZmVyLVRvOiBcIiArIHJlZmVyVG8pO1xuICAgIHJldHVybiBleHRyYUhlYWRlcnM7XG4gIH1cblxuICBwcml2YXRlIHJlZmVyVG9TdHJpbmcodGFyZ2V0OiBVUkkgfCBTZXNzaW9uKTogc3RyaW5nIHtcbiAgICBsZXQgcmVmZXJUbzogc3RyaW5nO1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBVUkkpIHtcbiAgICAgIC8vIFJFRkVSIHdpdGhvdXQgUmVwbGFjZXMgKEJsaW5kIFRyYW5zZmVyKVxuICAgICAgcmVmZXJUbyA9IHRhcmdldC50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSRUZFUiB3aXRoIFJlcGxhY2VzIChBdHRlbmRlZCBUcmFuc2ZlcilcbiAgICAgIGlmICghdGFyZ2V0LmRpYWxvZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgdW5kZWZpbmVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gdGFyZ2V0LnJlbW90ZUlkZW50aXR5LmZyaWVuZGx5TmFtZTtcbiAgICAgIGNvbnN0IHJlbW90ZVRhcmdldCA9IHRhcmdldC5kaWFsb2cucmVtb3RlVGFyZ2V0LnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBjYWxsSWQgPSB0YXJnZXQuZGlhbG9nLmNhbGxJZDtcbiAgICAgIGNvbnN0IHJlbW90ZVRhZyA9IHRhcmdldC5kaWFsb2cucmVtb3RlVGFnO1xuICAgICAgY29uc3QgbG9jYWxUYWcgPSB0YXJnZXQuZGlhbG9nLmxvY2FsVGFnO1xuICAgICAgY29uc3QgcmVwbGFjZXMgPSBlbmNvZGVVUklDb21wb25lbnQoYCR7Y2FsbElkfTt0by10YWc9JHtyZW1vdGVUYWd9O2Zyb20tdGFnPSR7bG9jYWxUYWd9YCk7XG4gICAgICByZWZlclRvID0gYFwiJHtkaXNwbGF5TmFtZX1cIiA8JHtyZW1vdGVUYXJnZXR9P1JlcGxhY2VzPSR7cmVwbGFjZXN9PmA7XG4gICAgfVxuICAgIHJldHVybiByZWZlclRvO1xuICB9XG59XG4iLCIvKipcbiAqIHtAbGluayBSZWdpc3RlcmVyfSBzdGF0ZS5cbiAqIEByZW1hcmtzXG4gKiBUaGUge0BsaW5rIFJlZ2lzdGVyZXJ9IGJlaGF2ZXMgaW4gYSBkZXRlcm1pbmlzdGljIG1hbm5lciBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZ1xuICogRmluaXRlIFN0YXRlIE1hY2hpbmUgKEZTTSkuXG4gKiBgYGB0eHRcbiAqICAgICAgICAgICAgICAgICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICogICAgICAgICAgICAgICAgICB8ICBfX19fX19fX19fX19fX19fX19fX19fX19fXyAgICAgICAgICAgICAgfFxuICogUmVnaXN0ZXJlciAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICAgICAgdlxuICogQ29uc3RydWN0ZWQgLT4gSW5pdGlhbCAtPiBSZWdpc3RlcmVkIC0+IFVucmVnaXN0ZXJlZCAtPiBUZXJtaW5hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBeX19fX19fX19fX19ffCAgICAgICAgICAgICBeXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGVudW0gUmVnaXN0ZXJlclN0YXRlIHtcbiAgSW5pdGlhbCA9IFwiSW5pdGlhbFwiLFxuICBSZWdpc3RlcmVkID0gIFwiUmVnaXN0ZXJlZFwiLFxuICBVbnJlZ2lzdGVyZWQgPSBcIlVucmVnaXN0ZXJlZFwiLFxuICBUZXJtaW5hdGVkID0gXCJUZXJtaW5hdGVkXCJcbn1cbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudHNcIjtcblxuaW1wb3J0IHtcbiAgQyxcbiAgR3JhbW1hcixcbiAgTG9nZ2VyLFxuICBPdXRnb2luZ1JlZ2lzdGVyUmVxdWVzdCxcbiAgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgVVJJXG59IGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBfbWFrZUVtaXR0ZXIsIEVtaXR0ZXIgfSBmcm9tIFwiLi9lbWl0dGVyXCI7XG5pbXBvcnQgeyBSZXF1ZXN0UGVuZGluZ0Vycm9yIH0gZnJvbSBcIi4vZXhjZXB0aW9uc1wiO1xuaW1wb3J0IHsgUmVnaXN0ZXJlck9wdGlvbnMgfSBmcm9tIFwiLi9yZWdpc3RlcmVyLW9wdGlvbnNcIjtcbmltcG9ydCB7IFJlZ2lzdGVyZXJSZWdpc3Rlck9wdGlvbnMgfSBmcm9tIFwiLi9yZWdpc3RlcmVyLXJlZ2lzdGVyLW9wdGlvbnNcIjtcbmltcG9ydCB7IFJlZ2lzdGVyZXJTdGF0ZSB9IGZyb20gXCIuL3JlZ2lzdGVyZXItc3RhdGVcIjtcbmltcG9ydCB7IFJlZ2lzdGVyZXJVbnJlZ2lzdGVyT3B0aW9ucyB9IGZyb20gXCIuL3JlZ2lzdGVyZXItdW5yZWdpc3Rlci1vcHRpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnQgfSBmcm9tIFwiLi91c2VyLWFnZW50XCI7XG5cbi8qKlxuICogQSByZWdpc3RlcmVyIHJlZ2lzdGVycyBhIGNvbnRhY3QgZm9yIGFuIGFkZHJlc3Mgb2YgcmVjb3JkIChvdXRnb2luZyBSRUdJU1RFUikuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RlcmVyIHtcblxuICAvKiogRGVmYXVsdCByZWdpc3RlcmVyIG9wdGlvbnMuICovXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGRlZmF1bHRPcHRpb25zOiBSZXF1aXJlZDxSZWdpc3RlcmVyT3B0aW9ucz4gPSB7XG4gICAgZXhwaXJlczogNjAwLFxuICAgIGV4dHJhQ29udGFjdEhlYWRlclBhcmFtczogW10sXG4gICAgZXh0cmFIZWFkZXJzOiBbXSxcbiAgICBsb2dDb25maWd1cmF0aW9uOiB0cnVlLFxuICAgIGluc3RhbmNlSWQ6IFwiXCIsXG4gICAgcGFyYW1zOiB7fSxcbiAgICByZWdJZDogMCxcbiAgICByZWdpc3RyYXI6IG5ldyBVUkkoXCJzaXBcIiwgXCJhbm9ueW1vdXNcIiwgXCJhbm9ueW1vdXMuaW52YWxpZFwiKVxuICB9O1xuXG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy8xMDk1MzgvYnJvb2ZhXG4gIHByaXZhdGUgc3RhdGljIG5ld1VVSUQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBVVUlEOiBzdHJpbmcgPSBcInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICAgIGNvbnN0IHI6IG51bWJlciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KTtcbiAgICAgIGNvbnN0IHY6IG51bWJlciA9IGMgPT09IFwieFwiID8gciA6IChyICUgNCArIDgpO1xuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuICAgIHJldHVybiBVVUlEO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmlwIHByb3BlcnRpZXMgd2l0aCB1bmRlZmluZWQgdmFsdWVzIGZyb20gb3B0aW9ucy5cbiAgICogVGhpcyBpcyBhIHdvcmsgYXJvdW5kIHdoaWxlIHdhaXRpbmcgZm9yIG1pc3NpbmcgdnMgdW5kZWZpbmVkIHRvIGJlIGFkZHJlc3NlZCAob3Igbm90KS4uLlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEzMTk1XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byByZWR1Y2VcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHN0cmlwVW5kZWZpbmVkUHJvcGVydGllcyhvcHRpb25zOiBQYXJ0aWFsPFJlZ2lzdGVyZXJPcHRpb25zPik6IFBhcnRpYWw8UmVnaXN0ZXJlck9wdGlvbnM+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKChvYmplY3QsIGtleSkgPT4ge1xuICAgICAgaWYgKChvcHRpb25zIGFzIGFueSlba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIChvYmplY3QgYXMgYW55KVtrZXldID0gKG9wdGlvbnMgYXMgYW55KVtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LCB7fSk7XG4gIH1cblxuICBwcml2YXRlIGRpc3Bvc2VkID0gZmFsc2U7XG4gIHByaXZhdGUgaWQ6IHN0cmluZztcbiAgcHJpdmF0ZSBleHBpcmVzOiBudW1iZXI7XG4gIHByaXZhdGUgbG9nZ2VyOiBMb2dnZXI7XG4gIHByaXZhdGUgb3B0aW9uczogUmVnaXN0ZXJlck9wdGlvbnM7XG4gIHByaXZhdGUgcmVxdWVzdDogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZTtcbiAgcHJpdmF0ZSB1c2VyQWdlbnQ6IFVzZXJBZ2VudDtcblxuICBwcml2YXRlIHJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lcjogYW55IHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIHJlZ2lzdHJhdGlvblRpbWVyOiBhbnkgfCB1bmRlZmluZWQ7XG5cbiAgLyoqIFRoZSBjb250YWN0cyByZXR1cm5lZCBmcm9tIHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBSRUdJU1RFUiByZXF1ZXN0LiAqL1xuICBwcml2YXRlIF9jb250YWN0czogQXJyYXk8c3RyaW5nPiA9IFtdO1xuXG4gIC8qKiBUaGUgcmVnaXN0cmF0aW9uIHN0YXRlLiAqL1xuICBwcml2YXRlIF9zdGF0ZTogUmVnaXN0ZXJlclN0YXRlID0gUmVnaXN0ZXJlclN0YXRlLkluaXRpYWw7XG4gIC8qKiBFbWl0cyB3aGVuIHRoZSByZWdpc3RyYXRpb24gc3RhdGUgY2hhbmdlcy4gKi9cbiAgcHJpdmF0ZSBfc3RhdGVFdmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqIFRydWUgaXMgd2FpdGluZyBmb3IgZmluYWwgcmVzcG9uc2UgdG8gb3V0c3RhbmRpbmcgUkVHSVNURVIgcmVxdWVzdC4gKi9cbiAgcHJpdmF0ZSBfd2FpdGluZyA9IGZhbHNlO1xuICAvKiogRW1pdHMgd2hlbiB3YWl0aW5nIGNoYW5nZXMuICovXG4gIHByaXZhdGUgX3dhaXRpbmdFdmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBSZWdpc3RlcmVyYCBjbGFzcy5cbiAgICogQHBhcmFtIHVzZXJBZ2VudCAtIFVzZXIgYWdlbnQuIFNlZSB7QGxpbmsgVXNlckFnZW50fSBmb3IgZGV0YWlscy5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC4gU2VlIHtAbGluayBSZWdpc3RlcmVyT3B0aW9uc30gZm9yIGRldGFpbHMuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IodXNlckFnZW50OiBVc2VyQWdlbnQsIG9wdGlvbnM6IFJlZ2lzdGVyZXJPcHRpb25zID0ge30pIHtcblxuICAgIC8vIFNldCB1c2VyIGFnZW50XG4gICAgdGhpcy51c2VyQWdlbnQgPSB1c2VyQWdlbnQ7XG5cbiAgICAvLyBEZWZhdWx0IHJlZ2lzdHJhciBpcyBkb21haW4gcG9ydGlvbiBvZiB1c2VyIGFnZW50IHVyaVxuICAgIGNvbnN0IGRlZmF1bHRVc2VyQWdlbnRSZWdpc3RyYXIgPSB1c2VyQWdlbnQuY29uZmlndXJhdGlvbi51cmkuY2xvbmUoKTtcbiAgICBkZWZhdWx0VXNlckFnZW50UmVnaXN0cmFyLnVzZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBJbml0aWFsaXplIGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAvLyBzdGFydCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbiB2YWx1ZXNcbiAgICAgIC4uLlJlZ2lzdGVyZXIuZGVmYXVsdE9wdGlvbnMsXG4gICAgICAvLyBzZXQgdGhlIGFwcHJvcHJpYXRlIGRlZmF1bHQgcmVnaXN0cmFyXG4gICAgICAuLi57IHJlZ2lzdHJhcjogZGVmYXVsdFVzZXJBZ2VudFJlZ2lzdHJhciB9LFxuICAgICAgLy8gYXBwbHkgYW55IG9wdGlvbnMgcGFzc2VkIGluIHZpYSB0aGUgY29uc3RydWN0b3JcbiAgICAgIC4uLlJlZ2lzdGVyZXIuc3RyaXBVbmRlZmluZWRQcm9wZXJ0aWVzKG9wdGlvbnMpXG4gICAgfTtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgbm90IHVzaW5nIHJlZmVyZW5jZXMgdG8gYXJyYXkgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5leHRyYUNvbnRhY3RIZWFkZXJQYXJhbXMgPSAodGhpcy5vcHRpb25zLmV4dHJhQ29udGFjdEhlYWRlclBhcmFtcyB8fCBbXSkuc2xpY2UoKTtcbiAgICB0aGlzLm9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKHRoaXMub3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgYXJlIG5vdCB1c2luZyByZWZlcmVuY2VzIHRvIHJlZ2lzdHJhciB1cmlcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yZWdpc3RyYXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lzdHJhciB1bmRlZmluZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMucmVnaXN0cmFyID0gdGhpcy5vcHRpb25zLnJlZ2lzdHJhci5jbG9uZSgpO1xuXG4gICAgLy8gU2V0IGluc3RhbmNlSWQgYW5kIHJlZ0lkIGNvbmRpdGlvbmFsIGRlZmF1bHRzIGFuZCB2YWxpZGF0ZVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVnSWQgJiYgIXRoaXMub3B0aW9ucy5pbnN0YW5jZUlkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaW5zdGFuY2VJZCA9IFJlZ2lzdGVyZXIubmV3VVVJRCgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5yZWdJZCAmJiB0aGlzLm9wdGlvbnMuaW5zdGFuY2VJZCkge1xuICAgICAgdGhpcy5vcHRpb25zLnJlZ0lkID0gMTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbnN0YW5jZUlkICYmIEdyYW1tYXIucGFyc2UodGhpcy5vcHRpb25zLmluc3RhbmNlSWQsIFwidXVpZFwiKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5zdGFuY2VJZC5cIik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVnSWQgJiYgdGhpcy5vcHRpb25zLnJlZ0lkIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZWdJZC5cIik7XG4gICAgfVxuXG4gICAgY29uc3QgcmVnaXN0cmFyID0gdGhpcy5vcHRpb25zLnJlZ2lzdHJhcjtcbiAgICBjb25zdCBmcm9tVVJJID0gKHRoaXMub3B0aW9ucy5wYXJhbXMgJiYgdGhpcy5vcHRpb25zLnBhcmFtcy5mcm9tVXJpKSB8fCB1c2VyQWdlbnQudXNlckFnZW50Q29yZS5jb25maWd1cmF0aW9uLmFvcjtcbiAgICBjb25zdCB0b1VSSSA9ICh0aGlzLm9wdGlvbnMucGFyYW1zICYmIHRoaXMub3B0aW9ucy5wYXJhbXMudG9VcmkpIHx8IHVzZXJBZ2VudC5jb25maWd1cmF0aW9uLnVyaTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLm9wdGlvbnMucGFyYW1zIHx8IHt9O1xuICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICAgIC8vIEJ1aWxkIHRoZSByZXF1ZXN0XG4gICAgdGhpcy5yZXF1ZXN0ID0gdXNlckFnZW50LnVzZXJBZ2VudENvcmUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoXG4gICAgICBDLlJFR0lTVEVSLFxuICAgICAgcmVnaXN0cmFyLFxuICAgICAgZnJvbVVSSSxcbiAgICAgIHRvVVJJLFxuICAgICAgcGFyYW1zLFxuICAgICAgZXh0cmFIZWFkZXJzLFxuICAgICAgdW5kZWZpbmVkXG4gICAgKTtcblxuICAgIC8vIFJlZ2lzdHJhdGlvbiBleHBpcmVzXG4gICAgdGhpcy5leHBpcmVzID0gdGhpcy5vcHRpb25zLmV4cGlyZXMgfHwgUmVnaXN0ZXJlci5kZWZhdWx0T3B0aW9ucy5leHBpcmVzO1xuICAgIGlmICh0aGlzLmV4cGlyZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGV4cGlyZXMuXCIpO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgbG9nZ2VyXG4gICAgdGhpcy5sb2dnZXIgPSB1c2VyQWdlbnQuZ2V0TG9nZ2VyKFwic2lwLlJlZ2lzdGVyZXJcIik7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxvZ0NvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkNvbmZpZ3VyYXRpb246XCIpO1xuICAgICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAodGhpcy5vcHRpb25zIGFzIGFueSlba2V5XTtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlIFwicmVnaXN0cmFyXCI6XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCLCtyBcIiArIGtleSArIFwiOiBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCLCtyBcIiArIGtleSArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZpZXJcbiAgICB0aGlzLmlkID0gdGhpcy5yZXF1ZXN0LmNhbGxJZCArIHRoaXMucmVxdWVzdC5mcm9tLnBhcmFtZXRlcnMudGFnO1xuXG4gICAgLy8gQWRkIHRvIHRoZSB1c2VyIGFnZW50J3Mgc2Vzc2lvbiBjb2xsZWN0aW9uLlxuICAgIHRoaXMudXNlckFnZW50Ll9yZWdpc3RlcmVyc1t0aGlzLmlkXSA9IHRoaXM7XG4gIH1cblxuICAvKiogVGhlIHJlZ2lzdGVyZWQgY29udGFjdHMuICovXG4gIHB1YmxpYyBnZXQgY29udGFjdHMoKTogQXJyYXk8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhY3RzLnNsaWNlKCk7XG4gIH1cblxuICAvKiogVGhlIHJlZ2lzdHJhdGlvbiBzdGF0ZS4gKi9cbiAgcHVibGljIGdldCBzdGF0ZSgpOiBSZWdpc3RlcmVyU3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSByZWdpc3RlcmVyIHN0YXRlIGNoYW5nZXMuICovXG4gIHB1YmxpYyBnZXQgc3RhdGVDaGFuZ2UoKTogRW1pdHRlcjxSZWdpc3RlcmVyU3RhdGU+IHtcbiAgICByZXR1cm4gX21ha2VFbWl0dGVyKHRoaXMuX3N0YXRlRXZlbnRFbWl0dGVyKTtcbiAgfVxuXG4gIC8qKiBEZXN0cnVjdG9yLiAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLmxvZ2dlci5sb2coYFJlZ2lzdGVyZXIgJHt0aGlzLmlkfSBpbiBzdGF0ZSAke3RoaXMuc3RhdGV9IGlzIGJlaW5nIGRpc3Bvc2VkYCk7XG5cbiAgICAvLyBSZW1vdmUgZnJvbSB0aGUgdXNlciBhZ2VudCdzIHJlZ2lzdGVyZXIgY29sbGVjdGlvblxuICAgIGRlbGV0ZSB0aGlzLnVzZXJBZ2VudC5fcmVnaXN0ZXJlcnNbdGhpcy5pZF07XG5cbiAgICAvLyBJZiByZWdpc3RlcmVkLCB1bnJlZ2lzdGVycyBhbmQgcmVzb2x2ZXMgYWZ0ZXIgZmluYWwgcmVzcG9uc2UgcmVjZWl2ZWQuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGRvQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIElmIHdlIGFyZSByZWdpc3RlcmVkLCB1bnJlZ2lzdGVyIGFuZCByZXNvbHZlIGFmdGVyIG91ciBzdGF0ZSBjaGFuZ2VzXG4gICAgICAgIGlmICghdGhpcy53YWl0aW5nICYmIHRoaXMuX3N0YXRlID09PSBSZWdpc3RlcmVyU3RhdGUuUmVnaXN0ZXJlZCkge1xuICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2UuYWRkTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgIHRoaXMudW5yZWdpc3RlcigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UganVzdCByZXNvbHZlXG4gICAgICAgIHRoaXMudGVybWluYXRlZCgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgd2FpdGluZyBmb3IgYW4gb3V0c3RhbmRpbmcgcmVxdWVzdCwgd2FpdCBmb3IgaXQgdG8gZmluaXNoIGFuZCB0aGVuIHRyeSBjbG9zaW5nLlxuICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgdHJ5IGNsb3NpbmcuXG4gICAgICBpZiAodGhpcy53YWl0aW5nKSB7XG4gICAgICAgIHRoaXMud2FpdGluZ0NoYW5nZS5hZGRMaXN0ZW5lcigoKSA9PiBkb0Nsb3NlKCksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvQ2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgUkVHSVNURVIgcmVxdWVzdC5cbiAgICogQHJlbWFya3NcbiAgICogSWYgc3VjY2Vzc2Z1bCwgc2VuZHMgcmUtUkVHSVNURVIgcmVxdWVzdHMgcHJpb3IgdG8gcmVnaXN0cmF0aW9uIGV4cGlyYXRpb24gdW50aWwgYHVuc3Vic2NyaWJlKClgIGlzIGNhbGxlZC5cbiAgICogUmVqZWN0cyB3aXRoIGBSZXF1ZXN0UGVuZGluZ0Vycm9yYCBpZiBhIFJFR0lTVEVSIHJlcXVlc3QgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcy5cbiAgICovXG4gIHB1YmxpYyByZWdpc3RlcihvcHRpb25zOiBSZWdpc3RlcmVyUmVnaXN0ZXJPcHRpb25zID0ge30pOiBQcm9taXNlPE91dGdvaW5nUmVnaXN0ZXJSZXF1ZXN0PiB7XG4gICAgLy8gVUFzIE1VU1QgTk9UIHNlbmQgYSBuZXcgcmVnaXN0cmF0aW9uICh0aGF0IGlzLCBjb250YWluaW5nIG5ldyBDb250YWN0XG4gICAgLy8gaGVhZGVyIGZpZWxkIHZhbHVlcywgYXMgb3Bwb3NlZCB0byBhIHJldHJhbnNtaXNzaW9uKSB1bnRpbCB0aGV5IGhhdmVcbiAgICAvLyByZWNlaXZlZCBhIGZpbmFsIHJlc3BvbnNlIGZyb20gdGhlIHJlZ2lzdHJhciBmb3IgdGhlIHByZXZpb3VzIG9uZSBvclxuICAgIC8vIHRoZSBwcmV2aW91cyBSRUdJU1RFUiByZXF1ZXN0IGhhcyB0aW1lZCBvdXQuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMC4yXG4gICAgaWYgKHRoaXMud2FpdGluZykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgUmVxdWVzdFBlbmRpbmdFcnJvcihcIlJFR0lTVEVSIHJlcXVlc3QgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2FpdGluZyBmb3IgZmluYWwgcmVzcG9uc2VcIik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIE9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5yZXF1ZXN0T3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gey4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucy5yZXF1ZXN0T3B0aW9uc307XG4gICAgfVxuXG4gICAgLy8gRXh0cmEgaGVhZGVyc1xuICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9ICh0aGlzLm9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQ29udGFjdDogXCIgKyB0aGlzLmdlbmVyYXRlQ29udGFjdEhlYWRlcih0aGlzLmV4cGlyZXMpKTtcbiAgICAvLyB0aGlzIGlzIFVBLkMuQUxMT1dFRF9NRVRIT0RTLCByZW1vdmVkIHRvIGdldCBhcm91bmQgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQWxsb3c6IFwiICsgW1xuICAgICAgXCJBQ0tcIixcbiAgICAgIFwiQ0FOQ0VMXCIsXG4gICAgICBcIklOVklURVwiLFxuICAgICAgXCJNRVNTQUdFXCIsXG4gICAgICBcIkJZRVwiLFxuICAgICAgXCJPUFRJT05TXCIsXG4gICAgICBcIklORk9cIixcbiAgICAgIFwiTk9USUZZXCIsXG4gICAgICBcIlJFRkVSXCJcbiAgICBdLnRvU3RyaW5nKCkpO1xuXG4gICAgLy8gQ2FsbC1JRDogQWxsIHJlZ2lzdHJhdGlvbnMgZnJvbSBhIFVBQyBTSE9VTEQgdXNlIHRoZSBzYW1lIENhbGwtSURcbiAgICAvLyBoZWFkZXIgZmllbGQgdmFsdWUgZm9yIHJlZ2lzdHJhdGlvbnMgc2VudCB0byBhIHBhcnRpY3VsYXJcbiAgICAvLyByZWdpc3RyYXIuXG4gICAgLy9cbiAgICAvLyBDU2VxOiBUaGUgQ1NlcSB2YWx1ZSBndWFyYW50ZWVzIHByb3BlciBvcmRlcmluZyBvZiBSRUdJU1RFUlxuICAgIC8vIHJlcXVlc3RzLiAgQSBVQSBNVVNUIGluY3JlbWVudCB0aGUgQ1NlcSB2YWx1ZSBieSBvbmUgZm9yIGVhY2hcbiAgICAvLyBSRUdJU1RFUiByZXF1ZXN0IHdpdGggdGhlIHNhbWUgQ2FsbC1JRC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEwLjJcbiAgICB0aGlzLnJlcXVlc3QuY3NlcSsrO1xuICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoXCJjc2VxXCIsIHRoaXMucmVxdWVzdC5jc2VxICsgXCIgUkVHSVNURVJcIik7XG4gICAgdGhpcy5yZXF1ZXN0LmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcblxuICAgIHRoaXMud2FpdGluZ1RvZ2dsZSh0cnVlKTtcblxuICAgIGNvbnN0IG91dGdvaW5nUmVnaXN0ZXJSZXF1ZXN0ID0gdGhpcy51c2VyQWdlbnQudXNlckFnZW50Q29yZS5yZWdpc3Rlcih0aGlzLnJlcXVlc3QsIHtcbiAgICAgIG9uQWNjZXB0OiAocmVzcG9uc2UpOiB2b2lkID0+IHtcbiAgICAgICAgbGV0IGV4cGlyZXM6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBGSVhNRTogVGhpcyBkb2VzIE5PVCBhcHBlYXIgdG8gYmUgdG8gc3BlYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICAgIC8vIEkgaGF2ZW4ndCBmb3VuZCBhbnl3aGVyZSB0aGF0IGFuIEV4cGlyZXMgaGVhZGVyIG1heSBiZSB1c2VkIGluIGEgcmVzcG9uc2UuXG4gICAgICAgIGlmIChyZXNwb25zZS5tZXNzYWdlLmhhc0hlYWRlcihcImV4cGlyZXNcIikpIHtcbiAgICAgICAgICBleHBpcmVzID0gTnVtYmVyKHJlc3BvbnNlLm1lc3NhZ2UuZ2V0SGVhZGVyKFwiZXhwaXJlc1wiKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA4LiBUaGUgcmVnaXN0cmFyIHJldHVybnMgYSAyMDAgKE9LKSByZXNwb25zZS4gIFRoZSByZXNwb25zZSBNVVNUXG4gICAgICAgIC8vIGNvbnRhaW4gQ29udGFjdCBoZWFkZXIgZmllbGQgdmFsdWVzIGVudW1lcmF0aW5nIGFsbCBjdXJyZW50XG4gICAgICAgIC8vIGJpbmRpbmdzLiAgRWFjaCBDb250YWN0IHZhbHVlIE1VU1QgZmVhdHVyZSBhbiBcImV4cGlyZXNcIlxuICAgICAgICAvLyBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpdHMgZXhwaXJhdGlvbiBpbnRlcnZhbCBjaG9zZW4gYnkgdGhlXG4gICAgICAgIC8vIHJlZ2lzdHJhci4gIFRoZSByZXNwb25zZSBTSE9VTEQgaW5jbHVkZSBhIERhdGUgaGVhZGVyIGZpZWxkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEwLjNcbiAgICAgICAgdGhpcy5fY29udGFjdHMgPSByZXNwb25zZS5tZXNzYWdlLmdldEhlYWRlcnMoXCJjb250YWN0XCIpO1xuICAgICAgICBsZXQgY29udGFjdHMgPSB0aGlzLl9jb250YWN0cy5sZW5ndGg7XG4gICAgICAgIGlmICghY29udGFjdHMpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIk5vIENvbnRhY3QgaGVhZGVyIGluIHJlc3BvbnNlIHRvIFJFR0lTVEVSLCBkcm9wcGluZyByZXNwb25zZS5cIik7XG4gICAgICAgICAgdGhpcy51bnJlZ2lzdGVyZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgMjAwIChPSykgcmVzcG9uc2UgZnJvbSB0aGUgcmVnaXN0cmFyIGNvbnRhaW5zIGEgbGlzdCBvZiBDb250YWN0XG4gICAgICAgIC8vIGZpZWxkcyBlbnVtZXJhdGluZyBhbGwgY3VycmVudCBiaW5kaW5ncy4gIFRoZSBVQSBjb21wYXJlcyBlYWNoXG4gICAgICAgIC8vIGNvbnRhY3QgYWRkcmVzcyB0byBzZWUgaWYgaXQgY3JlYXRlZCB0aGUgY29udGFjdCBhZGRyZXNzLCB1c2luZ1xuICAgICAgICAvLyBjb21wYXJpc29uIHJ1bGVzIGluIFNlY3Rpb24gMTkuMS40LiAgSWYgc28sIGl0IHVwZGF0ZXMgdGhlIGV4cGlyYXRpb25cbiAgICAgICAgLy8gdGltZSBpbnRlcnZhbCBhY2NvcmRpbmcgdG8gdGhlIGV4cGlyZXMgcGFyYW1ldGVyIG9yLCBpZiBhYnNlbnQsIHRoZVxuICAgICAgICAvLyBFeHBpcmVzIGZpZWxkIHZhbHVlLiAgVGhlIFVBIHRoZW4gaXNzdWVzIGEgUkVHSVNURVIgcmVxdWVzdCBmb3IgZWFjaFxuICAgICAgICAvLyBvZiBpdHMgYmluZGluZ3MgYmVmb3JlIHRoZSBleHBpcmF0aW9uIGludGVydmFsIGhhcyBlbGFwc2VkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEwLjIuNFxuICAgICAgICBsZXQgY29udGFjdDogYW55O1xuICAgICAgICB3aGlsZSAoY29udGFjdHMtLSkge1xuICAgICAgICAgIGNvbnRhY3QgPSByZXNwb25zZS5tZXNzYWdlLnBhcnNlSGVhZGVyKFwiY29udGFjdFwiLCBjb250YWN0cyk7XG4gICAgICAgICAgaWYgKGNvbnRhY3QudXJpLnVzZXIgPT09IHRoaXMudXNlckFnZW50LmNvbnRhY3QudXJpLnVzZXIpIHtcbiAgICAgICAgICAgIGV4cGlyZXMgPSBjb250YWN0LmdldFBhcmFtKFwiZXhwaXJlc1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIG11c3QgYmUgYSBtYXRjaGluZyBjb250YWN0LlxuICAgICAgICBpZiAoY29udGFjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJObyBDb250YWN0IGhlYWRlciBwb2ludGluZyB0byB1cywgZHJvcHBpbmcgcmVzcG9uc2VcIik7XG4gICAgICAgICAgdGhpcy51bnJlZ2lzdGVyZWQoKTtcbiAgICAgICAgICB0aGlzLndhaXRpbmdUb2dnbGUoZmFsc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBjb250YWN0IG11c3QgaGF2ZSBhbiBleHBpcmVzLlxuICAgICAgICBpZiAoZXhwaXJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJDb250YWN0IHBvaW50aW5nIHRvIHVzIGlzIG1pc3NpbmcgZXhwaXJlcyBwYXJhbWV0ZXIsIGRyb3BwaW5nIHJlc3BvbnNlXCIpO1xuICAgICAgICAgIHRoaXMudW5yZWdpc3RlcmVkKCk7XG4gICAgICAgICAgdGhpcy53YWl0aW5nVG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIGdydXUgdmFsdWVzXG4gICAgICAgIGlmIChjb250YWN0Lmhhc1BhcmFtKFwidGVtcC1ncnV1XCIpKSB7XG4gICAgICAgICAgdGhpcy51c2VyQWdlbnQuY29udGFjdC50ZW1wR3J1dSA9IEdyYW1tYXIuVVJJUGFyc2UoY29udGFjdC5nZXRQYXJhbShcInRlbXAtZ3J1dVwiKS5yZXBsYWNlKC9cIi9nLCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhY3QuaGFzUGFyYW0oXCJwdWItZ3J1dVwiKSkge1xuICAgICAgICAgIHRoaXMudXNlckFnZW50LmNvbnRhY3QucHViR3J1dSA9IEdyYW1tYXIuVVJJUGFyc2UoY29udGFjdC5nZXRQYXJhbShcInB1Yi1ncnV1XCIpLnJlcGxhY2UoL1wiL2csIFwiXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZChleHBpcmVzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVxdWVzdERlbGVnYXRlICYmIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uQWNjZXB0KSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25BY2NlcHQocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdGluZ1RvZ2dsZShmYWxzZSk7XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzczogKHJlc3BvbnNlKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblByb2dyZXNzKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25Qcm9ncmVzcyhyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblJlZGlyZWN0OiAocmVzcG9uc2UpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJSZWRpcmVjdCByZWNlaXZlZC4gTm90IHN1cHBvcnRlZC5cIik7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlcmVkKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblJlZGlyZWN0KSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25SZWRpcmVjdChyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWl0aW5nVG9nZ2xlKGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBvblJlamVjdDogKHJlc3BvbnNlKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5tZXNzYWdlLnN0YXR1c0NvZGUgPT09IDQyMykge1xuICAgICAgICAgIC8vIElmIGEgVUEgcmVjZWl2ZXMgYSA0MjMgKEludGVydmFsIFRvbyBCcmllZikgcmVzcG9uc2UsIGl0IE1BWSByZXRyeVxuICAgICAgICAgIC8vIHRoZSByZWdpc3RyYXRpb24gYWZ0ZXIgbWFraW5nIHRoZSBleHBpcmF0aW9uIGludGVydmFsIG9mIGFsbCBjb250YWN0XG4gICAgICAgICAgLy8gYWRkcmVzc2VzIGluIHRoZSBSRUdJU1RFUiByZXF1ZXN0IGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiB0aGVcbiAgICAgICAgICAvLyBleHBpcmF0aW9uIGludGVydmFsIHdpdGhpbiB0aGUgTWluLUV4cGlyZXMgaGVhZGVyIGZpZWxkIG9mIHRoZSA0MjNcbiAgICAgICAgICAvLyAoSW50ZXJ2YWwgVG9vIEJyaWVmKSByZXNwb25zZS5cbiAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEwLjIuOFxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhlIHJlZ2lzdHJhciBNQVkgY2hvb3NlIGFuIGV4cGlyYXRpb24gbGVzcyB0aGFuIHRoZSByZXF1ZXN0ZWRcbiAgICAgICAgICAvLyBleHBpcmF0aW9uIGludGVydmFsLiAgSWYgYW5kIG9ubHkgaWYgdGhlIHJlcXVlc3RlZCBleHBpcmF0aW9uXG4gICAgICAgICAgLy8gaW50ZXJ2YWwgaXMgZ3JlYXRlciB0aGFuIHplcm8gQU5EIHNtYWxsZXIgdGhhbiBvbmUgaG91ciBBTkRcbiAgICAgICAgICAvLyBsZXNzIHRoYW4gYSByZWdpc3RyYXItY29uZmlndXJlZCBtaW5pbXVtLCB0aGUgcmVnaXN0cmFyIE1BWVxuICAgICAgICAgIC8vIHJlamVjdCB0aGUgcmVnaXN0cmF0aW9uIHdpdGggYSByZXNwb25zZSBvZiA0MjMgKEludGVydmFsIFRvb1xuICAgICAgICAgIC8vIEJyaWVmKS4gIFRoaXMgcmVzcG9uc2UgTVVTVCBjb250YWluIGEgTWluLUV4cGlyZXMgaGVhZGVyIGZpZWxkXG4gICAgICAgICAgLy8gdGhhdCBzdGF0ZXMgdGhlIG1pbmltdW0gZXhwaXJhdGlvbiBpbnRlcnZhbCB0aGUgcmVnaXN0cmFyIGlzXG4gICAgICAgICAgLy8gd2lsbGluZyB0byBob25vci4gIEl0IHRoZW4gc2tpcHMgdGhlIHJlbWFpbmluZyBzdGVwcy5cbiAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEwLjNcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm1lc3NhZ2UuaGFzSGVhZGVyKFwibWluLWV4cGlyZXNcIikpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgcmVzcG9uc2UgTVVTVCBjb250YWluIGEgTWluLUV4cGlyZXMgaGVhZGVyIGZpZWxkXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIjQyMyByZXNwb25zZSByZWNlaXZlZCBmb3IgUkVHSVNURVIgd2l0aG91dCBNaW4tRXhwaXJlcywgZHJvcHBpbmcgcmVzcG9uc2VcIik7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJlZCgpO1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nVG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSW5jcmVhc2Ugb3VyIHJlZ2lzdHJhdGlvbiBpbnRlcnZhbCB0byB0aGUgc3VnZ2VzdGVkIG1pbmltdW1cbiAgICAgICAgICB0aGlzLmV4cGlyZXMgPSBOdW1iZXIocmVzcG9uc2UubWVzc2FnZS5nZXRIZWFkZXIoXCJtaW4tZXhwaXJlc1wiKSk7XG4gICAgICAgICAgLy8gQXR0ZW1wdCB0aGUgcmVnaXN0cmF0aW9uIGFnYWluIGltbWVkaWF0ZWx5XG4gICAgICAgICAgdGhpcy53YWl0aW5nVG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYEZhaWxlZCB0byByZWdpc3Rlciwgc3RhdHVzIGNvZGUgJHtyZXNwb25zZS5tZXNzYWdlLnN0YXR1c0NvZGV9YCk7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlcmVkKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblJlamVjdCkge1xuICAgICAgICAgIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uUmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhaXRpbmdUb2dnbGUoZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIG9uVHJ5aW5nOiAocmVzcG9uc2UpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVxdWVzdERlbGVnYXRlICYmIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uVHJ5aW5nKSB7XG4gICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25UcnlpbmcocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG91dGdvaW5nUmVnaXN0ZXJSZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgUkVHSVNURVIgcmVxdWVzdCB3aXRoIGV4cGlyZXMgZXF1YWwgdG8gemVyby5cbiAgICogUmVqZWN0cyB3aXRoIGBSZXF1ZXN0UGVuZGluZ0Vycm9yYCBpZiBhIFJFR0lTVEVSIHJlcXVlc3QgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcy5cbiAgICovXG4gIHB1YmxpYyB1bnJlZ2lzdGVyKG9wdGlvbnM6IFJlZ2lzdGVyZXJVbnJlZ2lzdGVyT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxPdXRnb2luZ1JlZ2lzdGVyUmVxdWVzdD4ge1xuICAgIC8vIFVBcyBNVVNUIE5PVCBzZW5kIGEgbmV3IHJlZ2lzdHJhdGlvbiAodGhhdCBpcywgY29udGFpbmluZyBuZXcgQ29udGFjdFxuICAgIC8vIGhlYWRlciBmaWVsZCB2YWx1ZXMsIGFzIG9wcG9zZWQgdG8gYSByZXRyYW5zbWlzc2lvbikgdW50aWwgdGhleSBoYXZlXG4gICAgLy8gcmVjZWl2ZWQgYSBmaW5hbCByZXNwb25zZSBmcm9tIHRoZSByZWdpc3RyYXIgZm9yIHRoZSBwcmV2aW91cyBvbmUgb3JcbiAgICAvLyB0aGUgcHJldmlvdXMgUkVHSVNURVIgcmVxdWVzdCBoYXMgdGltZWQgb3V0LlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTAuMlxuICAgIGlmICh0aGlzLndhaXRpbmcpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFJlcXVlc3RQZW5kaW5nRXJyb3IoXCJSRUdJU1RFUiByZXF1ZXN0IGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdhaXRpbmcgZm9yIGZpbmFsIHJlc3BvbnNlXCIpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IFJlZ2lzdGVyZXJTdGF0ZS5SZWdpc3RlcmVkICYmICFvcHRpb25zLmFsbCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcIk5vdCBjdXJyZW50bHkgcmVnaXN0ZXJlZCwgYnV0IHNlbmRpbmcgYW4gdW5yZWdpc3RlciBhbnl3YXkuXCIpO1xuICAgIH1cblxuICAgIC8vIEV4dHJhIGhlYWRlcnNcbiAgICBjb25zdCBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyAmJiBvcHRpb25zLnJlcXVlc3RPcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICB0aGlzLnJlcXVlc3QuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuXG4gICAgLy8gUmVnaXN0cmF0aW9ucyBhcmUgc29mdCBzdGF0ZSBhbmQgZXhwaXJlIHVubGVzcyByZWZyZXNoZWQsIGJ1dCBjYW5cbiAgICAvLyBhbHNvIGJlIGV4cGxpY2l0bHkgcmVtb3ZlZC4gIEEgY2xpZW50IGNhbiBhdHRlbXB0IHRvIGluZmx1ZW5jZSB0aGVcbiAgICAvLyBleHBpcmF0aW9uIGludGVydmFsIHNlbGVjdGVkIGJ5IHRoZSByZWdpc3RyYXIgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb25cbiAgICAvLyAxMC4yLjEuICBBIFVBIHJlcXVlc3RzIHRoZSBpbW1lZGlhdGUgcmVtb3ZhbCBvZiBhIGJpbmRpbmcgYnlcbiAgICAvLyBzcGVjaWZ5aW5nIGFuIGV4cGlyYXRpb24gaW50ZXJ2YWwgb2YgXCIwXCIgZm9yIHRoYXQgY29udGFjdCBhZGRyZXNzIGluXG4gICAgLy8gYSBSRUdJU1RFUiByZXF1ZXN0LiAgVUFzIFNIT1VMRCBzdXBwb3J0IHRoaXMgbWVjaGFuaXNtIHNvIHRoYXRcbiAgICAvLyBiaW5kaW5ncyBjYW4gYmUgcmVtb3ZlZCBiZWZvcmUgdGhlaXIgZXhwaXJhdGlvbiBpbnRlcnZhbCBoYXMgcGFzc2VkLlxuICAgIC8vXG4gICAgLy8gVGhlIFJFR0lTVEVSLXNwZWNpZmljIENvbnRhY3QgaGVhZGVyIGZpZWxkIHZhbHVlIG9mIFwiKlwiIGFwcGxpZXMgdG9cbiAgICAvLyBhbGwgcmVnaXN0cmF0aW9ucywgYnV0IGl0IE1VU1QgTk9UIGJlIHVzZWQgdW5sZXNzIHRoZSBFeHBpcmVzIGhlYWRlclxuICAgIC8vIGZpZWxkIGlzIHByZXNlbnQgd2l0aCBhIHZhbHVlIG9mIFwiMFwiLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTAuMi4yXG4gICAgaWYgKG9wdGlvbnMuYWxsKSB7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6ICpcIik7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaChcIkV4cGlyZXM6IDBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQ29udGFjdDogXCIgKyB0aGlzLmdlbmVyYXRlQ29udGFjdEhlYWRlcigwKSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbC1JRDogQWxsIHJlZ2lzdHJhdGlvbnMgZnJvbSBhIFVBQyBTSE9VTEQgdXNlIHRoZSBzYW1lIENhbGwtSURcbiAgICAvLyBoZWFkZXIgZmllbGQgdmFsdWUgZm9yIHJlZ2lzdHJhdGlvbnMgc2VudCB0byBhIHBhcnRpY3VsYXJcbiAgICAvLyByZWdpc3RyYXIuXG4gICAgLy9cbiAgICAvLyBDU2VxOiBUaGUgQ1NlcSB2YWx1ZSBndWFyYW50ZWVzIHByb3BlciBvcmRlcmluZyBvZiBSRUdJU1RFUlxuICAgIC8vIHJlcXVlc3RzLiAgQSBVQSBNVVNUIGluY3JlbWVudCB0aGUgQ1NlcSB2YWx1ZSBieSBvbmUgZm9yIGVhY2hcbiAgICAvLyBSRUdJU1RFUiByZXF1ZXN0IHdpdGggdGhlIHNhbWUgQ2FsbC1JRC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEwLjJcbiAgICB0aGlzLnJlcXVlc3QuY3NlcSsrO1xuICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoXCJjc2VxXCIsIHRoaXMucmVxdWVzdC5jc2VxICsgXCIgUkVHSVNURVJcIik7XG5cbiAgICAvLyBQcmUtZW1wdGl2ZSBjbGVhciB0aGUgcmVnaXN0cmF0aW9uIHRpbWVyIHRvIGF2b2lkIGEgcmFjZSBjb25kaXRpb24gd2hlcmVcbiAgICAvLyB0aGlzIHRpbWVyIGZpcmVzIHdoaWxlIHdhaXRpbmcgZm9yIGEgZmluYWwgcmVzcG9uc2UgdG8gdGhlIHVuc3Vic2NyaWJlLlxuICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyKTtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy53YWl0aW5nVG9nZ2xlKHRydWUpO1xuXG4gICAgY29uc3Qgb3V0Z29pbmdSZWdpc3RlclJlcXVlc3QgPSB0aGlzLnVzZXJBZ2VudC51c2VyQWdlbnRDb3JlLnJlZ2lzdGVyKHRoaXMucmVxdWVzdCwge1xuICAgICAgb25BY2NlcHQ6IChyZXNwb25zZSk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLl9jb250YWN0cyA9IHJlc3BvbnNlLm1lc3NhZ2UuZ2V0SGVhZGVycyhcImNvbnRhY3RcIik7IC8vIFVwZGF0ZSBjb250YWN0c1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJlZCgpO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUgJiYgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25BY2NlcHQpIHtcbiAgICAgICAgICBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vbkFjY2VwdChyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWl0aW5nVG9nZ2xlKGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzOiAocmVzcG9uc2UpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVxdWVzdERlbGVnYXRlICYmIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblByb2dyZXNzKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUmVkaXJlY3Q6IChyZXNwb25zZSk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlVucmVnaXN0ZXIgcmVkaXJlY3RlZC4gTm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJlZCgpO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUgJiYgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25SZWRpcmVjdCkge1xuICAgICAgICAgIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uUmVkaXJlY3QocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdGluZ1RvZ2dsZShmYWxzZSk7XG4gICAgICB9LFxuICAgICAgb25SZWplY3Q6IChyZXNwb25zZSk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgVW5yZWdpc3RlciByZWplY3RlZCB3aXRoIHN0YXR1cyBjb2RlICR7cmVzcG9uc2UubWVzc2FnZS5zdGF0dXNDb2RlfWApO1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJlZCgpO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUgJiYgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25SZWplY3QpIHtcbiAgICAgICAgICBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblJlamVjdChyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWl0aW5nVG9nZ2xlKGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBvblRyeWluZzogKHJlc3BvbnNlKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblRyeWluZykge1xuICAgICAgICAgIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uVHJ5aW5nKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvdXRnb2luZ1JlZ2lzdGVyUmVxdWVzdCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgcmVnaXN0cmF0aW9uIHRpbWVycy5cbiAgICovXG4gIHByaXZhdGUgY2xlYXJUaW1lcnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uVGltZXIpO1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyKTtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBDb250YWN0IEhlYWRlclxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZUNvbnRhY3RIZWFkZXIoZXhwaXJlczogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBsZXQgY29udGFjdCA9IHRoaXMudXNlckFnZW50LmNvbnRhY3QudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlZ0lkICYmIHRoaXMub3B0aW9ucy5pbnN0YW5jZUlkKSB7XG4gICAgICBjb250YWN0ICs9IFwiO3JlZy1pZD1cIiArIHRoaXMub3B0aW9ucy5yZWdJZDtcbiAgICAgIGNvbnRhY3QgKz0gJzsrc2lwLmluc3RhbmNlPVwiPHVybjp1dWlkOicgKyB0aGlzLm9wdGlvbnMuaW5zdGFuY2VJZCArICc+XCInO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0cmFDb250YWN0SGVhZGVyUGFyYW1zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZXh0cmFDb250YWN0SGVhZGVyUGFyYW1zLmZvckVhY2goKGhlYWRlcjogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnRhY3QgKz0gXCI7XCIgKyBoZWFkZXI7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb250YWN0ICs9IFwiO2V4cGlyZXM9XCIgKyBleHBpcmVzO1xuXG4gICAgcmV0dXJuIGNvbnRhY3Q7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbiByZWdpc3RlcmVkLlxuICAgKi9cbiAgcHJpdmF0ZSByZWdpc3RlcmVkKGV4cGlyZXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcblxuICAgIC8vIFJlLVJlZ2lzdGVyIGJlZm9yZSB0aGUgZXhwaXJhdGlvbiBpbnRlcnZhbCBoYXMgZWxhcHNlZC5cbiAgICAvLyBGb3IgdGhhdCwgZGVjcmVhc2UgdGhlIGV4cGlyZXMgdmFsdWUuIGllOiAzIHNlY29uZHNcbiAgICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWdpc3RlcigpO1xuICAgIH0sIChleHBpcmVzICogMTAwMCkgLSAzMDAwKTtcblxuICAgIC8vIFdlIGFyZSB1bnJlZ2lzdGVyZWQgaWYgdGhlIHJlZ2lzdHJhdGlvbiBleHBpcmVzLlxuICAgIHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiUmVnaXN0cmF0aW9uIGV4cGlyZWRcIik7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJlZCgpO1xuICAgIH0sIGV4cGlyZXMgKiAxMDAwKTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gUmVnaXN0ZXJlclN0YXRlLlJlZ2lzdGVyZWQpIHtcbiAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFJlZ2lzdGVyZXJTdGF0ZS5SZWdpc3RlcmVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbiB1bnJlZ2lzdGVyZWQuXG4gICAqL1xuICBwcml2YXRlIHVucmVnaXN0ZXJlZCgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IFJlZ2lzdGVyZXJTdGF0ZS5VbnJlZ2lzdGVyZWQpIHtcbiAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFJlZ2lzdGVyZXJTdGF0ZS5VbnJlZ2lzdGVyZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24sIGNhbGxlZCB3aGVuIHRlcm1pbmF0ZWQuXG4gICAqL1xuICBwcml2YXRlIHRlcm1pbmF0ZWQoKTogdm9pZCB7XG4gICAgdGhpcy5jbGVhclRpbWVycygpO1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBSZWdpc3RlcmVyU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oUmVnaXN0ZXJlclN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9uIHJlZ2lzdHJhdGlvbiBzdGF0ZS5cbiAgICovXG4gIHByaXZhdGUgc3RhdGVUcmFuc2l0aW9uKG5ld1N0YXRlOiBSZWdpc3RlcmVyU3RhdGUpOiB2b2lkIHtcbiAgICBjb25zdCBpbnZhbGlkVHJhbnNpdGlvbiA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gJHt0aGlzLl9zdGF0ZX0gdG8gJHtuZXdTdGF0ZX1gKTtcbiAgICB9O1xuXG4gICAgLy8gVmFsaWRhdGUgdHJhbnNpdGlvblxuICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgIGNhc2UgUmVnaXN0ZXJlclN0YXRlLkluaXRpYWw6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXdTdGF0ZSAhPT0gUmVnaXN0ZXJlclN0YXRlLlJlZ2lzdGVyZWQgJiZcbiAgICAgICAgICBuZXdTdGF0ZSAhPT0gUmVnaXN0ZXJlclN0YXRlLlVucmVnaXN0ZXJlZCAmJlxuICAgICAgICAgIG5ld1N0YXRlICE9PSBSZWdpc3RlcmVyU3RhdGUuVGVybWluYXRlZFxuICAgICAgICApIHtcbiAgICAgICAgICBpbnZhbGlkVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSZWdpc3RlcmVyU3RhdGUuUmVnaXN0ZXJlZDpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5ld1N0YXRlICE9PSBSZWdpc3RlcmVyU3RhdGUuVW5yZWdpc3RlcmVkICYmXG4gICAgICAgICAgbmV3U3RhdGUgIT09IFJlZ2lzdGVyZXJTdGF0ZS5UZXJtaW5hdGVkXG4gICAgICAgICkge1xuICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJlZ2lzdGVyZXJTdGF0ZS5VbnJlZ2lzdGVyZWQ6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXdTdGF0ZSAhPT0gUmVnaXN0ZXJlclN0YXRlLlJlZ2lzdGVyZWQgJiZcbiAgICAgICAgICBuZXdTdGF0ZSAhPT0gUmVnaXN0ZXJlclN0YXRlLlRlcm1pbmF0ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW52YWxpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmVnaXN0ZXJlclN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHN0YXRlLlwiKTtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2l0aW9uXG4gICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB0aGlzLmxvZ2dlci5sb2coYFJlZ2lzdHJhdGlvbiB0cmFuc2l0aW9uZWQgdG8gc3RhdGUgJHt0aGlzLl9zdGF0ZX1gKTtcbiAgICB0aGlzLl9zdGF0ZUV2ZW50RW1pdHRlci5lbWl0KFwiZXZlbnRcIiwgdGhpcy5fc3RhdGUpO1xuXG4gICAgLy8gRGlzcG9zZVxuICAgIGlmIChuZXdTdGF0ZSA9PT0gUmVnaXN0ZXJlclN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUcnVlIGlmIHRoZSByZWdpc3RlcmVyIGlzIGN1cnJlbnRseSB3YWl0aW5nIGZvciBmaW5hbCByZXNwb25zZSB0byBhIFJFR0lTVEVSIHJlcXVlc3QuICovXG4gIHByaXZhdGUgZ2V0IHdhaXRpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3dhaXRpbmc7XG4gIH1cblxuICAvKiogRW1pdHMgd2hlbiB0aGUgcmVnaXN0ZXJlciB3YWl0aW5nIHN0YXRlIGNoYW5nZXMuICovXG4gIHByaXZhdGUgZ2V0IHdhaXRpbmdDaGFuZ2UoKTogRW1pdHRlcjxib29sZWFuPiB7XG4gICAgcmV0dXJuIF9tYWtlRW1pdHRlcih0aGlzLl93YWl0aW5nRXZlbnRFbWl0dGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgd2FpdGluZy5cbiAgICovXG4gIHByaXZhdGUgd2FpdGluZ1RvZ2dsZSh3YWl0aW5nOiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3dhaXRpbmcgPT09IHdhaXRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3YWl0aW5nIHRyYW5zaXRpb24gZnJvbSAke3RoaXMuX3dhaXRpbmd9IHRvICR7d2FpdGluZ31gKTtcbiAgICB9XG4gICAgdGhpcy5fd2FpdGluZyA9IHdhaXRpbmc7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBXYWl0aW5nIHRvZ2dsZWQgdG8gJHt0aGlzLl93YWl0aW5nfWApO1xuICAgIHRoaXMuX3dhaXRpbmdFdmVudEVtaXR0ZXIuZW1pdChcImV2ZW50XCIsIHRoaXMuX3dhaXRpbmcpO1xuICB9XG59XG4iLCIvKipcbiAqIHtAbGluayBTZXNzaW9ufSBzdGF0ZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHtAbGluayBTZXNzaW9ufSBiZWhhdmVzIGluIGEgZGV0ZXJtaW5pc3RpYyBtYW5uZXIgYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmdcbiAqIEZpbml0ZSBTdGF0ZSBNYWNoaW5lIChGU00pLlxuICogYGBgdHh0XG4gKiAgICAgICAgICAgICAgICAgICBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICogICAgICAgICAgICAgICAgICB8ICBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX18gICAgfCAgICAgICAgICAgIHxcbiAqIFNlc3Npb24gICAgICAgICAgfCB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgICB2ICAgICAgICAgICAgdlxuICogQ29uc3RydWN0ZWQgLT4gSW5pdGlhbCAtPiBFc3RhYmxpc2hpbmcgLT4gRXN0YWJsaXNoZWQgLT4gVGVybWluYXRpbmcgLT4gVGVybWluYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICB8X19fX19fX19fX19fX19fX19fX19fX19fX19fXiAgIF5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGVudW0gU2Vzc2lvblN0YXRlIHtcbiAgLyoqXG4gICAqIElmIGBJbnZpdGVyYCwgSU5WSVRFIG5vdCBzZW50IHlldC5cbiAgICogSWYgYEludml0YXRpb25gLCByZWNlaXZlZCBJTlZJVEUgKGJ1dCBubyBmaW5hbCByZXNwb25zZSBzZW50IHlldCkuXG4gICAqL1xuICBJbml0aWFsID0gXCJJbml0aWFsXCIsXG4gIC8qKlxuICAgKiBJZiBgSW52aXRlcmAsIHNlbnQgSU5WSVRFIGFuZCB3YWl0aW5nIGZvciBhIGZpbmFsIHJlc3BvbnNlLlxuICAgKiBJZiBgSW52aXRhdGlvbmAsIHJlY2VpdmVkIElOVklURSBhbmQgYXR0ZW1wdGluZyB0byBzZW5kIDIwMCBmaW5hbCByZXNwb25zZSAoYnV0IGhhcyBub3Qgc2VudCBpdCB5ZXQpLlxuICAgKi9cbiAgRXN0YWJsaXNoaW5nID0gXCJFc3RhYmxpc2hpbmdcIixcbiAgLyoqXG4gICAqIElmIGBJbnZpdGVyYCwgc2VudCBJTlZJVEUgYW5kIHJlY2VpdmVkIDIwMCBmaW5hbCByZXNwb25zZSBhbmQgc2VudCBBQ0suXG4gICAqIElmIGBJbnZpdGF0aW9uYCwgcmVjZWl2ZWQgSU5WSVRFIGFuZCBzZW50IDIwMCBmaW5hbCByZXNwb25zZS5cbiAgICovXG4gIEVzdGFibGlzaGVkID0gXCJFc3RhYmxpc2hlZFwiLFxuICAvKipcbiAgICogSWYgYEludml0ZXJgLCBzZW50IElOVklURSwgc2VudCBDQU5DRUwgYW5kIG5vdyB3YWl0aW5nIGZvciA0ODcgZmluYWwgcmVzcG9uc2UgdG8gQUNLIChvciAyMDAgdG8gQUNLICYgQllFKS5cbiAgICogSWYgYEludml0YXRpb25gLCByZWNlaXZlZCBJTlZJVEUsIHNlbnQgMjAwIGZpbmFsIHJlc3BvbnNlIGFuZCBub3cgd2FpdGluZyBvbiBBQ0sgYW5kIHVwb24gcmVjZWlwdCB3aWxsIGF0dGVtcHQgQllFXG4gICAqIChhcyB0aGUgcHJvdG9jb2wgc3BlY2lmaWNhdGlvbiByZXF1aXJlcywgYmVmb3JlIHNlbmRpbmcgYSBCWUUgd2UgbXVzdCByZWNlaXZlIHRoZSBBQ0sgLSBzbyB3ZSBhcmUgd2FpdGluZykuXG4gICAqL1xuICBUZXJtaW5hdGluZyA9IFwiVGVybWluYXRpbmdcIixcbiAgLyoqXG4gICAqIElmIGBJbnZpdGVyYCwgc2VudCBJTlZJVEUgYW5kIHJlY2VpdmVkIG5vbi0yMDAgZmluYWwgcmVzcG9uc2UgKG9yIHNlbnQvcmVjZWl2ZWQgQllFIGFmdGVyIHJlY2VpdmluZyAyMDApLlxuICAgKiBJZiBgSW52aXRhdGlvbmAsIHJlY2VpdmVkIElOVklURSBhbmQgc2VudCBub24tMjAwIGZpbmFsIHJlc3BvbnNlIChvciBzZW50L3JlY2VpdmVkIEJZRSBhZnRlciBzZW5kaW5nIDIwMCkuXG4gICAqL1xuICBUZXJtaW5hdGVkID0gXCJUZXJtaW5hdGVkXCJcbn1cbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudHNcIjtcblxuaW1wb3J0IHtcbiAgQWNrYWJsZUluY29taW5nUmVzcG9uc2VXaXRoU2Vzc2lvbixcbiAgQm9keSxcbiAgZnJvbUJvZHlMZWdhY3ksXG4gIGdldEJvZHksXG4gIEdyYW1tYXIsXG4gIEluY29taW5nQWNrUmVxdWVzdCxcbiAgSW5jb21pbmdCeWVSZXF1ZXN0LFxuICBJbmNvbWluZ0luZm9SZXF1ZXN0LFxuICBJbmNvbWluZ0ludml0ZVJlcXVlc3QsXG4gIEluY29taW5nTm90aWZ5UmVxdWVzdCxcbiAgSW5jb21pbmdQcmFja1JlcXVlc3QsXG4gIEluY29taW5nUmVmZXJSZXF1ZXN0LFxuICBMb2dnZXIsXG4gIE5hbWVBZGRySGVhZGVyLFxuICBPdXRnb2luZ0J5ZVJlcXVlc3QsXG4gIE91dGdvaW5nSW52aXRlUmVxdWVzdCxcbiAgT3V0Z29pbmdJbnZpdGVSZXF1ZXN0RGVsZWdhdGUsXG4gIE91dGdvaW5nUmVxdWVzdERlbGVnYXRlLFxuICBSZXF1ZXN0T3B0aW9ucyxcbiAgU2Vzc2lvbiBhcyBTZXNzaW9uRGlhbG9nLFxuICBTZXNzaW9uU3RhdGUgYXMgU2Vzc2lvbkRpYWxvZ1N0YXRlLFxuICBTaWduYWxpbmdTdGF0ZVxufSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgZ2V0UmVhc29uUGhyYXNlIH0gZnJvbSBcIi4uL2NvcmUvbWVzc2FnZXMvdXRpbHNcIjtcbmltcG9ydCB7IEFsbG93ZWRNZXRob2RzIH0gZnJvbSBcIi4uL2NvcmUvdXNlci1hZ2VudC1jb3JlL2FsbG93ZWQtbWV0aG9kc1wiO1xuaW1wb3J0IHsgX21ha2VFbWl0dGVyLCBFbWl0dGVyIH0gZnJvbSBcIi4vZW1pdHRlclwiO1xuaW1wb3J0IHsgQ29udGVudFR5cGVVbnN1cHBvcnRlZEVycm9yLCBSZXF1ZXN0UGVuZGluZ0Vycm9yIH0gZnJvbSBcIi4vZXhjZXB0aW9uc1wiO1xuaW1wb3J0IHsgSW5mbyB9IGZyb20gXCIuL2luZm9cIjtcbmltcG9ydCB7IEludml0ZXIgfSBmcm9tIFwiLi9pbnZpdGVyXCI7XG5pbXBvcnQgeyBJbnZpdGVyT3B0aW9ucyB9IGZyb20gXCIuL2ludml0ZXItb3B0aW9uc1wiO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uIH0gZnJvbSBcIi4vbm90aWZpY2F0aW9uXCI7XG5pbXBvcnQgeyBSZWZlcnJhbCB9IGZyb20gXCIuL3JlZmVycmFsXCI7XG5pbXBvcnQgeyBSZWZlcnJlciB9IGZyb20gXCIuL3JlZmVycmVyXCI7XG5pbXBvcnQgeyBTZXNzaW9uRGVsZWdhdGUgfSBmcm9tIFwiLi9zZXNzaW9uLWRlbGVnYXRlXCI7XG5pbXBvcnQge1xuICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLFxuICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXIsXG4gIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zXG59IGZyb20gXCIuL3Nlc3Npb24tZGVzY3JpcHRpb24taGFuZGxlclwiO1xuaW1wb3J0IHsgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkgfSBmcm9tIFwiLi9zZXNzaW9uLWRlc2NyaXB0aW9uLWhhbmRsZXItZmFjdG9yeVwiO1xuaW1wb3J0IHsgU2Vzc2lvbkludml0ZU9wdGlvbnMgfSBmcm9tIFwiLi9zZXNzaW9uLWludml0ZS1vcHRpb25zXCI7XG5pbXBvcnQgeyBTZXNzaW9uT3B0aW9ucyB9IGZyb20gXCIuL3Nlc3Npb24tb3B0aW9uc1wiO1xuaW1wb3J0IHsgU2Vzc2lvblN0YXRlIH0gZnJvbSBcIi4vc2Vzc2lvbi1zdGF0ZVwiO1xuaW1wb3J0IHsgVXNlckFnZW50IH0gZnJvbSBcIi4vdXNlci1hZ2VudFwiO1xuXG4vKipcbiAqIEEgc2Vzc2lvbiBwcm92aWRlcyByZWFsIHRpbWUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIG9uZSBvciBtb3JlIHBhcnRpY2lwYW50cy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHRyYW5zcG9ydCBiZWhhdmVzIGluIGEgZGV0ZXJtaW5pc3RpYyBtYW5uZXIgYWNjb3JkaW5nIHRvIHRoZVxuICogdGhlIHN0YXRlIGRlZmluZWQgaW4ge0BsaW5rIFNlc3Npb25TdGF0ZX0uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTZXNzaW9uIHtcblxuICAvKipcbiAgICogUHJvcGVydHkgcmVzZXJ2ZWQgZm9yIHVzZSBieSBpbnN0YW5jZSBvd25lci5cbiAgICogQGRlZmF1bHRWYWx1ZSBgdW5kZWZpbmVkYFxuICAgKi9cbiAgcHVibGljIGRhdGE6IGFueTtcblxuICAvKipcbiAgICogVGhlIHNlc3Npb24gZGVsZWdhdGUuXG4gICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcbiAgICovXG4gIHB1YmxpYyBkZWxlZ2F0ZTogU2Vzc2lvbkRlbGVnYXRlIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpdHkgb2YgdGhlIGxvY2FsIHVzZXIuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgbG9jYWxJZGVudGl0eTogTmFtZUFkZHJIZWFkZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBpZGVudGl0eSBvZiB0aGUgcmVtb3RlIHVzZXIuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgcmVtb3RlSWRlbnRpdHk6IE5hbWVBZGRySGVhZGVyO1xuXG4gIC8vXG4gIC8vIFB1YmxpYyBwcm9wZXJ0aWVzIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAvL1xuICAvKiogQGludGVybmFsICovXG4gIHB1YmxpYyBfY29udGFjdDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIHB1YmxpYyBfcmVmZXJyYWw6IEludml0ZXIgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIF9yZWZlcnJlcjogUmVmZXJyZXIgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIF9yZXBsYWNlZTogU2Vzc2lvbiB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogTG9nZ2VyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGxvZ2dlcjogTG9nZ2VyO1xuXG4gIC8vXG4gIC8vIFByb3RlY3RlZCBwcm9wZXJ0aWVzIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAvL1xuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfaWQ6IHN0cmluZztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQgX2Fzc2VydGVkSWRlbnRpdHk6IE5hbWVBZGRySGVhZGVyIHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCBfZGlhbG9nOiBTZXNzaW9uRGlhbG9nIHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCBfcmVmZXJyYWxJbnZpdGVyT3B0aW9uczogSW52aXRlck9wdGlvbnMgfCB1bmRlZmluZWQ7IC8vIEZJWE1FOiBUaGlzIGlzIG5vdCBnZXR0aW5nIHNldCBieSBJbnZpdGF0aW9uXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJvdGVjdGVkIF9yZW5kZXJib2R5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJvdGVjdGVkIF9yZW5kZXJ0eXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJvdGVjdGVkIF9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzOiBBcnJheTxTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXI+IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCBfc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM6IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zIHwgdW5kZWZpbmVkO1xuXG4gIC8qKiBUcnVlIGlmIHRoZXJlIGlzIGEgcmUtSU5WSVRFIHJlcXVlc3Qgb3V0c3RhbmRpbmcuICovXG4gIHByaXZhdGUgcGVuZGluZ1JlaW52aXRlOiBib29sZWFuID0gZmFsc2U7XG4gIC8qKiBEaWFsb2dzIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlci4gKi9cbiAgcHJpdmF0ZSBfc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcjogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciB8IHVuZGVmaW5lZDtcbiAgLyoqIFNlc3Npb24gc3RhdGUuICovXG4gIHByaXZhdGUgX3N0YXRlOiBTZXNzaW9uU3RhdGUgPSBTZXNzaW9uU3RhdGUuSW5pdGlhbDtcbiAgLyoqIFNlc3Npb24gc3RhdGUgZW1pdHRlci4gKi9cbiAgcHJpdmF0ZSBfc3RhdGVFdmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIC8qKiBVc2VyIGFnZW50LiAqL1xuICBwcml2YXRlIF91c2VyQWdlbnQ6IFVzZXJBZ2VudDtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB1c2VyQWdlbnQgLSBVc2VyIGFnZW50LiBTZWUge0BsaW5rIFVzZXJBZ2VudH0gZm9yIGRldGFpbHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHVzZXJBZ2VudDogVXNlckFnZW50LCBvcHRpb25zOiBTZXNzaW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IG9wdGlvbnMuZGVsZWdhdGU7XG4gICAgdGhpcy5fdXNlckFnZW50ID0gdXNlckFnZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3RydWN0b3IuXG4gICAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYFNlc3Npb24gJHt0aGlzLmlkfSBpbiBzdGF0ZSAke3RoaXMuX3N0YXRlfSBpcyBiZWluZyBkaXNwb3NlZGApO1xuXG4gICAgLy8gUmVtb3ZlIGZyb20gdGhlIHVzZXIgYWdlbnQncyBzZXNzaW9uIGNvbGxlY3Rpb25cbiAgICBkZWxldGUgdGhpcy51c2VyQWdlbnQuX3Nlc3Npb25zW3RoaXMuaWRdO1xuXG4gICAgLy8gRGlzcG9zZSBvZiBkaWFsb2cgbWVkaWFcbiAgICBpZiAodGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5jbG9zZSgpO1xuXG4gICAgICAvLyBUT0RPOiBUaGUgU0RIIG5lZWRzIHRvIHJlbWFpbiBkZWZpbmVkIGFzIGl0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IGlzIGNsb3NlZCBpbiBjYXNlc1xuICAgICAgLy8gd2hlcmUgYW4gYW5zd2VyL29mZmVyIGFycml2ZXMgd2hpbGUgdGhlIHNlc3Npb24gaXMgYmVpbmcgdG9ybiBkb3duLiBUaGVyZSBhcmUgYSB2YXJpZXR5XG4gICAgICAvLyBvZiBjaXJjdW1zdGFuY2VzIHdoZXJlIHRoaXMgY2FuIGhhcHBlbiAtIHNlbmRpbmcgYSBCWUUgZHVyaW5nIGEgcmUtSU5WSVRFIGZvciBleGFtcGxlLlxuICAgICAgLy8gVGhlIGNvZGUgaXMgY3VycmVudGx5IHdyaXR0ZW4gc3VjaCB0aGF0IGl0IGxhemlseSBtYWtlcyBhIG5ldyBTREggd2hlbiBpdCBuZWVkcyBvbmVcbiAgICAgIC8vIGFuZCBvbmUgaXMgbm90IHlldCBkZWZpbmVkLiBUaHVzIGlmIHdlIHVuZGVmaW5lZCBpdCBoZXJlLCBpdCB3aWxsIGN1cnJlbnRseSBtYWtlIGFcbiAgICAgIC8vIG5ldyBvbmUgd2hpY2ggaXMgb3V0IG9mIHN5bmMgYW5kIHRoZW4gbmV2ZXIgZ2V0cyBjbGVhbmVkIHVwLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBkb3duc2lkZSBvZiBsZWF2aW5nIGl0IGRlZmluZWQgYXJlIHRoYXQgY2FsbHMgdGhpcyBjbG9zZWQgU0RIIHdpbGwgY29udGludWUgdG8gYmVcbiAgICAgIC8vIG1hZGUgKHRoaW5rIHNldERlc2NyaXB0aW9uKSBhbmQgdGhvc2Ugc2hvdWxkL3dpbGwgZmFpbC4gVGhlc2UgZmFpbHVyZXMgYXJlIGhhbmRsZWQsIGJ1dFxuICAgICAgLy8gaXQgd291bGQgYmUgbmljZSB0byBoYXZlIGl0IGFsbCBjb2RlZCB1cCBpbiBhIHdheSB3aGVyZSBoYXZpbmcgYW4gdW5kZWZpbmVkIFNESCB3aGVyZVxuICAgICAgLy8gb25lIGlzIGV4cGVjdGVkIHRocm93cyBhbiBlcnJvci5cbiAgICAgIC8vXG4gICAgICAvLyB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTZXNzaW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgYnJlYWs7IC8vIHRoZSBJbnZpdGVyL0ludml0YXRpb24gc3ViIGNsYXNzIGRpc3Bvc2UgbWV0aG9kIGhhbmRsZXMgdGhpcyBjYXNlXG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmc6XG4gICAgICAgIGJyZWFrOyAvLyB0aGUgSW52aXRlci9JbnZpdGF0aW9uIHN1YiBjbGFzcyBkaXNwb3NlIG1ldGhvZCBoYW5kbGVzIHRoaXMgY2FzZVxuICAgICAgY2FzZSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQ6XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5fYnllKHsgLy8gd2FpdCBmb3IgdGhlIHJlc3BvbnNlIHRvIHRoZSBCWUUgYmVmb3JlIHJlc29sdmluZ1xuICAgICAgICAgICAgb25BY2NlcHQ6ICgpID0+IHJlc29sdmUoKSxcbiAgICAgICAgICAgIG9uUmVkaXJlY3Q6ICgpID0+IHJlc29sdmUoKSxcbiAgICAgICAgICAgIG9uUmVqZWN0OiAoKSA9PiByZXNvbHZlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZzpcbiAgICAgICAgYnJlYWs7IC8vIG5vdGhpbmcgdG8gYmUgZG9uZVxuICAgICAgY2FzZSBTZXNzaW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgYnJlYWs7IC8vIG5vdGhpbmcgdG8gYmUgZG9uZVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdGF0ZS5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhc3NlcnRlZCBpZGVudGl0eSBvZiB0aGUgcmVtb3RlIHVzZXIuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFzc2VydGVkSWRlbnRpdHkoKTogTmFtZUFkZHJIZWFkZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9hc3NlcnRlZElkZW50aXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb25maXJtZWQgc2Vzc2lvbiBkaWFsb2cuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGRpYWxvZygpOiBTZXNzaW9uRGlhbG9nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fZGlhbG9nO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICovXG4gIHB1YmxpYyBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNlc3Npb24gYmVpbmcgcmVwbGFjZSBieSB0aGlzIG9uZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgcmVwbGFjZWUoKTogU2Vzc2lvbiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGxhY2VlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlci5cbiAgICogQHJlbWFya3NcbiAgICogSWYgYHRoaXNgIGlzIGFuIGluc3RhbmNlIG9mIGBJbnZpdGF0aW9uYCxcbiAgICogYHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJgIHdpbGwgYmUgZGVmaW5lZCB3aGVuIHRoZSBzZXNzaW9uIHN0YXRlIGNoYW5nZXMgdG8gXCJlc3RhYmxpc2hlZFwiLlxuICAgKiBJZiBgdGhpc2AgaXMgYW4gaW5zdGFuY2Ugb2YgYEludml0ZXJgIGFuZCBhbiBvZmZlciB3YXMgc2VudCBpbiB0aGUgSU5WSVRFLFxuICAgKiBgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcmAgd2lsbCBiZSBkZWZpbmVkIHdoZW4gdGhlIHNlc3Npb24gc3RhdGUgY2hhbmdlcyB0byBcImVzdGFibGlzaGluZ1wiLlxuICAgKiBJZiBgdGhpc2AgaXMgYW4gaW5zdGFuY2Ugb2YgYEludml0ZXJgIGFuZCBhbiBvZmZlciB3YXMgbm90IHNlbnQgaW4gdGhlIElOVklURSxcbiAgICogYHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJgIHdpbGwgYmUgZGVmaW5lZCB3aGVuIHRoZSBzZXNzaW9uIHN0YXRlIGNoYW5nZXMgdG8gXCJlc3RhYmxpc2hlZFwiLlxuICAgKiBPdGhlcndpc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIoKTogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG4gIH1cblxuICAvKipcbiAgICogU2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGZhY3RvcnkuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5KCk6IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5IHtcbiAgICByZXR1cm4gdGhpcy51c2VyQWdlbnQuY29uZmlndXJhdGlvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXNzaW9uIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGdldCBzdGF0ZSgpOiBTZXNzaW9uU3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXNzaW9uIHN0YXRlIGNoYW5nZSBlbWl0dGVyLlxuICAgKi9cbiAgcHVibGljIGdldCBzdGF0ZUNoYW5nZSgpOiBFbWl0dGVyPFNlc3Npb25TdGF0ZT4ge1xuICAgIHJldHVybiBfbWFrZUVtaXR0ZXIodGhpcy5fc3RhdGVFdmVudEVtaXR0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB1c2VyIGFnZW50LlxuICAgKi9cbiAgcHVibGljIGdldCB1c2VyQWdlbnQoKTogVXNlckFnZW50IHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckFnZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmVnb3RpYXRlIHRoZSBzZXNzaW9uLiBTZW5kcyBhIHJlLUlOVklURS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHB1YmxpYyBpbnZpdGUob3B0aW9uczogU2Vzc2lvbkludml0ZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8T3V0Z29pbmdJbnZpdGVSZXF1ZXN0PiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbi5pbnZpdGVcIik7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgSW52YWxpZCBzZXNzaW9uIHN0YXRlICR7dGhpcy5zdGF0ZX1gKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBlbmRpbmdSZWludml0ZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgUmVxdWVzdFBlbmRpbmdFcnJvcihcIlJlaW52aXRlIGluIHByb2dyZXNzLiBQbGVhc2Ugd2FpdCB1bnRpbCBjb21wbGV0ZSwgdGhlbiB0cnkgYWdhaW4uXCJcbiAgICAgICkpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdSZWludml0ZSA9IHRydWU7XG5cbiAgICBjb25zdCBkZWxlZ2F0ZTogT3V0Z29pbmdJbnZpdGVSZXF1ZXN0RGVsZWdhdGUgPSB7XG4gICAgICBvbkFjY2VwdDogKHJlc3BvbnNlKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIEEgcmUtSU5WSVRFIHRyYW5zYWN0aW9uIGhhcyBhbiBvZmZlci9hbnN3ZXIgW1JGQzMyNjRdIGV4Y2hhbmdlXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aCBpdC4gIFRoZSBVQUMgKFVzZXIgQWdlbnQgQ2xpZW50KSBnZW5lcmF0aW5nIGEgZ2l2ZW5cbiAgICAgICAgLy8gcmUtSU5WSVRFIGNhbiBhY3QgYXMgdGhlIG9mZmVyZXIgb3IgYXMgdGhlIGFuc3dlcmVyLiAgQSBVQUMgd2lsbGluZ1xuICAgICAgICAvLyB0byBhY3QgYXMgdGhlIG9mZmVyZXIgaW5jbHVkZXMgYW4gb2ZmZXIgaW4gdGhlIHJlLUlOVklURS4gIFRoZSBVQVNcbiAgICAgICAgLy8gKFVzZXIgQWdlbnQgU2VydmVyKSB0aGVuIHByb3ZpZGVzIGFuIGFuc3dlciBpbiBhIHJlc3BvbnNlIHRvIHRoZVxuICAgICAgICAvLyByZS1JTlZJVEUuICBBIFVBQyB3aWxsaW5nIHRvIGFjdCBhcyBhbnN3ZXJlciBkb2VzIG5vdCBpbmNsdWRlIGFuXG4gICAgICAgIC8vIG9mZmVyIGluIHRoZSByZS1JTlZJVEUuICBUaGUgVUFTIHRoZW4gcHJvdmlkZXMgYW4gb2ZmZXIgaW4gYSByZXNwb25zZVxuICAgICAgICAvLyB0byB0aGUgcmUtSU5WSVRFIGJlY29taW5nLCB0aHVzLCB0aGUgb2ZmZXJlci5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYxNDEjc2VjdGlvbi0xXG4gICAgICAgIGNvbnN0IGJvZHkgPSBnZXRCb2R5KHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAvLyBObyB3YXkgdG8gcmVjb3Zlciwgc28gdGVybWluYXRlIHNlc3Npb24gYW5kIG1hcmsgYXMgZmFpbGVkLlxuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiUmVjZWl2ZWQgMnh4IHJlc3BvbnNlIHRvIHJlLUlOVklURSB3aXRob3V0IGEgc2Vzc2lvbiBkZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICB0aGlzLmFja0FuZEJ5ZShyZXNwb25zZSwgNDAwLCBcIk1pc3Npbmcgc2Vzc2lvbiBkZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy53aXRob3V0U2RwKSB7XG4gICAgICAgICAgLy8gSU5WSVRFIHdpdGhvdXQgU0RQIC0gc2V0IHJlbW90ZSBvZmZlciBhbmQgc2VuZCBhbiBhbnN3ZXIgaW4gdGhlIEFDS1xuICAgICAgICAgIC8vIEZJWE1FOiBTREggb3B0aW9ucyAmIFNESCBtb2RpZmllcnMgb3B0aW9ucyBhcmUgYXBwbGllZCBzb21ld2hhdCBhbWJpZ3VvdXNseVxuICAgICAgICAgIC8vICAgICAgICBUaGlzIGJlaGF2aW9yIHdhcyBwb3J0ZWQgZnJvbSBsZWdhY3kgY29kZSBhbmQgdGhlIGlzc3VlIHB1bnRlZCBkb3duIHRoZSByb2FkLlxuICAgICAgICAgIGNvbnN0IGFuc3dlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9uczogb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyxcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM6IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyc1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5zZXRPZmZlckFuZEdldEFuc3dlcihib2R5LCBhbnN3ZXJPcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oKGFuc3dlckJvZHkpID0+IHtcbiAgICAgICAgICAgICAgcmVzcG9uc2UuYWNrKHsgYm9keTogYW5zd2VyQm9keSB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyBObyB3YXkgdG8gcmVjb3Zlciwgc28gdGVybWluYXRlIHNlc3Npb24gYW5kIG1hcmsgYXMgZmFpbGVkLlxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBoYW5kbGUgb2ZmZXIgaW4gMnh4IHJlc3BvbnNlIHRvIHJlLUlOVklURVwiKTtcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTZXNzaW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEEgQllFIHNob3VsZCBub3QgYmUgc2VudCBpZiBhbHJlYWR5IHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGEgQllFIG1heSBiZSBzZW50L3JlY2VpdmVkIHdoaWxlIHJlLUlOVklURSBpcyBvdXRzdGFuZGluZy5cbiAgICAgICAgICAgICAgICByZXNwb25zZS5hY2soKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFja0FuZEJ5ZShyZXNwb25zZSwgNDg4LCBcIkJhZCBNZWRpYSBEZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vbkFjY2VwdCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uQWNjZXB0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSU5WSVRFIHdpdGggU0RQIC0gc2V0IHJlbW90ZSBhbnN3ZXIgYW5kIHNlbmQgYW4gQUNLXG4gICAgICAgICAgLy8gRklYTUU6IFNESCBvcHRpb25zICYgU0RIIG1vZGlmaWVycyBvcHRpb25zIGFyZSBhcHBsaWVkIHNvbWV3aGF0IGFtYmlndW91c2x5XG4gICAgICAgICAgLy8gICAgICAgIFRoaXMgYmVoYXZpb3Igd2FzIHBvcnRlZCBmcm9tIGxlZ2FjeSBjb2RlIGFuZCB0aGUgaXNzdWUgcHVudGVkIGRvd24gdGhlIHJvYWQuXG4gICAgICAgICAgY29uc3QgYW5zd2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyxcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM6IHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuc2V0QW5zd2VyKGJvZHksIGFuc3dlck9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlLmFjaygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIC8vIE5vIHdheSB0byByZWNvdmVyLCBzbyB0ZXJtaW5hdGUgc2Vzc2lvbiBhbmQgbWFyayBhcyBmYWlsZWQuXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGhhbmRsZSBhbnN3ZXIgaW4gMnh4IHJlc3BvbnNlIHRvIHJlLUlOVklURVwiKTtcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgIC8vIEEgQllFIHNob3VsZCBvbmx5IGJlIHNlbnQgaWYgc2Vzc2lvbiBpcyBub3QgYWxyZWFkeSB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgYSBCWUUgbWF5IGJlIHNlbnQvcmVjZWl2ZWQgd2hpbGUgcmUtSU5WSVRFIGlzIG91dHN0YW5kaW5nLlxuICAgICAgICAgICAgICAvLyBUaGUgQUNLIG5lZWRzIHRvIGJlIHNlbnQgcmVnYXJkbGVzcyBhcyBpdCB3YXMgbm90IGhhbmRsZWQgYnkgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFja0FuZEJ5ZShyZXNwb25zZSwgNDg4LCBcIkJhZCBNZWRpYSBEZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vbkFjY2VwdCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uQWNjZXB0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzOiAocmVzcG9uc2UpOiB2b2lkID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSxcbiAgICAgIG9uUmVkaXJlY3Q6IChyZXNwb25zZSk6IHZvaWQgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgICB9LFxuICAgICAgb25SZWplY3Q6IChyZXNwb25zZSk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiUmVjZWl2ZWQgYSBub24tMnh4IHJlc3BvbnNlIHRvIHJlLUlOVklURVwiKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2l0aG91dFNkcCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblJlamVjdCkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25SZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJvbGxiYWNrT2ZmZXIoKVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgLy8gTm8gd2F5IHRvIHJlY292ZXIsIHNvIHRlcm1pbmF0ZSBzZXNzaW9uIGFuZCBtYXJrIGFzIGZhaWxlZC5cbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gcm9sbGJhY2sgb2ZmZXIgb24gbm9uLTJ4eCByZXNwb25zZSB0byByZS1JTlZJVEVcIik7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAvLyBBIEJZRSBzaG91bGQgb25seSBiZSBzZW50IGlmIHNlc3Npb24gaXMgbm90IGFscmVhZHkgdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGEgQllFIG1heSBiZSBzZW50L3JlY2VpdmVkIHdoaWxlIHJlLUlOVklURSBpcyBvdXRzdGFuZGluZy5cbiAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBBQ0sgd2FzIGFscmVhZHkgc2VudCBieSB0aGUgdHJhbnNhY3Rpb24sIHNvIGp1c3QgbmVlZCB0byBzZW5kIEJZRS5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhSGVhZGVyczogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVhc29uOiBcIiArIHRoaXMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoNTAwLCBcIkludGVybmFsIFNlcnZlciBFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFsb2cuYnllKHVuZGVmaW5lZCwgeyBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUgJiYgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25SZWplY3QpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Ucnlpbmc6IChyZXNwb25zZSk6IHZvaWQgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyB8fCB7fTtcbiAgICByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMgPSAocmVxdWVzdE9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgIHJlcXVlc3RPcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiQWxsb3c6IFwiICsgQWxsb3dlZE1ldGhvZHMudG9TdHJpbmcoKSk7XG4gICAgcmVxdWVzdE9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goXCJDb250YWN0OiBcIiArIHRoaXMuX2NvbnRhY3QpO1xuXG4gICAgLy8gSnVzdCBzZW5kIGFuIElOVklURSB3aXRoIG5vIHNkcC4uLlxuICAgIGlmIChvcHRpb25zLndpdGhvdXRTZHApIHtcbiAgICAgIGlmICghdGhpcy5kaWFsb2cpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZGlhbG9nLmludml0ZShkZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYW4gb2ZmZXIgYW5kIHNlbmQgaXQgaW4gYW4gSU5WSVRFXG4gICAgLy8gRklYTUU6IFNESCBvcHRpb25zICYgU0RIIG1vZGlmaWVycyBvcHRpb25zIGFyZSBhcHBsaWVkIHNvbWV3aGF0IGFtYmlndW91c2x5XG4gICAgLy8gICAgICAgIFRoaXMgYmVoYXZpb3Igd2FzIHBvcnRlZCBmcm9tIGxlZ2FjeSBjb2RlIGFuZCB0aGUgaXNzdWUgcHVudGVkIGRvd24gdGhlIHJvYWQuXG4gICAgY29uc3Qgb2ZmZXJPcHRpb25zID0ge1xuICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM6IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsXG4gICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzOiBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnNcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmdldE9mZmVyKG9mZmVyT3B0aW9ucylcbiAgICAgIC50aGVuKChvZmZlckJvZHkpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuYm9keSA9IG9mZmVyQm9keTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nLmludml0ZShkZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBzZW5kIHJlLUlOVklURVwiKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIFJFRkVSLlxuICAgKiBAcGFyYW0gcmVmZXJyZXIgLSBSZWZlcnJlci5cbiAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnMgYnVja2V0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyByZWZlcihcbiAgICByZWZlcnJlcjogUmVmZXJyZXIsXG4gICAgZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSxcbiAgICBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnNcbiAgKTogUHJvbWlzZTxPdXRnb2luZ0J5ZVJlcXVlc3Q+IHtcbiAgICAvLyBVc2luZyBjb3JlIHNlc3Npb24gZGlhbG9nXG4gICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlNlc3Npb24gZGlhbG9nIHVuZGVmaW5lZC5cIikpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgc2Vzc2lvbiBoYXMgYSByZWZlcnJlciwgaXQgd2lsbCByZWNlaXZlIGFueSBpbi1kaWFsb2cgTk9USUZZIHJlcXVlc3RzLlxuICAgIHRoaXMuX3JlZmVycmVyID0gcmVmZXJyZXI7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmRpYWxvZy5yZWZlcihkZWxlZ2F0ZSwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgQllFLlxuICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9ucyBidWNrZXQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF9ieWUoZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxPdXRnb2luZ0J5ZVJlcXVlc3Q+IHtcbiAgICAvLyBVc2luZyBjb3JlIHNlc3Npb24gZGlhbG9nXG4gICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlNlc3Npb24gZGlhbG9nIHVuZGVmaW5lZC5cIikpO1xuICAgIH1cbiAgICBjb25zdCBkaWFsb2cgPSB0aGlzLmRpYWxvZztcblxuICAgIC8vIFRoZSBjYWxsZXIncyBVQSBNQVkgc2VuZCBhIEJZRSBmb3IgZWl0aGVyIGNvbmZpcm1lZCBvciBlYXJseSBkaWFsb2dzLFxuICAgIC8vIGFuZCB0aGUgY2FsbGVlJ3MgVUEgTUFZIHNlbmQgYSBCWUUgb24gY29uZmlybWVkIGRpYWxvZ3MsIGJ1dCBNVVNUIE5PVFxuICAgIC8vIHNlbmQgYSBCWUUgb24gZWFybHkgZGlhbG9ncy4gSG93ZXZlciwgdGhlIGNhbGxlZSdzIFVBIE1VU1QgTk9UIHNlbmQgYVxuICAgIC8vIEJZRSBvbiBhIGNvbmZpcm1lZCBkaWFsb2cgdW50aWwgaXQgaGFzIHJlY2VpdmVkIGFuIEFDSyBmb3IgaXRzIDJ4eFxuICAgIC8vIHJlc3BvbnNlIG9yIHVudGlsIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gdGltZXMgb3V0LlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTVcbiAgICBzd2l0Y2ggKGRpYWxvZy5zZXNzaW9uU3RhdGUpIHtcbiAgICAgIGNhc2UgU2Vzc2lvbkRpYWxvZ1N0YXRlLkluaXRpYWw6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkaWFsb2cgc3RhdGUgJHtkaWFsb2cuc2Vzc2lvblN0YXRlfWApO1xuICAgICAgY2FzZSBTZXNzaW9uRGlhbG9nU3RhdGUuRWFybHk6IC8vIEltcGxlbWVudGF0aW9uIGNob2ljZSAtIG5vdCBzZW5kaW5nIEJZRSBmb3IgZWFybHkgZGlhbG9ncy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRpYWxvZyBzdGF0ZSAke2RpYWxvZy5zZXNzaW9uU3RhdGV9YCk7XG4gICAgICBjYXNlIFNlc3Npb25EaWFsb2dTdGF0ZS5BY2tXYWl0OiB7IC8vIFRoaXMgc3RhdGUgb25seSBvY2N1cnMgaWYgd2UgYXJlIHRoZSBjYWxsZWUuXG4gICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZyk7IC8vIFdlJ3JlIHRlcm1pbmF0aW5nXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgZGlhbG9nLmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgLy8gV2hlbiBBQ0sgc2hvd3MgdXAsIHNheSBCWUUuXG4gICAgICAgICAgICBvbkFjazogKCk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gZGlhbG9nLmJ5ZShkZWxlZ2F0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBPciB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIHRpbWVzIG91dCBiZWZvcmUgdGhlIEFDSyBhcnJpdmVzLlxuICAgICAgICAgICAgb25BY2tUaW1lb3V0OiAoKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBkaWFsb2cuYnllKGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBTZXNzaW9uRGlhbG9nU3RhdGUuQ29uZmlybWVkOiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBkaWFsb2cuYnllKGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlcXVlc3QpO1xuICAgICAgfVxuICAgICAgY2FzZSBTZXNzaW9uRGlhbG9nU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRpYWxvZyBzdGF0ZSAke2RpYWxvZy5zZXNzaW9uU3RhdGV9YCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgc3RhdGUuXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIElORk8uXG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zIGJ1Y2tldC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX2luZm8oZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxPdXRnb2luZ0J5ZVJlcXVlc3Q+IHtcbiAgICAvLyBVc2luZyBjb3JlIHNlc3Npb24gZGlhbG9nXG4gICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlNlc3Npb24gZGlhbG9nIHVuZGVmaW5lZC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZGlhbG9nLmluZm8oZGVsZWdhdGUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIEFDSyBhbmQgdGhlbiBCWUUuIFRoZXJlIGFyZSB1bnJlY292ZXJhYmxlIGVycm9ycyB3aGljaCBjYW4gb2NjdXJcbiAgICogd2hpbGUgaGFuZGxpbmcgZGlhbG9nIGZvcm1pbmcgYW5kIGluLWRpYWxvZyBJTlZJVEUgcmVzcG9uc2VzIGFuZCB3aGVuXG4gICAqIHRoZXkgb2NjdXIgd2UgQUNLIHRoZSByZXNwb25zZSBhbmQgc2VuZCBhIEJZRS5cbiAgICogTm90ZSB0aGF0IHRoZSBCWUUgaXMgc2VudCBpbiB0aGUgZGlhbG9nIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzcG9uc2VcbiAgICogd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5IGB0aGlzLmRpYWxvZ2AuIEFuZCwgYWNjb3JkaW5nbHksIHRoZVxuICAgKiBzZXNzaW9uIHN0YXRlIGlzIG5vdCB0cmFuc2l0aW9uZWQgdG8gdGVybWluYXRlZCBhbmQgc2Vzc2lvbiBpcyBub3QgY2xvc2VkLlxuICAgKiBAcGFyYW0gaW52aXRlUmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UgY2F1c2luZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSBzdGF0dXNDb2RlIC0gU3RhdHVzIGNvZGUgZm9yIGhlIHJlYXNvbiBwaHJhc2UuXG4gICAqIEBwYXJhbSByZWFzb25QaHJhc2UgLSBSZWFzb24gcGhyYXNlIGZvciB0aGUgQllFLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBhY2tBbmRCeWUoXG4gICAgcmVzcG9uc2U6IEFja2FibGVJbmNvbWluZ1Jlc3BvbnNlV2l0aFNlc3Npb24sXG4gICAgc3RhdHVzQ29kZT86IG51bWJlcixcbiAgICByZWFzb25QaHJhc2U/OiBzdHJpbmdcbiAgKTogdm9pZCB7XG4gICAgcmVzcG9uc2UuYWNrKCk7XG4gICAgY29uc3QgZXh0cmFIZWFkZXJzOiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgaWYgKHN0YXR1c0NvZGUpIHtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVhc29uOiBcIiArIHRoaXMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlKSk7XG4gICAgfVxuICAgIC8vIFVzaW5nIHRoZSBkaWFsb2cgc2Vzc2lvbiBhc3NvY2lhdGUgd2l0aCB0aGUgcmVzcG9uc2UgKHdoaWNoIG1pZ2h0IG5vdCBiZSB0aGlzLmRpYWxvZylcbiAgICByZXNwb25zZS5zZXNzaW9uLmJ5ZSh1bmRlZmluZWQsIHsgZXh0cmFIZWFkZXJzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBpbiBkaWFsb2cgQUNLIHJlcXVlc3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIG9uQWNrUmVxdWVzdChyZXF1ZXN0OiBJbmNvbWluZ0Fja1JlcXVlc3QpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJTZXNzaW9uLm9uQWNrUmVxdWVzdFwiKTtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkICYmIHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZykge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEFDSyByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSAke3RoaXMuc3RhdGV9LCBkcm9wcGluZyByZXF1ZXN0YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlhbG9nID0gdGhpcy5kaWFsb2c7XG4gICAgaWYgKCFkaWFsb2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyB1bmRlZmluZWQuXCIpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGlhbG9nLnNpZ25hbGluZ1N0YXRlKSB7XG4gICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkluaXRpYWw6IHtcbiAgICAgICAgLy8gU3RhdGUgc2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQgYXMgZmlyc3QgcmVsaWFibGUgcmVzcG9uc2UgbXVzdCBoYXZlIGFuc3dlci9vZmZlci5cbiAgICAgICAgLy8gU28gd2UgbXVzdCBoYXZlIG5ldmVyIGhhcyBzZW50IGFuIG9mZmVyLlxuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgJHtkaWFsb2cuc2lnbmFsaW5nU3RhdGV9LmApO1xuICAgICAgICBjb25zdCBleHRyYUhlYWRlcnMgPSBbXCJSZWFzb246IFwiICsgdGhpcy5nZXRSZWFzb25IZWFkZXJWYWx1ZSg0ODgsIFwiQmFkIE1lZGlhIERlc2NyaXB0aW9uXCIpXTtcbiAgICAgICAgZGlhbG9nLmJ5ZSh1bmRlZmluZWQsIHsgZXh0cmFIZWFkZXJzIH0pO1xuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuU3RhYmxlOiB7XG4gICAgICAgIC8vIFN0YXRlIHdlIHNob3VsZCBiZSBpbi5cbiAgICAgICAgLy8gRWl0aGVyIHRoZSBBQ0sgaGFzIHRoZSBhbnN3ZXIgdGhhdCBnb3QgdXMgaGVyZSwgb3Igd2Ugd2VyZSBpbiB0aGlzIHN0YXRlIHByaW9yIHRvIHRoZSBBQ0suXG4gICAgICAgIGNvbnN0IGJvZHkgPSBnZXRCb2R5KHJlcXVlc3QubWVzc2FnZSk7XG4gICAgICAgIC8vIElmIHRoZSBBQ0sgZG9lc24ndCBoYXZlIGFuIGFuc3dlciwgbm90aGluZyB0byBiZSBkb25lLlxuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkuY29udGVudERpc3Bvc2l0aW9uID09PSBcInJlbmRlclwiKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyYm9keSA9IGJvZHkuY29udGVudDtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJ0eXBlID0gYm9keS5jb250ZW50VHlwZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkuY29udGVudERpc3Bvc2l0aW9uICE9PSBcInNlc3Npb25cIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWNlaXZlZCBhbnN3ZXIgaW4gQUNLLlxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyxcbiAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzOiB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0QW5zd2VyKGJvZHksIG9wdGlvbnMpXG4gICAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgZXh0cmFIZWFkZXJzID0gW1wiUmVhc29uOiBcIiArIHRoaXMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoNDg4LCBcIkJhZCBNZWRpYSBEZXNjcmlwdGlvblwiKV07XG4gICAgICAgICAgICBkaWFsb2cuYnllKHVuZGVmaW5lZCwgeyBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXI6IHtcbiAgICAgICAgLy8gU3RhdGUgc2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQgYXMgbG9jYWwgb2ZmZXIgd291bGQgYmUgYW5zd2VyZWQgYnkgdGhpcyBBQ0suXG4gICAgICAgIC8vIFNvIHdlIG11c3QgaGF2ZSByZWNlaXZlZCBhbiBBQ0sgd2l0aG91dCBhbiBhbnN3ZXIuXG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBJbnZhbGlkIHNpZ25hbGluZyBzdGF0ZSAke2RpYWxvZy5zaWduYWxpbmdTdGF0ZX0uYCk7XG4gICAgICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9IFtcIlJlYXNvbjogXCIgKyB0aGlzLmdldFJlYXNvbkhlYWRlclZhbHVlKDQ4OCwgXCJCYWQgTWVkaWEgRGVzY3JpcHRpb25cIildO1xuICAgICAgICBkaWFsb2cuYnllKHVuZGVmaW5lZCwgeyBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXI6IHtcbiAgICAgICAgLy8gU3RhdGUgc2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQgYXMgcmVtb3RlIG9mZmVyIHdvdWxkIGJlIGFuc3dlcmVkIGluIGZpcnN0IHJlbGlhYmxlIHJlc3BvbnNlLlxuICAgICAgICAvLyBTbyB3ZSBtdXN0IGhhdmUgbmV2ZXIgaGFzIHNlbnQgYW4gYW5zd2VyLlxuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgJHtkaWFsb2cuc2lnbmFsaW5nU3RhdGV9LmApO1xuICAgICAgICBjb25zdCBleHRyYUhlYWRlcnMgPSBbXCJSZWFzb246IFwiICsgdGhpcy5nZXRSZWFzb25IZWFkZXJWYWx1ZSg0ODgsIFwiQmFkIE1lZGlhIERlc2NyaXB0aW9uXCIpXTtcbiAgICAgICAgZGlhbG9nLmJ5ZSh1bmRlZmluZWQsIHsgZXh0cmFIZWFkZXJzIH0pO1xuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmFsaW5nIHN0YXRlICR7ZGlhbG9nLnNpZ25hbGluZ1N0YXRlfS5gKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgJHtkaWFsb2cuc2lnbmFsaW5nU3RhdGV9LmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgaW4gZGlhbG9nIEJZRSByZXF1ZXN0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBvbkJ5ZVJlcXVlc3QocmVxdWVzdDogSW5jb21pbmdCeWVSZXF1ZXN0KTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbi5vbkJ5ZVJlcXVlc3RcIik7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEJZRSByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSAke3RoaXMuc3RhdGV9LCBkcm9wcGluZyByZXF1ZXN0YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlcXVlc3QuYWNjZXB0KCk7XG4gICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBpbiBkaWFsb2cgSU5GTyByZXF1ZXN0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBvbkluZm9SZXF1ZXN0KHJlcXVlc3Q6IEluY29taW5nSW5mb1JlcXVlc3QpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJTZXNzaW9uLm9uSW5mb1JlcXVlc3RcIik7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYElORk8gcmVjZWl2ZWQgd2hpbGUgaW4gc3RhdGUgJHt0aGlzLnN0YXRlfSwgZHJvcHBpbmcgcmVxdWVzdGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25JbmZvKSB7XG4gICAgICBjb25zdCBpbmZvID0gbmV3IEluZm8ocmVxdWVzdCk7XG4gICAgICB0aGlzLmRlbGVnYXRlLm9uSW5mbyhpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGluIGRpYWxvZyBJTlZJVEUgcmVxdWVzdC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgb25JbnZpdGVSZXF1ZXN0KHJlcXVlc3Q6IEluY29taW5nSW52aXRlUmVxdWVzdCk6IHZvaWQge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24ub25JbnZpdGVSZXF1ZXN0XCIpO1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBJTlZJVEUgcmVjZWl2ZWQgd2hpbGUgaW4gc3RhdGUgJHt0aGlzLnN0YXRlfSwgZHJvcHBpbmcgcmVxdWVzdGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBjb3JlIHRyYWNrIGFuZCBzZXQgdGhlIENvbnRhY3QgaGVhZGVyLFxuICAgIC8vIGJ1dCBjdXJyZW50bHkgdGhlIHNlc3Npb24gd2hpY2ggaXMgc2V0dGluZyBpdCBpcyBob2xkaW5nIG9udG8gaXQuXG4gICAgY29uc3QgZXh0cmFIZWFkZXJzID0gW1wiQ29udGFjdDogXCIgKyB0aGlzLl9jb250YWN0XTtcblxuICAgIC8vIEhhbmRsZSBQLUFzc2VydGVkLUlkZW50aXR5XG4gICAgaWYgKHJlcXVlc3QubWVzc2FnZS5oYXNIZWFkZXIoXCJQLUFzc2VydGVkLUlkZW50aXR5XCIpKSB7XG4gICAgICBjb25zdCBoZWFkZXIgPSByZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKTtcbiAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlciB1bmRlZmluZWQuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYXNzZXJ0ZWRJZGVudGl0eSA9IEdyYW1tYXIubmFtZUFkZHJIZWFkZXJQYXJzZShoZWFkZXIpO1xuICAgIH1cblxuICAgIC8vIEZJWE1FOiBTREggb3B0aW9ucyAmIFNESCBtb2RpZmllcnMgb3B0aW9ucyBhcmUgYXBwbGllZCBzb21ld2hhdCBhbWJpZ3VvdXNseVxuICAgIC8vICAgICAgICBUaGlzIGJlaGF2aW9yIHdhcyBwb3J0ZWQgZnJvbSBsZWdhY3kgY29kZSBhbmQgdGhlIGlzc3VlIHB1bnRlZCBkb3duIHRoZSByb2FkLlxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9uczogdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsXG4gICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzOiB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzXG4gICAgfTtcbiAgICB0aGlzLmdlbmVyYXRlUmVzcG9uc2VPZmZlckFuc3dlckluRGlhbG9nKG9wdGlvbnMpXG4gICAgICAudGhlbigoYm9keSkgPT4ge1xuICAgICAgICBjb25zdCBvdXRnb2luZ1Jlc3BvbnNlID0gcmVxdWVzdC5hY2NlcHQoeyBzdGF0dXNDb2RlOiAyMDAsIGV4dHJhSGVhZGVycywgYm9keSB9KTtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25JbnZpdGUocmVxdWVzdC5tZXNzYWdlLCBvdXRnb2luZ1Jlc3BvbnNlLm1lc3NhZ2UsIDIwMCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gaGFuZGxlIHRvIHJlLUlOVklURSByZXF1ZXN0XCIpO1xuICAgICAgICBpZiAoIXRoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IodGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGUpO1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbG9jYWwvcmVtb3RlIG9mZmVyLi4uXG4gICAgICAgIGlmICh0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZSA9PT0gU2lnbmFsaW5nU3RhdGUuU3RhYmxlKSB7XG4gICAgICAgICAgY29uc3Qgb3V0Z29pbmdSZXNwb25zZSA9IHJlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogNDg4IH0pOyAvLyBOb3QgQWNjZXB0YWJsZSBIZXJlXG4gICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkludml0ZShyZXF1ZXN0Lm1lc3NhZ2UsIG91dGdvaW5nUmVzcG9uc2UubWVzc2FnZSwgNDg4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSByb2xsYmFja1xuICAgICAgICB0aGlzLnJvbGxiYWNrT2ZmZXIoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG91dGdvaW5nUmVzcG9uc2UgPSByZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4OCB9KTsgLy8gTm90IEFjY2VwdGFibGUgSGVyZVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSkge1xuICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uSW52aXRlKHJlcXVlc3QubWVzc2FnZSwgb3V0Z29pbmdSZXNwb25zZS5tZXNzYWdlLCA0ODgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoICgoZXJyb3JSb2xsYmFjazogRXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIE5vIHdheSB0byByZWNvdmVyLCBzbyB0ZXJtaW5hdGUgc2Vzc2lvbiBhbmQgbWFyayBhcyBmYWlsZWQuXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvclJvbGxiYWNrLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gcm9sbGJhY2sgb2ZmZXIgb24gcmUtSU5WSVRFIHJlcXVlc3RcIik7XG4gICAgICAgICAgICBjb25zdCBvdXRnb2luZ1Jlc3BvbnNlID0gcmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODggfSk7IC8vIE5vdCBBY2NlcHRhYmxlIEhlcmVcbiAgICAgICAgICAgIC8vIEEgQllFIHNob3VsZCBvbmx5IGJlIHNlbnQgaWYgc2Vzc2lvbiBpcyBub3QgYWxyZWFkeSB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGEgQllFIG1heSBiZSBzZW50L3JlY2VpdmVkIHdoaWxlIHJlLUlOVklURSBpcyBvdXRzdGFuZGluZy5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgQUNLIHdhcyBhbHJlYWR5IHNlbnQgYnkgdGhlIHRyYW5zYWN0aW9uLCBzbyBqdXN0IG5lZWQgdG8gc2VuZCBCWUUuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGV4dHJhSGVhZGVyc0J5ZTogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICAgICAgICBleHRyYUhlYWRlcnNCeWUucHVzaChcIlJlYXNvbjogXCIgKyB0aGlzLmdldFJlYXNvbkhlYWRlclZhbHVlKDUwMCwgXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIikpO1xuICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5ieWUodW5kZWZpbmVkLCB7IGV4dHJhSGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSkge1xuICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uSW52aXRlKHJlcXVlc3QubWVzc2FnZSwgb3V0Z29pbmdSZXNwb25zZS5tZXNzYWdlLCA0ODgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGluIGRpYWxvZyBOT1RJRlkgcmVxdWVzdC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgb25Ob3RpZnlSZXF1ZXN0KHJlcXVlc3Q6IEluY29taW5nTm90aWZ5UmVxdWVzdCk6IHZvaWQge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24ub25Ob3RpZnlSZXF1ZXN0XCIpO1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBOT1RJRlkgcmVjZWl2ZWQgd2hpbGUgaW4gc3RhdGUgJHt0aGlzLnN0YXRlfSwgZHJvcHBpbmcgcmVxdWVzdGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgYSBOT1RJRlkgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm9ncmVzcyBvZiBhIFJFRkVSLFxuICAgIC8vIGxvb2sgdG8gZGVsZWdhdGUgaGFuZGxpbmcgdG8gdGhlIGFzc29jaWF0ZWQgUmVmZXJyZXIuXG4gICAgaWYgKHRoaXMuX3JlZmVycmVyICYmIHRoaXMuX3JlZmVycmVyLmRlbGVnYXRlICYmIHRoaXMuX3JlZmVycmVyLmRlbGVnYXRlLm9uTm90aWZ5KSB7XG4gICAgICBjb25zdCBub3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKHJlcXVlc3QpO1xuICAgICAgdGhpcy5fcmVmZXJyZXIuZGVsZWdhdGUub25Ob3RpZnkobm90aWZpY2F0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgYWNjZXB0IHRoZSBOT1RJRlkuXG4gICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSkge1xuICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbihyZXF1ZXN0KTtcbiAgICAgIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkobm90aWZpY2F0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGluIGRpYWxvZyBQUkFDSyByZXF1ZXN0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBvblByYWNrUmVxdWVzdChyZXF1ZXN0OiBJbmNvbWluZ1ByYWNrUmVxdWVzdCk6IHZvaWQge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24ub25QcmFja1JlcXVlc3RcIik7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYFBSQUNLIHJlY2VpdmVkIHdoaWxlIGluIHN0YXRlICR7dGhpcy5zdGF0ZX0sIGRyb3BwaW5nIHJlcXVlc3RgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkLlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgaW4gZGlhbG9nIFJFRkVSIHJlcXVlc3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIG9uUmVmZXJSZXF1ZXN0KHJlcXVlc3Q6IEluY29taW5nUmVmZXJSZXF1ZXN0KTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbi5vblJlZmVyUmVxdWVzdFwiKTtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgUkVGRVIgcmVjZWl2ZWQgd2hpbGUgaW4gc3RhdGUgJHt0aGlzLnN0YXRlfSwgZHJvcHBpbmcgcmVxdWVzdGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJFRkVSIGlzIGEgU0lQIHJlcXVlc3QgYW5kIGlzIGNvbnN0cnVjdGVkIGFzIGRlZmluZWQgaW4gWzFdLiAgQSBSRUZFUlxuICAgIC8vIHJlcXVlc3QgTVVTVCBjb250YWluIGV4YWN0bHkgb25lIFJlZmVyLVRvIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzUxNSNzZWN0aW9uLTIuNC4xXG4gICAgaWYgKCFyZXF1ZXN0Lm1lc3NhZ2UuaGFzSGVhZGVyKFwicmVmZXItdG9cIikpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJJbnZhbGlkIFJFRkVSIHBhY2tldC4gQSByZWZlci10byBoZWFkZXIgaXMgcmVxdWlyZWQuIFJlamVjdGluZy5cIik7XG4gICAgICByZXF1ZXN0LnJlamVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZmVycmFsID0gbmV3IFJlZmVycmFsKHJlcXVlc3QsIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblJlZmVyKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlLm9uUmVmZXIocmVmZXJyYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJObyBkZWxlZ2F0ZSBhdmFpbGFibGUgdG8gaGFuZGxlIFJFRkVSLCBhdXRvbWF0aWNhbGx5IGFjY2VwdGluZyBhbmQgZm9sbG93aW5nLlwiKTtcbiAgICAgIHJlZmVycmFsXG4gICAgICAgIC5hY2NlcHQoKVxuICAgICAgICAudGhlbigoKSA9PiByZWZlcnJhbFxuICAgICAgICAgIC5tYWtlSW52aXRlcih0aGlzLl9yZWZlcnJhbEludml0ZXJPcHRpb25zKVxuICAgICAgICAgIC5pbnZpdGUoKVxuICAgICAgICApXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgLy8gRklYTUU6IGxvZ2dpbmcgYW5kIGVhdGluZyBlcnJvci4uLlxuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gb2ZmZXIgb3IgYW5zd2VyIGZvciBhIHJlc3BvbnNlIHRvIGFuIElOVklURSByZXF1ZXN0LlxuICAgKiBJZiBhIHJlbW90ZSBvZmZlciB3YXMgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QsIHNldCB0aGUgcmVtb3RlXG4gICAqIGRlc2NyaXB0aW9uIGFuZCBnZXQgYSBsb2NhbCBhbnN3ZXIuIElmIGEgcmVtb3RlIG9mZmVyIHdhcyBub3RcbiAgICogcHJvdmlkZWQsIGdlbmVyYXRlcyBhIGxvY2FsIG9mZmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBnZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXIoXG4gICAgcmVxdWVzdDogSW5jb21pbmdJbnZpdGVSZXF1ZXN0LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zPzogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsXG4gICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzPzogQXJyYXk8U2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyPlxuICAgIH1cbiAgKTogUHJvbWlzZTxCb2R5IHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKHRoaXMuZGlhbG9nKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXJJbkRpYWxvZyhvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGdldEJvZHkocmVxdWVzdC5tZXNzYWdlKTtcbiAgICBpZiAoIWJvZHkgfHwgYm9keS5jb250ZW50RGlzcG9zaXRpb24gIT09IFwic2Vzc2lvblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPZmZlcihvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0T2ZmZXJBbmRHZXRBbnN3ZXIoYm9keSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIG9mZmVyIG9yIGFuc3dlciBmb3IgYSByZXNwb25zZSB0byBhbiBJTlZJVEUgcmVxdWVzdFxuICAgKiB3aGVuIGEgZGlhbG9nIChlYXJseSBvciBvdGhlcndpc2UpIGhhcyBhbHJlYWR5IGJlZW4gZXN0YWJsaXNoZWQuXG4gICAqIFRoaXMgbWV0aG9kIG1heSBOT1QgYmUgY2FsbGVkIGlmIGEgZGlhbG9nIGhhcyB5ZXQgdG8gYmUgZXN0YWJsaXNoZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIGdlbmVyYXRlUmVzcG9uc2VPZmZlckFuc3dlckluRGlhbG9nKFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zPzogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsXG4gICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzPzogQXJyYXk8U2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyPlxuICAgIH1cbiAgKTogUHJvbWlzZTxCb2R5IHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2ZmZXIob3B0aW9ucyk7XG4gICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyOlxuICAgICAgICAvLyBvICBPbmNlIHRoZSBVQVMgaGFzIHNlbnQgb3IgcmVjZWl2ZWQgYW4gYW5zd2VyIHRvIHRoZSBpbml0aWFsXG4gICAgICAgIC8vIG9mZmVyLCBpdCBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiBhbnkgcmVzcG9uc2VzXG4gICAgICAgIC8vIHRvIHRoZSBpbml0aWFsIElOVklURS4gIFRoaXMgbWVhbnMgdGhhdCBhIFVBUyBiYXNlZCBvbiB0aGlzXG4gICAgICAgIC8vIHNwZWNpZmljYXRpb24gYWxvbmUgY2FuIG5ldmVyIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIHVudGlsXG4gICAgICAgIC8vIGNvbXBsZXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyOlxuICAgICAgICBpZiAoIXRoaXMuZGlhbG9nLm9mZmVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXNzaW9uIG9mZmVyIHVuZGVmaW5lZCBpbiBzaWduYWxpbmcgc3RhdGUgJHt0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0T2ZmZXJBbmRHZXRBbnN3ZXIodGhpcy5kaWFsb2cub2ZmZXIsIG9wdGlvbnMpO1xuICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5TdGFibGU6XG4gICAgICAgIC8vIG8gIE9uY2UgdGhlIFVBUyBoYXMgc2VudCBvciByZWNlaXZlZCBhbiBhbnN3ZXIgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgLy8gb2ZmZXIsIGl0IE1VU1QgTk9UIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIGluIGFueSByZXNwb25zZXNcbiAgICAgICAgLy8gdG8gdGhlIGluaXRpYWwgSU5WSVRFLiAgVGhpcyBtZWFucyB0aGF0IGEgVUFTIGJhc2VkIG9uIHRoaXNcbiAgICAgICAgLy8gc3BlY2lmaWNhdGlvbiBhbG9uZSBjYW4gbmV2ZXIgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgdW50aWxcbiAgICAgICAgLy8gY29tcGxldGlvbiBvZiB0aGUgaW5pdGlhbCB0cmFuc2FjdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBkaWFsb2cgSU5WSVRFIHdpdGhvdXQgb2ZmZXIsIGdldCBhbiBvZmZlciBmb3IgdGhlIHJlc3BvbnNlLlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRPZmZlcihvcHRpb25zKTtcbiAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmFsaW5nIHN0YXRlICR7dGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGV9LmApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hbGluZyBzdGF0ZSAke3RoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlfS5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxvY2FsIG9mZmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBnZXRPZmZlcihvcHRpb25zOiB7XG4gICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM/OiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyxcbiAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzPzogQXJyYXk8U2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyPlxuICB9KTogUHJvbWlzZTxCb2R5PiB7XG4gICAgY29uc3Qgc2RoID0gdGhpcy5zZXR1cFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIoKTtcbiAgICBjb25zdCBzZGhPcHRpb25zID0gb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucztcbiAgICBjb25zdCBzZGhNb2RpZmllcnMgPSBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM7XG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gdmVyeSBkZWZlbnNpdmVseS4gRG9uJ3QgdHJ1c3QgU0RIIHRvIGJlaGF2ZS5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHNkaC5nZXREZXNjcmlwdGlvbihzZGhPcHRpb25zLCBzZGhNb2RpZmllcnMpXG4gICAgICAgIC50aGVuKChib2R5QW5kQ29udGVudFR5cGUpID0+IGZyb21Cb2R5TGVnYWN5KGJvZHlBbmRDb250ZW50VHlwZSkpXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IGFueSkgPT4geyAvLyBkb24ndCB0cnVzdCBTREggdG8gcmVqZWN0IHdpdGggRXJyb3JcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24uZ2V0T2ZmZXI6IFNESCBnZXREZXNjcmlwdGlvbiByZWplY3RlZC4uLlwiKTtcbiAgICAgICAgICBjb25zdCBlID0gIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvLyBkb24ndCB0cnVzdCBTREggdG8gdGhyb3cgYW4gRXJyb3JcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5nZXRPZmZlcjogU0RIIGdldERlc2NyaXB0aW9uIHRocmV3Li4uXCIpO1xuICAgICAgY29uc3QgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xsYmFjayBsb2NhbC9yZW1vdGUgb2ZmZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIHJvbGxiYWNrT2ZmZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc2RoID0gdGhpcy5zZXR1cFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIoKTtcbiAgICBpZiAoIXNkaC5yb2xsYmFja0Rlc2NyaXB0aW9uKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSB3cml0dGVuIHZlcnkgZGVmZW5zaXZlbHkuIERvbid0IHRydXN0IFNESCB0byBiZWhhdmUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzZGgucm9sbGJhY2tEZXNjcmlwdGlvbigpXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IGFueSkgPT4geyAvLyBkb24ndCB0cnVzdCBTREggdG8gcmVqZWN0IHdpdGggRXJyb3JcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24ucm9sbGJhY2tPZmZlcjogU0RIIHJvbGxiYWNrRGVzY3JpcHRpb24gcmVqZWN0ZWQuLi5cIik7XG4gICAgICAgICAgY29uc3QgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvLyBkb24ndCB0cnVzdCBTREggdG8gdGhyb3cgYW4gRXJyb3JcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5yb2xsYmFja09mZmVyOiBTREggcm9sbGJhY2tEZXNjcmlwdGlvbiB0aHJldy4uLlwiKTtcbiAgICAgIGNvbnN0IGUgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHJlbW90ZSBhbnN3ZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIHNldEFuc3dlcihhbnN3ZXI6IEJvZHksIG9wdGlvbnM6IHtcbiAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucz86IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLFxuICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM/OiBBcnJheTxTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXI+XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzZGggPSB0aGlzLnNldHVwU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcigpO1xuICAgIGNvbnN0IHNkaE9wdGlvbnMgPSBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zO1xuICAgIGNvbnN0IHNkaE1vZGlmaWVycyA9IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVycztcbiAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiB2ZXJ5IGRlZmVuc2l2ZWx5LiBEb24ndCB0cnVzdCBTREggdG8gYmVoYXZlLlxuICAgIHRyeSB7XG4gICAgICBpZiAoIXNkaC5oYXNEZXNjcmlwdGlvbihhbnN3ZXIuY29udGVudFR5cGUpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQ29udGVudFR5cGVVbnN1cHBvcnRlZEVycm9yKCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24uc2V0QW5zd2VyOiBTREggaGFzRGVzY3JpcHRpb24gdGhyZXcuLi5cIik7XG4gICAgICBjb25zdCBlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKTtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc2RoLnNldERlc2NyaXB0aW9uKGFuc3dlci5jb250ZW50LCBzZGhPcHRpb25zLCBzZGhNb2RpZmllcnMpXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IGFueSkgPT4geyAvLyBkb24ndCB0cnVzdCBTREggdG8gcmVqZWN0IHdpdGggRXJyb3JcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24uc2V0QW5zd2VyOiBTREggc2V0RGVzY3JpcHRpb24gcmVqZWN0ZWQuLi5cIik7XG4gICAgICAgICAgY29uc3QgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvLyBkb24ndCB0cnVzdCBTREggdG8gdGhyb3cgYW4gRXJyb3JcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5zZXRBbnN3ZXI6IFNESCBzZXREZXNjcmlwdGlvbiB0aHJldy4uLlwiKTtcbiAgICAgIGNvbnN0IGUgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHJlbW90ZSBvZmZlciBhbmQgZ2V0IGxvY2FsIGFuc3dlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgc2V0T2ZmZXJBbmRHZXRBbnN3ZXIob2ZmZXI6IEJvZHksIG9wdGlvbnM6IHtcbiAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucz86IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLFxuICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM/OiBBcnJheTxTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXI+XG4gIH0pOiBQcm9taXNlPEJvZHk+IHtcbiAgICBjb25zdCBzZGggPSB0aGlzLnNldHVwU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcigpO1xuICAgIGNvbnN0IHNkaE9wdGlvbnMgPSBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zO1xuICAgIGNvbnN0IHNkaE1vZGlmaWVycyA9IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVycztcbiAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiB2ZXJ5IGRlZmVuc2l2ZWx5LiBEb24ndCB0cnVzdCBTREggdG8gYmVoYXZlLlxuICAgIHRyeSB7XG4gICAgICBpZiAoIXNkaC5oYXNEZXNjcmlwdGlvbihvZmZlci5jb250ZW50VHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBDb250ZW50VHlwZVVuc3VwcG9ydGVkRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5zZXRPZmZlckFuZEdldEFuc3dlcjogU0RIIGhhc0Rlc2NyaXB0aW9uIHRocmV3Li4uXCIpO1xuICAgICAgY29uc3QgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHNkaC5zZXREZXNjcmlwdGlvbihvZmZlci5jb250ZW50LCBzZGhPcHRpb25zLCBzZGhNb2RpZmllcnMpXG4gICAgICAgIC50aGVuKCgpID0+IHNkaC5nZXREZXNjcmlwdGlvbihzZGhPcHRpb25zLCBzZGhNb2RpZmllcnMpKVxuICAgICAgICAudGhlbigoYm9keUFuZENvbnRlbnRUeXBlKSA9PiBmcm9tQm9keUxlZ2FjeShib2R5QW5kQ29udGVudFR5cGUpKVxuICAgICAgICAuY2F0Y2goKGVycm9yOiBhbnkpID0+IHsgLy8gZG9uJ3QgdHJ1c3QgU0RIIHRvIHJlamVjdCB3aXRoIEVycm9yXG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJTZXNzaW9uLnNldE9mZmVyQW5kR2V0QW5zd2VyOiBTREggc2V0RGVzY3JpcHRpb24gb3IgZ2V0RGVzY3JpcHRpb24gcmVqZWN0ZWQuLi5cIik7XG4gICAgICAgICAgY29uc3QgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvLyBkb24ndCB0cnVzdCBTREggdG8gdGhyb3cgYW4gRXJyb3JcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5zZXRPZmZlckFuZEdldEFuc3dlcjogU0RIIHNldERlc2NyaXB0aW9uIG9yIGdldERlc2NyaXB0aW9uIHRocmV3Li4uXCIpO1xuICAgICAgY29uc3QgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTREggZm9yIGNvbmZpcm1lZCBkaWFsb2cuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIHNldFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIoc2RoOiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBkZWZpbmVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IHNkaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTREggZm9yIGNvbmZpcm1lZCBkaWFsb2cuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIHNldHVwU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcigpOiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIHtcbiAgICBpZiAodGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG4gICAgfVxuICAgIHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPVxuICAgICAgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSh0aGlzLCB0aGlzLnVzZXJBZ2VudC5jb25maWd1cmF0aW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5T3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNpdGlvbiBzZXNzaW9uIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBzdGF0ZVRyYW5zaXRpb24obmV3U3RhdGU6IFNlc3Npb25TdGF0ZSk6IHZvaWQge1xuICAgIGNvbnN0IGludmFsaWRUcmFuc2l0aW9uID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gZnJvbSAke3RoaXMuX3N0YXRlfSB0byAke25ld1N0YXRlfWApO1xuICAgIH07XG5cbiAgICAvLyBWYWxpZGF0ZSB0cmFuc2l0aW9uXG4gICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgY2FzZSBTZXNzaW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5ld1N0YXRlICE9PSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoaW5nICYmXG4gICAgICAgICAgbmV3U3RhdGUgIT09IFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCAmJlxuICAgICAgICAgIG5ld1N0YXRlICE9PSBTZXNzaW9uU3RhdGUuVGVybWluYXRpbmcgJiZcbiAgICAgICAgICBuZXdTdGF0ZSAhPT0gU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW52YWxpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLkVzdGFibGlzaGluZzpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5ld1N0YXRlICE9PSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQgJiZcbiAgICAgICAgICBuZXdTdGF0ZSAhPT0gU2Vzc2lvblN0YXRlLlRlcm1pbmF0aW5nICYmXG4gICAgICAgICAgbmV3U3RhdGUgIT09IFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkXG4gICAgICAgICkge1xuICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZDpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5ld1N0YXRlICE9PSBTZXNzaW9uU3RhdGUuVGVybWluYXRpbmcgJiZcbiAgICAgICAgICBuZXdTdGF0ZSAhPT0gU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW52YWxpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLlRlcm1pbmF0aW5nOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgbmV3U3RhdGUgIT09IFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkXG4gICAgICAgICkge1xuICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICBpbnZhbGlkVHJhbnNpdGlvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBzdGF0ZS5cIik7XG4gICAgfVxuXG4gICAgLy8gVHJhbnNpdGlvblxuICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBTZXNzaW9uICR7dGhpcy5pZH0gdHJhbnNpdGlvbmVkIHRvIHN0YXRlICR7dGhpcy5fc3RhdGV9YCk7XG4gICAgdGhpcy5fc3RhdGVFdmVudEVtaXR0ZXIuZW1pdChcImV2ZW50XCIsIHRoaXMuX3N0YXRlKTtcblxuICAgIC8vIERpc3Bvc2VcbiAgICBpZiAobmV3U3RhdGUgPT09IFNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldFJlYXNvbkhlYWRlclZhbHVlKGNvZGU6IG51bWJlciwgcmVhc29uPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBjYXVzZSA9IGNvZGU7XG4gICAgbGV0IHRleHQgPSBnZXRSZWFzb25QaHJhc2UoY29kZSk7XG4gICAgaWYgKCF0ZXh0ICYmIHJlYXNvbikge1xuICAgICAgdGV4dCA9IHJlYXNvbjtcbiAgICB9XG4gICAgcmV0dXJuIFwiU0lQO2NhdXNlPVwiICsgY2F1c2UgKyAnO3RleHQ9XCInICsgdGV4dCArICdcIic7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEMsXG4gIGZyb21Cb2R5TGVnYWN5LFxuICBJbmNvbWluZ05vdGlmeVJlcXVlc3QsXG4gIEluY29taW5nUmVxdWVzdFdpdGhTdWJzY3JpcHRpb24sXG4gIEluY29taW5nUmVzcG9uc2UsXG4gIExvZ2dlcixcbiAgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0LFxuICBSZXF1ZXN0T3B0aW9ucyxcbiAgU3Vic2NyaXB0aW9uIGFzIFN1YnNjcmlwdGlvbkRpYWxvZyxcbiAgU3Vic2NyaXB0aW9uU3RhdGUgYXMgU3Vic2NyaXB0aW9uRGlhbG9nU3RhdGUsXG4gIFVSSSxcbiAgVXNlckFnZW50Q29yZVxufSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgQWxsb3dlZE1ldGhvZHMgfSBmcm9tIFwiLi4vY29yZS91c2VyLWFnZW50LWNvcmUvYWxsb3dlZC1tZXRob2RzXCI7XG5pbXBvcnQgeyBOb3RpZmljYXRpb24gfSBmcm9tIFwiLi9ub3RpZmljYXRpb25cIjtcbmltcG9ydCB7IEJvZHlBbmRDb250ZW50VHlwZSB9IGZyb20gXCIuL3Nlc3Npb24tZGVzY3JpcHRpb24taGFuZGxlclwiO1xuaW1wb3J0IHsgU3Vic2NyaWJlck9wdGlvbnMgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLW9wdGlvbnNcIjtcbmltcG9ydCB7IFN1YnNjcmliZXJTdWJzY3JpYmVPcHRpb25zIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1zdWJzY3JpYmUtb3B0aW9uc1wiO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSBcIi4vc3Vic2NyaXB0aW9uXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25TdGF0ZSB9IGZyb20gXCIuL3N1YnNjcmlwdGlvbi1zdGF0ZVwiO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uVW5zdWJzY3JpYmVPcHRpb25zIH0gZnJvbSBcIi4vc3Vic2NyaXB0aW9uLXVuc3Vic2NyaWJlLW9wdGlvbnNcIjtcbmltcG9ydCB7IFVzZXJBZ2VudCB9IGZyb20gXCIuL3VzZXItYWdlbnRcIjtcblxuLyoqXG4gKiBBIHN1YnNjcmliZXIgZXN0YWJsaXNoZXMgYSB7QGxpbmsgU3Vic2NyaXB0aW9ufSAob3V0Z29pbmcgU1VCU0NSSUJFKS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBpcyAobW9yZSBvciBsZXNzKSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBhIFwic3Vic2NyaWJlclwiIGFzXG4gKiBkZWZpbmVkIGluIFJGQyA2NjY1IFwiU0lQLVNwZWNpZmljIEV2ZW50IE5vdGlmaWNhdGlvbnNcIi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiAvLyBDcmVhdGUgYSBuZXcgc3Vic2NyaWJlci5cbiAqIGNvbnN0IHRhcmdldFVSSSA9IG5ldyBVUkkoXCJzaXBcIiwgXCJhbGljZVwiLCBcImV4YW1wbGUuY29tXCIpO1xuICogY29uc3QgZXZlbnRUeXBlID0gXCJleGFtcGxlLW5hbWVcIjsgLy8gaHR0cHM6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvc2lwLWV2ZW50cy9zaXAtZXZlbnRzLnhodG1sXG4gKiBjb25zdCBzdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXIodXNlckFnZW50LCB0YXJnZXRVUkksIGV2ZW50VHlwZSk7XG4gKlxuICogLy8gQWRkIGRlbGVnYXRlIHRvIGhhbmRsZSBldmVudCBub3RpZmljYXRpb25zLlxuICogc3Vic2NyaWJlci5kZWxlZ2F0ZSA9IHtcbiAqICAgb25Ob3RpZnk6IChub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbikgPT4ge1xuICogICAgIC8vIGhhbmRsZSBub3RpZmljYXRpb24gaGVyZVxuICogICB9XG4gKiB9O1xuICpcbiAqIC8vIE1vbml0b3Igc3Vic2NyaXB0aW9uIHN0YXRlIGNoYW5nZXMuXG4gKiBzdWJzY3JpYmVyLnN0YXRlQ2hhbmdlLmFkZExpc3RlbmVyKChuZXdTdGF0ZTogU3Vic2NyaXB0aW9uU3RhdGUpID0+IHtcbiAqICAgaWYgKG5ld1N0YXRlID09PSBTdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gKiAgICAgLy8gaGFuZGxlIHN0YXRlIGNoYW5nZSBoZXJlXG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIEF0dGVtcHQgdG8gZXN0YWJsaXNoIHRoZSBzdWJzY3JpcHRpb25cbiAqIHN1YnNjcmliZXIuc3Vic2NyaWJlKCk7XG4gKlxuICogLy8gU29tZXRpbWUgbGF0ZXIgd2hlbiBkb25lIHdpdGggc3Vic2NyaXB0aW9uXG4gKiBzdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzY3JpYmVyIGV4dGVuZHMgU3Vic2NyaXB0aW9uIHtcblxuICAvLyBUT0RPOiBDbGVhbnVwIHRoZXNlIGludGVybmFsc1xuICBwcml2YXRlIGlkOiBzdHJpbmc7XG4gIHByaXZhdGUgYm9keTogQm9keUFuZENvbnRlbnRUeXBlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBwcml2YXRlIGV2ZW50OiBzdHJpbmc7XG4gIHByaXZhdGUgZXhwaXJlczogbnVtYmVyO1xuICBwcml2YXRlIGV4dHJhSGVhZGVyczogQXJyYXk8c3RyaW5nPjtcbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcbiAgcHJpdmF0ZSBvdXRnb2luZ1JlcXVlc3RNZXNzYWdlOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlO1xuICBwcml2YXRlIHJldHJ5QWZ0ZXJUaW1lcjogYW55IHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIHN1YnNjcmliZXJSZXF1ZXN0OiBTdWJzY3JpYmVyUmVxdWVzdDtcbiAgcHJpdmF0ZSB0YXJnZXRVUkk6IFVSSTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB1c2VyQWdlbnQgLSBVc2VyIGFnZW50LiBTZWUge0BsaW5rIFVzZXJBZ2VudH0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB0YXJnZXRVUkkgLSBUaGUgcmVxdWVzdCBVUkkgaWRlbnRpZnlpbmcgdGhlIHN1YnNjcmliZWQgZXZlbnQuXG4gICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZSBpZGVudGlmeWluZyB0aGUgc3Vic2NyaWJlZCBldmVudC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC4gU2VlIHtAbGluayBTdWJzY3JpYmVyT3B0aW9uc30gZm9yIGRldGFpbHMuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IodXNlckFnZW50OiBVc2VyQWdlbnQsIHRhcmdldFVSSTogVVJJLCBldmVudFR5cGU6IHN0cmluZywgb3B0aW9uczogU3Vic2NyaWJlck9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHVzZXJBZ2VudCwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmxvZ2dlciA9IHVzZXJBZ2VudC5nZXRMb2dnZXIoXCJzaXAuU3Vic2NyaWJlclwiKTtcbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICB0aGlzLmJvZHkgPSB7XG4gICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgY29udGVudFR5cGU6IG9wdGlvbnMuY29udGVudFR5cGUgPyBvcHRpb25zLmNvbnRlbnRUeXBlIDogXCJhcHBsaWNhdGlvbi9zZHBcIlxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldFVSSSA9IHRhcmdldFVSSTtcblxuICAgIC8vIFN1YnNjcmlwdGlvbiBldmVudFxuICAgIHRoaXMuZXZlbnQgPSBldmVudFR5cGU7XG5cbiAgICAvLyBTdWJzY3JpcHRpb24gZXhwaXJlc1xuICAgIGlmIChvcHRpb25zLmV4cGlyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5leHBpcmVzID0gMzYwMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmV4cGlyZXMgIT09IFwibnVtYmVyXCIpIHsgLy8gcHJlLXR5cGVzY3JpcHQgdHlwZSBndWFyZFxuICAgICAgdGhpcy5sb2dnZXIud2FybihgT3B0aW9uIFwiZXhwaXJlc1wiIG11c3QgYmUgYSBudW1iZXIuIFVzaW5nIGRlZmF1bHQgb2YgMzYwMC5gKTtcbiAgICAgIHRoaXMuZXhwaXJlcyA9IDM2MDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwaXJlcyA9IG9wdGlvbnMuZXhwaXJlcztcbiAgICB9XG5cbiAgICAvLyBTdWJzY3JpcHRpb24gZXh0cmEgaGVhZGVyc1xuICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuXG4gICAgLy8gU3Vic2NyaXB0aW9uIGNvbnRleHQuXG4gICAgdGhpcy5zdWJzY3JpYmVyUmVxdWVzdCA9IHRoaXMuaW5pdFN1YnNjcmliZXJSZXF1ZXN0KCk7XG5cbiAgICB0aGlzLm91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgPSB0aGlzLnN1YnNjcmliZXJSZXF1ZXN0Lm1lc3NhZ2U7XG5cbiAgICAvLyBBZGQgdG8gVXNlckFnZW50J3MgY29sbGVjdGlvblxuICAgIHRoaXMuaWQgPSB0aGlzLm91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuY2FsbElkICsgdGhpcy5vdXRnb2luZ1JlcXVlc3RNZXNzYWdlLmZyb20ucGFyYW1ldGVycy50YWcgKyB0aGlzLmV2ZW50O1xuICAgIHRoaXMuX3VzZXJBZ2VudC5fc3Vic2NyaXB0aW9uc1t0aGlzLmlkXSA9IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJ1Y3Rvci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coYFN1YnNjcmlwdGlvbiAke3RoaXMuaWR9IGluIHN0YXRlICR7dGhpcy5zdGF0ZX0gaXMgYmVpbmcgZGlzcG9zZWRgKTtcblxuICAgIC8vIFJlbW92ZSBmcm9tIHRoZSB1c2VyIGFnZW50J3Mgc3Vic2NyaXB0aW9uIGNvbGxlY3Rpb25cbiAgICBkZWxldGUgdGhpcy5fdXNlckFnZW50Ll9zdWJzY3JpcHRpb25zW3RoaXMuaWRdO1xuXG4gICAgLy8gQ2xlYXIgdGltZXJzXG4gICAgaWYgKHRoaXMucmV0cnlBZnRlclRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXRyeUFmdGVyVGltZXIpO1xuICAgICAgdGhpcy5yZXRyeUFmdGVyVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gRGlzcG9zZSBzdWJzY3JpYmVyIHJlcXVlc3RcbiAgICB0aGlzLnN1YnNjcmliZXJSZXF1ZXN0LmRpc3Bvc2UoKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0byBkaXNwb3NlIG9mIG91ciBwYXJlbnQsIHRoZW4gdW5zdWJzY3JpYmUgdGhlXG4gICAgLy8gc3Vic2NyaXB0aW9uIGRpYWxvZyAoaWYgbmVlZCBiZSkgYW5kIHJlc29sdmUgd2hlbiBpdCBoYXMgdGVybWluYXRlZC5cbiAgICByZXR1cm4gc3VwZXIuZGlzcG9zZSgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbmV2ZXIgc3Vic2NyaWJlZCB0aGVyZSBpcyBub3RoaW5nIHRvIHdhaXQgb24uXG4gICAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IHRyYW5zaXRpb25lZCB0byB0ZXJtaW5hdGVkIHRoZXJlIGlzIG5vIG5lZWQgdG8gdW5zdWJzY3JpYmUgYWdhaW4uXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdWJzY3JpcHRpb25TdGF0ZS5TdWJzY3JpYmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuX2RpYWxvZy5zdWJzY3JpcHRpb25TdGF0ZSA9PT0gU3Vic2NyaXB0aW9uRGlhbG9nU3RhdGUuUGVuZGluZyB8fFxuICAgICAgICAgIHRoaXMuX2RpYWxvZy5zdWJzY3JpcHRpb25TdGF0ZSA9PT0gU3Vic2NyaXB0aW9uRGlhbG9nU3RhdGUuQWN0aXZlXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGRpYWxvZyA9IHRoaXMuX2RpYWxvZztcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZGlhbG9nLmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgICBvblRlcm1pbmF0ZWQ6ICgpID0+IHJlc29sdmUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRpYWxvZy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gZXZlbnQgbm90aWZpY2F0aW9ucy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogU2VuZCBhbiBpbml0aWFsIFNVQlNDUklCRSByZXF1ZXN0IGlmIG5vIHN1YnNjcmlwdGlvbiBhcyBiZWVuIGVzdGFibGlzaGVkLlxuICAgKiBTZW5kcyBhIHJlLVNVQlNDUklCRSByZXF1ZXN0IGlmIHRoZSBzdWJzY3JpcHRpb24gaXMgXCJhY3RpdmVcIi5cbiAgICovXG4gIHB1YmxpYyBzdWJzY3JpYmUob3B0aW9uczogU3Vic2NyaWJlclN1YnNjcmliZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHN3aXRjaCAodGhpcy5zdWJzY3JpYmVyUmVxdWVzdC5zdGF0ZSkge1xuICAgICAgY2FzZSBTdWJzY3JpcHRpb25EaWFsb2dTdGF0ZS5Jbml0aWFsOlxuICAgICAgICAvLyB3ZSBjYW4gZW5kIHVwIGhlcmUgd2hlbiByZXRyeWluZyBzbyBvbmx5IHN0YXRlIHRyYW5zaXRpb24gaWYgaW4gU3Vic2NyaXB0aW9uU3RhdGUuSW5pdGlhbCBzdGF0ZVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3Vic2NyaXB0aW9uU3RhdGUuSW5pdGlhbCkge1xuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFN1YnNjcmlwdGlvblN0YXRlLk5vdGlmeVdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlclJlcXVlc3Quc3Vic2NyaWJlKCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3Muc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RpYWxvZyA9IHJlc3VsdC5zdWNjZXNzLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgdGhpcy5fZGlhbG9nLmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgICAgIG9uTm90aWZ5OiAocmVxdWVzdCkgPT4gdGhpcy5vbk5vdGlmeShyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICBvblJlZnJlc2g6IChyZXF1ZXN0KSA9PiB0aGlzLm9uUmVmcmVzaChyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICBvblRlcm1pbmF0ZWQ6ICgpID0+IHRoaXMuc3RhdGVUcmFuc2l0aW9uKFN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uTm90aWZ5KHJlc3VsdC5zdWNjZXNzLnJlcXVlc3QpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmZhaWx1cmUpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3Vic2NyaXB0aW9uRGlhbG9nU3RhdGUuTm90aWZ5V2FpdDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN1YnNjcmlwdGlvbkRpYWxvZ1N0YXRlLlBlbmRpbmc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdWJzY3JpcHRpb25EaWFsb2dTdGF0ZS5BY3RpdmU6XG4gICAgICAgIGlmICh0aGlzLl9kaWFsb2cpIHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fZGlhbG9nLnJlZnJlc2goKTtcbiAgICAgICAgICByZXF1ZXN0LmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgb25BY2NlcHQ6ICgocmVzcG9uc2UpID0+IHRoaXMub25BY2NlcHRlZChyZXNwb25zZSkpLFxuICAgICAgICAgICAgb25SZWRpcmVjdDogKChyZXNwb25zZSkgPT4gdGhpcy51bnN1YnNjcmliZSgpKSxcbiAgICAgICAgICAgIG9uUmVqZWN0OiAoKHJlc3BvbnNlKSA9PiB0aGlzLnVuc3Vic2NyaWJlKCkpLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN1YnNjcmlwdGlvbkRpYWxvZ1N0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGluaGVyaXREb2MgU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlfVxuICAgKi9cbiAgcHVibGljIHVuc3Vic2NyaWJlKG9wdGlvbnM6IFN1YnNjcmlwdGlvblVuc3Vic2NyaWJlT3B0aW9ucyA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnN1YnNjcmliZXJSZXF1ZXN0LnN0YXRlKSB7XG4gICAgICBjYXNlIFN1YnNjcmlwdGlvbkRpYWxvZ1N0YXRlLkluaXRpYWw6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdWJzY3JpcHRpb25EaWFsb2dTdGF0ZS5Ob3RpZnlXYWl0OlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3Vic2NyaXB0aW9uRGlhbG9nU3RhdGUuUGVuZGluZzpcbiAgICAgICAgaWYgKHRoaXMuX2RpYWxvZykge1xuICAgICAgICAgIHRoaXMuX2RpYWxvZy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIC8vIHJlc3BvbnNlcyBpbnRlbnRpb25hbGx5IGlnbm9yZWRcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3Vic2NyaXB0aW9uRGlhbG9nU3RhdGUuQWN0aXZlOlxuICAgICAgICBpZiAodGhpcy5fZGlhbG9nKSB7XG4gICAgICAgICAgdGhpcy5fZGlhbG9nLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgLy8gcmVzcG9uc2VzIGludGVudGlvbmFsbHkgaWdub3JlZFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdWJzY3JpcHRpb25EaWFsb2dTdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc3RhdGUuXCIpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHJlLVNVQlNDUklCRSByZXF1ZXN0IGlmIHRoZSBzdWJzY3JpcHRpb24gaXMgXCJhY3RpdmVcIi5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzdWJzY3JpYmVgIGluc3RlYWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF9yZWZyZXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLnN1YnNjcmliZXJSZXF1ZXN0LnN0YXRlID09PSBTdWJzY3JpcHRpb25EaWFsb2dTdGF0ZS5BY3RpdmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCBvbkFjY2VwdGVkKHJlc3BvbnNlOiBJbmNvbWluZ1Jlc3BvbnNlKTogdm9pZCB7XG4gICAgLy8gTk9URTogSWYgeW91IHRoaW5rIHlvdSBzaG91bGQgZG8gc29tZXRoaW5nIHdpdGggdGhpcyByZXNwb25zZSxcbiAgICAvLyBwbGVhc2UgbWFrZSBzdXJlIHlvdSB1bmRlcnN0YW5kIHdoYXQgaXQgaXMgeW91IGFyZSBkb2luZyBhbmQgd2h5LlxuICAgIC8vIFBlciB0aGUgUkZDLCB0aGUgZmlyc3QgTk9USUZZIGlzIGFsbCB0aGF0IGFjdHVhbGx5IG1hdHRlcnMuXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCBvbk5vdGlmeShyZXF1ZXN0OiBJbmNvbWluZ05vdGlmeVJlcXVlc3QpOiB2b2lkIHtcbiAgICAvLyBJZiB3ZSd2ZSBzZXQgc3RhdGUgdG8gZG9uZSwgbm8gZnVydGhlciBwcm9jZXNzaW5nIHNob3VsZCB0YWtlIHBsYWNlXG4gICAgLy8gYW5kIHdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gY2xlYW5pbmcgdXAgYWZ0ZXIgdGhlIGFwcHJvcHJpYXRlIE5PVElGWS5cbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdGF0ZSB0cmFuc2l0aW9uIGlmIG5lZWRlZC5cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3Vic2NyaXB0aW9uU3RhdGUuU3Vic2NyaWJlZCkge1xuICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU3Vic2NyaXB0aW9uU3RhdGUuU3Vic2NyaWJlZCk7XG4gICAgfVxuXG4gICAgLy8gRGVsZWdhdGUgbm90aWZpY2F0aW9uLlxuICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkpIHtcbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IG5ldyBOb3RpZmljYXRpb24ocmVxdWVzdCk7XG4gICAgICB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5KG5vdGlmaWNhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QuYWNjZXB0KCk7XG4gICAgfVxuXG4gICAgLy8gIElmIHRoZSBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIHZhbHVlIGlzIFN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQsIHRoZSBzdWJzY3JpYmVyXG4gICAgLy8gIE1VU1QgY29uc2lkZXIgdGhlIHN1YnNjcmlwdGlvbiB0ZXJtaW5hdGVkLiAgVGhlIFwiZXhwaXJlc1wiIHBhcmFtZXRlclxuICAgIC8vICBoYXMgbm8gc2VtYW50aWNzIGZvciBTdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkIC0tIG5vdGlmaWVycyBTSE9VTEQgTk9UIGluY2x1ZGUgYW5cbiAgICAvLyAgXCJleHBpcmVzXCIgcGFyYW1ldGVyIG9uIGEgXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBoZWFkZXIgZmllbGQgd2l0aCBhXG4gICAgLy8gIHZhbHVlIG9mIFN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQsIGFuZCBzdWJzY3JpYmVycyBNVVNUIGlnbm9yZSBhbnkgc3VjaFxuICAgIC8vICBwYXJhbWV0ZXIsIGlmIHByZXNlbnQuICBJZiBhIHJlYXNvbiBjb2RlIGlzIHByZXNlbnQsIHRoZSBjbGllbnRcbiAgICAvLyAgc2hvdWxkIGJlaGF2ZSBhcyBkZXNjcmliZWQgYmVsb3cuICBJZiBubyByZWFzb24gY29kZSBvciBhbiB1bmtub3duXG4gICAgLy8gIHJlYXNvbiBjb2RlIGlzIHByZXNlbnQsIHRoZSBjbGllbnQgTUFZIGF0dGVtcHQgdG8gcmUtc3Vic2NyaWJlIGF0IGFueVxuICAgIC8vICB0aW1lICh1bmxlc3MgYSBcInJldHJ5LWFmdGVyXCIgcGFyYW1ldGVyIGlzIHByZXNlbnQsIGluIHdoaWNoIGNhc2UgdGhlXG4gICAgLy8gIGNsaWVudCBTSE9VTEQgTk9UIGF0dGVtcHQgcmUtc3Vic2NyaXB0aW9uIHVudGlsIGFmdGVyIHRoZSBudW1iZXIgb2ZcbiAgICAvLyAgc2Vjb25kcyBzcGVjaWZpZWQgYnkgdGhlIFwicmV0cnktYWZ0ZXJcIiBwYXJhbWV0ZXIpLiAgVGhlIHJlYXNvbiBjb2Rlc1xuICAgIC8vICBkZWZpbmVkIGJ5IHRoaXMgZG9jdW1lbnQgYXJlOlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjNcbiAgICBjb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHJlcXVlc3QubWVzc2FnZS5wYXJzZUhlYWRlcihcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiKTtcbiAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdGUgJiYgc3Vic2NyaXB0aW9uU3RhdGUuc3RhdGUpIHtcbiAgICAgIHN3aXRjaCAoc3Vic2NyaXB0aW9uU3RhdGUuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcInRlcm1pbmF0ZWRcIjpcbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdGUucmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coYFRlcm1pbmF0ZWQgc3Vic2NyaXB0aW9uIHdpdGggcmVhc29uICR7c3Vic2NyaXB0aW9uU3RhdGUucmVhc29ufWApO1xuICAgICAgICAgICAgc3dpdGNoIChzdWJzY3JpcHRpb25TdGF0ZS5yZWFzb24pIHtcbiAgICAgICAgICAgICAgY2FzZSBcImRlYWN0aXZhdGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ0aW1lb3V0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0U3Vic2NyaWJlclJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgY2FzZSBcInByb2JhdGlvblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZ2l2ZXVwXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0U3Vic2NyaWJlclJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdGUucGFyYW1zICYmIHN1YnNjcmlwdGlvblN0YXRlLnBhcmFtc1tcInJldHJ5LWFmdGVyXCJdKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJldHJ5QWZ0ZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdWJzY3JpYmUoKSwgc3Vic2NyaXB0aW9uU3RhdGUucGFyYW1zW1wicmV0cnktYWZ0ZXJcIl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwibm9yZXNvdXJjZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaW52YXJpYW50XCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCBvblJlZnJlc2gocmVxdWVzdDogT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0KTogdm9pZCB7XG4gICAgcmVxdWVzdC5kZWxlZ2F0ZSA9IHtcbiAgICAgIG9uQWNjZXB0OiAocmVzcG9uc2UpID0+IHRoaXMub25BY2NlcHRlZChyZXNwb25zZSlcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0U3Vic2NyaWJlclJlcXVlc3QoKTogU3Vic2NyaWJlclJlcXVlc3Qge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgICAgYm9keTogdGhpcy5ib2R5ID8gZnJvbUJvZHlMZWdhY3kodGhpcy5ib2R5KSA6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVyUmVxdWVzdCA9IG5ldyBTdWJzY3JpYmVyUmVxdWVzdChcbiAgICAgIHRoaXMuX3VzZXJBZ2VudC51c2VyQWdlbnRDb3JlLFxuICAgICAgdGhpcy50YXJnZXRVUkksXG4gICAgICB0aGlzLmV2ZW50LFxuICAgICAgdGhpcy5leHBpcmVzLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpYmVyUmVxdWVzdC5kZWxlZ2F0ZSA9IHtcbiAgICAgIG9uQWNjZXB0OiAoKHJlc3BvbnNlKSA9PiB0aGlzLm9uQWNjZXB0ZWQocmVzcG9uc2UpKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlclJlcXVlc3Q7XG4gIH1cbn1cblxuaW50ZXJmYWNlIFN1YnNjcmliZXJSZXF1ZXN0RGVsZWdhdGUge1xuICAvKipcbiAgICogVGhpcyBTVUJTQ1JJQkUgcmVxdWVzdCB3aWxsIGJlIGNvbmZpcm1lZCB3aXRoIGEgZmluYWwgcmVzcG9uc2UuXG4gICAqIDIwMC1jbGFzcyByZXNwb25zZXMgaW5kaWNhdGUgdGhhdCB0aGUgc3Vic2NyaXB0aW9uIGhhcyBiZWVuIGFjY2VwdGVkXG4gICAqIGFuZCB0aGF0IGEgTk9USUZZIHJlcXVlc3Qgd2lsbCBiZSBzZW50IGltbWVkaWF0ZWx5LlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjFcbiAgICpcbiAgICogQ2FsbGVkIGZvciBpbml0aWFsIFNVQlNDUklCRSByZXF1ZXN0IG9ubHkuXG4gICAqIEBwYXJhbSByZXNwb25zZSAyMDAtY2xhc3MgaW5jb21pbmcgcmVzcG9uc2UuXG4gICAqL1xuICBvbkFjY2VwdD8ocmVzcG9uc2U6IEluY29taW5nUmVzcG9uc2UpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgU3Vic2NyaWJlUmVzdWx0IHtcbiAgLyoqIEV4aXN0cyBpZiBzdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQgYSBzdWJzY3JpcHRpb24sIG90aGVyd2lzZSB1bmRlZmluZWQuICovXG4gIHN1Y2Nlc3M/OiBJbmNvbWluZ1JlcXVlc3RXaXRoU3Vic2NyaXB0aW9uO1xuICAvKiogRXhpc3RzIGlmIGZhaWxlZCB0byBlc3RhYmxpc2ggYSBzdWJzY3JpcHRpb24sIG90aGVyd2lzZSB1bmRlZmluZWQuICovXG4gIGZhaWx1cmU/OiB7XG4gICAgLyoqXG4gICAgICogVGhlIG5lZ2F0aXZlIGZpbmFsIHJlc3BvbnNlIHRvIHRoZSBTVUJTQ1JJQkUsIGlmIG9uZSB3YXMgcmVjZWl2ZWQuXG4gICAgICogT3RoZXJ3aXNlIGEgdGltZW91dCBvY2N1cnJlZCB3YWl0aW5nIGZvciB0aGUgaW5pdGlhbCBOT1RJRlkuXG4gICAgICovXG4gICAgcmVzcG9uc2U/OiBJbmNvbWluZ1Jlc3BvbnNlO1xuICB9O1xufVxuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbmNsYXNzIFN1YnNjcmliZXJSZXF1ZXN0IHtcbiAgcHVibGljIGRlbGVnYXRlOiBTdWJzY3JpYmVyUmVxdWVzdERlbGVnYXRlIHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgbWVzc2FnZTogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZTtcblxuICBwcml2YXRlIGxvZ2dlcjogTG9nZ2VyO1xuICBwcml2YXRlIHJlcXVlc3Q6IE91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdCB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbkRpYWxvZyB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHN1YnNjcmliZWQgPSBmYWxzZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb3JlOiBVc2VyQWdlbnRDb3JlLFxuICAgIHByaXZhdGUgdGFyZ2V0OiBVUkksXG4gICAgcHJpdmF0ZSBldmVudDogc3RyaW5nLFxuICAgIHByaXZhdGUgZXhwaXJlczogbnVtYmVyLFxuICAgIG9wdGlvbnM6IFJlcXVlc3RPcHRpb25zLFxuICAgIGRlbGVnYXRlPzogU3Vic2NyaWJlclJlcXVlc3REZWxlZ2F0ZVxuICApIHtcbiAgICB0aGlzLmxvZ2dlciA9IGNvcmUubG9nZ2VyRmFjdG9yeS5nZXRMb2dnZXIoXCJzaXAuU3Vic2NyaWJlclwiKTtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG5cbiAgICBjb25zdCBhbGxvd0hlYWRlciA9IFwiQWxsb3c6IFwiICsgQWxsb3dlZE1ldGhvZHMudG9TdHJpbmcoKTtcbiAgICBjb25zdCBleHRyYUhlYWRlcnMgPSAob3B0aW9ucyAmJiBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaChhbGxvd0hlYWRlcik7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goXCJFdmVudDogXCIgKyB0aGlzLmV2ZW50KTtcbiAgICBleHRyYUhlYWRlcnMucHVzaChcIkV4cGlyZXM6IFwiICsgdGhpcy5leHBpcmVzKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24uY29udGFjdC50b1N0cmluZygpKTtcblxuICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zICYmIG9wdGlvbnMuYm9keTtcblxuICAgIHRoaXMubWVzc2FnZSA9IGNvcmUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoXG4gICAgICBDLlNVQlNDUklCRSxcbiAgICAgIHRoaXMudGFyZ2V0LFxuICAgICAgdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24uYW9yLFxuICAgICAgdGhpcy50YXJnZXQsXG4gICAgICB7fSxcbiAgICAgIGV4dHJhSGVhZGVycyxcbiAgICAgIGJvZHlcbiAgICApO1xuICB9XG5cbiAgLyoqIERlc3RydWN0b3IuICovXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgIHRoaXMucmVxdWVzdC53YWl0Tm90aWZ5U3RvcCgpO1xuICAgICAgdGhpcy5yZXF1ZXN0LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMucmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKiogU3Vic2NyaXB0aW9uIHN0YXRlLiAqL1xuICBwdWJsaWMgZ2V0IHN0YXRlKCk6IFN1YnNjcmlwdGlvbkRpYWxvZ1N0YXRlIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbi5zdWJzY3JpcHRpb25TdGF0ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3Vic2NyaWJlZCkge1xuICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbkRpYWxvZ1N0YXRlLk5vdGlmeVdhaXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBTdWJzY3JpcHRpb25EaWFsb2dTdGF0ZS5Jbml0aWFsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RhYmxpc2ggc3Vic2NyaXB0aW9uLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHB1YmxpYyBzdWJzY3JpYmUoKTogUHJvbWlzZTxTdWJzY3JpYmVSZXN1bHQ+IHtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm90IGluIGluaXRpYWwgc3RhdGUuIERpZCB5b3UgY2FsbCBzdWJzY3JpYmUgbW9yZSB0aGFuIG9uY2U/XCIpKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMubWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXNzYWdlIHVuZGVmaW5lZC5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLmNvcmUuc3Vic2NyaWJlKHRoaXMubWVzc2FnZSwge1xuICAgICAgICAvLyBUaGlzIFNVQlNDUklCRSByZXF1ZXN0IHdpbGwgYmUgY29uZmlybWVkIHdpdGggYSBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgLy8gMjAwLWNsYXNzIHJlc3BvbnNlcyBpbmRpY2F0ZSB0aGF0IHRoZSBzdWJzY3JpcHRpb24gaGFzIGJlZW4gYWNjZXB0ZWRcbiAgICAgICAgLy8gYW5kIHRoYXQgYSBOT1RJRlkgcmVxdWVzdCB3aWxsIGJlIHNlbnQgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMVxuICAgICAgICBvbkFjY2VwdDogKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkFjY2VwdCkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkFjY2VwdChyZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBEdWUgdG8gdGhlIHBvdGVudGlhbCBmb3Igb3V0LW9mLW9yZGVyIG1lc3NhZ2VzLCBwYWNrZXQgbG9zcywgYW5kXG4gICAgICAgIC8vIGZvcmtpbmcsIHRoZSBzdWJzY3JpYmVyIE1VU1QgYmUgcHJlcGFyZWQgdG8gcmVjZWl2ZSBOT1RJRlkgcmVxdWVzdHNcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBTVUJTQ1JJQkUgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi40XG4gICAgICAgIG9uTm90aWZ5OiAocmVxdWVzdFdpdGhTdWJzY3JpcHRpb24pOiB2b2lkID0+IHtcbiAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHJlcXVlc3RXaXRoU3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmF1dG9SZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSh7IHN1Y2Nlc3M6IHJlcXVlc3RXaXRoU3Vic2NyaXB0aW9uIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBJZiB0aGlzIFRpbWVyIE4gZXhwaXJlcyBwcmlvciB0byB0aGUgcmVjZWlwdCBvZiBhIE5PVElGWSByZXF1ZXN0LFxuICAgICAgICAvLyB0aGUgc3Vic2NyaWJlciBjb25zaWRlcnMgdGhlIHN1YnNjcmlwdGlvbiBmYWlsZWQsIGFuZCBjbGVhbnMgdXBcbiAgICAgICAgLy8gYW55IHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3Vic2NyaXB0aW9uIGF0dGVtcHQuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuNFxuICAgICAgICBvbk5vdGlmeVRpbWVvdXQ6ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHsgZmFpbHVyZToge30gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRoaXMgU1VCU0NSSUJFIHJlcXVlc3Qgd2lsbCBiZSBjb25maXJtZWQgd2l0aCBhIGZpbmFsIHJlc3BvbnNlLlxuICAgICAgICAvLyBOb24tMjAwLWNsYXNzIGZpbmFsIHJlc3BvbnNlcyBpbmRpY2F0ZSB0aGF0IG5vIHN1YnNjcmlwdGlvbiBvciBuZXdcbiAgICAgICAgLy8gZGlhbG9nIHVzYWdlIGhhcyBiZWVuIGNyZWF0ZWQsIGFuZCBubyBzdWJzZXF1ZW50IE5PVElGWSByZXF1ZXN0IHdpbGxcbiAgICAgICAgLy8gYmUgc2VudC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4xXG4gICAgICAgIG9uUmVkaXJlY3Q6IChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoeyBmYWlsdXJlOiB7IHJlc3BvbnNlIH0gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRoaXMgU1VCU0NSSUJFIHJlcXVlc3Qgd2lsbCBiZSBjb25maXJtZWQgd2l0aCBhIGZpbmFsIHJlc3BvbnNlLlxuICAgICAgICAvLyBOb24tMjAwLWNsYXNzIGZpbmFsIHJlc3BvbnNlcyBpbmRpY2F0ZSB0aGF0IG5vIHN1YnNjcmlwdGlvbiBvciBuZXdcbiAgICAgICAgLy8gZGlhbG9nIHVzYWdlIGhhcyBiZWVuIGNyZWF0ZWQsIGFuZCBubyBzdWJzZXF1ZW50IE5PVElGWSByZXF1ZXN0IHdpbGxcbiAgICAgICAgLy8gYmUgc2VudC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4xXG4gICAgICAgIG9uUmVqZWN0OiAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHsgZmFpbHVyZTogeyByZXNwb25zZSB9IH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqXG4gKiB7QGxpbmsgU3Vic2NyaXB0aW9ufSBzdGF0ZS5cbiAqIEByZW1hcmtzXG4gKiBUaGUge0BsaW5rIFN1YnNjcmlwdGlvbn0gYmVoYXZlcyBpbiBhIGRldGVybWluaXN0aWMgbWFubmVyIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nXG4gKiBGaW5pdGUgU3RhdGUgTWFjaGluZSAoRlNNKS5cbiAqIGBgYHR4dFxuICogICAgICAgICAgICAgICAgICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICogU3Vic2NyaXB0aW9uICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZcbiAqIENvbnN0cnVjdGVkIC0+IEluaXRpYWwgLT4gTm90aWZ5V2FpdCAtPiBTdWJzY3JpYmVkIC0+IFRlcm1pbmF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19eXG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGVudW0gU3Vic2NyaXB0aW9uU3RhdGUge1xuICBJbml0aWFsID0gXCJJbml0aWFsXCIsXG4gIE5vdGlmeVdhaXQgPSAgXCJOb3RpZnlXYWl0XCIsXG4gIFN1YnNjcmliZWQgPSBcIlN1YnNjcmliZWRcIixcbiAgVGVybWluYXRlZCA9IFwiVGVybWluYXRlZFwiXG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRzXCI7XG5cbmltcG9ydCB7XG4gIExvZ2dlcixcbiAgU3Vic2NyaXB0aW9uIGFzIFN1YnNjcmlwdGlvbkRpYWxvZ1xufSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgX21ha2VFbWl0dGVyLCBFbWl0dGVyLCB9IGZyb20gXCIuL2VtaXR0ZXJcIjtcbmltcG9ydCB7IFN1YnNjcmlwdGlvbkRlbGVnYXRlIH0gZnJvbSBcIi4vc3Vic2NyaXB0aW9uLWRlbGVnYXRlXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25PcHRpb25zIH0gZnJvbSBcIi4vc3Vic2NyaXB0aW9uLW9wdGlvbnNcIjtcbmltcG9ydCB7IFN1YnNjcmlwdGlvblN0YXRlIH0gZnJvbSBcIi4vc3Vic2NyaXB0aW9uLXN0YXRlXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25TdWJzY3JpYmVPcHRpb25zIH0gZnJvbSBcIi4vc3Vic2NyaXB0aW9uLXN1YnNjcmliZS1vcHRpb25zXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25VbnN1YnNjcmliZU9wdGlvbnMgfSBmcm9tIFwiLi9zdWJzY3JpcHRpb24tdW5zdWJzY3JpYmUtb3B0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50IH0gZnJvbSBcIi4vdXNlci1hZ2VudFwiO1xuXG4vKipcbiAqIEEgc3Vic2NyaXB0aW9uIHByb3ZpZGVzIHtAbGluayBOb3RpZmljYXRpb259IG9mIGV2ZW50cy5cbiAqXG4gKiBAcmVtYXJrc1xuICogU2VlIHtAbGluayBTdWJzY3JpYmVyfSBmb3IgZGV0YWlscyBvbiBlc3RhYmxpc2hpbmcgYSBzdWJzY3JpcHRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3Vic2NyaXB0aW9uIHtcblxuICAvKipcbiAgICogUHJvcGVydHkgcmVzZXJ2ZWQgZm9yIHVzZSBieSBpbnN0YW5jZSBvd25lci5cbiAgICogQGRlZmF1bHRWYWx1ZSBgdW5kZWZpbmVkYFxuICAgKi9cbiAgcHVibGljIGRhdGE6IGFueTtcblxuICAvKipcbiAgICogU3Vic2NyaXB0aW9uIGRlbGVnYXRlLiBTZWUge0BsaW5rIFN1YnNjcmlwdGlvbkRlbGVnYXRlfSBmb3IgZGV0YWlscy5cbiAgICogQGRlZmF1bHRWYWx1ZSBgdW5kZWZpbmVkYFxuICAgKi9cbiAgcHVibGljIGRlbGVnYXRlOiBTdWJzY3JpcHRpb25EZWxlZ2F0ZSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogSWYgdGhlIHN1YnNjcmlwdGlvbiBzdGF0ZSBpcyBTdWJzY3JpcHRpb25TdGF0ZS5TdWJzY3JpYmVkLCB0aGUgYXNzb2NpYXRlZCBzdWJzY3JpcHRpb24gZGlhbG9nLiBPdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBfZGlhbG9nOiBTdWJzY3JpcHRpb25EaWFsb2cgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIE91ciB1c2VyIGFnZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBfdXNlckFnZW50OiBVc2VyQWdlbnQ7XG5cbiAgcHJpdmF0ZSBfZGlzcG9zZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfbG9nZ2VyOiBMb2dnZXI7XG4gIHByaXZhdGUgX3N0YXRlOiBTdWJzY3JpcHRpb25TdGF0ZSA9IFN1YnNjcmlwdGlvblN0YXRlLkluaXRpYWw7XG4gIHByaXZhdGUgX3N0YXRlRXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHVzZXJBZ2VudCAtIFVzZXIgYWdlbnQuIFNlZSB7QGxpbmsgVXNlckFnZW50fSBmb3IgZGV0YWlscy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IodXNlckFnZW50OiBVc2VyQWdlbnQsIG9wdGlvbnM6IFN1YnNjcmlwdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2xvZ2dlciA9IHVzZXJBZ2VudC5nZXRMb2dnZXIoXCJzaXAuU3Vic2NyaXB0aW9uXCIpO1xuICAgIHRoaXMuX3VzZXJBZ2VudCA9IHVzZXJBZ2VudDtcbiAgICB0aGlzLmRlbGVnYXRlID0gb3B0aW9ucy5kZWxlZ2F0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cnVjdG9yLlxuICAgKi9cbiAgcHVibGljIGRpc3Bvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zdGF0ZUV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN1YnNjcmliZWQgc3Vic2NyaXB0aW9uIGRpYWxvZy5cbiAgICovXG4gIHB1YmxpYyBnZXQgZGlhbG9nKCk6IFN1YnNjcmlwdGlvbkRpYWxvZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2RpYWxvZztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVlIGlmIGRpc3Bvc2VkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBnZXQgZGlzcG9zZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbiBzdGF0ZS4gU2VlIHtAbGluayBTdWJzY3JpcHRpb25TdGF0ZX0gZm9yIGRldGFpbHMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YXRlKCk6IFN1YnNjcmlwdGlvblN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIGBzdGF0ZWAgcHJvcGVydHkgY2hhbmdlcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGVDaGFuZ2UoKTogRW1pdHRlcjxTdWJzY3JpcHRpb25TdGF0ZT4ge1xuICAgIHJldHVybiBfbWFrZUVtaXR0ZXIodGhpcy5fc3RhdGVFdmVudEVtaXR0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmUtU1VCU0NSSUJFIHJlcXVlc3QgaWYgdGhlIHN1YnNjcmlwdGlvbiBpcyBcImFjdGl2ZVwiLlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHN1YnNjcmliZShvcHRpb25zPzogU3Vic2NyaXB0aW9uU3Vic2NyaWJlT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gZXZlbnQgbm90aWZpY2F0aW9ucy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogSWYgdGhlIHN1YnNjcmlwdGlvbiBzdGF0ZSBpcyBTdWJzY3JpcHRpb25TdGF0ZS5TdWJzY3JpYmVkLCBzZW5kcyBhbiBpbiBkaWFsb2cgU1VCU0NSSUJFIHJlcXVlc3RcbiAgICogd2l0aCBleHBpcmVzIHRpbWUgb2YgemVybyAoYW4gdW4tc3Vic2NyaWJlKSBhbmQgdGVybWluYXRlcyB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKiBPdGhlcndpc2UgYSBub29wLlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHVuc3Vic2NyaWJlKG9wdGlvbnM/OiBTdWJzY3JpcHRpb25VbnN1YnNjcmliZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJvdGVjdGVkIHN0YXRlVHJhbnNpdGlvbihuZXdTdGF0ZTogU3Vic2NyaXB0aW9uU3RhdGUpOiB2b2lkIHtcbiAgICBjb25zdCBpbnZhbGlkVHJhbnNpdGlvbiA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gJHt0aGlzLl9zdGF0ZX0gdG8gJHtuZXdTdGF0ZX1gKTtcbiAgICB9O1xuXG4gICAgLy8gVmFsaWRhdGUgdHJhbnNpdGlvblxuICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgIGNhc2UgU3Vic2NyaXB0aW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBTdWJzY3JpcHRpb25TdGF0ZS5Ob3RpZnlXYWl0ICYmIG5ld1N0YXRlICE9PSBTdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgaW52YWxpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdDpcbiAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBTdWJzY3JpcHRpb25TdGF0ZS5TdWJzY3JpYmVkICYmIG5ld1N0YXRlICE9PSBTdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgaW52YWxpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3Vic2NyaXB0aW9uU3RhdGUuU3Vic2NyaWJlZDpcbiAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBTdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgaW52YWxpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3Vic2NyaXB0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgaW52YWxpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgc3RhdGUuXCIpO1xuICAgIH1cblxuICAgIC8vIEd1YXJkIGFnYWluc3QgZHVwbGljYXRlIHRyYW5zaXRpb25cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IG5ld1N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhbnNpdGlvblxuICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgdGhpcy5fbG9nZ2VyLmxvZyhgU3Vic2NyaXB0aW9uICR7dGhpcy5fZGlhbG9nID8gdGhpcy5fZGlhbG9nLmlkIDogdW5kZWZpbmVkfSB0cmFuc2l0aW9uZWQgdG8gJHt0aGlzLl9zdGF0ZX1gKTtcbiAgICB0aGlzLl9zdGF0ZUV2ZW50RW1pdHRlci5lbWl0KFwiZXZlbnRcIiwgdGhpcy5fc3RhdGUpO1xuXG4gICAgLy8gRGlzcG9zZVxuICAgIGlmIChuZXdTdGF0ZSA9PT0gU3Vic2NyaXB0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIHtAbGluayBUcmFuc3BvcnR9IHN0YXRlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUge0BsaW5rIFRyYW5zcG9ydH0gYmVoYXZlcyBpbiBhIGRldGVybWluaXN0aWMgbWFubmVyIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nXG4gKiBGaW5pdGUgU3RhdGUgTWFjaGluZSAoRlNNKS5cbiAqIGBgYHR4dFxuICogICAgICAgICAgICAgICAgICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICogICAgICAgICAgICAgICAgICAgfCAgICBfX19fX19fX19fX18gICAgICAgICAgICAgIHxcbiAqIFRyYW5zcG9ydCAgICAgICAgIHYgICB2ICAgICAgICAgICAgfCAgICAgICAgICAgICB8XG4gKiBDb25zdHJ1Y3RlZCAtPiBEaXNjb25uZWN0ZWQgLT4gQ29ubmVjdGluZyAtPiBDb25uZWN0ZWQgLT4gRGlzY29ubmVjdGluZ1xuICogICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgXiAgICB8X19fX19fX19fX19fX19fX19fX19fXiAgfCAgfFxuICogICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19ffCAgfFxuICogICAgICAgICAgICAgICAgICAgICB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffFxuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBlbnVtIFRyYW5zcG9ydFN0YXRlIHtcbiAgLyoqXG4gICAqIFRoZSBgY29ubmVjdCgpYCBtZXRob2Qgd2FzIGNhbGxlZC5cbiAgICovXG4gIENvbm5lY3RpbmcgPSBcIkNvbm5lY3RpbmdcIixcbiAgLyoqXG4gICAqIFRoZSBgY29ubmVjdCgpYCBtZXRob2QgcmVzb2x2ZWQuXG4gICAqL1xuICBDb25uZWN0ZWQgPSBcIkNvbm5lY3RlZFwiLFxuICAvKipcbiAgICogVGhlIGBkaXNjb25uZWN0KClgIG1ldGhvZCB3YXMgY2FsbGVkLlxuICAgKi9cbiAgRGlzY29ubmVjdGluZyA9IFwiRGlzY29ubmVjdGluZ1wiLFxuICAvKipcbiAgICogVGhlIGBjb25uZWN0KClgIG1ldGhvZCB3YXMgcmVqZWN0ZWQsIG9yXG4gICAqIHRoZSBgZGlzY29ubmVjdCgpYCBtZXRob2QgY29tcGxldGVkLCBvclxuICAgKiBuZXR3b3JrIGNvbm5lY3Rpdml0eSB3YXMgbG9zdC5cbiAgICovXG4gIERpc2Nvbm5lY3RlZCA9IFwiRGlzY29ubmVjdGVkXCJcbn1cbiIsImltcG9ydCB7IFVSSSB9IGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSB9IGZyb20gXCIuL3Nlc3Npb24tZGVzY3JpcHRpb24taGFuZGxlci1mYWN0b3J5XCI7XG5pbXBvcnQgeyBUcmFuc3BvcnQgfSBmcm9tIFwiLi90cmFuc3BvcnRcIjtcbmltcG9ydCB7IFVzZXJBZ2VudERlbGVnYXRlIH0gZnJvbSBcIi4vdXNlci1hZ2VudC1kZWxlZ2F0ZVwiO1xuXG4vKipcbiAqIExvZyBsZXZlbC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgTG9nTGV2ZWwgPSAgXCJkZWJ1Z1wiIHwgXCJsb2dcIiB8IFwid2FyblwiIHwgXCJlcnJvclwiO1xuXG4vKipcbiAqIExvZyBjb25uZWN0b3IgZnVuY3Rpb24uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIExvZ0Nvbm5lY3RvciA9IChcbiAgbGV2ZWw6IExvZ0xldmVsLFxuICBjYXRlZ29yeTogc3RyaW5nLFxuICBsYWJlbDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBjb250ZW50OiBzdHJpbmdcbikgPT4gdm9pZDtcblxuLyoqXG4gKiBTSVAgZXh0ZW5zaW9uIHN1cHBvcnQgbGV2ZWwuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBlbnVtIFNJUEV4dGVuc2lvbiB7XG4gIFJlcXVpcmVkID0gXCJSZXF1aXJlZFwiLFxuICBTdXBwb3J0ZWQgPSBcIlN1cHBvcnRlZFwiLFxuICBVbnN1cHBvcnRlZCA9IFwiVW5zdXBwb3J0ZWRcIlxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHtAbGluayBVc2VyQWdlbnR9IGNvbnN0cnVjdG9yLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJBZ2VudE9wdGlvbnMge1xuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgdXNlciBhZ2VudCB3aWxsIGFjY2VwdCBvdXQgb2YgZGlhbG9nIE5PVElGWS5cbiAgICogQHJlbWFya3NcbiAgICogUkZDIDY2NjUgb2Jzb2xldGVzIHRoZSB1c2Ugb2Ygb3V0IG9mIGRpYWxvZyBOT1RJRlkgZnJvbSBSRkMgMzI2NS5cbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICBhbGxvd0xlZ2FjeU5vdGlmaWNhdGlvbnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB1c2VyIGFnZW50IHdpbGwgYWNjZXB0IG91dCBvZiBkaWFsb2cgUkVGRVIuXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKi9cbiAgYWxsb3dPdXRPZkRpYWxvZ1JlZmVycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEF1dGhvcml6YXRpb24gcGFzc3dvcmQuXG4gICAqIEBkZWZhdWx0VmFsdWUgYFwiXCJgXG4gICAqL1xuICBhdXRob3JpemF0aW9uUGFzc3dvcmQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEF1dGhvcml6YXRpb24gdXNlcm5hbWUuXG4gICAqIEBkZWZhdWx0VmFsdWUgYFwiXCJgXG4gICAqL1xuICBhdXRob3JpemF0aW9uVXNlcm5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIElmIGB0cnVlYCwgdGhlIHVzZXIgYWdlbnQgY2FsbHMgdGhlIGBzdGFydCgpYCBtZXRob2QgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICogQHJlbWFya3NcbiAgICogVGhlIGNhbGwgdG8gc3RhcnQoKSByZXNvbHZlcyB3aGVuIHRoZSB1c2VyIGFnZW50IGNvbm5lY3RzLCBzbyBpZiB0aGlzXG4gICAqIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuIGFsdGVybmF0aXZlIG1ldGhvZCBvZiBjb25uZWN0aW9uIGRldGVjdGlvblxuICAgKiBtdXN0IGJlIHVzZWQuXG4gICAqL1xuICBhdXRvU3RhcnQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB1c2VyIGFnZW50IGNhbGxzIHRoZSBgc3RvcCgpYCBtZXRob2Qgb24gdW5sb2FkIChpZiBydW5uaW5nIGluIGJyb3dzZXIgd2luZG93KS5cbiAgICogQGRlZmF1bHRWYWx1ZSBgdHJ1ZWBcbiAgICovXG4gIGF1dG9TdG9wPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGVsZWdhdGUgZm9yIHtAbGluayBVc2VyQWdlbnR9LlxuICAgKiBAZGVmYXVsdFZhbHVlIGB7fWBcbiAgICovXG4gIGRlbGVnYXRlPzogVXNlckFnZW50RGVsZWdhdGU7XG5cbiAgLyoqXG4gICAqIFRoZSBkaXNwbGF5IG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyIGFnZW50LlxuICAgKiBAcmVtYXJrc1xuICAgKiBEZXNjcmlwdGl2ZSBuYW1lIHRvIGJlIHNob3duIHRvIHRoZSBjYWxsZWQgcGFydHkgd2hlbiBjYWxsaW5nIG9yIHNlbmRpbmcgSU0gbWVzc2FnZXNcbiAgICogKHRoZSBkaXNwbGF5IG5hbWUgcG9ydGlvbiBvZiB0aGUgRnJvbSBoZWFkZXIpLlxuICAgKiBJdCBtdXN0IE5PVCBiZSBlbmNsb3NlZCBiZXR3ZWVuIGRvdWJsZSBxdW90ZXMgZXZlbiBpZiB0aGUgZ2l2ZW4gbmFtZSBjb250YWlucyBtdWx0aS1ieXRlIHN5bWJvbHNcbiAgICogKFNJUGpzIHdpbGwgYWx3YXlzIGVuY2xvc2UgdGhlIGBkaXNwbGF5TmFtZWAgdmFsdWUgYmV0d2VlbiBkb3VibGUgcXVvdGVzKS5cbiAgICogQGRlZmF1bHRWYWx1ZSBgXCJcImBcbiAgICovXG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGb3JjZSBhZGRpbmcgcnBvcnQgdG8gVmlhIGhlYWRlci5cbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICBmb3JjZVJwb3J0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSGFja1xuICAgKiBAZGVwcmVjYXRlZCBUQkRcbiAgICovXG4gIGhhY2tJcEluQ29udGFjdD86IGJvb2xlYW4gfCBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEhhY2tcbiAgICogQGRlcHJlY2F0ZWQgVEJEXG4gICAqL1xuICBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSGFja1xuICAgKiBAZGVwcmVjYXRlZCBUQkRcbiAgICovXG4gIGhhY2tWaWFUY3A/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBIYWNrXG4gICAqIEBkZXByZWNhdGVkIFRCRFxuICAgKi9cbiAgaGFja1dzc0luVHJhbnNwb3J0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgbG9nIG1lc3NhZ2VzIHNob3VsZCBiZSB3cml0dGVuIHRvIHRoZSBicm93c2VyIGNvbnNvbGUuXG4gICAqIEBkZWZhdWx0VmFsdWUgYHRydWVgXG4gICAqL1xuICBsb2dCdWlsdGluRW5hYmxlZD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIGNvbnN0cnVjdG9yIGxvZ3MgdGhlIHVzZXIgYWdlbnQgY29uZmlndXJhdGlvbi5cbiAgICogQGRlZmF1bHRWYWx1ZSBgdHJ1ZWBcbiAgICovXG4gIGxvZ0NvbmZpZ3VyYXRpb24/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBsb2cgaXMgZ2VuZXJhdGVkLlxuICAgKiBAZGVmYXVsdFZhbHVlIEEgbm9vcFxuICAgKi9cbiAgbG9nQ29ubmVjdG9yPzogTG9nQ29ubmVjdG9yO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhlIHZlcmJvc2l0eSBsZXZlbCBvZiB0aGUgbG9nIG1lc3NhZ2VzLlxuICAgKiBAZGVmYXVsdFZhbHVlIGBcImxvZ1wiYFxuICAgKi9cbiAgbG9nTGV2ZWw/OiBMb2dMZXZlbDtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgd2hpY2ggYW4gaW5jb21pbmcgY2FsbCBpcyByZWplY3RlZCBpZiBub3QgYW5zd2VyZWQuXG4gICAqIEBkZWZhdWx0VmFsdWUgNjBcbiAgICovXG4gIG5vQW5zd2VyVGltZW91dD86IG51bWJlcjtcblxuICAvKipcbiAgICogQWRkcyBhIFJvdXRlIGhlYWRlcihzKSB0byBvdXRnb2luZyByZXF1ZXN0cy5cbiAgICogQGRlZmF1bHRWYWx1ZSBgW11gXG4gICAqL1xuICBwcmVsb2FkZWRSb3V0ZVNldD86IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIGF0dGVtcHQgdG8gcmVjb25uZWN0IHdoZW4gdGhlIHRyYW5zcG9ydCBjb25uZWN0aW9uIGRyb3BzLlxuICAgKiBAZGVmYXVsdFZhbHVlIDBcbiAgICovXG4gIHJlY29ubmVjdGlvbkF0dGVtcHRzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBTZWNvbmRzIHRvIHdhaXQgYmV0d2VlbiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgd2hlbiB0aGUgdHJhbnNwb3J0IGNvbm5lY3Rpb24gZHJvcHMuXG4gICAqIEBkZWZhdWx0VmFsdWUgNFxuICAgKi9cbiAgcmVjb25uZWN0aW9uRGVsYXk/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEEgZmFjdG9yeSBmb3IgZ2VuZXJhdGluZyBgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcmAgaW5zdGFuY2VzLlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgZmFjdG9yeSB3aWxsIGJlIHBhc3NlZCBhIGBTZXNzaW9uYCBvYmplY3QgZm9yIHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICogYW5kIHRoZSBgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlPcHRpb25zYCBvYmplY3QuXG4gICAqIEBkZWZhdWx0VmFsdWUgYFdlYi5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmRlZmF1bHRGYWN0b3J5YFxuICAgKi9cbiAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3Rvcnk/OiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeTtcblxuICAvKipcbiAgICogT3B0aW9ucyB0byBwYXNzZWQgdG8gYHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5YC5cbiAgICogQHJlbWFya3NcbiAgICogU2VlIGBXZWIuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnNgIGZvciBkZXRhaWxzLlxuICAgKiBAZGVmYXVsdFZhbHVlIGB7fWBcbiAgICovXG4gIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5T3B0aW9ucz86IG9iamVjdDtcblxuICAvKipcbiAgICogUmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MlxuICAgKiBAZGVmYXVsdFZhbHVlIGBTSVBFeHRlbnNpb24uVW5zdXBwb3J0ZWRgXG4gICAqL1xuICBzaXBFeHRlbnNpb24xMDByZWw/OiBTSVBFeHRlbnNpb247XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGhlYWRlci5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM4OTFcbiAgICogQGRlZmF1bHRWYWx1ZSBgU0lQRXh0ZW5zaW9uLlVuc3VwcG9ydGVkYFxuICAgKi9cbiAgc2lwRXh0ZW5zaW9uUmVwbGFjZXM/OiBTSVBFeHRlbnNpb247XG5cbiAgLyoqXG4gICAqIEV4dHJhIG9wdGlvbiB0YWdzIHRvIGNsYWltIHN1cHBvcnQgZm9yLlxuICAgKiBAcmVtYXJrc1xuICAgKiBTZXR0aW5nIGFuIGV4dHJhIG9wdGlvbiB0YWcgZG9lcyBub3QgZW5hYmxlIHN1cHBvcnQgZm9yIHRoZSBhc3NvY2lhdGVkIGV4dGVuc2lvblxuICAgKiBpdCBzaW1wbHkgYWRkcyB0aGUgdGFnIHRvIHRoZSBsaXN0IG9mIHN1cHBvcnRlZCBvcHRpb25zLlxuICAgKiBTZWUge0BsaW5rIFVzZXJBZ2VudFJlZ2lzdGVyZWRPcHRpb25UYWdzfSBmb3IgdmFsaWQgb3B0aW9uIHRhZ3MuXG4gICAqIEBkZWZhdWx0VmFsdWUgYFtdYFxuICAgKi9cbiAgc2lwRXh0ZW5zaW9uRXh0cmFTdXBwb3J0ZWQ/OiBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBBbiBpZCB1bmlxdWVseSBpZGVudGlmeSB0aGlzIHVzZXIgYWdlbnQgaW5zdGFuY2UuXG4gICAqIEBkZWZhdWx0VmFsdWVcbiAgICogQSByYW5kb20gaWQgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuICBzaXBqc0lkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgdXNlciBhZ2VudCdzIGBUcmFuc3BvcnRgLlxuICAgKiBAcmVtYXJrc1xuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjcmVhdGluZyB5b3VyIG93biB0cmFuc3BvcnQgc2VlIGBUcmFuc3BvcnRgLlxuICAgKiBAZGVmYXVsdFZhbHVlIGBXZWJTb2NrZXRUcmFuc3BvcnRgXG4gICAqL1xuICB0cmFuc3BvcnRDb25zdHJ1Y3Rvcj86IG5ldyAobG9nZ2VyOiBhbnksIG9wdGlvbnM6IGFueSkgPT4gVHJhbnNwb3J0O1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25zIGJ1Y2tldCBvYmplY3QgcGFzc2VkIHRvIGB0cmFuc3BvcnRDb25zdHJ1Y3RvcmAgd2hlbiBpbnN0YW50aWF0ZWQuXG4gICAqIEByZW1hcmtzXG4gICAqIFNlZSBXZWJTb2NrZXQgVHJhbnNwb3J0IENvbmZpZ3VyYXRpb24gUGFyYW1ldGVycyBmb3IgdGhlIGZ1bGwgbGlzdCBvZiBvcHRpb25zIGZvciB0aGUgZGVmYXVsdCB0cmFuc3BvcnQuXG4gICAqIEBkZWZhdWx0VmFsdWUgYHt9YFxuICAgKi9cbiAgdHJhbnNwb3J0T3B0aW9ucz86IGFueTtcblxuICAvKipcbiAgICogU0lQIEFkZHJlc3Nlcy1vZi1SZWNvcmQgVVJJIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciBhZ2VudC5cbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBpcyBhIFNJUCBhZGRyZXNzIGdpdmVuIHRvIHlvdSBieSB5b3VyIHByb3ZpZGVyLlxuICAgKiBJZiB0aGUgdXNlciBhZ2VudCByZWdpc3RlcnMsIGl0IGlzIHRoZSBhZGRyZXNzLW9mLXJlY29yZCB3aGljaCB0aGUgdXNlciBhZ2VudCByZWdpc3RlcnMgYSBjb250YWN0IGZvci5cbiAgICogQW4gYWRkcmVzcy1vZi1yZWNvcmQgcmVwcmVzZW50cyBhbiBpZGVudGl0eSBvZiB0aGUgdXNlciwgZ2VuZXJhbGx5IGEgbG9uZy10ZXJtIGlkZW50aXR5LFxuICAgKiBhbmQgaXQgZG9lcyBub3QgaGF2ZSBhIGRlcGVuZGVuY3kgb24gYW55IGRldmljZTsgdXNlcnMgY2FuIG1vdmUgYmV0d2VlbiBkZXZpY2VzIG9yIGV2ZW5cbiAgICogYmUgYXNzb2NpYXRlZCB3aXRoIG11bHRpcGxlIGRldmljZXMgYXQgb25lIHRpbWUgd2hpbGUgcmV0YWluaW5nIHRoZSBzYW1lIGFkZHJlc3Mtb2YtcmVjb3JkLlxuICAgKiBBIHNpbXBsZSBVUkksIGdlbmVyYWxseSBvZiB0aGUgZm9ybSBgc2lwOmVnZGFyQGV4YW1wbGUuY29tYCwgaXMgdXNlZCBmb3IgYW4gYWRkcmVzcy1vZi1yZWNvcmQuXG4gICAqIEBkZWZhdWx0VmFsdWVcbiAgICogQnkgZGVmYXVsdCwgVVJJIGlzIHNldCB0byBgc2lwOmFub255bW91cy5YQGFub255bW91cy5pbnZhbGlkYCwgd2hlcmUgWCBpcyBhIHJhbmRvbSB0b2tlbiBnZW5lcmF0ZWQgZm9yIGVhY2ggVUEuXG4gICAqL1xuICB1cmk/OiBVUkk7XG5cbiAgLyoqXG4gICAqIFVzZXIgYWdlbnQgc3RyaW5nIHVzZWQgaW4gdGhlIFVzZXJBZ2VudCBoZWFkZXIuXG4gICAqIEBkZWZhdWx0VmFsdWVcbiAgICogQSByZWFzb25hYmxlIHZhbHVlIGlzIHV0aWxpemVkLlxuICAgKi9cbiAgdXNlckFnZW50U3RyaW5nPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBIb3N0bmFtZSB0byB1c2UgaW4gVmlhIGhlYWRlci5cbiAgICogQGRlZmF1bHRWYWx1ZVxuICAgKiBBIHJhbmRvbSBob3N0bmFtZSBpbiB0aGUgLmludmFsaWQgZG9tYWluLlxuICAgKi9cbiAgdmlhSG9zdD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBTSVAgT3B0aW9uIFRhZ3NcbiAqIEByZW1hcmtzXG4gKiBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL3NpcC1wYXJhbWV0ZXJzL3NpcC1wYXJhbWV0ZXJzLnhodG1sI3NpcC1wYXJhbWV0ZXJzLTRcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IFVzZXJBZ2VudFJlZ2lzdGVyZWRPcHRpb25UYWdzOiB7W29wdGlvbjogc3RyaW5nXTogYm9vbGVhbn0gPSB7XG4gIFwiMTAwcmVsXCI6ICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzI2MlxuICBcIjE5OVwiOiAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDYyMjhcbiAgXCJhbnN3ZXJtb2RlXCI6ICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1MzczXG4gIFwiZWFybHktc2Vzc2lvblwiOiAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzk1OVxuICBcImV2ZW50bGlzdFwiOiAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQ2NjJcbiAgXCJleHBsaWNpdHN1YlwiOiAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQy1pZXRmLXNpcGNvcmUtcmVmZXItZXhwbGljaXQtc3Vic2NyaXB0aW9uLTAzXG4gIFwiZnJvbS1jaGFuZ2VcIjogICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDkxNlxuICBcImdlb2xvY2F0aW9uLWh0dHBcIjogICAgICAgICB0cnVlLCAgLy8gUkZDIDY0NDJcbiAgXCJnZW9sb2NhdGlvbi1zaXBcIjogICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA2NDQyXG4gIFwiZ2luXCI6ICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNjE0MFxuICBcImdydXVcIjogICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDU2MjdcbiAgXCJoaXN0aW5mb1wiOiAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA3MDQ0XG4gIFwiaWNlXCI6ICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNTc2OFxuICBcImpvaW5cIjogICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDM5MTFcbiAgXCJtdWx0aXBsZS1yZWZlclwiOiAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1MzY4XG4gIFwibm9yZWZlcnN1YlwiOiAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDQ4OFxuICBcIm5vc3ViXCI6ICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDLWlldGYtc2lwY29yZS1yZWZlci1leHBsaWNpdC1zdWJzY3JpcHRpb24tMDNcbiAgXCJvdXRib3VuZFwiOiAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1NjI2XG4gIFwicGF0aFwiOiAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzMyN1xuICBcInBvbGljeVwiOiAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDY3OTRcbiAgXCJwcmVjb25kaXRpb25cIjogICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMzEyXG4gIFwicHJlZlwiOiAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzg0MFxuICBcInByaXZhY3lcIjogICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDMzMjNcbiAgXCJyZWNpcGllbnQtbGlzdC1pbnZpdGVcIjogICAgdHJ1ZSwgIC8vIFJGQyA1MzY2XG4gIFwicmVjaXBpZW50LWxpc3QtbWVzc2FnZVwiOiAgIHRydWUsICAvLyBSRkMgNTM2NVxuICBcInJlY2lwaWVudC1saXN0LXN1YnNjcmliZVwiOiB0cnVlLCAgLy8gUkZDIDUzNjdcbiAgXCJyZXBsYWNlc1wiOiAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzODkxXG4gIFwicmVzb3VyY2UtcHJpb3JpdHlcIjogICAgICAgIHRydWUsICAvLyBSRkMgNDQxMlxuICBcInNkcC1hbmF0XCI6ICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQwOTJcbiAgXCJzZWMtYWdyZWVcIjogICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMzI5XG4gIFwidGRpYWxvZ1wiOiAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDUzOFxuICBcInRpbWVyXCI6ICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQwMjhcbiAgXCJ1dWlcIjogICAgICAgICAgICAgICAgICAgICAgdHJ1ZSAgIC8vIFJGQyA3NDMzXG59O1xuIiwiLyoqXG4gKiB7QGxpbmsgVXNlckFnZW50fSBzdGF0ZS5cbiAqIEByZW1hcmtzXG4gKiBWYWxpZCBzdGF0ZSB0cmFuc2l0aW9uczpcbiAqIGBgYFxuICogMS4gXCJTdGFydGVkXCIgLS0+IFwiU3RvcHBlZFwiXG4gKiAyLiBcIlN0b3BwZWRcIiAtLT4gXCJTdGFydGVkXCJcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZW51bSBVc2VyQWdlbnRTdGF0ZSB7XG4gIFN0YXJ0ZWQgPSBcIlN0YXJ0ZWRcIixcbiAgU3RvcHBlZCA9IFwiU3RvcHBlZFwiXG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRzXCI7XG5cbmltcG9ydCB7XG4gIENvbnRhY3QsXG4gIERpZ2VzdEF1dGhlbnRpY2F0aW9uLFxuICBHcmFtbWFyLFxuICBJbmNvbWluZ0ludml0ZVJlcXVlc3QsXG4gIEluY29taW5nTWVzc2FnZVJlcXVlc3QsXG4gIEluY29taW5nTm90aWZ5UmVxdWVzdCxcbiAgSW5jb21pbmdSZWZlclJlcXVlc3QsXG4gIEluY29taW5nUmVnaXN0ZXJSZXF1ZXN0LFxuICBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSxcbiAgSW5jb21pbmdTdWJzY3JpYmVSZXF1ZXN0LFxuICBMZXZlbHMsXG4gIExvZ2dlcixcbiAgTG9nZ2VyRmFjdG9yeSxcbiAgUGFyc2VyLFxuICBUcmFuc3BvcnRFcnJvcixcbiAgVVJJLFxuICBVc2VyQWdlbnRDb3JlLFxuICBVc2VyQWdlbnRDb3JlQ29uZmlndXJhdGlvbixcbiAgVXNlckFnZW50Q29yZURlbGVnYXRlXG59IGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQge1xuICBjcmVhdGVSYW5kb21Ub2tlbixcbiAgc3RyX3V0ZjhfbGVuZ3RoXG59IGZyb20gXCIuLi9jb3JlL21lc3NhZ2VzL3V0aWxzXCI7XG5pbXBvcnQgeyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIGFzIFdlYlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgfSBmcm9tIFwiLi4vcGxhdGZvcm0vd2ViL3Nlc3Npb24tZGVzY3JpcHRpb24taGFuZGxlclwiO1xuaW1wb3J0IHsgVHJhbnNwb3J0IGFzIFdlYlRyYW5zcG9ydCB9IGZyb20gXCIuLi9wbGF0Zm9ybS93ZWIvdHJhbnNwb3J0XCI7XG5pbXBvcnQgeyBMSUJSQVJZX1ZFUlNJT04gfSBmcm9tIFwiLi4vdmVyc2lvblwiO1xuaW1wb3J0IHsgX21ha2VFbWl0dGVyLCBFbWl0dGVyIH0gZnJvbSBcIi4vZW1pdHRlclwiO1xuaW1wb3J0IHsgSW52aXRhdGlvbiB9IGZyb20gXCIuL2ludml0YXRpb25cIjtcbmltcG9ydCB7IEludml0ZXIgfSBmcm9tIFwiLi9pbnZpdGVyXCI7XG5pbXBvcnQgeyBJbnZpdGVyT3B0aW9ucyB9IGZyb20gXCIuL2ludml0ZXItb3B0aW9uc1wiO1xuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuL21lc3NhZ2VcIjtcbmltcG9ydCB7IE5vdGlmaWNhdGlvbiB9IGZyb20gXCIuL25vdGlmaWNhdGlvblwiO1xuaW1wb3J0IHsgUHVibGlzaGVyIH0gZnJvbSBcIi4vcHVibGlzaGVyXCI7XG5pbXBvcnQgeyBSZWdpc3RlcmVyIH0gZnJvbSBcIi4vcmVnaXN0ZXJlclwiO1xuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gXCIuL3Nlc3Npb25cIjtcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gXCIuL3N1YnNjcmlwdGlvblwiO1xuaW1wb3J0IHsgVHJhbnNwb3J0IH0gZnJvbSBcIi4vdHJhbnNwb3J0XCI7XG5pbXBvcnQgeyBVc2VyQWdlbnREZWxlZ2F0ZSB9IGZyb20gXCIuL3VzZXItYWdlbnQtZGVsZWdhdGVcIjtcbmltcG9ydCB7XG4gIFNJUEV4dGVuc2lvbixcbiAgVXNlckFnZW50T3B0aW9ucyxcbiAgVXNlckFnZW50UmVnaXN0ZXJlZE9wdGlvblRhZ3Ncbn0gZnJvbSBcIi4vdXNlci1hZ2VudC1vcHRpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRTdGF0ZSB9IGZyb20gXCIuL3VzZXItYWdlbnQtc3RhdGVcIjtcblxuZGVjbGFyZSB2YXIgY2hyb21lOiBhbnk7XG5cbi8qKlxuICogQSB1c2VyIGFnZW50IHNlbmRzIGFuZCByZWNlaXZlcyByZXF1ZXN0cyB1c2luZyBhIGBUcmFuc3BvcnRgLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBIHVzZXIgYWdlbnQgKFVBKSBpcyBhc3NvY2lhdGVkIHdpdGggYSB1c2VyIHZpYSB0aGUgdXNlcidzIFNJUCBhZGRyZXNzIG9mIHJlY29yZCAoQU9SKVxuICogYW5kIGFjdHMgb24gYmVoYWxmIG9mIHRoYXQgdXNlciB0byBzZW5kIGFuZCByZWNlaXZlIFNJUCByZXF1ZXN0cy4gVGhlIHVzZXIgYWdlbnQgY2FuXG4gKiByZWdpc3RlciB0byByZWNlaXZlIGluY29taW5nIHJlcXVlc3RzLCBhcyB3ZWxsIGFzIGNyZWF0ZSBhbmQgc2VuZCBvdXRib3VuZCBtZXNzYWdlcy5cbiAqIFRoZSB1c2VyIGFnZW50IGFsc28gbWFpbnRhaW5zIHRoZSBUcmFuc3BvcnQgb3ZlciB3aGljaCBpdHMgc2lnbmFsaW5nIHRyYXZlbHMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVXNlckFnZW50IHtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgVVJJIGluc3RhbmNlIGZyb20gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB1cmkgLSBUaGUgc3RyaW5nIHRvIHBhcnNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCB1cmkgPSBVc2VyQWdlbnQubWFrZVVSSShcInNpcDplZGdhckBleGFtcGxlLmNvbVwiKTtcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1ha2VVUkkodXJpOiBzdHJpbmcpOiBVUkkgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBHcmFtbWFyLlVSSVBhcnNlKHVyaSk7XG4gIH1cblxuICAvKiogRGVmYXVsdCB1c2VyIGFnZW50IG9wdGlvbnMuICovXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGRlZmF1bHRPcHRpb25zOiBSZXF1aXJlZDxVc2VyQWdlbnRPcHRpb25zPiA9IHtcbiAgICBhbGxvd0xlZ2FjeU5vdGlmaWNhdGlvbnM6IGZhbHNlLFxuICAgIGFsbG93T3V0T2ZEaWFsb2dSZWZlcnM6IGZhbHNlLFxuICAgIGF1dGhvcml6YXRpb25QYXNzd29yZDogXCJcIixcbiAgICBhdXRob3JpemF0aW9uVXNlcm5hbWU6IFwiXCIsXG4gICAgYXV0b1N0YXJ0OiBmYWxzZSxcbiAgICBhdXRvU3RvcDogdHJ1ZSxcbiAgICBkZWxlZ2F0ZToge30sXG4gICAgZGlzcGxheU5hbWU6IFwiXCIsXG4gICAgZm9yY2VScG9ydDogZmFsc2UsXG4gICAgaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFnczogZmFsc2UsXG4gICAgaGFja0lwSW5Db250YWN0OiBmYWxzZSxcbiAgICBoYWNrVmlhVGNwOiBmYWxzZSxcbiAgICBoYWNrV3NzSW5UcmFuc3BvcnQ6IGZhbHNlLFxuICAgIGxvZ0J1aWx0aW5FbmFibGVkOiB0cnVlLFxuICAgIGxvZ0NvbmZpZ3VyYXRpb246IHRydWUsXG4gICAgbG9nQ29ubmVjdG9yOiAoKSA9PiB7IC8qIG5vb3AgKi8gfSxcbiAgICBsb2dMZXZlbDogXCJsb2dcIixcbiAgICBub0Fuc3dlclRpbWVvdXQ6IDYwLFxuICAgIHByZWxvYWRlZFJvdXRlU2V0OiBbXSxcbiAgICByZWNvbm5lY3Rpb25BdHRlbXB0czogMCxcbiAgICByZWNvbm5lY3Rpb25EZWxheTogNCxcbiAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeTogV2ViU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5kZWZhdWx0RmFjdG9yeSxcbiAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnM6IHt9LFxuICAgIHNpcEV4dGVuc2lvbjEwMHJlbDogU0lQRXh0ZW5zaW9uLlVuc3VwcG9ydGVkLFxuICAgIHNpcEV4dGVuc2lvblJlcGxhY2VzOiBTSVBFeHRlbnNpb24uVW5zdXBwb3J0ZWQsXG4gICAgc2lwRXh0ZW5zaW9uRXh0cmFTdXBwb3J0ZWQ6IFtdLFxuICAgIHNpcGpzSWQ6IFwiXCIsXG4gICAgdHJhbnNwb3J0Q29uc3RydWN0b3I6IFdlYlRyYW5zcG9ydCxcbiAgICB0cmFuc3BvcnRPcHRpb25zOiB7fSxcbiAgICB1cmk6IG5ldyBVUkkoXCJzaXBcIiwgXCJhbm9ueW1vdXNcIiwgXCJhbm9ueW1vdXMuaW52YWxpZFwiKSxcbiAgICB1c2VyQWdlbnRTdHJpbmc6IFwiU0lQLmpzL1wiICsgTElCUkFSWV9WRVJTSU9OLFxuICAgIHZpYUhvc3Q6IFwiXCJcbiAgfTtcblxuICAvKipcbiAgICogU3RyaXAgcHJvcGVydGllcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSBvcHRpb25zLlxuICAgKiBUaGlzIGlzIGEgd29yayBhcm91bmQgd2hpbGUgd2FpdGluZyBmb3IgbWlzc2luZyB2cyB1bmRlZmluZWQgdG8gYmUgYWRkcmVzc2VkIChvciBub3QpLi4uXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTMxOTVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIHJlZHVjZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgc3RyaXBVbmRlZmluZWRQcm9wZXJ0aWVzKG9wdGlvbnM6IFBhcnRpYWw8VXNlckFnZW50T3B0aW9ucz4pOiBQYXJ0aWFsPFVzZXJBZ2VudE9wdGlvbnM+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKChvYmplY3QsIGtleSkgPT4ge1xuICAgICAgaWYgKChvcHRpb25zIGFzIGFueSlba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIChvYmplY3QgYXMgYW55KVtrZXldID0gKG9wdGlvbnMgYXMgYW55KVtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvcGVydHkgcmVzZXJ2ZWQgZm9yIHVzZSBieSBpbnN0YW5jZSBvd25lci5cbiAgICogQGRlZmF1bHRWYWx1ZSBgdW5kZWZpbmVkYFxuICAgKi9cbiAgcHVibGljIGRhdGE6IGFueTtcblxuICAvKipcbiAgICogRGVsZWdhdGUuXG4gICAqL1xuICBwdWJsaWMgZGVsZWdhdGU6IFVzZXJBZ2VudERlbGVnYXRlIHwgdW5kZWZpbmVkO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIF9wdWJsaXNoZXJzOiB7IFtpZDogc3RyaW5nXTogUHVibGlzaGVyIH0gPSB7fTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwdWJsaWMgX3JlZ2lzdGVyZXJzOiB7IFtpZDogc3RyaW5nXTogUmVnaXN0ZXJlciB9ID0ge307XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIF9zZXNzaW9uczogeyBbaWQ6IHN0cmluZ106IFNlc3Npb24gfSA9IHt9O1xuICAvKiogQGludGVybmFsICovXG4gIHB1YmxpYyBfc3Vic2NyaXB0aW9uczogeyBbaWQ6IHN0cmluZ106IFN1YnNjcmlwdGlvbiB9ID0ge307XG5cbiAgcHJpdmF0ZSBfY29udGFjdDogQ29udGFjdDtcbiAgcHJpdmF0ZSBfc3RhdGU6IFVzZXJBZ2VudFN0YXRlID0gVXNlckFnZW50U3RhdGUuU3RvcHBlZDtcbiAgcHJpdmF0ZSBfc3RhdGVFdmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIHByaXZhdGUgX3N0YXRlSW5pdGlhbCA9IHRydWU7XG4gIHByaXZhdGUgX3RyYW5zcG9ydDogVHJhbnNwb3J0O1xuICBwcml2YXRlIF91c2VyQWdlbnRDb3JlOiBVc2VyQWdlbnRDb3JlO1xuXG4gIC8qKiBMb2dnZXIuICovXG4gIHByaXZhdGUgbG9nZ2VyOiBMb2dnZXI7XG4gIC8qKiBMb2dnZXJGYWN0b3J5LiAqL1xuICBwcml2YXRlIGxvZ2dlckZhY3Rvcnk6IExvZ2dlckZhY3RvcnkgPSBuZXcgTG9nZ2VyRmFjdG9yeSgpO1xuICAvKiogT3B0aW9ucy4gKi9cbiAgcHJpdmF0ZSBvcHRpb25zOiBSZXF1aXJlZDxVc2VyQWdlbnRPcHRpb25zPjtcbiAgLyoqIFVubG9hZCBsaXN0ZW5lci4gKi9cbiAgcHJpdmF0ZSB1bmxvYWRMaXN0ZW5lciA9ICgoKSA9PiB7IHRoaXMuc3RvcCgpOyB9KTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFVzZXJBZ2VudGAgY2xhc3MuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuIFNlZSB7QGxpbmsgVXNlckFnZW50T3B0aW9uc30gZm9yIGRldGFpbHMuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgb3B0aW9uczogUGFydGlhbDxVc2VyQWdlbnRPcHRpb25zPiA9IHt9XG4gICkge1xuICAgIC8vIGluaXRpYWxpemUgZGVsZWdhdGVcbiAgICB0aGlzLmRlbGVnYXRlID0gb3B0aW9ucy5kZWxlZ2F0ZTtcblxuICAgIC8vIGluaXRpYWxpemUgY29uZmlndXJhdGlvblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC8vIHN0YXJ0IHdpdGggdGhlIGRlZmF1bHQgb3B0aW9uIHZhbHVlc1xuICAgICAgLi4uVXNlckFnZW50LmRlZmF1bHRPcHRpb25zLFxuICAgICAgLy8gYWRkIGEgdW5pcXVlIHNpcGpzIGlkIGZvciBlYWNoIGluc3RhbmNlXG4gICAgICAuLi57IHNpcGpzSWQ6IGNyZWF0ZVJhbmRvbVRva2VuKDUpIH0sXG4gICAgICAvLyBhZGQgYSB1bmlxdWUgYW5vbnltb3VzIHVyaSBmb3IgZWFjaCBpbnN0YW5jZVxuICAgICAgLi4ueyB1cmk6IG5ldyBVUkkoXCJzaXBcIiwgXCJhbm9ueW1vdXMuXCIgKyBjcmVhdGVSYW5kb21Ub2tlbig2KSwgXCJhbm9ueW1vdXMuaW52YWxpZFwiKSB9LFxuICAgICAgLy8gYWRkIGEgdW5pcXVlIHZpYSBob3N0IGZvciBlYWNoIGluc3RhbmNlXG4gICAgICAuLi57IHZpYUhvc3Q6IGNyZWF0ZVJhbmRvbVRva2VuKDEyKSArIFwiLmludmFsaWRcIiB9LFxuICAgICAgLy8gYXBwbHkgYW55IG9wdGlvbnMgcGFzc2VkIGluIHZpYSB0aGUgY29uc3RydWN0b3JcbiAgICAgIC4uLlVzZXJBZ2VudC5zdHJpcFVuZGVmaW5lZFByb3BlcnRpZXMob3B0aW9ucylcbiAgICB9O1xuXG4gICAgLy8gdmlhSG9zdCBpcyBoYWNrXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYWNrSXBJbkNvbnRhY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmhhY2tJcEluQ29udGFjdCA9PT0gXCJib29sZWFuXCIgJiYgdGhpcy5vcHRpb25zLmhhY2tJcEluQ29udGFjdCkge1xuICAgICAgICBjb25zdCBmcm9tOiBudW1iZXIgPSAxO1xuICAgICAgICBjb25zdCB0bzogbnVtYmVyID0gMjU0O1xuICAgICAgICBjb25zdCBvY3RldDogbnVtYmVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHRvIC0gZnJvbSArIDEpICsgZnJvbSk7XG4gICAgICAgIC8vIHJhbmRvbSBUZXN0LU5ldCBJUCAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTczNSlcbiAgICAgICAgdGhpcy5vcHRpb25zLnZpYUhvc3QgPSBcIjE5Mi4wLjIuXCIgKyBvY3RldDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmhhY2tJcEluQ29udGFjdCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmlhSG9zdCA9IHRoaXMub3B0aW9ucy5oYWNrSXBJbkNvbnRhY3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBsb2dnZXIgJiBsb2dnZXIgZmFjdG9yeVxuICAgIHRoaXMubG9nZ2VyID0gdGhpcy5sb2dnZXJGYWN0b3J5LmdldExvZ2dlcihcInNpcC5Vc2VyQWdlbnRcIik7XG4gICAgdGhpcy5sb2dnZXJGYWN0b3J5LmJ1aWx0aW5FbmFibGVkID0gdGhpcy5vcHRpb25zLmxvZ0J1aWx0aW5FbmFibGVkO1xuICAgIHRoaXMubG9nZ2VyRmFjdG9yeS5jb25uZWN0b3IgPSB0aGlzLm9wdGlvbnMubG9nQ29ubmVjdG9yIGFzXG4gICAgICAobGV2ZWw6IHN0cmluZywgY2F0ZWdvcnk6IHN0cmluZywgbGFiZWw6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGVudDogc3RyaW5nKSA9PiB2b2lkO1xuICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLmxvZ0xldmVsKSB7XG4gICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgdGhpcy5sb2dnZXJGYWN0b3J5LmxldmVsID0gTGV2ZWxzLmVycm9yO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ3YXJuXCI6XG4gICAgICAgIHRoaXMubG9nZ2VyRmFjdG9yeS5sZXZlbCA9IExldmVscy53YXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgdGhpcy5sb2dnZXJGYWN0b3J5LmxldmVsID0gTGV2ZWxzLmxvZztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgdGhpcy5sb2dnZXJGYWN0b3J5LmxldmVsID0gTGV2ZWxzLmRlYnVnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubG9nQ29uZmlndXJhdGlvbikge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFwiQ29uZmlndXJhdGlvbjpcIik7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLm9wdGlvbnMgYXMgYW55KVtrZXldO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgXCJ1cmlcIjpcbiAgICAgICAgICBjYXNlIFwic2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlcIjpcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIsK3IFwiICsga2V5ICsgXCI6IFwiICsgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImF1dGhvcml6YXRpb25QYXNzd29yZFwiOlxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiwrcgXCIgKyBrZXkgKyBcIjogXCIgKyBcIk5PVCBTSE9XTlwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0cmFuc3BvcnRDb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiwrcgXCIgKyBrZXkgKyBcIjogXCIgKyB2YWx1ZS5uYW1lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCLCtyBcIiArIGtleSArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGd1YXJkIGRlcHJlY2F0ZWQgdHJhbnNwb3J0IG9wdGlvbnMgKHJlbW92ZSB0aGlzIGluIHZlcnNpb24gMTYueClcbiAgICBpZiAodGhpcy5vcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnNEZXByZWNhdGVkOiBhbnkgPSB0aGlzLm9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucztcbiAgICAgIGNvbnN0IG1heFJlY29ubmVjdGlvbkF0dGVtcHRzRGVwcmVjYXRlZDogbnVtYmVyIHwgdW5kZWZpbmVkID0gb3B0aW9uc0RlcHJlY2F0ZWQubWF4UmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gICAgICBjb25zdCByZWNvbm5lY3Rpb25UaW1lb3V0RGVwcmVjYXRlZDogbnVtYmVyIHwgdW5kZWZpbmVkID0gb3B0aW9uc0RlcHJlY2F0ZWQucmVjb25uZWN0aW9uVGltZW91dDtcbiAgICAgIGlmIChtYXhSZWNvbm5lY3Rpb25BdHRlbXB0c0RlcHJlY2F0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBkZXByZWNhdGVkTWVzc2FnZSA9XG4gICAgICAgICAgYFRoZSB0cmFuc3BvcnQgb3B0aW9uIFwibWF4UmVjb25uZWN0aW9uQXR0ZW1wdHNcIiBhcyBoYXMgYXBwYXJlbnRseSBiZWVuIHNwZWNpZmllZCBhbmQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gYCArXG4gICAgICAgICAgXCJJdCB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUgc3RhcnRpbmcgd2l0aCBTSVAuanMgcmVsZWFzZSAwLjE2LjAuIFBsZWFzZSB1cGRhdGUgYWNjb3JkaW5nbHkuXCI7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZGVwcmVjYXRlZE1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKHJlY29ubmVjdGlvblRpbWVvdXREZXByZWNhdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZGVwcmVjYXRlZE1lc3NhZ2UgPVxuICAgICAgICAgIGBUaGUgdHJhbnNwb3J0IG9wdGlvbiBcInJlY29ubmVjdGlvblRpbWVvdXRcIiBhcyBoYXMgYXBwYXJlbnRseSBiZWVuIHNwZWNpZmllZCBhbmQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gYCArXG4gICAgICAgICAgXCJJdCB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUgc3RhcnRpbmcgd2l0aCBTSVAuanMgcmVsZWFzZSAwLjE2LjAuIFBsZWFzZSB1cGRhdGUgYWNjb3JkaW5nbHkuXCI7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZGVwcmVjYXRlZE1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYWNrXG4gICAgICBpZiAob3B0aW9ucy5yZWNvbm5lY3Rpb25EZWxheSA9PT0gdW5kZWZpbmVkICYmIHJlY29ubmVjdGlvblRpbWVvdXREZXByZWNhdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnJlY29ubmVjdGlvbkRlbGF5ID0gcmVjb25uZWN0aW9uVGltZW91dERlcHJlY2F0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9PT0gdW5kZWZpbmVkICYmIG1heFJlY29ubmVjdGlvbkF0dGVtcHRzRGVwcmVjYXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IG1heFJlY29ubmVjdGlvbkF0dGVtcHRzRGVwcmVjYXRlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBndWFyZCBkZXByZWNhdGVkIHVzZXIgYWdlbnQgb3B0aW9ucyAocmVtb3ZlIHRoaXMgaW4gdmVyc2lvbiAxNi54KVxuICAgIGlmIChvcHRpb25zLnJlY29ubmVjdGlvbkRlbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRlcHJlY2F0ZWRNZXNzYWdlID1cbiAgICAgICAgYFRoZSB1c2VyIGFnZW50IG9wdGlvbiBcInJlY29ubmVjdGlvbkRlbGF5XCIgYXMgaGFzIGFwcGFyZW50bHkgYmVlbiBzcGVjaWZpZWQgYW5kIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIGAgK1xuICAgICAgICBcIkl0IHdpbGwgbm8gbG9uZ2VyIGJlIGF2YWlsYWJsZSBzdGFydGluZyB3aXRoIFNJUC5qcyByZWxlYXNlIDAuMTYuMC4gUGxlYXNlIHVwZGF0ZSBhY2NvcmRpbmdseS5cIjtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oZGVwcmVjYXRlZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZWNvbm5lY3Rpb25BdHRlbXB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkZXByZWNhdGVkTWVzc2FnZSA9XG4gICAgICAgIGBUaGUgdXNlciBhZ2VudCBvcHRpb24gXCJyZWNvbm5lY3Rpb25BdHRlbXB0c1wiIGFzIGhhcyBhcHBhcmVudGx5IGJlZW4gc3BlY2lmaWVkIGFuZCBoYXMgYmVlbiBkZXByZWNhdGVkLiBgICtcbiAgICAgICAgXCJJdCB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUgc3RhcnRpbmcgd2l0aCBTSVAuanMgcmVsZWFzZSAwLjE2LjAuIFBsZWFzZSB1cGRhdGUgYWNjb3JkaW5nbHkuXCI7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGRlcHJlY2F0ZWRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIFRyYW5zcG9ydFxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG5ldyB0aGlzLm9wdGlvbnMudHJhbnNwb3J0Q29uc3RydWN0b3IoXG4gICAgICB0aGlzLmdldExvZ2dlcihcInNpcC5UcmFuc3BvcnRcIiksXG4gICAgICB0aGlzLm9wdGlvbnMudHJhbnNwb3J0T3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5pbml0VHJhbnNwb3J0Q2FsbGJhY2tzKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIENvbnRhY3RcbiAgICB0aGlzLl9jb250YWN0ID0gdGhpcy5pbml0Q29udGFjdCgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBVc2VyQWdlbnRDb3JlXG4gICAgdGhpcy5fdXNlckFnZW50Q29yZSA9IHRoaXMuaW5pdENvcmUoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1N0YXJ0KSB7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZXIgYWdlbnQgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBnZXQgY29uZmlndXJhdGlvbigpOiBSZXF1aXJlZDxVc2VyQWdlbnRPcHRpb25zPiB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VyIGFnZW50IGNvbnRhY3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNvbnRhY3QoKTogQ29udGFjdCB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhY3Q7XG4gIH1cblxuICAvKipcbiAgICogVXNlciBhZ2VudCBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGUoKTogVXNlckFnZW50U3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VyIGFnZW50IHN0YXRlIGNoYW5nZSBlbWl0dGVyLlxuICAgKi9cbiAgcHVibGljIGdldCBzdGF0ZUNoYW5nZSgpOiBFbWl0dGVyPFVzZXJBZ2VudFN0YXRlPiB7XG4gICAgcmV0dXJuIF9tYWtlRW1pdHRlcih0aGlzLl9zdGF0ZUV2ZW50RW1pdHRlcik7XG4gIH1cblxuICAvKipcbiAgICogVXNlciBhZ2VudCB0cmFuc3BvcnQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRyYW5zcG9ydCgpOiBUcmFuc3BvcnQge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlciBhZ2VudCBjb3JlLlxuICAgKi9cbiAgcHVibGljIGdldCB1c2VyQWdlbnRDb3JlKCk6IFVzZXJBZ2VudENvcmUge1xuICAgIHJldHVybiB0aGlzLl91c2VyQWdlbnRDb3JlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsb2dnZXIuXG4gICAqL1xuICBwdWJsaWMgZ2V0TG9nZ2VyKGNhdGVnb3J5OiBzdHJpbmcsIGxhYmVsPzogc3RyaW5nKTogTG9nZ2VyIHtcbiAgICByZXR1cm4gdGhpcy5sb2dnZXJGYWN0b3J5LmdldExvZ2dlcihjYXRlZ29yeSwgbGFiZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsb2dnZXIgZmFjdG9yeS5cbiAgICovXG4gIHB1YmxpYyBnZXRMb2dnZXJGYWN0b3J5KCk6IExvZ2dlckZhY3Rvcnkge1xuICAgIHJldHVybiB0aGlzLmxvZ2dlckZhY3Rvcnk7XG4gIH1cblxuICAvKipcbiAgICogVHJ1ZSBpZiB0cmFuc3BvcnQgaXMgY29ubmVjdGVkLlxuICAgKi9cbiAgcHVibGljIGlzQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5pc0Nvbm5lY3RlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29ubmVjdCB0aGUgdHJhbnNwb3J0LlxuICAgKi9cbiAgcHVibGljIHJlY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVXNlckFnZW50U3RhdGUuU3RvcHBlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlVzZXIgYWdlbnQgc3RvcHBlZC5cIikpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgY2FsbCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdGhpcy50cmFuc3BvcnQuY29ubmVjdCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgdXNlciBhZ2VudC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogUmVzb2x2ZXMgaWYgdHJhbnNwb3J0IGNvbm5lY3RzLCBvdGhlcndpc2UgcmVqZWN0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogdXNlckFnZW50LnN0YXJ0KClcbiAgICogICAudGhlbigoKSA9PiB7XG4gICAqICAgICAvLyB1c2VyQWdlbnQuaXNDb25uZWN0ZWQoKSA9PT0gdHJ1ZVxuICAgKiAgIH0pXG4gICAqICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICogICAgIC8vIHVzZXJBZ2VudC5pc0Nvbm5lY3RlZCgpID09PSBmYWxzZVxuICAgKiAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBzdGFydCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVXNlckFnZW50U3RhdGUuU3RhcnRlZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgVXNlciBhZ2VudCBhbHJlYWR5IHN0YXJ0ZWRgKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIubG9nKGBTdGFydGluZyAke3RoaXMuY29uZmlndXJhdGlvbi51cml9YCk7XG5cbiAgICAvLyBUT0RPOiBNYWtlIHRoZXNlIHByb3BlcnRpZXMgb25seSB2YWxpZCB3aGlsZSBpbiBcIlN0YXJ0ZWRcIiBzdGF0ZS5cbiAgICAvLyBUaGlzIGlzIGhvbGQgb3ZlciBvZiBlYXJsaWVyIHRpbWVzLiBPdGhlciBpbnRlcm5hbC9leHRlcm5hbCBjb2RlXG4gICAgLy8gaXMgZGVwZW5kaW5nIG9uIHRoZXNlIHByb3BlcnRpZXMgZXhpc3RpbmcgYWZ0ZXIgY29uc3RydWN0aW9uLCBzb1xuICAgIC8vIHdlIGNvbnN0cnVjdCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlbSBkdXJpbmcgY29uc3RydWN0aW9uLiBXZVxuICAgIC8vIGRvbid0IG5lZWQgdG8gcmVtYWtlIHRoZW0gdGhlIGZpcnN0IHRpbWUgc3RhcnQoKSBpcyBjYWxsZWQsIHNvXG4gICAgLy8gd2UgaGF2ZSB0aGlzIGxpdHRsZSBzdGF0ZUluaXRpYWwgdGhpbmcgZ29pbmcgb24uLi5cbiAgICBpZiAoIXRoaXMuX3N0YXRlSW5pdGlhbCkge1xuICAgICAgdGhpcy5fc3RhdGVJbml0aWFsID0gZmFsc2U7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgVHJhbnNwb3J0XG4gICAgICB0aGlzLl90cmFuc3BvcnQgPSBuZXcgdGhpcy5vcHRpb25zLnRyYW5zcG9ydENvbnN0cnVjdG9yKFxuICAgICAgICB0aGlzLmdldExvZ2dlcihcInNpcC5UcmFuc3BvcnRcIiksXG4gICAgICAgIHRoaXMub3B0aW9ucy50cmFuc3BvcnRPcHRpb25zXG4gICAgICApO1xuICAgICAgdGhpcy5pbml0VHJhbnNwb3J0Q2FsbGJhY2tzKCk7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgQ29udGFjdFxuICAgICAgdGhpcy5fY29udGFjdCA9IHRoaXMuaW5pdENvbnRhY3QoKTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBVc2VyQWdlbnRDb3JlXG4gICAgICB0aGlzLl91c2VyQWdlbnRDb3JlID0gdGhpcy5pbml0Q29yZSgpO1xuICAgIH1cblxuICAgIC8vIFRyYW5zaXRpb24gc3RhdGVcbiAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZShVc2VyQWdlbnRTdGF0ZS5TdGFydGVkKTtcblxuICAgIC8vIFRPRE86IFJldmlldyB0aGlzIGFzIGl0IGlzIG5vdCBjbGVhciBpdCBoYXMgYW55IGJlbmVmaXQgYW5kIGF0IHdvcnN0IGNhdXNlcyBhZGRpdGlvbmFsIGxvYWQgdGhlIHNlcnZlci5cbiAgICAvLyBPbiB1bmxvYWQgaXQgbWF5IGJlIGJlc3QgdG8gc2ltcGx5IGluIG1vc3Qgc2NlbmFyaW9zIHRvIGRvIG5vdGhpbmcuIEZ1cnRoZXJtb3JlIGFuZCByZWdhcmRsZXNzLCB0aGlzXG4gICAgLy8ga2luZCBvZiBiZWhhdmlvciBzZWVtcyBtb3JlIGFwcHJvcHJpYXRlIHRvIGJlIG1hbmFnZWQgYnkgdGhlIGNvbnN1bWVyIG9mIHRoZSBBUEkgdGhhbiB0aGUgQVBJIGl0c2VsZi5cbiAgICAvLyBTaG91bGQgdGhpcyBwZXJoYXBzIGJlIGRlcHJlY2F0ZWQ/XG4gICAgLy9cbiAgICAvLyBBZGQgd2luZG93IHVubG9hZCBldmVudCBsaXN0ZW5lclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1N0b3ApIHtcbiAgICAgIC8vIEdvb2dsZSBDaHJvbWUgUGFja2FnZWQgQXBwcyBkb24ndCBhbGxvdyAndW5sb2FkJyBsaXN0ZW5lcnM6IHVubG9hZCBpcyBub3QgYXZhaWxhYmxlIGluIHBhY2thZ2VkIGFwcHNcbiAgICAgIGNvbnN0IGdvb2dsZUNocm9tZVBhY2thZ2VkQXBwID0gdHlwZW9mIGNocm9tZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjaHJvbWUuYXBwICYmIGNocm9tZS5hcHAucnVudGltZSA/IHRydWUgOiBmYWxzZTtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAhZ29vZ2xlQ2hyb21lUGFja2FnZWRBcHBcbiAgICAgICkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCB0aGlzLnVubG9hZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuY29ubmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHVzZXIgYWdlbnQuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFJlc29sdmVzIHdoZW4gdGhlIHVzZXIgYWdlbnQgaGFzIGNvbXBsZXRlZCBhIGdyYWNlZnVsIHNodXRkb3duLlxuICAgKiBgYGB0eHRcbiAgICogMSkgU2Vzc2lvbnMgdGVybWluYXRlLlxuICAgKiAyKSBSZWdpc3RlcmVycyB1bnJlZ2lzdGVyLlxuICAgKiAzKSBTdWJzY3JpYmVycyB1bnN1YnNjcmliZS5cbiAgICogNCkgUHVibGlzaGVycyB1bnB1Ymxpc2guXG4gICAqIDUpIFRyYW5zcG9ydCBkaXNjb25uZWN0cy5cbiAgICogNikgVXNlciBBZ2VudCBDb3JlIHJlc2V0cy5cbiAgICogYGBgXG4gICAqIE5PVEU6IFdoaWxlIHRoaXMgaXMgYSBcImdyYWNlZnVsIHNodXRkb3duXCIsIGl0IGNhbiBhbHNvIGJlIHZlcnkgc2xvdyBvbmUgaWYgeW91XG4gICAqIGFyZSB3YWl0aW5nIGZvciB0aGUgcmV0dXJuZWQgUHJvbWlzZSB0byByZXNvbHZlLiBUaGUgZGlzcG9zYWwgb2YgdGhlIGNsaWVudHMgYW5kXG4gICAqIGRpYWxvZ3MgaXMgZG9uZSBzZXJpYWxseSAtIHdhaXRpbmcgb24gb25lIHRvIGZpbmlzaCBiZWZvcmUgbW92aW5nIG9uIHRvIHRoZSBuZXh0LlxuICAgKiBUaGlzIGNhbiBiZSBzbG93IGlmIHRoZXJlIGFyZSBsb3Qgb2Ygc3Vic2NyaXB0aW9ucyB0byB1bnN1YnNjcmliZSBmb3IgZXhhbXBsZS5cbiAgICpcbiAgICogVEhFIFNMT1cgUEFDRSBJUyBJTlRFTlRJT05BTCFcbiAgICogV2hpbGUgb25lIGNvdWxkIHNwaW4gdGhlbSBhbGwgZG93biBpbiBwYXJhbGxlbCwgdGhpcyBjb3VsZCBzbGFtIHRoZSByZW1vdGUgc2VydmVyLlxuICAgKiBJdCBpcyBiYWQgcHJhY3RpY2UgdG8gZGVuaWFsIG9mIHNlcnZpY2UgYXR0YWNrIChEb1MgYXR0YWNrKSBzZXJ2ZXJzISEhXG4gICAqIE1vcmVvdmVyLCBwcm9kdWN0aW9uIHNlcnZlcnMgd2lsbCBhdXRvbWF0aWNhbGx5IGJsYWNrbGlzdCBjbGllbnRzIHdoaWNoIHNlbmQgdG9vXG4gICAqIG1hbnkgcmVxdWVzdHMgaW4gdG9vIHNob3J0IGEgcGVyaW9kIG9mIHRpbWUgLSBkcm9wcGluZyBhbnkgYWRkaXRpb25hbCByZXF1ZXN0cy5cbiAgICpcbiAgICogSWYgYSBkaWZmZXJlbnQgYXBwcm9hY2ggdG8gZGlzcG9zaW5nIGlzIG5lZWRlZCwgb25lIGNhbiBpbXBsZW1lbnQgd2hhdGV2ZXIgaXNcbiAgICogbmVlZGVkIGFuZCBleGVjdXRlIHRoYXQgcHJpb3IgdG8gY2FsbGluZyBgc3RvcCgpYC4gQWx0ZXJuYXRpdmVseSBvbmUgbWF5IHNpbXBseVxuICAgKiBub3Qgd2FpdCBmb3IgdGhlIFByb21pc2UgcmV0dXJuZWQgYnkgYHN0b3AoKWAgdG8gY29tcGxldGUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3RvcCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVXNlckFnZW50U3RhdGUuU3RvcHBlZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgVXNlciBhZ2VudCBhbHJlYWR5IHN0b3BwZWRgKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIubG9nKGBTdG9wcGluZyAke3RoaXMuY29uZmlndXJhdGlvbi51cml9YCk7XG5cbiAgICAvLyBUcmFuc2l0aW9uIHN0YXRlXG4gICAgdGhpcy50cmFuc2l0aW9uU3RhdGUoVXNlckFnZW50U3RhdGUuU3RvcHBlZCk7XG5cbiAgICAvLyBUT0RPOiBTZWUgY29tbWVudHMgd2l0aCBhc3NvY2lhdGVkIGNvbXBsaW1lbnRhcnkgY29kZSBpbiBzdGFydCgpLiBTaG91bGQgdGhpcyBwZXJoYXBzIGJlIGRlcHJlY2F0ZWQ/XG4gICAgLy8gUmVtb3ZlIHdpbmRvdyB1bmxvYWQgZXZlbnQgbGlzdGVuZXJcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9TdG9wKSB7XG4gICAgICAvLyBHb29nbGUgQ2hyb21lIFBhY2thZ2VkIEFwcHMgZG9uJ3QgYWxsb3cgJ3VubG9hZCcgbGlzdGVuZXJzOiB1bmxvYWQgaXMgbm90IGF2YWlsYWJsZSBpbiBwYWNrYWdlZCBhcHBzXG4gICAgICBjb25zdCBnb29nbGVDaHJvbWVQYWNrYWdlZEFwcCA9IHR5cGVvZiBjaHJvbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY2hyb21lLmFwcCAmJiBjaHJvbWUuYXBwLnJ1bnRpbWUgPyB0cnVlIDogZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgJiZcbiAgICAgICAgIWdvb2dsZUNocm9tZVBhY2thZ2VkQXBwXG4gICAgICApIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgdGhpcy51bmxvYWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmUgY2FyZWZ1bCBoZXJlIHRvIHVzZSBhIGxvY2FsIHJlZmVyZW5jZXMgYXMgc3RhcnQoKSBjYW4gYmUgY2FsbGVkXG4gICAgLy8gYWdhaW4gYmVmb3JlIHdlIGNvbXBsZXRlIGFuZCB3ZSBkb24ndCB3YW50IHRvIHRvdWNoIG5ldyBjbGllbnRzXG4gICAgLy8gYW5kIHdlIGRvbid0IHdhbnQgdG8gc3RlcCBvbiB0aGUgbmV3IGluc3RhbmNlcyAob3IgdmljZSB2ZXJzYSkuXG4gICAgY29uc3QgcHVibGlzaGVycyA9IHsgLi4udGhpcy5fcHVibGlzaGVycyB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyZXJzID0geyAuLi50aGlzLl9yZWdpc3RlcmVycyB9O1xuICAgIGNvbnN0IHNlc3Npb25zID0geyAuLi50aGlzLl9zZXNzaW9ucyB9O1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB7IC4uLnRoaXMuX3N1YnNjcmlwdGlvbnMgfTtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydDtcbiAgICBjb25zdCB1c2VyQWdlbnRDb3JlID0gdGhpcy51c2VyQWdlbnRDb3JlO1xuXG4gICAgLy9cbiAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgY29tcGxldGVkIHRoZSBzdGF0ZSB0cmFuc2l0aW9uIGFuZCBldmVyeXRoaW5nXG4gICAgLy8gZm9sbG93aW5nIHdpbGwgZWZmZWN0aXZlbHkgcnVuIGFzeW5jIGFuZCBNVVNUIE5PVCBjYXVzZSBhbnkgaXNzdWVzXG4gICAgLy8gaWYgVXNlckFnZW50LnN0YXJ0KCkgaXMgY2FsbGVkIHdoaWxlIHRoZSBmb2xsb3dpbmcgY29kZSBjb250aW51ZXMuXG4gICAgLy9cbiAgICAvLyBUT0RPOiBNaW5vciBvcHRpbWl6YXRpb24uXG4gICAgLy8gVGhlIGRpc3Bvc2FsIGluIGFsbCBjYXNlcyBpbnZvbHZlcywgaW4gcGFydCwgc2VuZGluZyBtZXNzYWdlcyB3aGljaFxuICAgIC8vIGlzIG5vdCB3b3J0aCBkb2luZyBpZiB0aGUgdHJhbnNwb3J0IGlzIG5vdCBjb25uZWN0ZWQgYXMgd2Uga25vdyBhdHRlbXB0aW5nXG4gICAgLy8gdG8gc2VuZCBtZXNzYWdlcyB3aWxsIGJlIGZ1dGlsZS4gQnV0IG5vbmUgb2YgdGhlc2UgZGlzcG9zYWwgbWV0aG9kcyBjaGVja1xuICAgIC8vIGlmIHRoYXQncyBpcyB0aGUgY2FzZSBhbmQgaXQgd291bGQgYmUgZWFzeSBmb3IgdGhlbSB0byBkbyBzbyBhdCB0aGlzIHBvaW50LlxuXG4gICAgLy8gRGlzcG9zZSBvZiBSZWdpc3RlcmVyc1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgRGlzcG9zZSBvZiByZWdpc3RlcmVyc2ApO1xuICAgIGZvciAoY29uc3QgaWQgaW4gcmVnaXN0ZXJlcnMpIHtcbiAgICAgIGlmIChyZWdpc3RlcmVyc1tpZF0pIHtcbiAgICAgICAgYXdhaXQgcmVnaXN0ZXJlcnNbaWRdLmRpc3Bvc2UoKVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZWdpc3RlcmVyc1tpZF07XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNwb3NlIG9mIFNlc3Npb25zXG4gICAgdGhpcy5sb2dnZXIubG9nKGBEaXNwb3NlIG9mIHNlc3Npb25zYCk7XG4gICAgZm9yIChjb25zdCBpZCBpbiBzZXNzaW9ucykge1xuICAgICAgaWYgKHNlc3Npb25zW2lkXSkge1xuICAgICAgICBhd2FpdCBzZXNzaW9uc1tpZF0uZGlzcG9zZSgpXG4gICAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Nlc3Npb25zW2lkXTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpc3Bvc2Ugb2YgU3Vic2NyaXB0aW9uc1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgRGlzcG9zZSBvZiBzdWJzY3JpcHRpb25zYCk7XG4gICAgZm9yIChjb25zdCBpZCBpbiBzdWJzY3JpcHRpb25zKSB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uc1tpZF0pIHtcbiAgICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uc1tpZF0uZGlzcG9zZSgpXG4gICAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNbaWRdO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGlzcG9zZSBvZiBQdWJsaXNoZXJzXG4gICAgdGhpcy5sb2dnZXIubG9nKGBEaXNwb3NlIG9mIHB1Ymxpc2hlcnNgKTtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHB1Ymxpc2hlcnMpIHtcbiAgICAgIGlmIChwdWJsaXNoZXJzW2lkXSkge1xuICAgICAgICBhd2FpdCBwdWJsaXNoZXJzW2lkXS5kaXNwb3NlKClcbiAgICAgICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcHVibGlzaGVyc1tpZF07XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNwb3NlIG9mIHRoZSB0cmFuc3BvcnQgKGRpc2Nvbm5lY3RpbmcpXG4gICAgdGhpcy5sb2dnZXIubG9nKGBEaXNwb3NlIG9mIHRyYW5zcG9ydGApO1xuICAgIGF3YWl0IHRyYW5zcG9ydC5kaXNwb3NlKClcbiAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgLy8gRGlzcG9zZSBvZiB0aGUgdXNlciBhZ2VudCBjb3JlIChyZXNldHRpbmcpXG4gICAgdGhpcy5sb2dnZXIubG9nKGBEaXNwb3NlIG9mIGNvcmVgKTtcbiAgICB1c2VyQWdlbnRDb3JlLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF9tYWtlSW52aXRlcihcbiAgICB0YXJnZXRVUkk6IFVSSSxcbiAgICBvcHRpb25zPzogSW52aXRlck9wdGlvbnNcbiAgKTogSW52aXRlciB7XG4gICAgcmV0dXJuIG5ldyBJbnZpdGVyKHRoaXMsIHRhcmdldFVSSSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCByZWNvbm5lY3Rpb24gdXAgdG8gYG1heFJlY29ubmVjdGlvbkF0dGVtcHRzYCB0aW1lcy5cbiAgICogQHBhcmFtIHJlY29ubmVjdGlvbkF0dGVtcHQgLSBDdXJyZW50IGF0dGVtcHQgbnVtYmVyLlxuICAgKi9cbiAgcHJpdmF0ZSBhdHRlbXB0UmVjb25uZWN0aW9uKHJlY29ubmVjdGlvbkF0dGVtcHQ6IG51bWJlciA9IDEpOiB2b2lkIHtcbiAgICBjb25zdCByZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHRoaXMub3B0aW9ucy5yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgICBjb25zdCByZWNvbm5lY3Rpb25EZWxheSA9IHRoaXMub3B0aW9ucy5yZWNvbm5lY3Rpb25EZWxheTtcblxuICAgIGlmIChyZWNvbm5lY3Rpb25BdHRlbXB0ID4gcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgTWF4aW11bSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZyhgUmVjb25uZWN0aW9uIGF0dGVtcHQgJHtyZWNvbm5lY3Rpb25BdHRlbXB0fSBvZiAke3JlY29ubmVjdGlvbkF0dGVtcHRzfSAtIHRyeWluZ2ApO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZWNvbm5lY3QoKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBSZWNvbm5lY3Rpb24gYXR0ZW1wdCAke3JlY29ubmVjdGlvbkF0dGVtcHR9IG9mICR7cmVjb25uZWN0aW9uQXR0ZW1wdHN9IC0gc3VjY2VlZGVkYCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBSZWNvbm5lY3Rpb24gYXR0ZW1wdCAke3JlY29ubmVjdGlvbkF0dGVtcHR9IG9mICR7cmVjb25uZWN0aW9uQXR0ZW1wdHN9IC0gZmFpbGVkYCk7XG4gICAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0aW9uKCsrcmVjb25uZWN0aW9uQXR0ZW1wdCk7XG4gICAgICAgIH0pO1xuICAgIH0sIHJlY29ubmVjdGlvbkF0dGVtcHQgPT09IDEgPyAwIDogcmVjb25uZWN0aW9uRGVsYXkgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGNvbnRhY3QuXG4gICAqL1xuICBwcml2YXRlIGluaXRDb250YWN0KCk6IENvbnRhY3Qge1xuICAgIGNvbnN0IGNvbnRhY3ROYW1lID0gY3JlYXRlUmFuZG9tVG9rZW4oOCk7IC8vIEZJWE1FOiBzaG91bGQgYmUgY29uZmlndXJhYmxlXG4gICAgY29uc3QgY29udGFjdFRyYW5zcG9ydCA9XG4gICAgICB0aGlzLm9wdGlvbnMuaGFja1dzc0luVHJhbnNwb3J0ID8gXCJ3c3NcIiA6IFwid3NcIjsgLy8gRklYTUU6IGNsZWFybHkgYnJva2VuIGZvciBub24gd3MgdHJhbnNwb3J0c1xuICAgIGNvbnN0IGNvbnRhY3QgPSB7XG4gICAgICBwdWJHcnV1OiB1bmRlZmluZWQsXG4gICAgICB0ZW1wR3J1dTogdW5kZWZpbmVkLFxuICAgICAgdXJpOiBuZXcgVVJJKFwic2lwXCIsIGNvbnRhY3ROYW1lLCB0aGlzLm9wdGlvbnMudmlhSG9zdCwgdW5kZWZpbmVkLCB7IHRyYW5zcG9ydDogY29udGFjdFRyYW5zcG9ydCB9KSxcbiAgICAgIHRvU3RyaW5nOiAoY29udGFjdFRvU3RyaW5nT3B0aW9uczogeyBhbm9ueW1vdXM/OiBib29sZWFuLCBvdXRib3VuZD86IGJvb2xlYW4gfSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGFub255bW91cyA9IGNvbnRhY3RUb1N0cmluZ09wdGlvbnMuYW5vbnltb3VzIHx8IGZhbHNlO1xuICAgICAgICBjb25zdCBvdXRib3VuZCA9IGNvbnRhY3RUb1N0cmluZ09wdGlvbnMub3V0Ym91bmQgfHwgZmFsc2U7XG4gICAgICAgIGxldCBjb250YWN0U3RyaW5nOiBzdHJpbmcgPSBcIjxcIjtcbiAgICAgICAgaWYgKGFub255bW91cykge1xuICAgICAgICAgIGNvbnRhY3RTdHJpbmcgKz0gdGhpcy5jb250YWN0LnRlbXBHcnV1IHx8IGBzaXA6YW5vbnltb3VzQGFub255bW91cy5pbnZhbGlkO3RyYW5zcG9ydD0ke2NvbnRhY3RUcmFuc3BvcnR9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250YWN0U3RyaW5nICs9IHRoaXMuY29udGFjdC5wdWJHcnV1IHx8IHRoaXMuY29udGFjdC51cmk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dGJvdW5kKSB7XG4gICAgICAgICAgY29udGFjdFN0cmluZyArPSBcIjtvYlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhY3RTdHJpbmcgKz0gXCI+XCI7XG4gICAgICAgIHJldHVybiBjb250YWN0U3RyaW5nO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNvbnRhY3Q7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB1c2VyIGFnZW50IGNvcmUuXG4gICAqL1xuICBwcml2YXRlIGluaXRDb3JlKCk6IFVzZXJBZ2VudENvcmUge1xuICAgIC8vIHN1cHBvcnRlZCBvcHRpb25zXG4gICAgbGV0IHN1cHBvcnRlZE9wdGlvblRhZ3M6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICBzdXBwb3J0ZWRPcHRpb25UYWdzLnB1c2goXCJvdXRib3VuZFwiKTsgLy8gVE9ETzogaXMgdGhpcyByZWFsbHkgc3VwcG9ydGVkP1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lwRXh0ZW5zaW9uMTAwcmVsID09PSBTSVBFeHRlbnNpb24uU3VwcG9ydGVkKSB7XG4gICAgICBzdXBwb3J0ZWRPcHRpb25UYWdzLnB1c2goXCIxMDByZWxcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lwRXh0ZW5zaW9uUmVwbGFjZXMgPT09IFNJUEV4dGVuc2lvbi5TdXBwb3J0ZWQpIHtcbiAgICAgIHN1cHBvcnRlZE9wdGlvblRhZ3MucHVzaChcInJlcGxhY2VzXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNpcEV4dGVuc2lvbkV4dHJhU3VwcG9ydGVkKSB7XG4gICAgICBzdXBwb3J0ZWRPcHRpb25UYWdzLnB1c2goLi4udGhpcy5vcHRpb25zLnNpcEV4dGVuc2lvbkV4dHJhU3VwcG9ydGVkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncykge1xuICAgICAgc3VwcG9ydGVkT3B0aW9uVGFncyA9IHN1cHBvcnRlZE9wdGlvblRhZ3MuZmlsdGVyKChvcHRpb25UYWcpID0+IFVzZXJBZ2VudFJlZ2lzdGVyZWRPcHRpb25UYWdzW29wdGlvblRhZ10pO1xuICAgIH1cbiAgICBzdXBwb3J0ZWRPcHRpb25UYWdzID0gQXJyYXkuZnJvbShuZXcgU2V0KHN1cHBvcnRlZE9wdGlvblRhZ3MpKTsgLy8gYXJyYXkgb2YgdW5pcXVlIHZhbHVlc1xuXG4gICAgLy8gRklYTUU6IFRPRE86IFRoaXMgd2FzIHBvcnRlZCwgYnV0IHRoaXMgaXMgYW5kIHdhcyBqdXN0IHBsYWluIGJyb2tlbi5cbiAgICBjb25zdCBzdXBwb3J0ZWRPcHRpb25UYWdzUmVzcG9uc2UgPSBzdXBwb3J0ZWRPcHRpb25UYWdzLnNsaWNlKCk7XG4gICAgaWYgKHRoaXMuY29udGFjdC5wdWJHcnV1IHx8IHRoaXMuY29udGFjdC50ZW1wR3J1dSkge1xuICAgICAgc3VwcG9ydGVkT3B0aW9uVGFnc1Jlc3BvbnNlLnB1c2goXCJncnV1XCIpO1xuICAgIH1cblxuICAgIC8vIGNvcmUgY29uZmlndXJhdGlvblxuICAgIGNvbnN0IHVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uOiBVc2VyQWdlbnRDb3JlQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgIGFvcjogdGhpcy5vcHRpb25zLnVyaSxcbiAgICAgIGNvbnRhY3Q6IHRoaXMuY29udGFjdCxcbiAgICAgIGRpc3BsYXlOYW1lOiB0aGlzLm9wdGlvbnMuZGlzcGxheU5hbWUsXG4gICAgICBsb2dnZXJGYWN0b3J5OiB0aGlzLmxvZ2dlckZhY3RvcnksXG4gICAgICBoYWNrVmlhVGNwOiB0aGlzLm9wdGlvbnMuaGFja1ZpYVRjcCxcbiAgICAgIHJvdXRlU2V0OiB0aGlzLm9wdGlvbnMucHJlbG9hZGVkUm91dGVTZXQsXG4gICAgICBzdXBwb3J0ZWRPcHRpb25UYWdzLFxuICAgICAgc3VwcG9ydGVkT3B0aW9uVGFnc1Jlc3BvbnNlLFxuICAgICAgc2lwanNJZDogdGhpcy5vcHRpb25zLnNpcGpzSWQsXG4gICAgICB1c2VyQWdlbnRIZWFkZXJGaWVsZFZhbHVlOiB0aGlzLm9wdGlvbnMudXNlckFnZW50U3RyaW5nLFxuICAgICAgdmlhRm9yY2VScG9ydDogdGhpcy5vcHRpb25zLmZvcmNlUnBvcnQsXG4gICAgICB2aWFIb3N0OiB0aGlzLm9wdGlvbnMudmlhSG9zdCxcbiAgICAgIGF1dGhlbnRpY2F0aW9uRmFjdG9yeTogKCkgPT4ge1xuICAgICAgICBjb25zdCB1c2VybmFtZSA9XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmF1dGhvcml6YXRpb25Vc2VybmFtZSA/XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0aG9yaXphdGlvblVzZXJuYW1lIDpcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy51cmkudXNlcjsgLy8gaWYgYXV0aG9yaXphdGlvbiB1c2VybmFtZSBub3QgcHJvdmlkZWQsIHVzZSB1cmkgdXNlciBhcyB1c2VybmFtZVxuICAgICAgICBjb25zdCBwYXNzd29yZCA9XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmF1dGhvcml6YXRpb25QYXNzd29yZCA/XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0aG9yaXphdGlvblBhc3N3b3JkIDpcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG5ldyBEaWdlc3RBdXRoZW50aWNhdGlvbih0aGlzLmdldExvZ2dlckZhY3RvcnkoKSwgdXNlcm5hbWUsIHBhc3N3b3JkKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc3BvcnRBY2Nlc3NvcjogKCkgPT4gdGhpcy50cmFuc3BvcnRcbiAgICB9O1xuXG4gICAgY29uc3QgdXNlckFnZW50Q29yZURlbGVnYXRlOiBVc2VyQWdlbnRDb3JlRGVsZWdhdGUgPSB7XG4gICAgICBvbkludml0ZTogKGluY29taW5nSW52aXRlUmVxdWVzdDogSW5jb21pbmdJbnZpdGVSZXF1ZXN0KTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IGludml0YXRpb24gPSBuZXcgSW52aXRhdGlvbih0aGlzLCBpbmNvbWluZ0ludml0ZVJlcXVlc3QpO1xuXG4gICAgICAgIGluY29taW5nSW52aXRlUmVxdWVzdC5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICBvbkNhbmNlbDogKGNhbmNlbDogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgaW52aXRhdGlvbi5fb25DYW5jZWwoY2FuY2VsKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVHJhbnNwb3J0RXJyb3I6IChlcnJvcjogVHJhbnNwb3J0RXJyb3IpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIC8vIEEgc2VydmVyIHRyYW5zYWN0aW9uIE1VU1QgTk9UIGRpc2NhcmQgdHJhbnNhY3Rpb24gc3RhdGUgYmFzZWQgb25seSBvblxuICAgICAgICAgICAgLy8gZW5jb3VudGVyaW5nIGEgbm9uLXJlY292ZXJhYmxlIHRyYW5zcG9ydCBlcnJvciB3aGVuIHNlbmRpbmcgYVxuICAgICAgICAgICAgLy8gcmVzcG9uc2UuICBJbnN0ZWFkLCB0aGUgYXNzb2NpYXRlZCBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uIHN0YXRlXG4gICAgICAgICAgICAvLyBtYWNoaW5lIE1VU1QgcmVtYWluIGluIGl0cyBjdXJyZW50IHN0YXRlLiAgKFRpbWVycyB3aWxsIGV2ZW50dWFsbHlcbiAgICAgICAgICAgIC8vIGNhdXNlIGl0IHRvIHRyYW5zaXRpb24gdG8gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlKS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tNy4xXG5cbiAgICAgICAgICAgIC8vIEFzIG5vdGVkIGluIHRoZSBjb21tZW50IGFib3ZlLCB3ZSBhcmUgdG8gbGVhdmluZyBpdCB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIHRpbWVycyB0byBldmVudHVhbGx5IGNhdXNlIHRoZSB0cmFuc2FjdGlvbiB0byBzb3J0IGl0c2VsZiBvdXQgaW4gdGhlIGNhc2VcbiAgICAgICAgICAgIC8vIG9mIGEgdHJhbnNwb3J0IGZhaWx1cmUgaW4gYW4gaW52aXRlIHNlcnZlciB0cmFuc2FjdGlvbi4gVGhpcyBkZWxlZ2F0ZSBtZXRob2RcbiAgICAgICAgICAgIC8vIGlzIGhlcmUgc2ltcGx5IGhlcmUgZm9yIGNvbXBsZXRlbmVzcyBhbmQgdG8gbWFrZSBpdCBjbGVhciB0aGF0IGl0IHByb3ZpZGVzXG4gICAgICAgICAgICAvLyBub3RoaW5nIG1vcmUgdGhhbiBpbmZvcm1hdGlvbmFsIGhvb2sgaW50byB0aGUgY29yZS4gVGhhdCBpcywgaWYgeW91IHRoaW5rXG4gICAgICAgICAgICAvLyB5b3Ugc2hvdWxkIGJlIHRyeWluZyB0byBkZWFsIHdpdGggYSB0cmFuc3BvcnQgZXJyb3IgaGVyZSwgeW91IGFyZSBsaWtlbHkgd3JvbmcuXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkEgdHJhbnNwb3J0IGVycm9yIGhhcyBvY2N1cnJlZCB3aGlsZSBoYW5kbGluZyBhbiBpbmNvbWluZyBJTlZJVEUgcmVxdWVzdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZJWE1FOiBQb3J0ZWQgLSAxMDAgVHJ5aW5nIHNlbmQgc2hvdWxkIGJlIGNvbmZpZ3VyYWJsZS5cbiAgICAgICAgLy8gT25seSByZXF1aXJlZCBpZiBUVSB3aWxsIG5vdCByZXNwb25kIGluIDIwMG1zLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICBpbmNvbWluZ0ludml0ZVJlcXVlc3QudHJ5aW5nKCk7XG5cbiAgICAgICAgLy8gVGhlIFJlcGxhY2VzIGhlYWRlciBjb250YWlucyBpbmZvcm1hdGlvbiB1c2VkIHRvIG1hdGNoIGFuIGV4aXN0aW5nXG4gICAgICAgIC8vIFNJUCBkaWFsb2cgKGNhbGwtaWQsIHRvLXRhZywgYW5kIGZyb20tdGFnKS4gIFVwb24gcmVjZWl2aW5nIGFuIElOVklURVxuICAgICAgICAvLyB3aXRoIGEgUmVwbGFjZXMgaGVhZGVyLCB0aGUgVXNlciBBZ2VudCAoVUEpIGF0dGVtcHRzIHRvIG1hdGNoIHRoaXNcbiAgICAgICAgLy8gaW5mb3JtYXRpb24gd2l0aCBhIGNvbmZpcm1lZCBvciBlYXJseSBkaWFsb2cuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzODkxI3NlY3Rpb24tM1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpcEV4dGVuc2lvblJlcGxhY2VzICE9PSBTSVBFeHRlbnNpb24uVW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gaW5jb21pbmdJbnZpdGVSZXF1ZXN0Lm1lc3NhZ2U7XG4gICAgICAgICAgY29uc3QgcmVwbGFjZXMgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwicmVwbGFjZXNcIik7XG4gICAgICAgICAgaWYgKHJlcGxhY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsSWQgPSByZXBsYWNlcy5jYWxsX2lkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBvZiBjYWxsIGlkIGlzIG5vdCBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b1RhZyA9IHJlcGxhY2VzLnJlcGxhY2VzX3RvX3RhZztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9UYWcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBvZiB0byB0YWcgaXMgbm90IHN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZyb21UYWcgPSByZXBsYWNlcy5yZXBsYWNlc19mcm9tX3RhZztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJvbVRhZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIG9mIGZyb20gdGFnIGlzIG5vdCBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXJnZXREaWFsb2dJZCA9IGNhbGxJZCArIHRvVGFnICsgZnJvbVRhZztcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERpYWxvZyA9IHRoaXMudXNlckFnZW50Q29yZS5kaWFsb2dzLmdldCh0YXJnZXREaWFsb2dJZCk7XG5cbiAgICAgICAgICAgIC8vIElmIG5vIG1hdGNoIGlzIGZvdW5kLCB0aGUgVUFTIHJlamVjdHMgdGhlIElOVklURSBhbmQgcmV0dXJucyBhIDQ4MVxuICAgICAgICAgICAgLy8gQ2FsbC9UcmFuc2FjdGlvbiBEb2VzIE5vdCBFeGlzdCByZXNwb25zZS4gIExpa2V3aXNlLCBpZiB0aGUgUmVwbGFjZXNcbiAgICAgICAgICAgIC8vIGhlYWRlciBmaWVsZCBtYXRjaGVzIGEgZGlhbG9nIHdoaWNoIHdhcyBub3QgY3JlYXRlZCB3aXRoIGFuIElOVklURSxcbiAgICAgICAgICAgIC8vIHRoZSBVQVMgTVVTVCByZWplY3QgdGhlIHJlcXVlc3Qgd2l0aCBhIDQ4MSByZXNwb25zZS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzODkxI3NlY3Rpb24tM1xuICAgICAgICAgICAgaWYgKCF0YXJnZXREaWFsb2cpIHtcbiAgICAgICAgICAgICAgaW52aXRhdGlvbi5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODEgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIFJlcGxhY2VzIGhlYWRlciBmaWVsZCBtYXRjaGVzIGEgY29uZmlybWVkIGRpYWxvZywgaXQgY2hlY2tzXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBcImVhcmx5LW9ubHlcIiBmbGFnIGluIHRoZSBSZXBsYWNlcyBoZWFkZXJcbiAgICAgICAgICAgIC8vIGZpZWxkLiAgKFRoaXMgZmxhZyBhbGxvd3MgdGhlIFVBQyB0byBwcmV2ZW50IGEgcG90ZW50aWFsbHlcbiAgICAgICAgICAgIC8vIHVuZGVzaXJhYmxlIHJhY2UgY29uZGl0aW9uIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDcuMS4pIElmIHRoZSBmbGFnIGlzXG4gICAgICAgICAgICAvLyBwcmVzZW50LCB0aGUgVUEgcmVqZWN0cyB0aGUgcmVxdWVzdCB3aXRoIGEgNDg2IEJ1c3kgcmVzcG9uc2UuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzg5MSNzZWN0aW9uLTNcbiAgICAgICAgICAgIGlmICghdGFyZ2V0RGlhbG9nLmVhcmx5ICYmIHJlcGxhY2VzLmVhcmx5X29ubHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaW52aXRhdGlvbi5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODYgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJvdmlkZSBhIGhhbmRsZSBvbiB0aGUgc2Vzc2lvbiBiZWluZyByZXBsYWNlZC5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNlc3Npb24gPSB0aGlzLl9zZXNzaW9uc1tjYWxsSWQgKyBmcm9tVGFnXSB8fCB0aGlzLl9zZXNzaW9uc1tjYWxsSWQgKyB0b1RhZ10gfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW52aXRhdGlvbi5fcmVwbGFjZWUgPSB0YXJnZXRTZXNzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgY29tbW9uIHNjZW5hcmlvIG9jY3VycyB3aGVuIHRoZSBjYWxsZWUgaXMgY3VycmVudGx5IG5vdCB3aWxsaW5nIG9yXG4gICAgICAgIC8vIGFibGUgdG8gdGFrZSBhZGRpdGlvbmFsIGNhbGxzIGF0IHRoaXMgZW5kIHN5c3RlbS4gIEEgNDg2IChCdXN5IEhlcmUpXG4gICAgICAgIC8vIFNIT1VMRCBiZSByZXR1cm5lZCBpbiBzdWNoIGEgc2NlbmFyaW8uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjNcbiAgICAgICAgaWYgKCF0aGlzLmRlbGVnYXRlIHx8ICF0aGlzLmRlbGVnYXRlLm9uSW52aXRlKSB7XG4gICAgICAgICAgaW52aXRhdGlvbi5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODYgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVsZWdhdGUgaW52aXRhdGlvbiBoYW5kbGluZy5cbiAgICAgICAgaWYgKCFpbnZpdGF0aW9uLmF1dG9TZW5kQW5Jbml0aWFsUHJvdmlzaW9uYWxSZXNwb25zZSkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25JbnZpdGUoaW52aXRhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb25JbnZpdGUgPSB0aGlzLmRlbGVnYXRlLm9uSW52aXRlO1xuICAgICAgICAgIGludml0YXRpb24ucHJvZ3Jlc3MoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gb25JbnZpdGUoaW52aXRhdGlvbikpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25NZXNzYWdlOiAoaW5jb21pbmdNZXNzYWdlUmVxdWVzdDogSW5jb21pbmdNZXNzYWdlUmVxdWVzdCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uTWVzc2FnZSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZShpbmNvbWluZ01lc3NhZ2VSZXF1ZXN0KTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBY2NlcHQgdGhlIE1FU1NBR0UgcmVxdWVzdCwgYnV0IGRvIG5vdGhpbmcgd2l0aCBpdC5cbiAgICAgICAgICBpbmNvbWluZ01lc3NhZ2VSZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Ob3RpZnk6IChpbmNvbWluZ05vdGlmeVJlcXVlc3Q6IEluY29taW5nTm90aWZ5UmVxdWVzdCk6IHZvaWQgPT4ge1xuICAgICAgICAvLyBOT1RJRlkgcmVxdWVzdHMgYXJlIHNlbnQgdG8gaW5mb3JtIHN1YnNjcmliZXJzIG9mIGNoYW5nZXMgaW4gc3RhdGUgdG9cbiAgICAgICAgLy8gd2hpY2ggdGhlIHN1YnNjcmliZXIgaGFzIGEgc3Vic2NyaXB0aW9uLiAgU3Vic2NyaXB0aW9ucyBhcmUgY3JlYXRlZFxuICAgICAgICAvLyB1c2luZyB0aGUgU1VCU0NSSUJFIG1ldGhvZC4gIEluIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbnMsIGl0IGlzXG4gICAgICAgIC8vIHBvc3NpYmxlIHRoYXQgb3RoZXIgbWVhbnMgb2Ygc3Vic2NyaXB0aW9uIGNyZWF0aW9uIGhhdmUgYmVlbiB1c2VkLlxuICAgICAgICAvLyBIb3dldmVyLCB0aGlzIHNwZWNpZmljYXRpb24gZG9lcyBub3QgYWxsb3cgdGhlIGNyZWF0aW9uIG9mXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbnMgZXhjZXB0IHRocm91Z2ggU1VCU0NSSUJFIHJlcXVlc3RzIGFuZCAoZm9yIGJhY2t3YXJkcy1cbiAgICAgICAgLy8gY29tcGF0aWJpbGl0eSkgUkVGRVIgcmVxdWVzdHMgW1JGQzM1MTVdLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTMuMlxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5KSB7XG4gICAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbihpbmNvbWluZ05vdGlmeVJlcXVlc3QpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkobm90aWZpY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQZXIgdGhlIGFib3ZlIHdoaWNoIG9ic29sZXRlcyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2NSxcbiAgICAgICAgICAvLyB0aGUgdXNlIG9mIG91dCBvZiBkaWFsb2cgTk9USUZZIGlzIG9ic29sZXRlLCBidXQuLi5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93TGVnYWN5Tm90aWZpY2F0aW9ucykge1xuICAgICAgICAgICAgaW5jb21pbmdOb3RpZnlSZXF1ZXN0LmFjY2VwdCgpOyAvLyBBY2NlcHQgdGhlIE5PVElGWSByZXF1ZXN0LCBidXQgZG8gbm90aGluZyB3aXRoIGl0LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmNvbWluZ05vdGlmeVJlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogNDgxIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUmVmZXI6IChpbmNvbWluZ1JlZmVyUmVxdWVzdDogSW5jb21pbmdSZWZlclJlcXVlc3QpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiUmVjZWl2ZWQgYW4gb3V0IG9mIGRpYWxvZyByZWZlclwiKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dPdXRPZkRpYWxvZ1JlZmVycykge1xuICAgICAgICAgIGluY29taW5nUmVmZXJSZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IDQwNSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJBbGxvdyBvdXQgb2YgZGlhbG9nIHJlZmVycyBpcyBlbmFibGVkIG9uIHRoZSBVQVwiKTtcbiAgICAgICAgLy8gY29uc3QgcmVmZXJDb250ZXh0ID0gbmV3IFJlZmVyU2VydmVyQ29udGV4dCh0aGlzLCBpbmNvbWluZ1JlZmVyUmVxdWVzdCk7XG4gICAgICAgIC8vIGlmICh0aGlzLmxpc3RlbmVycyhcIm91dE9mRGlhbG9nUmVmZXJSZXF1ZXN0ZWRcIikubGVuZ3RoKSB7XG4gICAgICAgIC8vICAgdGhpcy5lbWl0KFwib3V0T2ZEaWFsb2dSZWZlclJlcXVlc3RlZFwiLCByZWZlckNvbnRleHQpO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgICAgLy8gICAgIFwiTm8gb3V0T2ZEaWFsb2dSZWZlclJlcXVlc3QgbGlzdGVuZXJzLCBhdXRvbWF0aWNhbGx5IGFjY2VwdGluZyBhbmQgZm9sbG93aW5nIHRoZSBvdXQgb2YgZGlhbG9nIHJlZmVyXCJcbiAgICAgICAgLy8gICApO1xuICAgICAgICAvLyAgIHJlZmVyQ29udGV4dC5hY2NlcHQoeyBmb2xsb3dSZWZlcjogdHJ1ZSB9KTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uUmVmZXIpIHtcbiAgICAgICAgLy8gICB0aGlzLmRlbGVnYXRlLm9uUmVmZXIoaW5jb21pbmdSZWZlclJlcXVlc3QpO1xuICAgICAgICAvLyB9XG4gICAgICB9LFxuICAgICAgb25SZWdpc3RlcjogKGluY29taW5nUmVnaXN0ZXJSZXF1ZXN0OiBJbmNvbWluZ1JlZ2lzdGVyUmVxdWVzdCk6IHZvaWQgPT4ge1xuICAgICAgICAvLyBUT09EOiB0aGlzLmRlbGVnYXRlLm9uUmVnaXN0ZXIoLi4uKVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uUmVnaXN0ZXJSZXF1ZXN0KSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZ2lzdGVyUmVxdWVzdChpbmNvbWluZ1JlZ2lzdGVyUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblN1YnNjcmliZTogKGluY29taW5nU3Vic2NyaWJlUmVxdWVzdDogSW5jb21pbmdTdWJzY3JpYmVSZXF1ZXN0KTogdm9pZCA9PiB7XG4gICAgICAgIC8vIFRPT0Q6IHRoaXMuZGVsZWdhdGUub25TdWJzY3JpYmUoLi4uKVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uU3Vic2NyaWJlUmVxdWVzdCkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25TdWJzY3JpYmVSZXF1ZXN0KGluY29taW5nU3Vic2NyaWJlUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBVc2VyQWdlbnRDb3JlKHVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uLCB1c2VyQWdlbnRDb3JlRGVsZWdhdGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0VHJhbnNwb3J0Q2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIHRoaXMudHJhbnNwb3J0Lm9uQ29ubmVjdCA9ICgpID0+IHRoaXMub25UcmFuc3BvcnRDb25uZWN0KCk7XG4gICAgdGhpcy50cmFuc3BvcnQub25EaXNjb25uZWN0ID0gKGVycm9yPzogRXJyb3IpID0+IHRoaXMub25UcmFuc3BvcnREaXNjb25uZWN0KGVycm9yKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5vbk1lc3NhZ2UgPSAobWVzc2FnZTogc3RyaW5nKSA9PiB0aGlzLm9uVHJhbnNwb3J0TWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuXG4gIHByaXZhdGUgb25UcmFuc3BvcnRDb25uZWN0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBVc2VyQWdlbnRTdGF0ZS5TdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Db25uZWN0KSB7XG4gICAgICB0aGlzLmRlbGVnYXRlLm9uQ29ubmVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25UcmFuc3BvcnREaXNjb25uZWN0KGVycm9yPzogRXJyb3IpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVXNlckFnZW50U3RhdGUuU3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uRGlzY29ubmVjdCkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkRpc2Nvbm5lY3QoZXJyb3IpO1xuICAgIH1cbiAgICAvLyBPbmx5IGF0dGVtcHQgdG8gcmVjb25uZWN0IGlmIG5ldHdvcmsvc2VydmVyIGRyb3BwZWQgdGhlIGNvbm5lY3Rpb24uXG4gICAgaWYgKGVycm9yICYmIHRoaXMub3B0aW9ucy5yZWNvbm5lY3Rpb25BdHRlbXB0cyA+IDApIHtcbiAgICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25UcmFuc3BvcnRNZXNzYWdlKG1lc3NhZ2VTdHJpbmc6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBQYXJzZXIucGFyc2VNZXNzYWdlKG1lc3NhZ2VTdHJpbmcsIHRoaXMuZ2V0TG9nZ2VyKFwic2lwLlBhcnNlclwiKSk7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIGluY29taW5nIG1lc3NhZ2UuIERyb3BwaW5nLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVXNlckFnZW50U3RhdGUuU3RvcHBlZCAmJiBtZXNzYWdlIGluc3RhbmNlb2YgSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgUmVjZWl2ZWQgJHttZXNzYWdlLm1ldGhvZH0gcmVxdWVzdCB3aGlsZSBzdG9wcGVkLiBEcm9wcGluZy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBIHZhbGlkIFNJUCByZXF1ZXN0IGZvcm11bGF0ZWQgYnkgYSBVQUMgTVVTVCwgYXQgYSBtaW5pbXVtLCBjb250YWluXG4gICAgLy8gdGhlIGZvbGxvd2luZyBoZWFkZXIgZmllbGRzOiBUbywgRnJvbSwgQ1NlcSwgQ2FsbC1JRCwgTWF4LUZvcndhcmRzLFxuICAgIC8vIGFuZCBWaWE7IGFsbCBvZiB0aGVzZSBoZWFkZXIgZmllbGRzIGFyZSBtYW5kYXRvcnkgaW4gYWxsIFNJUFxuICAgIC8vIHJlcXVlc3RzLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjFcbiAgICBjb25zdCBoYXNNaW5pbXVtSGVhZGVycyA9ICgpOiBib29sZWFuID0+IHtcbiAgICAgIGNvbnN0IG1hbmRhdG9yeUhlYWRlcnM6IEFycmF5PHN0cmluZz4gPSBbXCJmcm9tXCIsIFwidG9cIiwgXCJjYWxsX2lkXCIsIFwiY3NlcVwiLCBcInZpYVwiXTtcbiAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIG1hbmRhdG9yeUhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLmhhc0hlYWRlcihoZWFkZXIpKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgTWlzc2luZyBtYW5kYXRvcnkgaGVhZGVyIGZpZWxkIDogJHtoZWFkZXJ9LmApO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIFJlcXVlc3QgQ2hlY2tzXG4gICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlKSB7XG4gICAgICAvLyBUaGlzIGlzIHBvcnQgb2YgU2FuaXR5Q2hlY2subWluaW11bUhlYWRlcnMoKS5cbiAgICAgIGlmICghaGFzTWluaW11bUhlYWRlcnMoKSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBSZXF1ZXN0IG1pc3NpbmcgbWFuZGF0b3J5IGhlYWRlciBmaWVsZC4gRHJvcHBpbmcuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRklYTUU6IFRoaXMgaXMgbm9uLXN0YW5kYXJkIGFuZCBzaG91bGQgYmUgYSBjb25maWd1cmFibGUgYmVoYXZpb3IgKGRlc2lyYWJsZSByZWdhcmRsZXNzKS5cbiAgICAgIC8vIEN1c3RvbSBTSVAuanMgY2hlY2sgdG8gcmVqZWN0IHJlcXVlc3QgZnJvbSBvdXJzZWxmICh0aGlzIGluc3RhbmNlIG9mIFNJUC5qcykuXG4gICAgICAvLyBUaGlzIGlzIHBvcnQgb2YgU2FuaXR5Q2hlY2sucmZjMzI2MV8xNl8zXzQoKS5cbiAgICAgIGlmICghbWVzc2FnZS50b1RhZyAmJiBtZXNzYWdlLmNhbGxJZC5zdWJzdHIoMCwgNSkgPT09IHRoaXMub3B0aW9ucy5zaXBqc0lkKSB7XG4gICAgICAgIHRoaXMudXNlckFnZW50Q29yZS5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQ4MiB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGSVhNRTogVGhpcyBzaG91bGQgYmUgVHJhbnNwb3J0IGNoZWNrIGJlZm9yZSB3ZSBnZXQgaGVyZSAoU2VjdGlvbiAxOCkuXG4gICAgICAvLyBDdXN0b20gU0lQLmpzIGNoZWNrIHRvIHJlamVjdCByZXF1ZXN0cyBpZiBib2R5IGxlbmd0aCB3cm9uZy5cbiAgICAgIC8vIFRoaXMgaXMgcG9ydCBvZiBTYW5pdHlDaGVjay5yZmMzMjYxXzE4XzNfcmVxdWVzdCgpLlxuICAgICAgY29uc3QgbGVuOiBudW1iZXIgPSBzdHJfdXRmOF9sZW5ndGgobWVzc2FnZS5ib2R5KTtcbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGg6IHN0cmluZyB8IHVuZGVmaW5lZCA9IG1lc3NhZ2UuZ2V0SGVhZGVyKFwiY29udGVudC1sZW5ndGhcIik7XG4gICAgICBpZiAoY29udGVudExlbmd0aCAmJiBsZW4gPCBOdW1iZXIoY29udGVudExlbmd0aCkpIHtcbiAgICAgICAgdGhpcy51c2VyQWdlbnRDb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzcG9uc2UgQ2hlY2tzXG4gICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSkge1xuICAgICAgLy8gVGhpcyBpcyBwb3J0IG9mIFNhbml0eUNoZWNrLm1pbmltdW1IZWFkZXJzKCkuXG4gICAgICBpZiAoIWhhc01pbmltdW1IZWFkZXJzKCkpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgUmVzcG9uc2UgbWlzc2luZyBtYW5kYXRvcnkgaGVhZGVyIGZpZWxkLiBEcm9wcGluZy5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDdXN0b20gU0lQLmpzIGNoZWNrIHRvIGRyb3AgcmVzcG9uc2VzIGlmIG11bHRpcGxlIFZpYSBoZWFkZXJzLlxuICAgICAgLy8gVGhpcyBpcyBwb3J0IG9mIFNhbml0eUNoZWNrLnJmYzMyNjFfOF8xXzNfMygpLlxuICAgICAgaWYgKG1lc3NhZ2UuZ2V0SGVhZGVycyhcInZpYVwiKS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJNb3JlIHRoYW4gb25lIFZpYSBoZWFkZXIgZmllbGQgcHJlc2VudCBpbiB0aGUgcmVzcG9uc2UuIERyb3BwaW5nLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGSVhNRTogVGhpcyBzaG91bGQgYmUgVHJhbnNwb3J0IGNoZWNrIGJlZm9yZSB3ZSBnZXQgaGVyZSAoU2VjdGlvbiAxOCkuXG4gICAgICAvLyBDdXN0b20gU0lQLmpzIGNoZWNrIHRvIGRyb3AgcmVzcG9uc2VzIGlmIGJhZCBWaWEgaGVhZGVyLlxuICAgICAgLy8gVGhpcyBpcyBwb3J0IG9mIFNhbml0eUNoZWNrLnJmYzMyNjFfMThfMV8yKCkuXG4gICAgICBpZiAobWVzc2FnZS52aWEuaG9zdCAhPT0gdGhpcy5vcHRpb25zLnZpYUhvc3QgfHwgbWVzc2FnZS52aWEucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJWaWEgc2VudC1ieSBpbiB0aGUgcmVzcG9uc2UgZG9lcyBub3QgbWF0Y2ggVUEgVmlhIGhvc3QgdmFsdWUuIERyb3BwaW5nLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGSVhNRTogVGhpcyBzaG91bGQgYmUgVHJhbnNwb3J0IGNoZWNrIGJlZm9yZSB3ZSBnZXQgaGVyZSAoU2VjdGlvbiAxOCkuXG4gICAgICAvLyBDdXN0b20gU0lQLmpzIGNoZWNrIHRvIHJlamVjdCByZXF1ZXN0cyBpZiBib2R5IGxlbmd0aCB3cm9uZy5cbiAgICAgIC8vIFRoaXMgaXMgcG9ydCBvZiBTYW5pdHlDaGVjay5yZmMzMjYxXzE4XzNfcmVzcG9uc2UoKS5cbiAgICAgIGNvbnN0IGxlbjogbnVtYmVyID0gc3RyX3V0ZjhfbGVuZ3RoKG1lc3NhZ2UuYm9keSk7XG4gICAgICBjb25zdCBjb250ZW50TGVuZ3RoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSBtZXNzYWdlLmdldEhlYWRlcihcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICAgICAgaWYgKGNvbnRlbnRMZW5ndGggJiYgbGVuIDwgTnVtYmVyKGNvbnRlbnRMZW5ndGgpKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJNZXNzYWdlIGJvZHkgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIHZhbHVlIGluIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZC4gRHJvcHBpbmcuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIFJlcXVlc3RcbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEluY29taW5nUmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgIHRoaXMudXNlckFnZW50Q29yZS5yZWNlaXZlSW5jb21pbmdSZXF1ZXN0RnJvbVRyYW5zcG9ydChtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgUmVzcG9uc2VcbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEluY29taW5nUmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICB0aGlzLnVzZXJBZ2VudENvcmUucmVjZWl2ZUluY29taW5nUmVzcG9uc2VGcm9tVHJhbnNwb3J0KG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWVzc2FnZSB0eXBlLlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9uIHN0YXRlLlxuICAgKi9cbiAgcHJpdmF0ZSB0cmFuc2l0aW9uU3RhdGUobmV3U3RhdGU6IFVzZXJBZ2VudFN0YXRlLCBlcnJvcj86IEVycm9yKTogdm9pZCB7XG4gICAgY29uc3QgaW52YWxpZFRyYW5zaXRpb24gPSAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGUgdHJhbnNpdGlvbiBmcm9tICR7dGhpcy5fc3RhdGV9IHRvICR7bmV3U3RhdGV9YCk7XG4gICAgfTtcblxuICAgIC8vIFZhbGlkYXRlIHN0YXRlIHRyYW5zaXRpb25cbiAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICBjYXNlIFVzZXJBZ2VudFN0YXRlLlN0YXJ0ZWQ6XG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gVXNlckFnZW50U3RhdGUuU3RvcHBlZCkge1xuICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFVzZXJBZ2VudFN0YXRlLlN0b3BwZWQ6XG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gVXNlckFnZW50U3RhdGUuU3RhcnRlZCkge1xuICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHN0YXRlLlwiKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICB0aGlzLmxvZ2dlci5sb2coYFRyYW5zaXRpb25lZCBmcm9tICR7dGhpcy5fc3RhdGV9IHRvICR7bmV3U3RhdGV9YCk7XG4gICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB0aGlzLl9zdGF0ZUV2ZW50RW1pdHRlci5lbWl0KFwiZXZlbnRcIiwgdGhpcy5fc3RhdGUpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBCb2R5LFxuICBDLFxuICBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSxcbiAgTmFtZUFkZHJIZWFkZXIsXG4gIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UsXG4gIFVSSVxufSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENvcmUgfSBmcm9tIFwiLi4vdXNlci1hZ2VudC1jb3JlXCI7XG5pbXBvcnQgeyBEaWFsb2dTdGF0ZSB9IGZyb20gXCIuL2RpYWxvZy1zdGF0ZVwiO1xuXG4vKipcbiAqIERpYWxvZy5cbiAqIEByZW1hcmtzXG4gKiBBIGtleSBjb25jZXB0IGZvciBhIHVzZXIgYWdlbnQgaXMgdGhhdCBvZiBhIGRpYWxvZy4gIEEgZGlhbG9nXG4gKiByZXByZXNlbnRzIGEgcGVlci10by1wZWVyIFNJUCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0d28gdXNlciBhZ2VudHNcbiAqIHRoYXQgcGVyc2lzdHMgZm9yIHNvbWUgdGltZS4gIFRoZSBkaWFsb2cgZmFjaWxpdGF0ZXMgc2VxdWVuY2luZyBvZlxuICogbWVzc2FnZXMgYmV0d2VlbiB0aGUgdXNlciBhZ2VudHMgYW5kIHByb3BlciByb3V0aW5nIG9mIHJlcXVlc3RzXG4gKiBiZXR3ZWVuIGJvdGggb2YgdGhlbS4gIFRoZSBkaWFsb2cgcmVwcmVzZW50cyBhIGNvbnRleHQgaW4gd2hpY2ggdG9cbiAqIGludGVycHJldCBTSVAgbWVzc2FnZXMuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBEaWFsb2cge1xuXG4gIC8qKlxuICAgKiBXaGVuIGEgVUFDIHJlY2VpdmVzIGEgcmVzcG9uc2UgdGhhdCBlc3RhYmxpc2hlcyBhIGRpYWxvZywgaXRcbiAgICogY29uc3RydWN0cyB0aGUgc3RhdGUgb2YgdGhlIGRpYWxvZy4gIFRoaXMgc3RhdGUgTVVTVCBiZSBtYWludGFpbmVkXG4gICAqIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGRpYWxvZy5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjJcbiAgICogQHBhcmFtIG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgLSBPdXRnb2luZyByZXF1ZXN0IG1lc3NhZ2UgZm9yIGRpYWxvZy5cbiAgICogQHBhcmFtIGluY29taW5nUmVzcG9uc2VNZXNzYWdlIC0gSW5jb21pbmcgcmVzcG9uc2UgbWVzc2FnZSBjcmVhdGluZyBkaWFsb2cuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGluaXRpYWxEaWFsb2dTdGF0ZUZvclVzZXJBZ2VudENsaWVudChcbiAgICBvdXRnb2luZ1JlcXVlc3RNZXNzYWdlOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGluY29taW5nUmVzcG9uc2VNZXNzYWdlOiBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZVxuICApOiBEaWFsb2dTdGF0ZSB7XG4gICAgLy8gSWYgdGhlIHJlcXVlc3Qgd2FzIHNlbnQgb3ZlciBUTFMsIGFuZCB0aGUgUmVxdWVzdC1VUkkgY29udGFpbmVkIGFcbiAgICAvLyBTSVBTIFVSSSwgdGhlIFwic2VjdXJlXCIgZmxhZyBpcyBzZXQgdG8gVFJVRS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgIGNvbnN0IHNlY3VyZSA9IGZhbHNlOyAvLyBGSVhNRTogQ3VycmVudGx5IG5vIHN1cHBvcnQgZm9yIFRMUy5cblxuICAgIC8vIFRoZSByb3V0ZSBzZXQgTVVTVCBiZSBzZXQgdG8gdGhlIGxpc3Qgb2YgVVJJcyBpbiB0aGUgUmVjb3JkLVJvdXRlXG4gICAgLy8gaGVhZGVyIGZpZWxkIGZyb20gdGhlIHJlc3BvbnNlLCB0YWtlbiBpbiByZXZlcnNlIG9yZGVyIGFuZCBwcmVzZXJ2aW5nXG4gICAgLy8gYWxsIFVSSSBwYXJhbWV0ZXJzLiAgSWYgbm8gUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCBpcyBwcmVzZW50IGluXG4gICAgLy8gdGhlIHJlc3BvbnNlLCB0aGUgcm91dGUgc2V0IE1VU1QgYmUgc2V0IHRvIHRoZSBlbXB0eSBzZXQuICBUaGlzIHJvdXRlXG4gICAgLy8gc2V0LCBldmVuIGlmIGVtcHR5LCBvdmVycmlkZXMgYW55IHByZS1leGlzdGluZyByb3V0ZSBzZXQgZm9yIGZ1dHVyZVxuICAgIC8vIHJlcXVlc3RzIGluIHRoaXMgZGlhbG9nLiAgVGhlIHJlbW90ZSB0YXJnZXQgTVVTVCBiZSBzZXQgdG8gdGhlIFVSSVxuICAgIC8vIGZyb20gdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXNwb25zZS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgIGNvbnN0IHJvdXRlU2V0ID0gaW5jb21pbmdSZXNwb25zZU1lc3NhZ2UuZ2V0SGVhZGVycyhcInJlY29yZC1yb3V0ZVwiKS5yZXZlcnNlKCk7XG4gICAgY29uc3QgY29udGFjdCA9IGluY29taW5nUmVzcG9uc2VNZXNzYWdlLnBhcnNlSGVhZGVyKFwiY29udGFjdFwiKTtcbiAgICBpZiAoIWNvbnRhY3QpIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWN0IHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIGlmICghKGNvbnRhY3QgaW5zdGFuY2VvZiBOYW1lQWRkckhlYWRlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhY3Qgbm90IGluc3RhbmNlIG9mIE5hbWVBZGRySGVhZGVyLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVtb3RlVGFyZ2V0ID0gY29udGFjdC51cmk7XG5cbiAgICAvLyBUaGUgbG9jYWwgc2VxdWVuY2UgbnVtYmVyIE1VU1QgYmUgc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2VcbiAgICAvLyBudW1iZXIgaW4gdGhlIENTZXEgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXF1ZXN0LiAgVGhlIHJlbW90ZSBzZXF1ZW5jZVxuICAgIC8vIG51bWJlciBNVVNUIGJlIGVtcHR5IChpdCBpcyBlc3RhYmxpc2hlZCB3aGVuIHRoZSByZW1vdGUgVUEgc2VuZHMgYVxuICAgIC8vIHJlcXVlc3Qgd2l0aGluIHRoZSBkaWFsb2cpLiAgVGhlIGNhbGwgaWRlbnRpZmllciBjb21wb25lbnQgb2YgdGhlXG4gICAgLy8gZGlhbG9nIElEIE1VU1QgYmUgc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgQ2FsbC1JRCBpbiB0aGUgcmVxdWVzdC5cbiAgICAvLyBUaGUgbG9jYWwgdGFnIGNvbXBvbmVudCBvZiB0aGUgZGlhbG9nIElEIE1VU1QgYmUgc2V0IHRvIHRoZSB0YWcgaW5cbiAgICAvLyB0aGUgRnJvbSBmaWVsZCBpbiB0aGUgcmVxdWVzdCwgYW5kIHRoZSByZW1vdGUgdGFnIGNvbXBvbmVudCBvZiB0aGVcbiAgICAvLyBkaWFsb2cgSUQgTVVTVCBiZSBzZXQgdG8gdGhlIHRhZyBpbiB0aGUgVG8gZmllbGQgb2YgdGhlIHJlc3BvbnNlLiAgQVxuICAgIC8vIFVBQyBNVVNUIGJlIHByZXBhcmVkIHRvIHJlY2VpdmUgYSByZXNwb25zZSB3aXRob3V0IGEgdGFnIGluIHRoZSBUb1xuICAgIC8vIGZpZWxkLCBpbiB3aGljaCBjYXNlIHRoZSB0YWcgaXMgY29uc2lkZXJlZCB0byBoYXZlIGEgdmFsdWUgb2YgbnVsbC5cbiAgICAvL1xuICAgIC8vICAgIFRoaXMgaXMgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBSRkMgMjU0Mywgd2hpY2hcbiAgICAvLyAgICBkaWQgbm90IG1hbmRhdGUgVG8gdGFncy5cbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgY29uc3QgbG9jYWxTZXF1ZW5jZU51bWJlciA9IG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuY3NlcTtcbiAgICBjb25zdCByZW1vdGVTZXF1ZW5jZU51bWJlciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjYWxsSWQgPSBvdXRnb2luZ1JlcXVlc3RNZXNzYWdlLmNhbGxJZDtcbiAgICBjb25zdCBsb2NhbFRhZyA9IG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuZnJvbVRhZztcbiAgICBjb25zdCByZW1vdGVUYWcgPSBpbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZS50b1RhZztcbiAgICBpZiAoIWNhbGxJZCkgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGwgaWQgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFsb2NhbFRhZykgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyb20gdGFnIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIGlmICghcmVtb3RlVGFnKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gdGFnIHVuZGVmaW5lZC5cIik7IC8vIEZJWE1FOiBObyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIFJGQyAyNTQzXG4gICAgfVxuXG4gICAgLy8gVGhlIHJlbW90ZSBVUkkgTVVTVCBiZSBzZXQgdG8gdGhlIFVSSSBpbiB0aGUgVG8gZmllbGQsIGFuZCB0aGUgbG9jYWxcbiAgICAvLyBVUkkgTVVTVCBiZSBzZXQgdG8gdGhlIFVSSSBpbiB0aGUgRnJvbSBmaWVsZC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgIGlmICghb3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5mcm9tKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB1bmRlZmluZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIW91dGdvaW5nUmVxdWVzdE1lc3NhZ2UudG8pIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUbyB1bmRlZmluZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbFVSSSA9IG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuZnJvbS51cmk7XG4gICAgY29uc3QgcmVtb3RlVVJJID0gb3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS50by51cmk7XG5cbiAgICAvLyBBIGRpYWxvZyBjYW4gYWxzbyBiZSBpbiB0aGUgXCJlYXJseVwiIHN0YXRlLCB3aGljaCBvY2N1cnMgd2hlbiBpdCBpc1xuICAgIC8vIGNyZWF0ZWQgd2l0aCBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlLCBhbmQgdGhlbiB0cmFuc2l0aW9uIHRvIHRoZVxuICAgIC8vIFwiY29uZmlybWVkXCIgc3RhdGUgd2hlbiBhIDJ4eCBmaW5hbCByZXNwb25zZSBhcnJpdmVzLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTJcbiAgICBpZiAoIWluY29taW5nUmVzcG9uc2VNZXNzYWdlLnN0YXR1c0NvZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29taW5nIHJlc3BvbnNlIHN0YXR1cyBjb2RlIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGVhcmx5ID0gaW5jb21pbmdSZXNwb25zZU1lc3NhZ2Uuc3RhdHVzQ29kZSA8IDIwMCA/IHRydWUgOiBmYWxzZTtcblxuICAgIGNvbnN0IGRpYWxvZ1N0YXRlOiBEaWFsb2dTdGF0ZSA9IHtcbiAgICAgIGlkOiBjYWxsSWQgKyBsb2NhbFRhZyArIHJlbW90ZVRhZyxcbiAgICAgIGVhcmx5LFxuICAgICAgY2FsbElkLFxuICAgICAgbG9jYWxUYWcsXG4gICAgICByZW1vdGVUYWcsXG4gICAgICBsb2NhbFNlcXVlbmNlTnVtYmVyLFxuICAgICAgcmVtb3RlU2VxdWVuY2VOdW1iZXIsXG4gICAgICBsb2NhbFVSSSxcbiAgICAgIHJlbW90ZVVSSSxcbiAgICAgIHJlbW90ZVRhcmdldCxcbiAgICAgIHJvdXRlU2V0LFxuICAgICAgc2VjdXJlXG4gICAgfTtcbiAgICByZXR1cm4gZGlhbG9nU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFVBUyB0aGVuIGNvbnN0cnVjdHMgdGhlIHN0YXRlIG9mIHRoZSBkaWFsb2cuICBUaGlzIHN0YXRlIE1VU1QgYmVcbiAgICogbWFpbnRhaW5lZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkaWFsb2cuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4xXG4gICAqIEBwYXJhbSBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlIC0gSW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlIGNyZWF0aW5nIGRpYWxvZy5cbiAgICogQHBhcmFtIHRvVGFnIC0gVGFnIGluIHRoZSBUbyBmaWVsZCBpbiB0aGUgcmVzcG9uc2UgdG8gdGhlIGluY29taW5nIHJlcXVlc3QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGluaXRpYWxEaWFsb2dTdGF0ZUZvclVzZXJBZ2VudFNlcnZlcihcbiAgICBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICAgIHRvVGFnOiBzdHJpbmcsXG4gICAgZWFybHk6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBEaWFsb2dTdGF0ZSB7XG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgYXJyaXZlZCBvdmVyIFRMUywgYW5kIHRoZSBSZXF1ZXN0LVVSSSBjb250YWluZWQgYSBTSVBTXG4gICAgLy8gVVJJLCB0aGUgXCJzZWN1cmVcIiBmbGFnIGlzIHNldCB0byBUUlVFLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4xXG4gICAgY29uc3Qgc2VjdXJlID0gZmFsc2U7IC8vIEZJWE1FOiBDdXJyZW50bHkgbm8gc3VwcG9ydCBmb3IgVExTLlxuXG4gICAgLy8gVGhlIHJvdXRlIHNldCBNVVNUIGJlIHNldCB0byB0aGUgbGlzdCBvZiBVUklzIGluIHRoZSBSZWNvcmQtUm91dGVcbiAgICAvLyBoZWFkZXIgZmllbGQgZnJvbSB0aGUgcmVxdWVzdCwgdGFrZW4gaW4gb3JkZXIgYW5kIHByZXNlcnZpbmcgYWxsIFVSSVxuICAgIC8vIHBhcmFtZXRlcnMuICBJZiBubyBSZWNvcmQtUm91dGUgaGVhZGVyIGZpZWxkIGlzIHByZXNlbnQgaW4gdGhlXG4gICAgLy8gcmVxdWVzdCwgdGhlIHJvdXRlIHNldCBNVVNUIGJlIHNldCB0byB0aGUgZW1wdHkgc2V0LiAgVGhpcyByb3V0ZSBzZXQsXG4gICAgLy8gZXZlbiBpZiBlbXB0eSwgb3ZlcnJpZGVzIGFueSBwcmUtZXhpc3Rpbmcgcm91dGUgc2V0IGZvciBmdXR1cmVcbiAgICAvLyByZXF1ZXN0cyBpbiB0aGlzIGRpYWxvZy4gIFRoZSByZW1vdGUgdGFyZ2V0IE1VU1QgYmUgc2V0IHRvIHRoZSBVUklcbiAgICAvLyBmcm9tIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMVxuICAgIGNvbnN0IHJvdXRlU2V0ID0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpO1xuICAgIGNvbnN0IGNvbnRhY3QgPSBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlLnBhcnNlSGVhZGVyKFwiY29udGFjdFwiKTtcbiAgICBpZiAoIWNvbnRhY3QpIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWN0IHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIGlmICghKGNvbnRhY3QgaW5zdGFuY2VvZiBOYW1lQWRkckhlYWRlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhY3Qgbm90IGluc3RhbmNlIG9mIE5hbWVBZGRySGVhZGVyLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVtb3RlVGFyZ2V0ID0gY29udGFjdC51cmk7XG5cbiAgICAvLyBUaGUgcmVtb3RlIHNlcXVlbmNlIG51bWJlciBNVVNUIGJlIHNldCB0byB0aGUgdmFsdWUgb2YgdGhlIHNlcXVlbmNlXG4gICAgLy8gbnVtYmVyIGluIHRoZSBDU2VxIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdC4gIFRoZSBsb2NhbCBzZXF1ZW5jZVxuICAgIC8vIG51bWJlciBNVVNUIGJlIGVtcHR5LiAgVGhlIGNhbGwgaWRlbnRpZmllciBjb21wb25lbnQgb2YgdGhlIGRpYWxvZyBJRFxuICAgIC8vIE1VU1QgYmUgc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgQ2FsbC1JRCBpbiB0aGUgcmVxdWVzdC4gIFRoZSBsb2NhbFxuICAgIC8vIHRhZyBjb21wb25lbnQgb2YgdGhlIGRpYWxvZyBJRCBNVVNUIGJlIHNldCB0byB0aGUgdGFnIGluIHRoZSBUbyBmaWVsZFxuICAgIC8vIGluIHRoZSByZXNwb25zZSB0byB0aGUgcmVxdWVzdCAod2hpY2ggYWx3YXlzIGluY2x1ZGVzIGEgdGFnKSwgYW5kIHRoZVxuICAgIC8vIHJlbW90ZSB0YWcgY29tcG9uZW50IG9mIHRoZSBkaWFsb2cgSUQgTVVTVCBiZSBzZXQgdG8gdGhlIHRhZyBmcm9tIHRoZVxuICAgIC8vIEZyb20gZmllbGQgaW4gdGhlIHJlcXVlc3QuICBBIFVBUyBNVVNUIGJlIHByZXBhcmVkIHRvIHJlY2VpdmUgYVxuICAgIC8vIHJlcXVlc3Qgd2l0aG91dCBhIHRhZyBpbiB0aGUgRnJvbSBmaWVsZCwgaW4gd2hpY2ggY2FzZSB0aGUgdGFnIGlzXG4gICAgLy8gY29uc2lkZXJlZCB0byBoYXZlIGEgdmFsdWUgb2YgbnVsbC5cbiAgICAvL1xuICAgIC8vICAgIFRoaXMgaXMgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBSRkMgMjU0Mywgd2hpY2hcbiAgICAvLyAgICBkaWQgbm90IG1hbmRhdGUgRnJvbSB0YWdzLlxuICAgIC8vXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjFcbiAgICBjb25zdCByZW1vdGVTZXF1ZW5jZU51bWJlciA9IGluY29taW5nUmVxdWVzdE1lc3NhZ2UuY3NlcTtcbiAgICBjb25zdCBsb2NhbFNlcXVlbmNlTnVtYmVyID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNhbGxJZCA9IGluY29taW5nUmVxdWVzdE1lc3NhZ2UuY2FsbElkO1xuICAgIGNvbnN0IGxvY2FsVGFnID0gdG9UYWc7XG4gICAgY29uc3QgcmVtb3RlVGFnID0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS5mcm9tVGFnO1xuXG4gICAgLy8gVGhlIHJlbW90ZSBVUkkgTVVTVCBiZSBzZXQgdG8gdGhlIFVSSSBpbiB0aGUgRnJvbSBmaWVsZCwgYW5kIHRoZVxuICAgIC8vIGxvY2FsIFVSSSBNVVNUIGJlIHNldCB0byB0aGUgVVJJIGluIHRoZSBUbyBmaWVsZC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMVxuICAgIGNvbnN0IHJlbW90ZVVSSSA9IGluY29taW5nUmVxdWVzdE1lc3NhZ2UuZnJvbS51cmk7XG4gICAgY29uc3QgbG9jYWxVUkkgPSBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlLnRvLnVyaTtcblxuICAgIGNvbnN0IGRpYWxvZ1N0YXRlOiBEaWFsb2dTdGF0ZSA9IHtcbiAgICAgIGlkOiBjYWxsSWQgKyBsb2NhbFRhZyArIHJlbW90ZVRhZyxcbiAgICAgIGVhcmx5LFxuICAgICAgY2FsbElkLFxuICAgICAgbG9jYWxUYWcsXG4gICAgICByZW1vdGVUYWcsXG4gICAgICBsb2NhbFNlcXVlbmNlTnVtYmVyLFxuICAgICAgcmVtb3RlU2VxdWVuY2VOdW1iZXIsXG4gICAgICBsb2NhbFVSSSxcbiAgICAgIHJlbW90ZVVSSSxcbiAgICAgIHJlbW90ZVRhcmdldCxcbiAgICAgIHJvdXRlU2V0LFxuICAgICAgc2VjdXJlXG4gICAgfTtcbiAgICByZXR1cm4gZGlhbG9nU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogRGlhbG9nIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gY29yZSAtIFVzZXIgYWdlbnQgY29yZS5cbiAgICogQHBhcmFtIGRpYWxvZ1N0YXRlIC0gSW5pdGlhbCBkaWFsb2cgc3RhdGUuXG4gICAqL1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGNvcmU6IFVzZXJBZ2VudENvcmUsXG4gICAgcHJvdGVjdGVkIGRpYWxvZ1N0YXRlOiBEaWFsb2dTdGF0ZSxcbiAgKSB7XG4gICAgdGhpcy5jb3JlLmRpYWxvZ3Muc2V0KHRoaXMuaWQsIHRoaXMpO1xuICAgfVxuXG4gIC8qKiBEZXN0cnVjdG9yLiAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmNvcmUuZGlhbG9ncy5kZWxldGUodGhpcy5pZCk7XG4gIH1cblxuICAvKipcbiAgICogQSBkaWFsb2cgaXMgaWRlbnRpZmllZCBhdCBlYWNoIFVBIHdpdGggYSBkaWFsb2cgSUQsIHdoaWNoIGNvbnNpc3RzIG9mXG4gICAqIGEgQ2FsbC1JRCB2YWx1ZSwgYSBsb2NhbCB0YWcgYW5kIGEgcmVtb3RlIHRhZy4gIFRoZSBkaWFsb2cgSUQgYXQgZWFjaFxuICAgKiBVQSBpbnZvbHZlZCBpbiB0aGUgZGlhbG9nIGlzIG5vdCB0aGUgc2FtZS4gIFNwZWNpZmljYWxseSwgdGhlIGxvY2FsXG4gICAqIHRhZyBhdCBvbmUgVUEgaXMgaWRlbnRpY2FsIHRvIHRoZSByZW1vdGUgdGFnIGF0IHRoZSBwZWVyIFVBLiAgVGhlXG4gICAqIHRhZ3MgYXJlIG9wYXF1ZSB0b2tlbnMgdGhhdCBmYWNpbGl0YXRlIHRoZSBnZW5lcmF0aW9uIG9mIHVuaXF1ZVxuICAgKiBkaWFsb2cgSURzLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUuaWQ7XG4gIH1cblxuICAvKipcbiAgICogQSBkaWFsb2cgY2FuIGFsc28gYmUgaW4gdGhlIFwiZWFybHlcIiBzdGF0ZSwgd2hpY2ggb2NjdXJzIHdoZW4gaXQgaXNcbiAgICogY3JlYXRlZCB3aXRoIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UsIGFuZCB0aGVuIGl0IHRyYW5zaXRpb24gdG8gdGhlXG4gICAqIFwiY29uZmlybWVkXCIgc3RhdGUgd2hlbiBhIDJ4eCBmaW5hbCByZXNwb25zZSByZWNlaXZlZCBvciBpcyBzZW50LlxuICAgKlxuICAgKiBOb3RlOiBSRkMgMzI2MSBpcyBjb25jaXNlIG9uIHdoZW4gYSBkaWFsb2cgaXMgXCJjb25maXJtZWRcIiwgYnV0IGl0XG4gICAqIGNhbiBiZSBhIHBvaW50IG9mIGNvbmZ1c2lvbiBpZiBhbiBJTlZJVEUgZGlhbG9nIGlzIFwiY29uZmlybWVkXCIgYWZ0ZXJcbiAgICogYSAyeHggaXMgc2VudCBvciBhZnRlciByZWNlaXZpbmcgdGhlIEFDSyBmb3IgdGhlIDJ4eCByZXNwb25zZS5cbiAgICogV2l0aCBjYXJlZnVsIHJlYWRpbmcgaXQgY2FuIGJlIGluZmVycmVkIGEgZGlhbG9nIGlzIGFsd2F5cyBpc1xuICAgKiBcImNvbmZpcm1lZFwiIHdoZW4gdGhlIDJ4eCBpcyBzZW50IChyZWdhcmRsZXNzIG9mIHR5cGUgb2YgZGlhbG9nKS5cbiAgICogSG93ZXZlciBhIElOVklURSBkaWFsb2cgZG9lcyBoYXZlIGFkZGl0aW9uYWwgY29uc2lkZXJhdGlvbnNcbiAgICogd2hlbiBpdCBpcyBjb25maXJtZWQgYnV0IGFuIEFDSyBoYXMgbm90IHlldCBiZWVuIHJlY2VpdmVkIChpblxuICAgKiBwYXJ0aWN1bGFyIHdpdGggcmVnYXJkIHRvIGEgY2FsbGVlIHNlbmRpbmcgQllFIHJlcXVlc3RzKS5cbiAgICovXG4gIHB1YmxpYyBnZXQgZWFybHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUuZWFybHk7XG4gIH1cblxuICAvKiogQ2FsbCBpZGVudGlmaWVyIGNvbXBvbmVudCBvZiB0aGUgZGlhbG9nIGlkLiAqL1xuICBwdWJsaWMgZ2V0IGNhbGxJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmRpYWxvZ1N0YXRlLmNhbGxJZDtcbiAgfVxuXG4gIC8qKiBMb2NhbCB0YWcgY29tcG9uZW50IG9mIHRoZSBkaWFsb2cgaWQuICovXG4gIHB1YmxpYyBnZXQgbG9jYWxUYWcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5sb2NhbFRhZztcbiAgfVxuXG4gIC8qKiBSZW1vdGUgdGFnIGNvbXBvbmVudCBvZiB0aGUgZGlhbG9nIGlkLiAqL1xuICBwdWJsaWMgZ2V0IHJlbW90ZVRhZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmRpYWxvZ1N0YXRlLnJlbW90ZVRhZztcbiAgfVxuXG4gIC8qKiBMb2NhbCBzZXF1ZW5jZSBudW1iZXIgKHVzZWQgdG8gb3JkZXIgcmVxdWVzdHMgZnJvbSB0aGUgVUEgdG8gaXRzIHBlZXIpLiAqL1xuICBwdWJsaWMgZ2V0IGxvY2FsU2VxdWVuY2VOdW1iZXIoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5sb2NhbFNlcXVlbmNlTnVtYmVyO1xuICB9XG5cbiAgLyoqIFJlbW90ZSBzZXF1ZW5jZSBudW1iZXIgKHVzZWQgdG8gb3JkZXIgcmVxdWVzdHMgZnJvbSBpdHMgcGVlciB0byB0aGUgVUEpLiAqL1xuICBwdWJsaWMgZ2V0IHJlbW90ZVNlcXVlbmNlTnVtYmVyKCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUucmVtb3RlU2VxdWVuY2VOdW1iZXI7XG4gIH1cblxuICAvKiogTG9jYWwgVVJJLiAqL1xuICBwdWJsaWMgZ2V0IGxvY2FsVVJJKCk6IFVSSSB7XG4gICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUubG9jYWxVUkk7XG4gIH1cblxuICAvKiogUmVtb3RlIFVSSS4gKi9cbiAgcHVibGljIGdldCByZW1vdGVVUkkoKTogVVJJIHtcbiAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5yZW1vdGVVUkk7XG4gIH1cblxuICAvKiogUmVtb3RlIHRhcmdldC4gKi9cbiAgcHVibGljIGdldCByZW1vdGVUYXJnZXQoKTogVVJJIHtcbiAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5yZW1vdGVUYXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogUm91dGUgc2V0LCB3aGljaCBpcyBhbiBvcmRlcmVkIGxpc3Qgb2YgVVJJcy4gVGhlIHJvdXRlIHNldCBpcyB0aGVcbiAgICogbGlzdCBvZiBzZXJ2ZXJzIHRoYXQgbmVlZCB0byBiZSB0cmF2ZXJzZWQgdG8gc2VuZCBhIHJlcXVlc3QgdG8gdGhlIHBlZXIuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHJvdXRlU2V0KCk6IEFycmF5PHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmRpYWxvZ1N0YXRlLnJvdXRlU2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZXF1ZXN0IHdhcyBzZW50IG92ZXIgVExTLCBhbmQgdGhlIFJlcXVlc3QtVVJJIGNvbnRhaW5lZFxuICAgKiBhIFNJUFMgVVJJLCB0aGUgXCJzZWN1cmVcIiBmbGFnIGlzIHNldCB0byB0cnVlLiAqTk9UIElNUExFTUVOVEVEKlxuICAgKi9cbiAgcHVibGljIGdldCBzZWN1cmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUuc2VjdXJlO1xuICB9XG5cbiAgLyoqIFRoZSB1c2VyIGFnZW50IGNvcmUgc2VydmljaW5nIHRoaXMgZGlhbG9nLiAqL1xuICBwdWJsaWMgZ2V0IHVzZXJBZ2VudENvcmUoKTogVXNlckFnZW50Q29yZSB7XG4gICAgcmV0dXJuIHRoaXMuY29yZTtcbiAgfVxuXG4gIC8qKiBDb25maXJtIHRoZSBkaWFsb2cuIE9ubHkgbWF0dGVycyBpZiBkaWFsb2cgaXMgY3VycmVudGx5IGVhcmx5LiAqL1xuICBwdWJsaWMgY29uZmlybSgpOiB2b2lkIHtcbiAgICB0aGlzLmRpYWxvZ1N0YXRlLmVhcmx5ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdHMgc2VudCB3aXRoaW4gYSBkaWFsb2csIGFzIGFueSBvdGhlciByZXF1ZXN0cywgYXJlIGF0b21pYy4gIElmXG4gICAqIGEgcGFydGljdWxhciByZXF1ZXN0IGlzIGFjY2VwdGVkIGJ5IHRoZSBVQVMsIGFsbCB0aGUgc3RhdGUgY2hhbmdlc1xuICAgKiBhc3NvY2lhdGVkIHdpdGggaXQgYXJlIHBlcmZvcm1lZC4gIElmIHRoZSByZXF1ZXN0IGlzIHJlamVjdGVkLCBub25lXG4gICAqIG9mIHRoZSBzdGF0ZSBjaGFuZ2VzIGFyZSBwZXJmb3JtZWQuXG4gICAqXG4gICAqICAgIE5vdGUgdGhhdCBzb21lIHJlcXVlc3RzLCBzdWNoIGFzIElOVklURXMsIGFmZmVjdCBzZXZlcmFsIHBpZWNlcyBvZlxuICAgKiAgICBzdGF0ZS5cbiAgICpcbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2Ugd2l0aGluIHRoaXMgZGlhbG9nLlxuICAgKi9cbiAgcHVibGljIHJlY2VpdmVSZXF1ZXN0KG1lc3NhZ2U6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UpOiB2b2lkIHtcbiAgICAvLyBBQ0sgZ3VhcmQuXG4gICAgLy8gQnkgY29udmVudGlvbiwgdGhlIGhhbmRsaW5nIG9mIEFDS3MgaXMgdGhlIHJlc3BvbnNpYmlsaXR5XG4gICAgLy8gdGhlIHBhcnRpY3VsYXIgZGlhbG9nIGltcGxlbWVudGF0aW9uLiBGb3IgZXhhbXBsZSwgc2VlIFNlc3Npb25EaWFsb2cuXG4gICAgLy8gRnVydGhlcm1vcmUsIEFDS3MgaGF2ZSBzYW1lIHNlcXVlbmNlIG51bWJlciBhcyB0aGUgYXNzb2NpYXRlZCBJTlZJVEUuXG4gICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBDLkFDSykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSByZW1vdGUgc2VxdWVuY2UgbnVtYmVyIHdhcyBub3QgZW1wdHksIGJ1dCB0aGUgc2VxdWVuY2UgbnVtYmVyXG4gICAgLy8gb2YgdGhlIHJlcXVlc3QgaXMgbG93ZXIgdGhhbiB0aGUgcmVtb3RlIHNlcXVlbmNlIG51bWJlciwgdGhlIHJlcXVlc3RcbiAgICAvLyBpcyBvdXQgb2Ygb3JkZXIgYW5kIE1VU1QgYmUgcmVqZWN0ZWQgd2l0aCBhIDUwMCAoU2VydmVyIEludGVybmFsXG4gICAgLy8gRXJyb3IpIHJlc3BvbnNlLiAgSWYgdGhlIHJlbW90ZSBzZXF1ZW5jZSBudW1iZXIgd2FzIG5vdCBlbXB0eSwgYW5kXG4gICAgLy8gdGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGUgcmVxdWVzdCBpcyBncmVhdGVyIHRoYW4gdGhlIHJlbW90ZVxuICAgIC8vIHNlcXVlbmNlIG51bWJlciwgdGhlIHJlcXVlc3QgaXMgaW4gb3JkZXIuICBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlXG4gICAgLy8gQ1NlcSBzZXF1ZW5jZSBudW1iZXIgdG8gYmUgaGlnaGVyIHRoYW4gdGhlIHJlbW90ZSBzZXF1ZW5jZSBudW1iZXIgYnlcbiAgICAvLyBtb3JlIHRoYW4gb25lLiAgVGhpcyBpcyBub3QgYW4gZXJyb3IgY29uZGl0aW9uLCBhbmQgYSBVQVMgU0hPVUxEIGJlXG4gICAgLy8gcHJlcGFyZWQgdG8gcmVjZWl2ZSBhbmQgcHJvY2VzcyByZXF1ZXN0cyB3aXRoIENTZXEgdmFsdWVzIG1vcmUgdGhhblxuICAgIC8vIG9uZSBoaWdoZXIgdGhhbiB0aGUgcHJldmlvdXMgcmVjZWl2ZWQgcmVxdWVzdC4gIFRoZSBVQVMgTVVTVCB0aGVuIHNldFxuICAgIC8vIHRoZSByZW1vdGUgc2VxdWVuY2UgbnVtYmVyIHRvIHRoZSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2UgbnVtYmVyIGluIHRoZVxuICAgIC8vIENTZXEgaGVhZGVyIGZpZWxkIHZhbHVlIGluIHRoZSByZXF1ZXN0LlxuICAgIC8vXG4gICAgLy8gICAgSWYgYSBwcm94eSBjaGFsbGVuZ2VzIGEgcmVxdWVzdCBnZW5lcmF0ZWQgYnkgdGhlIFVBQywgdGhlIFVBQyBoYXNcbiAgICAvLyAgICB0byByZXN1Ym1pdCB0aGUgcmVxdWVzdCB3aXRoIGNyZWRlbnRpYWxzLiAgVGhlIHJlc3VibWl0dGVkIHJlcXVlc3RcbiAgICAvLyAgICB3aWxsIGhhdmUgYSBuZXcgQ1NlcSBudW1iZXIuICBUaGUgVUFTIHdpbGwgbmV2ZXIgc2VlIHRoZSBmaXJzdFxuICAgIC8vICAgIHJlcXVlc3QsIGFuZCB0aHVzLCBpdCB3aWxsIG5vdGljZSBhIGdhcCBpbiB0aGUgQ1NlcSBudW1iZXIgc3BhY2UuXG4gICAgLy8gICAgU3VjaCBhIGdhcCBkb2VzIG5vdCByZXByZXNlbnQgYW55IGVycm9yIGNvbmRpdGlvbi5cbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgaWYgKHRoaXMucmVtb3RlU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgIGlmIChtZXNzYWdlLmNzZXEgPD0gdGhpcy5yZW1vdGVTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdXQgb2Ygc2VxdWVuY2UgaW4gZGlhbG9nIHJlcXVlc3QuIERpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgc2VxdWVuY2VHdWFyZCgpP1wiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlhbG9nU3RhdGUucmVtb3RlU2VxdWVuY2VOdW1iZXIgPSBtZXNzYWdlLmNzZXE7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlbW90ZSBzZXF1ZW5jZSBudW1iZXIgaXMgZW1wdHksIGl0IE1VU1QgYmUgc2V0IHRvIHRoZSB2YWx1ZVxuICAgIC8vIG9mIHRoZSBzZXF1ZW5jZSBudW1iZXIgaW4gdGhlIENTZXEgaGVhZGVyIGZpZWxkIHZhbHVlIGluIHRoZSByZXF1ZXN0LlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgaWYgKCF0aGlzLnJlbW90ZVNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICB0aGlzLmRpYWxvZ1N0YXRlLnJlbW90ZVNlcXVlbmNlTnVtYmVyID0gbWVzc2FnZS5jc2VxO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYSBVQVMgcmVjZWl2ZXMgYSB0YXJnZXQgcmVmcmVzaCByZXF1ZXN0LCBpdCBNVVNUIHJlcGxhY2UgdGhlXG4gICAgLy8gZGlhbG9nJ3MgcmVtb3RlIHRhcmdldCBVUkkgd2l0aCB0aGUgVVJJIGZyb20gdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkXG4gICAgLy8gaW4gdGhhdCByZXF1ZXN0LCBpZiBwcmVzZW50LlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgLy8gTm90ZTogXCJ0YXJnZXQgcmVmcmVzaCByZXF1ZXN0XCIgcHJvY2Vzc2luZyBkZWxlZ2F0ZWQgdG8gc3ViLWNsYXNzLlxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBkaWFsb2cgaWRlbnRpZmllciBpbiB0aGUgMnh4IHJlc3BvbnNlIG1hdGNoZXMgdGhlIGRpYWxvZ1xuICAgKiBpZGVudGlmaWVyIG9mIGFuIGV4aXN0aW5nIGRpYWxvZywgdGhlIGRpYWxvZyBNVVNUIGJlIHRyYW5zaXRpb25lZCB0b1xuICAgKiB0aGUgXCJjb25maXJtZWRcIiBzdGF0ZSwgYW5kIHRoZSByb3V0ZSBzZXQgZm9yIHRoZSBkaWFsb2cgTVVTVCBiZVxuICAgKiByZWNvbXB1dGVkIGJhc2VkIG9uIHRoZSAyeHggcmVzcG9uc2UgdXNpbmcgdGhlIHByb2NlZHVyZXMgb2YgU2VjdGlvblxuICAgKiAxMi4yLjEuMi4gIE90aGVyd2lzZSwgYSBuZXcgZGlhbG9nIGluIHRoZSBcImNvbmZpcm1lZFwiIHN0YXRlIE1VU1QgYmVcbiAgICogY29uc3RydWN0ZWQgdXNpbmcgdGhlIHByb2NlZHVyZXMgb2YgU2VjdGlvbiAxMi4xLjIuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgb25seSBwaWVjZSBvZiBzdGF0ZSB0aGF0IGlzIHJlY29tcHV0ZWQgaXMgdGhlIHJvdXRlXG4gICAqIHNldC4gIE90aGVyIHBpZWNlcyBvZiBzdGF0ZSBzdWNoIGFzIHRoZSBoaWdoZXN0IHNlcXVlbmNlIG51bWJlcnNcbiAgICogKHJlbW90ZSBhbmQgbG9jYWwpIHNlbnQgd2l0aGluIHRoZSBkaWFsb2cgYXJlIG5vdCByZWNvbXB1dGVkLiAgVGhlXG4gICAqIHJvdXRlIHNldCBvbmx5IGlzIHJlY29tcHV0ZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiAgUkZDXG4gICAqIDI1NDMgZGlkIG5vdCBtYW5kYXRlIG1pcnJvcmluZyBvZiB0aGUgUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCBpblxuICAgKiBhIDF4eCwgb25seSAyeHguICBIb3dldmVyLCB3ZSBjYW5ub3QgdXBkYXRlIHRoZSBlbnRpcmUgc3RhdGUgb2ZcbiAgICogdGhlIGRpYWxvZywgc2luY2UgbWlkLWRpYWxvZyByZXF1ZXN0cyBtYXkgaGF2ZSBiZWVuIHNlbnQgd2l0aGluXG4gICAqIHRoZSBlYXJseSBkaWFsb2csIG1vZGlmeWluZyB0aGUgc2VxdWVuY2UgbnVtYmVycywgZm9yIGV4YW1wbGUuXG4gICAqXG4gICAqICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi40XG4gICAqL1xuICBwdWJsaWMgcmVjb21wdXRlUm91dGVTZXQobWVzc2FnZTogSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpOiB2b2lkIHtcbiAgICB0aGlzLmRpYWxvZ1N0YXRlLnJvdXRlU2V0ID0gbWVzc2FnZS5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpLnJldmVyc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHJlcXVlc3Qgd2l0aGluIGEgZGlhbG9nIGlzIGNvbnN0cnVjdGVkIGJ5IHVzaW5nIG1hbnkgb2YgdGhlXG4gICAqIGNvbXBvbmVudHMgb2YgdGhlIHN0YXRlIHN0b3JlZCBhcyBwYXJ0IG9mIHRoZSBkaWFsb2cuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4xLjFcbiAgICogQHBhcmFtIG1ldGhvZCAtIE91dGdvaW5nIHJlcXVlc3QgbWV0aG9kLlxuICAgKi9cbiAgcHVibGljIGNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoXG4gICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIGNzZXE/OiBudW1iZXI7XG4gICAgICBleHRyYUhlYWRlcnM/OiBBcnJheTxzdHJpbmc+O1xuICAgICAgYm9keT86IEJvZHk7XG4gICAgfVxuICApOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlIHtcbiAgICAvLyBUaGUgVVJJIGluIHRoZSBUbyBmaWVsZCBvZiB0aGUgcmVxdWVzdCBNVVNUIGJlIHNldCB0byB0aGUgcmVtb3RlIFVSSVxuICAgIC8vIGZyb20gdGhlIGRpYWxvZyBzdGF0ZS4gIFRoZSB0YWcgaW4gdGhlIFRvIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdFxuICAgIC8vIE1VU1QgYmUgc2V0IHRvIHRoZSByZW1vdGUgdGFnIG9mIHRoZSBkaWFsb2cgSUQuICBUaGUgRnJvbSBVUkkgb2YgdGhlXG4gICAgLy8gcmVxdWVzdCBNVVNUIGJlIHNldCB0byB0aGUgbG9jYWwgVVJJIGZyb20gdGhlIGRpYWxvZyBzdGF0ZS4gIFRoZSB0YWdcbiAgICAvLyBpbiB0aGUgRnJvbSBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3QgTVVTVCBiZSBzZXQgdG8gdGhlIGxvY2FsIHRhZ1xuICAgIC8vIG9mIHRoZSBkaWFsb2cgSUQuICBJZiB0aGUgdmFsdWUgb2YgdGhlIHJlbW90ZSBvciBsb2NhbCB0YWdzIGlzIG51bGwsXG4gICAgLy8gdGhlIHRhZyBwYXJhbWV0ZXIgTVVTVCBiZSBvbWl0dGVkIGZyb20gdGhlIFRvIG9yIEZyb20gaGVhZGVyIGZpZWxkcyxcbiAgICAvLyByZXNwZWN0aXZlbHkuXG4gICAgLy9cbiAgICAvLyAgICBVc2FnZSBvZiB0aGUgVVJJIGZyb20gdGhlIFRvIGFuZCBGcm9tIGZpZWxkcyBpbiB0aGUgb3JpZ2luYWxcbiAgICAvLyAgICByZXF1ZXN0IHdpdGhpbiBzdWJzZXF1ZW50IHJlcXVlc3RzIGlzIGRvbmUgZm9yIGJhY2t3YXJkc1xuICAgIC8vICAgIGNvbXBhdGliaWxpdHkgd2l0aCBSRkMgMjU0Mywgd2hpY2ggdXNlZCB0aGUgVVJJIGZvciBkaWFsb2dcbiAgICAvLyAgICBpZGVudGlmaWNhdGlvbi4gIEluIHRoaXMgc3BlY2lmaWNhdGlvbiwgb25seSB0aGUgdGFncyBhcmUgdXNlZCBmb3JcbiAgICAvLyAgICBkaWFsb2cgaWRlbnRpZmljYXRpb24uICBJdCBpcyBleHBlY3RlZCB0aGF0IG1hbmRhdG9yeSByZWZsZWN0aW9uXG4gICAgLy8gICAgb2YgdGhlIG9yaWdpbmFsIFRvIGFuZCBGcm9tIFVSSSBpbiBtaWQtZGlhbG9nIHJlcXVlc3RzIHdpbGwgYmVcbiAgICAvLyAgICBkZXByZWNhdGVkIGluIGEgc3Vic2VxdWVudCByZXZpc2lvbiBvZiB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjEuMVxuICAgIGNvbnN0IHRvVXJpID0gdGhpcy5yZW1vdGVVUkk7XG4gICAgY29uc3QgdG9UYWcgPSB0aGlzLnJlbW90ZVRhZztcbiAgICBjb25zdCBmcm9tVXJpID0gdGhpcy5sb2NhbFVSSTtcbiAgICBjb25zdCBmcm9tVGFnID0gdGhpcy5sb2NhbFRhZztcblxuICAgIC8vIFRoZSBDYWxsLUlEIG9mIHRoZSByZXF1ZXN0IE1VU1QgYmUgc2V0IHRvIHRoZSBDYWxsLUlEIG9mIHRoZSBkaWFsb2cuXG4gICAgLy8gUmVxdWVzdHMgd2l0aGluIGEgZGlhbG9nIE1VU1QgY29udGFpbiBzdHJpY3RseSBtb25vdG9uaWNhbGx5XG4gICAgLy8gaW5jcmVhc2luZyBhbmQgY29udGlndW91cyBDU2VxIHNlcXVlbmNlIG51bWJlcnMgKGluY3JlYXNpbmctYnktb25lKVxuICAgIC8vIGluIGVhY2ggZGlyZWN0aW9uIChleGNlcHRpbmcgQUNLIGFuZCBDQU5DRUwgb2YgY291cnNlLCB3aG9zZSBudW1iZXJzXG4gICAgLy8gZXF1YWwgdGhlIHJlcXVlc3RzIGJlaW5nIGFja25vd2xlZGdlZCBvciBjYW5jZWxsZWQpLiAgVGhlcmVmb3JlLCBpZlxuICAgIC8vIHRoZSBsb2NhbCBzZXF1ZW5jZSBudW1iZXIgaXMgbm90IGVtcHR5LCB0aGUgdmFsdWUgb2YgdGhlIGxvY2FsXG4gICAgLy8gc2VxdWVuY2UgbnVtYmVyIE1VU1QgYmUgaW5jcmVtZW50ZWQgYnkgb25lLCBhbmQgdGhpcyB2YWx1ZSBNVVNUIGJlXG4gICAgLy8gcGxhY2VkIGludG8gdGhlIENTZXEgaGVhZGVyIGZpZWxkLiAgSWYgdGhlIGxvY2FsIHNlcXVlbmNlIG51bWJlciBpc1xuICAgIC8vIGVtcHR5LCBhbiBpbml0aWFsIHZhbHVlIE1VU1QgYmUgY2hvc2VuIHVzaW5nIHRoZSBndWlkZWxpbmVzIG9mXG4gICAgLy8gU2VjdGlvbiA4LjEuMS41LiAgVGhlIG1ldGhvZCBmaWVsZCBpbiB0aGUgQ1NlcSBoZWFkZXIgZmllbGQgdmFsdWVcbiAgICAvLyBNVVNUIG1hdGNoIHRoZSBtZXRob2Qgb2YgdGhlIHJlcXVlc3QuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjEuMVxuICAgIGNvbnN0IGNhbGxJZCA9IHRoaXMuY2FsbElkO1xuICAgIGxldCBjc2VxOiBudW1iZXI7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jc2VxKSB7XG4gICAgICBjc2VxID0gb3B0aW9ucy5jc2VxO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZGlhbG9nU3RhdGUubG9jYWxTZXF1ZW5jZU51bWJlcikge1xuICAgICAgY3NlcSA9IHRoaXMuZGlhbG9nU3RhdGUubG9jYWxTZXF1ZW5jZU51bWJlciA9IDE7IC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjEuNVxuICAgIH0gZWxzZSB7XG4gICAgICBjc2VxID0gdGhpcy5kaWFsb2dTdGF0ZS5sb2NhbFNlcXVlbmNlTnVtYmVyICs9IDE7XG4gICAgfVxuXG4gICAgLy8gVGhlIFVBQyB1c2VzIHRoZSByZW1vdGUgdGFyZ2V0IGFuZCByb3V0ZSBzZXQgdG8gYnVpbGQgdGhlIFJlcXVlc3QtVVJJXG4gICAgLy8gYW5kIFJvdXRlIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZSByb3V0ZSBzZXQgaXMgZW1wdHksIHRoZSBVQUMgTVVTVCBwbGFjZSB0aGUgcmVtb3RlIHRhcmdldCBVUklcbiAgICAvLyBpbnRvIHRoZSBSZXF1ZXN0LVVSSS4gIFRoZSBVQUMgTVVTVCBOT1QgYWRkIGEgUm91dGUgaGVhZGVyIGZpZWxkIHRvXG4gICAgLy8gdGhlIHJlcXVlc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgcm91dGUgc2V0IGlzIG5vdCBlbXB0eSwgYW5kIHRoZSBmaXJzdCBVUkkgaW4gdGhlIHJvdXRlIHNldFxuICAgIC8vIGNvbnRhaW5zIHRoZSBsciBwYXJhbWV0ZXIgKHNlZSBTZWN0aW9uIDE5LjEuMSksIHRoZSBVQUMgTVVTVCBwbGFjZVxuICAgIC8vIHRoZSByZW1vdGUgdGFyZ2V0IFVSSSBpbnRvIHRoZSBSZXF1ZXN0LVVSSSBhbmQgTVVTVCBpbmNsdWRlIGEgUm91dGVcbiAgICAvLyBoZWFkZXIgZmllbGQgY29udGFpbmluZyB0aGUgcm91dGUgc2V0IHZhbHVlcyBpbiBvcmRlciwgaW5jbHVkaW5nIGFsbFxuICAgIC8vIHBhcmFtZXRlcnMuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgcm91dGUgc2V0IGlzIG5vdCBlbXB0eSwgYW5kIGl0cyBmaXJzdCBVUkkgZG9lcyBub3QgY29udGFpbiB0aGVcbiAgICAvLyBsciBwYXJhbWV0ZXIsIHRoZSBVQUMgTVVTVCBwbGFjZSB0aGUgZmlyc3QgVVJJIGZyb20gdGhlIHJvdXRlIHNldFxuICAgIC8vIGludG8gdGhlIFJlcXVlc3QtVVJJLCBzdHJpcHBpbmcgYW55IHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IGFsbG93ZWRcbiAgICAvLyBpbiBhIFJlcXVlc3QtVVJJLiAgVGhlIFVBQyBNVVNUIGFkZCBhIFJvdXRlIGhlYWRlciBmaWVsZCBjb250YWluaW5nXG4gICAgLy8gdGhlIHJlbWFpbmRlciBvZiB0aGUgcm91dGUgc2V0IHZhbHVlcyBpbiBvcmRlciwgaW5jbHVkaW5nIGFsbFxuICAgIC8vIHBhcmFtZXRlcnMuICBUaGUgVUFDIE1VU1QgdGhlbiBwbGFjZSB0aGUgcmVtb3RlIHRhcmdldCBVUkkgaW50byB0aGVcbiAgICAvLyBSb3V0ZSBoZWFkZXIgZmllbGQgYXMgdGhlIGxhc3QgdmFsdWUuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjEuMVxuXG4gICAgLy8gVGhlIGxyIHBhcmFtZXRlciwgd2hlbiBwcmVzZW50LCBpbmRpY2F0ZXMgdGhhdCB0aGUgZWxlbWVudFxuICAgIC8vIHJlc3BvbnNpYmxlIGZvciB0aGlzIHJlc291cmNlIGltcGxlbWVudHMgdGhlIHJvdXRpbmcgbWVjaGFuaXNtc1xuICAgIC8vIHNwZWNpZmllZCBpbiB0aGlzIGRvY3VtZW50LiAgVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSB1c2VkIGluIHRoZVxuICAgIC8vIFVSSXMgcHJveGllcyBwbGFjZSBpbnRvIFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGQgdmFsdWVzLCBhbmRcbiAgICAvLyBtYXkgYXBwZWFyIGluIHRoZSBVUklzIGluIGEgcHJlLWV4aXN0aW5nIHJvdXRlIHNldC5cbiAgICAvL1xuICAgIC8vIFRoaXMgcGFyYW1ldGVyIGlzIHVzZWQgdG8gYWNoaWV2ZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoXG4gICAgLy8gc3lzdGVtcyBpbXBsZW1lbnRpbmcgdGhlIHN0cmljdC1yb3V0aW5nIG1lY2hhbmlzbXMgb2YgUkZDIDI1NDNcbiAgICAvLyBhbmQgdGhlIHJmYzI1NDNiaXMgZHJhZnRzIHVwIHRvIGJpcy0wNS4gIEFuIGVsZW1lbnQgcHJlcGFyaW5nXG4gICAgLy8gdG8gc2VuZCBhIHJlcXVlc3QgYmFzZWQgb24gYSBVUkkgbm90IGNvbnRhaW5pbmcgdGhpcyBwYXJhbWV0ZXJcbiAgICAvLyBjYW4gYXNzdW1lIHRoZSByZWNlaXZpbmcgZWxlbWVudCBpbXBsZW1lbnRzIHN0cmljdC1yb3V0aW5nIGFuZFxuICAgIC8vIHJlZm9ybWF0IHRoZSBtZXNzYWdlIHRvIHByZXNlcnZlIHRoZSBpbmZvcm1hdGlvbiBpbiB0aGVcbiAgICAvLyBSZXF1ZXN0LVVSSS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE5LjEuMVxuXG4gICAgLy8gTk9URTogTm90IGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGggUkZDIDI1NDMgKG5vIHN1cHBvcnQgZm9yIHN0cmljdC1yb3V0aW5nKS5cbiAgICBjb25zdCBydXJpID0gdGhpcy5yZW1vdGVUYXJnZXQ7XG4gICAgY29uc3Qgcm91dGVTZXQgPSB0aGlzLnJvdXRlU2V0O1xuXG4gICAgY29uc3QgZXh0cmFIZWFkZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmV4dHJhSGVhZGVycztcbiAgICBjb25zdCBib2R5ID0gb3B0aW9ucyAmJiBvcHRpb25zLmJvZHk7XG5cbiAgICAvLyBUaGUgcmVsYXRpdmUgb3JkZXIgb2YgaGVhZGVyIGZpZWxkcyB3aXRoIGRpZmZlcmVudCBmaWVsZCBuYW1lcyBpcyBub3RcbiAgICAvLyBzaWduaWZpY2FudC4gIEhvd2V2ZXIsIGl0IGlzIFJFQ09NTUVOREVEIHRoYXQgaGVhZGVyIGZpZWxkcyB3aGljaCBhcmVcbiAgICAvLyBuZWVkZWQgZm9yIHByb3h5IHByb2Nlc3NpbmcgKFZpYSwgUm91dGUsIFJlY29yZC1Sb3V0ZSwgUHJveHktUmVxdWlyZSxcbiAgICAvLyBNYXgtRm9yd2FyZHMsIGFuZCBQcm94eS1BdXRob3JpemF0aW9uLCBmb3IgZXhhbXBsZSkgYXBwZWFyIHRvd2FyZHNcbiAgICAvLyB0aGUgdG9wIG9mIHRoZSBtZXNzYWdlIHRvIGZhY2lsaXRhdGUgcmFwaWQgcGFyc2luZy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTcuMy4xXG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMudXNlckFnZW50Q29yZS5tYWtlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShcbiAgICAgIG1ldGhvZCxcbiAgICAgIHJ1cmksXG4gICAgICBmcm9tVXJpLFxuICAgICAgdG9VcmksXG4gICAgICB7XG4gICAgICAgIGNhbGxJZCxcbiAgICAgICAgY3NlcSxcbiAgICAgICAgZnJvbVRhZyxcbiAgICAgICAgdG9UYWcsXG4gICAgICAgIHJvdXRlU2V0XG4gICAgICB9LFxuICAgICAgZXh0cmFIZWFkZXJzLFxuICAgICAgYm9keVxuICAgICk7XG5cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVtb3RlIHNlcXVlbmNlIG51bWJlciB3YXMgbm90IGVtcHR5LCBidXQgdGhlIHNlcXVlbmNlIG51bWJlclxuICAgKiBvZiB0aGUgcmVxdWVzdCBpcyBsb3dlciB0aGFuIHRoZSByZW1vdGUgc2VxdWVuY2UgbnVtYmVyLCB0aGUgcmVxdWVzdFxuICAgKiBpcyBvdXQgb2Ygb3JkZXIgYW5kIE1VU1QgYmUgcmVqZWN0ZWQgd2l0aCBhIDUwMCAoU2VydmVyIEludGVybmFsXG4gICAqIEVycm9yKSByZXNwb25zZS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBJbmNvbWluZyByZXF1ZXN0IHRvIGd1YXJkLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBwcm9ncmFtIGV4ZWN1dGlvbiBpcyB0byBjb250aW51ZSBpbiB0aGUgYnJhbmNoIGluIHF1ZXN0aW9uLlxuICAgKiAgICAgICAgICBPdGhlcndpc2UgYSA1MDAgU2VydmVyIEludGVybmFsIEVycm9yIHdhcyBzdGF0ZWxlc3Mgc2VudCBhbmQgcmVxdWVzdCBwcm9jZXNzaW5nIG11c3Qgc3RvcC5cbiAgICovXG4gIHByb3RlY3RlZCBzZXF1ZW5jZUd1YXJkKG1lc3NhZ2U6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UpOiBib29sZWFuIHtcbiAgICAvLyBBQ0sgZ3VhcmQuXG4gICAgLy8gQnkgY29udmVudGlvbiwgaGFuZGxpbmcgb2YgdW5leHBlY3RlZCBBQ0tzIGlzIHJlc3BvbnNpYmlsaXR5XG4gICAgLy8gdGhlIHBhcnRpY3VsYXIgZGlhbG9nIGltcGxlbWVudGF0aW9uLiBGb3IgZXhhbXBsZSwgc2VlIFNlc3Npb25EaWFsb2cuXG4gICAgLy8gRnVydGhlcm1vcmUsIHdlIGNhbm5vdCByZXBseSB0byBhbiBcIm91dCBvZiBzZXF1ZW5jZVwiIEFDSy5cbiAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IEMuQUNLKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiBXZSBhcmUgcmVqZWN0aW5nIG9uIFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvXCIgdGhlIHJlbW90ZVxuICAgIC8vIHNlcXVlbmNlIG51bWJlciAoZXhjZXB0aW5nIEFDSyB3aG9zZSBudW1iZXJzIGVxdWFsIHRoZSByZXF1ZXN0c1xuICAgIC8vIGJlaW5nIGFja25vd2xlZGdlZCBvciBjYW5jZWxsZWQpLCB3aGljaCBpcyB0aGUgY29ycmVjdCB0aGluZyB0b1xuICAgIC8vIGRvIGluIG91ciBjYXNlLiBUaGUgb25seSB0aW1lIGEgcmVxdWVzdCB3aXRoIHRoZSBzYW1lIHNlcXVlbmNlIG51bWJlclxuICAgIC8vIHdpbGwgc2hvdyB1cCBoZXJlIGlmIGlzIGEpIGl0IGlzIGEgdmVyeSBsYXRlIHJldHJhbnNtaXNzaW9uIG9mIGFcbiAgICAvLyByZXF1ZXN0IHdlIGFscmVhZHkgaGFuZGxlZCBvciBiKSBpdCBpcyBhIGRpZmZlcmVudCByZXF1ZXN0IHdpdGggdGhlXG4gICAgLy8gc2FtZSBzZXF1ZW5jZSBudW1iZXIgd2hpY2ggd291bGQgYmUgdmlvbGF0aW9uIG9mIHRoZSBzdGFuZGFyZC5cbiAgICAvLyBSZXF1ZXN0IHJldHJhbnNtaXNzaW9ucyBhcmUgYWJzb3JiZWQgYnkgdGhlIHRyYW5zYWN0aW9uIGxheWVyLFxuICAgIC8vIHNvIGFueSByZXF1ZXN0IHdpdGggYSBkdXBsaWNhdGUgc2VxdWVuY2UgbnVtYmVyIGdldHRpbmcgaGVyZVxuICAgIC8vIHdvdWxkIGhhdmUgdG8gYmUgYSByZXRyYW5zbWlzc2lvbiBhZnRlciB0aGUgdHJhbnNhY3Rpb24gdGVybWluYXRlZFxuICAgIC8vIG9yIGEgYnJva2VuIHJlcXVlc3QgKHdpdGggdW5pcXVlIHZpYSBicmFuY2ggdmFsdWUpLlxuXG4gICAgLy8gUmVxdWVzdHMgd2l0aGluIGEgZGlhbG9nIE1VU1QgY29udGFpbiBzdHJpY3RseSBtb25vdG9uaWNhbGx5XG4gICAgLy8gaW5jcmVhc2luZyBhbmQgY29udGlndW91cyBDU2VxIHNlcXVlbmNlIG51bWJlcnMgKGluY3JlYXNpbmctYnktb25lKVxuICAgIC8vIGluIGVhY2ggZGlyZWN0aW9uIChleGNlcHRpbmcgQUNLIGFuZCBDQU5DRUwgb2YgY291cnNlLCB3aG9zZSBudW1iZXJzXG4gICAgLy8gZXF1YWwgdGhlIHJlcXVlc3RzIGJlaW5nIGFja25vd2xlZGdlZCBvciBjYW5jZWxsZWQpLiAgVGhlcmVmb3JlLCBpZlxuICAgIC8vIHRoZSBsb2NhbCBzZXF1ZW5jZSBudW1iZXIgaXMgbm90IGVtcHR5LCB0aGUgdmFsdWUgb2YgdGhlIGxvY2FsXG4gICAgLy8gc2VxdWVuY2UgbnVtYmVyIE1VU1QgYmUgaW5jcmVtZW50ZWQgYnkgb25lLCBhbmQgdGhpcyB2YWx1ZSBNVVNUIGJlXG4gICAgLy8gcGxhY2VkIGludG8gdGhlIENTZXEgaGVhZGVyIGZpZWxkLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4xLjFcbiAgICBpZiAodGhpcy5yZW1vdGVTZXF1ZW5jZU51bWJlciAmJiBtZXNzYWdlLmNzZXEgPD0gdGhpcy5yZW1vdGVTZXF1ZW5jZU51bWJlcikge1xuICAgICAgdGhpcy5jb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNTAwIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSBcIi4vZGlhbG9nXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9kaWFsb2ctc3RhdGVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Nlc3Npb24tZGlhbG9nXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zdWJzY3JpcHRpb24tZGlhbG9nXCI7XG4iLCJpbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQge1xuICBCb2R5LFxuICBDLFxuICBnZXRCb2R5LFxuICBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSxcbiAgaXNCb2R5LFxuICBOYW1lQWRkckhlYWRlcixcbiAgT3V0Z29pbmdBY2tSZXF1ZXN0LFxuICBPdXRnb2luZ0J5ZVJlcXVlc3QsXG4gIE91dGdvaW5nSW5mb1JlcXVlc3QsXG4gIE91dGdvaW5nSW52aXRlUmVxdWVzdCxcbiAgT3V0Z29pbmdJbnZpdGVSZXF1ZXN0RGVsZWdhdGUsXG4gIE91dGdvaW5nTm90aWZ5UmVxdWVzdCxcbiAgT3V0Z29pbmdQcmFja1JlcXVlc3QsXG4gIE91dGdvaW5nUmVmZXJSZXF1ZXN0LFxuICBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSxcbiAgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgUmVxdWVzdE9wdGlvbnNcbn0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQge1xuICBTZXNzaW9uLFxuICBTZXNzaW9uRGVsZWdhdGUsXG4gIFNlc3Npb25TdGF0ZSxcbiAgU2lnbmFsaW5nU3RhdGVcbn0gZnJvbSBcIi4uL3Nlc3Npb25cIjtcbmltcG9ydCB7IFRpbWVycyB9IGZyb20gXCIuLi90aW1lcnNcIjtcbmltcG9ydCB7XG4gIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLFxuICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbixcbiAgVHJhbnNhY3Rpb25TdGF0ZVxufSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRDb3JlIH0gZnJvbSBcIi4uL3VzZXItYWdlbnQtY29yZVwiO1xuaW1wb3J0IHsgQnllVXNlckFnZW50Q2xpZW50IH0gZnJvbSBcIi4uL3VzZXItYWdlbnRzL2J5ZS11c2VyLWFnZW50LWNsaWVudFwiO1xuaW1wb3J0IHsgQnllVXNlckFnZW50U2VydmVyIH0gZnJvbSBcIi4uL3VzZXItYWdlbnRzL2J5ZS11c2VyLWFnZW50LXNlcnZlclwiO1xuaW1wb3J0IHsgSW5mb1VzZXJBZ2VudENsaWVudCB9IGZyb20gXCIuLi91c2VyLWFnZW50cy9pbmZvLXVzZXItYWdlbnQtY2xpZW50XCI7XG5pbXBvcnQgeyBJbmZvVXNlckFnZW50U2VydmVyIH0gZnJvbSBcIi4uL3VzZXItYWdlbnRzL2luZm8tdXNlci1hZ2VudC1zZXJ2ZXJcIjtcbmltcG9ydCB7IE5vdGlmeVVzZXJBZ2VudENsaWVudCB9IGZyb20gXCIuLi91c2VyLWFnZW50cy9ub3RpZnktdXNlci1hZ2VudC1jbGllbnRcIjtcbmltcG9ydCB7IE5vdGlmeVVzZXJBZ2VudFNlcnZlciB9IGZyb20gXCIuLi91c2VyLWFnZW50cy9ub3RpZnktdXNlci1hZ2VudC1zZXJ2ZXJcIjtcbmltcG9ydCB7IFByYWNrVXNlckFnZW50Q2xpZW50IH0gZnJvbSBcIi4uL3VzZXItYWdlbnRzL3ByYWNrLXVzZXItYWdlbnQtY2xpZW50XCI7XG5pbXBvcnQgeyBQcmFja1VzZXJBZ2VudFNlcnZlciB9IGZyb20gXCIuLi91c2VyLWFnZW50cy9wcmFjay11c2VyLWFnZW50LXNlcnZlclwiO1xuaW1wb3J0IHsgUmVJbnZpdGVVc2VyQWdlbnRDbGllbnQgfSBmcm9tIFwiLi4vdXNlci1hZ2VudHMvcmUtaW52aXRlLXVzZXItYWdlbnQtY2xpZW50XCI7XG5pbXBvcnQgeyBSZUludml0ZVVzZXJBZ2VudFNlcnZlciB9IGZyb20gXCIuLi91c2VyLWFnZW50cy9yZS1pbnZpdGUtdXNlci1hZ2VudC1zZXJ2ZXJcIjtcbmltcG9ydCB7IFJlZmVyVXNlckFnZW50Q2xpZW50IH0gZnJvbSBcIi4uL3VzZXItYWdlbnRzL3JlZmVyLXVzZXItYWdlbnQtY2xpZW50XCI7XG5pbXBvcnQgeyBSZWZlclVzZXJBZ2VudFNlcnZlciB9IGZyb20gXCIuLi91c2VyLWFnZW50cy9yZWZlci11c2VyLWFnZW50LXNlcnZlclwiO1xuaW1wb3J0IHsgRGlhbG9nIH0gZnJvbSBcIi4vZGlhbG9nXCI7XG5pbXBvcnQgeyBEaWFsb2dTdGF0ZSB9IGZyb20gXCIuL2RpYWxvZy1zdGF0ZVwiO1xuXG4vKipcbiAqIFNlc3Npb24gRGlhbG9nLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgU2Vzc2lvbkRpYWxvZyBleHRlbmRzIERpYWxvZyBpbXBsZW1lbnRzIFNlc3Npb24ge1xuICBwdWJsaWMgZGVsZWdhdGU6IFNlc3Npb25EZWxlZ2F0ZSB8IHVuZGVmaW5lZDtcblxuICBwdWJsaWMgcmVpbnZpdGVVc2VyQWdlbnRDbGllbnQ6IFJlSW52aXRlVXNlckFnZW50Q2xpZW50IHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgcmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXI6IFJlSW52aXRlVXNlckFnZW50U2VydmVyIHwgdW5kZWZpbmVkO1xuXG4gIC8qKiBUaGUgc3RhdGUgb2YgdGhlIG9mZmVyL2Fuc3dlciBleGNoYW5nZS4gKi9cbiAgcHJpdmF0ZSBfc2lnbmFsaW5nU3RhdGU6IFNpZ25hbGluZ1N0YXRlID0gU2lnbmFsaW5nU3RhdGUuSW5pdGlhbDtcbiAgLyoqIFRoZSBjdXJyZW50IG9mZmVyLiBVbmRlZmluZWQgdW5sZXNzIHNpZ25hbGluZyBzdGF0ZSBIYXZlTG9jYWxPZmZlciwgSGF2ZVJlbW90ZU9mZmVyLCBvciBTdGFibGUuICovXG4gIHByaXZhdGUgX29mZmVyOiBCb2R5IHwgdW5kZWZpbmVkO1xuICAvKiogVGhlIGN1cnJlbnQgYW5zd2VyLiBVbmRlZmluZWQgdW5sZXNzIHNpZ25hbGluZyBzdGF0ZSBTdGFibGUuICovXG4gIHByaXZhdGUgX2Fuc3dlcjogQm9keSB8IHVuZGVmaW5lZDtcbiAgLyoqIFRoZSByb2xsYmFjayBvZmZlci4gVW5kZWZpbmVkIHVubGVzcyBzaWduYWxpbmcgc3RhdGUgSGF2ZUxvY2FsT2ZmZXIgb3IgSGF2ZVJlbW90ZU9mZmVyLiAqL1xuICBwcml2YXRlIF9yb2xsYmFja09mZmVyOiBCb2R5IHwgdW5kZWZpbmVkO1xuICAvKiogVGhlIHJvbGxiYWNrIGFuc3dlci4gVW5kZWZpbmVkIHVubGVzcyBzaWduYWxpbmcgc3RhdGUgSGF2ZUxvY2FsT2ZmZXIgb3IgSGF2ZVJlbW90ZU9mZmVyLiAqL1xuICBwcml2YXRlIF9yb2xsYmFja0Fuc3dlcjogQm9keSB8IHVuZGVmaW5lZDtcblxuICAvKiogVHJ1ZSBpZiB3YWl0aW5nIGZvciBhbiBBQ0sgdG8gdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24gMnh4IChVQVMgb25seSkuICovXG4gIHByaXZhdGUgYWNrV2FpdCA9IGZhbHNlO1xuICAvKiogUmV0cmFuc21pc3Npb24gdGltZXIgZm9yIDJ4eCByZXNwb25zZSB3aGljaCBjb25maXJtZWQgdGhlIGRpYWxvZy4gKi9cbiAgcHJpdmF0ZSBpbnZpdGUyeHhUaW1lcjogYW55O1xuICAvKiogVGhlIHJzZXEgb2YgdGhlIGxhc3QgcmVsaWFibGUgcmVzcG9uc2UuICovXG4gIHByaXZhdGUgcnNlcTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgbG9nZ2VyOiBMb2dnZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpbml0aWFsVHJhbnNhY3Rpb246IEludml0ZUNsaWVudFRyYW5zYWN0aW9uIHwgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sXG4gICAgY29yZTogVXNlckFnZW50Q29yZSxcbiAgICBzdGF0ZTogRGlhbG9nU3RhdGUsXG4gICAgZGVsZWdhdGU/OiBTZXNzaW9uRGVsZWdhdGVcbiAgKSB7XG4gICAgc3VwZXIoY29yZSwgc3RhdGUpO1xuICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICBpZiAoaW5pdGlhbFRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgIC8vIElmIHdlJ3JlIGNyZWF0ZWQgYnkgYW4gaW52aXRlIHNlcnZlciB0cmFuc2FjdGlvbiwgd2UncmVcbiAgICAgIC8vIGdvaW5nIHRvIGJlIHdhaXRpbmcgZm9yIGFuIEFDSyBpZiBhcmUgdG8gYmUgY29uZmlybWVkLlxuICAgICAgdGhpcy5hY2tXYWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSWYgd2UncmUgY29uZmlybWVkIHVwb24gY3JlYXRpb24gc3RhcnQgdGhlIHJldHJhbnNtaXR0aW5nIHdoYXRldmVyXG4gICAgLy8gdGhlIDJ4eCBmaW5hbCByZXNwb25zZSB3YXMgdGhhdCBjb25maXJtZWQgdXMgaW50byBleGlzdGVuY2UuXG4gICAgaWYgKCF0aGlzLmVhcmx5KSB7XG4gICAgICB0aGlzLnN0YXJ0Mnh4UmV0cmFuc21pc3Npb25UaW1lcigpO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihpbml0aWFsVHJhbnNhY3Rpb24ucmVxdWVzdCk7XG4gICAgdGhpcy5sb2dnZXIgPSBjb3JlLmxvZ2dlckZhY3RvcnkuZ2V0TG9nZ2VyKFwic2lwLmludml0ZS1kaWFsb2dcIik7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBJTlZJVEUgZGlhbG9nICR7dGhpcy5pZH0gY29uc3RydWN0ZWRgKTtcbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IFNpZ25hbGluZ1N0YXRlLkNsb3NlZDtcbiAgICB0aGlzLl9vZmZlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuaW52aXRlMnh4VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmludml0ZTJ4eFRpbWVyKTtcbiAgICAgIHRoaXMuaW52aXRlMnh4VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gVGhlIFVBUyBNVVNUIHN0aWxsIHJlc3BvbmQgdG8gYW55IHBlbmRpbmcgcmVxdWVzdHMgcmVjZWl2ZWQgZm9yIHRoYXRcbiAgICAvLyBkaWFsb2cuICBJdCBpcyBSRUNPTU1FTkRFRCB0aGF0IGEgNDg3IChSZXF1ZXN0IFRlcm1pbmF0ZWQpIHJlc3BvbnNlXG4gICAgLy8gYmUgZ2VuZXJhdGVkIHRvIHRob3NlIHBlbmRpbmcgcmVxdWVzdHMuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNS4xLjJcblxuICAgIC8vIFRPRE86XG4gICAgLy8gdGhpcy51c2VyQWdlbnRTZXJ2ZXJzLmZvckVhY2goKHVhcykgPT4gdWFzLnJlcGx5KDQ4NykpO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKGBJTlZJVEUgZGlhbG9nICR7dGhpcy5pZH0gZGVzdHJveWVkYCk7XG4gIH1cblxuICAvLyBGSVhNRTogTmVlZCByZWFsIHN0YXRlIG1hY2hpbmVcbiAgZ2V0IHNlc3Npb25TdGF0ZSgpOiBTZXNzaW9uU3RhdGUge1xuICAgIGlmICh0aGlzLmVhcmx5KSB7XG4gICAgICByZXR1cm4gU2Vzc2lvblN0YXRlLkVhcmx5O1xuICAgIH0gZWxzZSBpZiAodGhpcy5hY2tXYWl0KSB7XG4gICAgICByZXR1cm4gU2Vzc2lvblN0YXRlLkFja1dhaXQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zaWduYWxpbmdTdGF0ZSA9PT0gU2lnbmFsaW5nU3RhdGUuQ2xvc2VkKSB7XG4gICAgICByZXR1cm4gU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBTZXNzaW9uU3RhdGUuQ29uZmlybWVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUaGUgc3RhdGUgb2YgdGhlIG9mZmVyL2Fuc3dlciBleGNoYW5nZS4gKi9cbiAgZ2V0IHNpZ25hbGluZ1N0YXRlKCk6IFNpZ25hbGluZ1N0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmFsaW5nU3RhdGU7XG4gIH1cblxuICAvKiogVGhlIGN1cnJlbnQgb2ZmZXIuIFVuZGVmaW5lZCB1bmxlc3Mgc2lnbmFsaW5nIHN0YXRlIEhhdmVMb2NhbE9mZmVyLCBIYXZlUmVtb3RlT2ZmZXIsIG9mIFN0YWJsZS4gKi9cbiAgZ2V0IG9mZmVyKCk6IEJvZHkgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9vZmZlcjtcbiAgfVxuXG4gIC8qKiBUaGUgY3VycmVudCBhbnN3ZXIuIFVuZGVmaW5lZCB1bmxlc3Mgc2lnbmFsaW5nIHN0YXRlIFN0YWJsZS4gKi9cbiAgZ2V0IGFuc3dlcigpOiBCb2R5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fYW5zd2VyO1xuICB9XG5cbiAgLyoqIENvbmZpcm0gdGhlIGRpYWxvZy4gT25seSBtYXR0ZXJzIGlmIGRpYWxvZyBpcyBjdXJyZW50bHkgZWFybHkuICovXG4gIHB1YmxpYyBjb25maXJtKCk6IHZvaWQge1xuICAgIC8vIFdoZW4gd2UncmUgY29uZmlybWVkIHN0YXJ0IHRoZSByZXRyYW5zbWl0dGluZyB3aGF0ZXZlclxuICAgIC8vIHRoZSAyeHggZmluYWwgcmVzcG9uc2UgdGhhdCBtYXkgaGF2ZSBjb25maXJtZWQgdXMuXG4gICAgaWYgKHRoaXMuZWFybHkpIHtcbiAgICAgIHRoaXMuc3RhcnQyeHhSZXRyYW5zbWlzc2lvblRpbWVyKCk7XG4gICAgfVxuICAgIHN1cGVyLmNvbmZpcm0oKTtcbiAgfVxuXG4gIC8qKiBSZS1jb25maXJtIHRoZSBkaWFsb2cuIE9ubHkgbWF0dGVycyBpZiBoYW5kbGluZyByZS1JTlZJVEUgcmVxdWVzdC4gKi9cbiAgcHVibGljIHJlQ29uZmlybSgpOiB2b2lkIHtcbiAgICAvLyBXaGVuIHdlJ3JlIGNvbmZpcm1lZCBzdGFydCB0aGUgcmV0cmFuc21pdHRpbmcgd2hhdGV2ZXJcbiAgICAvLyB0aGUgMnh4IGZpbmFsIHJlc3BvbnNlIHRoYXQgbWF5IGhhdmUgY29uZmlybWVkIHVzLlxuICAgIGlmICh0aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyKSB7XG4gICAgICB0aGlzLnN0YXJ0UmVJbnZpdGUyeHhSZXRyYW5zbWlzc2lvblRpbWVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBVQUMgY29yZSBNVVNUIGdlbmVyYXRlIGFuIEFDSyByZXF1ZXN0IGZvciBlYWNoIDJ4eCByZWNlaXZlZCBmcm9tXG4gICAqIHRoZSB0cmFuc2FjdGlvbiBsYXllci4gIFRoZSBoZWFkZXIgZmllbGRzIG9mIHRoZSBBQ0sgYXJlIGNvbnN0cnVjdGVkXG4gICAqIGluIHRoZSBzYW1lIHdheSBhcyBmb3IgYW55IHJlcXVlc3Qgc2VudCB3aXRoaW4gYSBkaWFsb2cgKHNlZSBTZWN0aW9uXG4gICAqIDEyKSB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIENTZXEgYW5kIHRoZSBoZWFkZXIgZmllbGRzIHJlbGF0ZWQgdG9cbiAgICogYXV0aGVudGljYXRpb24uICBUaGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBDU2VxIGhlYWRlciBmaWVsZCBNVVNUIGJlXG4gICAqIHRoZSBzYW1lIGFzIHRoZSBJTlZJVEUgYmVpbmcgYWNrbm93bGVkZ2VkLCBidXQgdGhlIENTZXEgbWV0aG9kIE1VU1RcbiAgICogYmUgQUNLLiAgVGhlIEFDSyBNVVNUIGNvbnRhaW4gdGhlIHNhbWUgY3JlZGVudGlhbHMgYXMgdGhlIElOVklURS4gIElmXG4gICAqIHRoZSAyeHggY29udGFpbnMgYW4gb2ZmZXIgKGJhc2VkIG9uIHRoZSBydWxlcyBhYm92ZSksIHRoZSBBQ0sgTVVTVFxuICAgKiBjYXJyeSBhbiBhbnN3ZXIgaW4gaXRzIGJvZHkuICBJZiB0aGUgb2ZmZXIgaW4gdGhlIDJ4eCByZXNwb25zZSBpcyBub3RcbiAgICogYWNjZXB0YWJsZSwgdGhlIFVBQyBjb3JlIE1VU1QgZ2VuZXJhdGUgYSB2YWxpZCBhbnN3ZXIgaW4gdGhlIEFDSyBhbmRcbiAgICogdGhlbiBzZW5kIGEgQllFIGltbWVkaWF0ZWx5LlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi40XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQUNLIG9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgcHVibGljIGFjayhvcHRpb25zOiBSZXF1ZXN0T3B0aW9ucyA9IHt9KTogT3V0Z29pbmdBY2tSZXF1ZXN0IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYElOVklURSBkaWFsb2cgJHt0aGlzLmlkfSBzZW5kaW5nIEFDSyByZXF1ZXN0YCk7XG4gICAgbGV0IHRyYW5zYWN0aW9uOiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbjtcbiAgICBpZiAodGhpcy5yZWludml0ZVVzZXJBZ2VudENsaWVudCkge1xuICAgICAgLy8gV2UncmUgc2VuZGluZyBBQ0sgZm9yIGEgcmUtSU5WSVRFXG4gICAgICBpZiAoISh0aGlzLnJlaW52aXRlVXNlckFnZW50Q2xpZW50LnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5cIik7XG4gICAgICB9XG4gICAgICB0cmFuc2FjdGlvbiA9IHRoaXMucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQudHJhbnNhY3Rpb247XG4gICAgICB0aGlzLnJlaW52aXRlVXNlckFnZW50Q2xpZW50ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSdyZSBzZW5kaW5nIEFDSyBmb3IgdGhlIGluaXRpYWwgSU5WSVRFXG4gICAgICBpZiAoISh0aGlzLmluaXRpYWxUcmFuc2FjdGlvbiBpbnN0YW5jZW9mIEludml0ZUNsaWVudFRyYW5zYWN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbml0aWFsIHRyYW5zYWN0aW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5cIik7XG4gICAgICB9XG4gICAgICB0cmFuc2FjdGlvbiA9IHRoaXMuaW5pdGlhbFRyYW5zYWN0aW9uO1xuICAgIH1cbiAgICAob3B0aW9ucyBhcyBhbnkpLmNzZXEgPSB0cmFuc2FjdGlvbi5yZXF1ZXN0LmNzZXE7IC8vIEFDSyBjc2VxIGlzIElOVklURSBjc2VxXG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuY3JlYXRlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShDLkFDSywgb3B0aW9ucyk7XG4gICAgdHJhbnNhY3Rpb24uYWNrUmVzcG9uc2UobWVzc2FnZSk7IC8vIFNlZSBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbiBmb3IgZGV0YWlscy5cbiAgICB0aGlzLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihtZXNzYWdlKTtcbiAgICByZXR1cm4geyBtZXNzYWdlIH07XG4gIH1cblxuICAvKipcbiAgICogVGVybWluYXRpbmcgYSBTZXNzaW9uXG4gICAqXG4gICAqIFRoaXMgc2VjdGlvbiBkZXNjcmliZXMgdGhlIHByb2NlZHVyZXMgZm9yIHRlcm1pbmF0aW5nIGEgc2Vzc2lvblxuICAgKiBlc3RhYmxpc2hlZCBieSBTSVAuICBUaGUgc3RhdGUgb2YgdGhlIHNlc3Npb24gYW5kIHRoZSBzdGF0ZSBvZiB0aGVcbiAgICogZGlhbG9nIGFyZSB2ZXJ5IGNsb3NlbHkgcmVsYXRlZC4gIFdoZW4gYSBzZXNzaW9uIGlzIGluaXRpYXRlZCB3aXRoIGFuXG4gICAqIElOVklURSwgZWFjaCAxeHggb3IgMnh4IHJlc3BvbnNlIGZyb20gYSBkaXN0aW5jdCBVQVMgY3JlYXRlcyBhXG4gICAqIGRpYWxvZywgYW5kIGlmIHRoYXQgcmVzcG9uc2UgY29tcGxldGVzIHRoZSBvZmZlci9hbnN3ZXIgZXhjaGFuZ2UsIGl0XG4gICAqIGFsc28gY3JlYXRlcyBhIHNlc3Npb24uICBBcyBhIHJlc3VsdCwgZWFjaCBzZXNzaW9uIGlzIFwiYXNzb2NpYXRlZFwiXG4gICAqIHdpdGggYSBzaW5nbGUgZGlhbG9nIC0gdGhlIG9uZSB3aGljaCByZXN1bHRlZCBpbiBpdHMgY3JlYXRpb24uICBJZiBhblxuICAgKiBpbml0aWFsIElOVklURSBnZW5lcmF0ZXMgYSBub24tMnh4IGZpbmFsIHJlc3BvbnNlLCB0aGF0IHRlcm1pbmF0ZXNcbiAgICogYWxsIHNlc3Npb25zIChpZiBhbnkpIGFuZCBhbGwgZGlhbG9ncyAoaWYgYW55KSB0aGF0IHdlcmUgY3JlYXRlZFxuICAgKiB0aHJvdWdoIHJlc3BvbnNlcyB0byB0aGUgcmVxdWVzdC4gIEJ5IHZpcnR1ZSBvZiBjb21wbGV0aW5nIHRoZVxuICAgKiB0cmFuc2FjdGlvbiwgYSBub24tMnh4IGZpbmFsIHJlc3BvbnNlIGFsc28gcHJldmVudHMgZnVydGhlciBzZXNzaW9uc1xuICAgKiBmcm9tIGJlaW5nIGNyZWF0ZWQgYXMgYSByZXN1bHQgb2YgdGhlIElOVklURS4gIFRoZSBCWUUgcmVxdWVzdCBpc1xuICAgKiB1c2VkIHRvIHRlcm1pbmF0ZSBhIHNwZWNpZmljIHNlc3Npb24gb3IgYXR0ZW1wdGVkIHNlc3Npb24uICBJbiB0aGlzXG4gICAqIGNhc2UsIHRoZSBzcGVjaWZpYyBzZXNzaW9uIGlzIHRoZSBvbmUgd2l0aCB0aGUgcGVlciBVQSBvbiB0aGUgb3RoZXJcbiAgICogc2lkZSBvZiB0aGUgZGlhbG9nLiAgV2hlbiBhIEJZRSBpcyByZWNlaXZlZCBvbiBhIGRpYWxvZywgYW55IHNlc3Npb25cbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoYXQgZGlhbG9nIFNIT1VMRCB0ZXJtaW5hdGUuICBBIFVBIE1VU1QgTk9UIHNlbmQgYVxuICAgKiBCWUUgb3V0c2lkZSBvZiBhIGRpYWxvZy4gIFRoZSBjYWxsZXIncyBVQSBNQVkgc2VuZCBhIEJZRSBmb3IgZWl0aGVyXG4gICAqIGNvbmZpcm1lZCBvciBlYXJseSBkaWFsb2dzLCBhbmQgdGhlIGNhbGxlZSdzIFVBIE1BWSBzZW5kIGEgQllFIG9uXG4gICAqIGNvbmZpcm1lZCBkaWFsb2dzLCBidXQgTVVTVCBOT1Qgc2VuZCBhIEJZRSBvbiBlYXJseSBkaWFsb2dzLlxuICAgKlxuICAgKiBIb3dldmVyLCB0aGUgY2FsbGVlJ3MgVUEgTVVTVCBOT1Qgc2VuZCBhIEJZRSBvbiBhIGNvbmZpcm1lZCBkaWFsb2dcbiAgICogdW50aWwgaXQgaGFzIHJlY2VpdmVkIGFuIEFDSyBmb3IgaXRzIDJ4eCByZXNwb25zZSBvciB1bnRpbCB0aGUgc2VydmVyXG4gICAqIHRyYW5zYWN0aW9uIHRpbWVzIG91dC4gIElmIG5vIFNJUCBleHRlbnNpb25zIGhhdmUgZGVmaW5lZCBvdGhlclxuICAgKiBhcHBsaWNhdGlvbiBsYXllciBzdGF0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBkaWFsb2csIHRoZSBCWUUgYWxzb1xuICAgKiB0ZXJtaW5hdGVzIHRoZSBkaWFsb2cuXG4gICAqXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTVcbiAgICogRklYTUU6IE1ha2UgdGhlc2UgcHJvcGVyIEV4Y2VwdGlvbnMuLi5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBCWUUgb3B0aW9ucyBidWNrZXQuXG4gICAqIEByZXR1cm5zXG4gICAqIFRocm93cyBgRXJyb3JgIGlmIGNhbGxlZSdzIFVBIGF0dGVtcHRzIGEgQllFIG9uIGFuIGVhcmx5IGRpYWxvZy5cbiAgICogVGhyb3dzIGBFcnJvcmAgaWYgY2FsbGVlJ3MgVUEgYXR0ZW1wdHMgYSBCWUUgb24gYSBjb25maXJtZWQgZGlhbG9nXG4gICAqICAgICAgICAgICAgICAgIHdoaWxlIGl0J3Mgd2FpdGluZyBvbiB0aGUgQUNLIGZvciBpdHMgMnh4IHJlc3BvbnNlLlxuICAgKi9cbiAgcHVibGljIGJ5ZShkZWxlZ2F0ZT86IE91dGdvaW5nUmVxdWVzdERlbGVnYXRlLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpOiBPdXRnb2luZ0J5ZVJlcXVlc3Qge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgSU5WSVRFIGRpYWxvZyAke3RoaXMuaWR9IHNlbmRpbmcgQllFIHJlcXVlc3RgKTtcblxuICAgIC8vIFRoZSBjYWxsZXIncyBVQSBNQVkgc2VuZCBhIEJZRSBmb3IgZWl0aGVyXG4gICAgLy8gY29uZmlybWVkIG9yIGVhcmx5IGRpYWxvZ3MsIGFuZCB0aGUgY2FsbGVlJ3MgVUEgTUFZIHNlbmQgYSBCWUUgb25cbiAgICAvLyBjb25maXJtZWQgZGlhbG9ncywgYnV0IE1VU1QgTk9UIHNlbmQgYSBCWUUgb24gZWFybHkgZGlhbG9ncy5cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIHRoZSBjYWxsZWUncyBVQSBNVVNUIE5PVCBzZW5kIGEgQllFIG9uIGEgY29uZmlybWVkIGRpYWxvZ1xuICAgIC8vIHVudGlsIGl0IGhhcyByZWNlaXZlZCBhbiBBQ0sgZm9yIGl0cyAyeHggcmVzcG9uc2Ugb3IgdW50aWwgdGhlIHNlcnZlclxuICAgIC8vIHRyYW5zYWN0aW9uIHRpbWVzIG91dC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE1XG4gICAgaWYgKHRoaXMuaW5pdGlhbFRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLmVhcmx5KSB7XG4gICAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVBUyBNVVNUIE5PVCBzZW5kIGEgQllFIG9uIGVhcmx5IGRpYWxvZ3MuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYWNrV2FpdCAmJiB0aGlzLmluaXRpYWxUcmFuc2FjdGlvbi5zdGF0ZSAhPT0gVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlVBUyBNVVNUIE5PVCBzZW5kIGEgQllFIG9uIGEgY29uZmlybWVkIGRpYWxvZyBcIiArXG4gICAgICAgICAgXCJ1bnRpbCBpdCBoYXMgcmVjZWl2ZWQgYW4gQUNLIGZvciBpdHMgMnh4IHJlc3BvbnNlIFwiICtcbiAgICAgICAgICBcIm9yIHVudGlsIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gdGltZXMgb3V0LlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQSBCWUUgcmVxdWVzdCBpcyBjb25zdHJ1Y3RlZCBhcyB3b3VsZCBhbnkgb3RoZXIgcmVxdWVzdCB3aXRoaW4gYVxuICAgIC8vIGRpYWxvZywgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMTIuXG4gICAgLy9cbiAgICAvLyBPbmNlIHRoZSBCWUUgaXMgY29uc3RydWN0ZWQsIHRoZSBVQUMgY29yZSBjcmVhdGVzIGEgbmV3IG5vbi1JTlZJVEVcbiAgICAvLyBjbGllbnQgdHJhbnNhY3Rpb24sIGFuZCBwYXNzZXMgaXQgdGhlIEJZRSByZXF1ZXN0LiAgVGhlIFVBQyBNVVNUXG4gICAgLy8gY29uc2lkZXIgdGhlIHNlc3Npb24gdGVybWluYXRlZCAoYW5kIHRoZXJlZm9yZSBzdG9wIHNlbmRpbmcgb3JcbiAgICAvLyBsaXN0ZW5pbmcgZm9yIG1lZGlhKSBhcyBzb29uIGFzIHRoZSBCWUUgcmVxdWVzdCBpcyBwYXNzZWQgdG8gdGhlXG4gICAgLy8gY2xpZW50IHRyYW5zYWN0aW9uLiAgSWYgdGhlIHJlc3BvbnNlIGZvciB0aGUgQllFIGlzIGEgNDgxXG4gICAgLy8gKENhbGwvVHJhbnNhY3Rpb24gRG9lcyBOb3QgRXhpc3QpIG9yIGEgNDA4IChSZXF1ZXN0IFRpbWVvdXQpIG9yIG5vXG4gICAgLy8gcmVzcG9uc2UgYXQgYWxsIGlzIHJlY2VpdmVkIGZvciB0aGUgQllFICh0aGF0IGlzLCBhIHRpbWVvdXQgaXNcbiAgICAvLyByZXR1cm5lZCBieSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uKSwgdGhlIFVBQyBNVVNUIGNvbnNpZGVyIHRoZVxuICAgIC8vIHNlc3Npb24gYW5kIHRoZSBkaWFsb2cgdGVybWluYXRlZC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE1LjEuMVxuICAgIHJldHVybiBuZXcgQnllVXNlckFnZW50Q2xpZW50KHRoaXMsIGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBJTkZPIHJlcXVlc3QgY2FuIGJlIGFzc29jaWF0ZWQgd2l0aCBhbiBJbmZvIFBhY2thZ2UgKHNlZVxuICAgKiBTZWN0aW9uIDUpLCBvciBhc3NvY2lhdGVkIHdpdGggYSBsZWdhY3kgSU5GTyB1c2FnZSAoc2VlIFNlY3Rpb24gMikuXG4gICAqXG4gICAqIFRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIElORk8gcmVxdWVzdCBpcyB0aGUgc2FtZSBhcyBhbnkgb3RoZXJcbiAgICogbm9uLXRhcmdldCByZWZyZXNoIHJlcXVlc3Qgd2l0aGluIGFuIGV4aXN0aW5nIGludml0ZSBkaWFsb2cgdXNhZ2UgYXNcbiAgICogZGVzY3JpYmVkIGluIFNlY3Rpb24gMTIuMiBvZiBSRkMgMzI2MS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwODYjc2VjdGlvbi00LjIuMVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgcHVibGljIGluZm8oZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogT3V0Z29pbmdJbmZvUmVxdWVzdCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBJTlZJVEUgZGlhbG9nICR7dGhpcy5pZH0gc2VuZGluZyBJTkZPIHJlcXVlc3RgKTtcbiAgICBpZiAodGhpcy5lYXJseSkge1xuICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIHRocm93IGEgcHJvcGVyIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyBub3QgY29uZmlybWVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbmZvVXNlckFnZW50Q2xpZW50KHRoaXMsIGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnlpbmcgYW4gRXhpc3RpbmcgU2Vzc2lvblxuICAgKlxuICAgKiBBIHN1Y2Nlc3NmdWwgSU5WSVRFIHJlcXVlc3QgKHNlZSBTZWN0aW9uIDEzKSBlc3RhYmxpc2hlcyBib3RoIGFcbiAgICogZGlhbG9nIGJldHdlZW4gdHdvIHVzZXIgYWdlbnRzIGFuZCBhIHNlc3Npb24gdXNpbmcgdGhlIG9mZmVyLWFuc3dlclxuICAgKiBtb2RlbC4gIFNlY3Rpb24gMTIgZXhwbGFpbnMgaG93IHRvIG1vZGlmeSBhbiBleGlzdGluZyBkaWFsb2cgdXNpbmcgYVxuICAgKiB0YXJnZXQgcmVmcmVzaCByZXF1ZXN0IChmb3IgZXhhbXBsZSwgY2hhbmdpbmcgdGhlIHJlbW90ZSB0YXJnZXQgVVJJXG4gICAqIG9mIHRoZSBkaWFsb2cpLiAgVGhpcyBzZWN0aW9uIGRlc2NyaWJlcyBob3cgdG8gbW9kaWZ5IHRoZSBhY3R1YWxcbiAgICogc2Vzc2lvbi4gIFRoaXMgbW9kaWZpY2F0aW9uIGNhbiBpbnZvbHZlIGNoYW5naW5nIGFkZHJlc3NlcyBvciBwb3J0cyxcbiAgICogYWRkaW5nIGEgbWVkaWEgc3RyZWFtLCBkZWxldGluZyBhIG1lZGlhIHN0cmVhbSwgYW5kIHNvIG9uLiAgVGhpcyBpc1xuICAgKiBhY2NvbXBsaXNoZWQgYnkgc2VuZGluZyBhIG5ldyBJTlZJVEUgcmVxdWVzdCB3aXRoaW4gdGhlIHNhbWUgZGlhbG9nXG4gICAqIHRoYXQgZXN0YWJsaXNoZWQgdGhlIHNlc3Npb24uICBBbiBJTlZJVEUgcmVxdWVzdCBzZW50IHdpdGhpbiBhblxuICAgKiBleGlzdGluZyBkaWFsb2cgaXMga25vd24gYXMgYSByZS1JTlZJVEUuXG4gICAqXG4gICAqICAgIE5vdGUgdGhhdCBhIHNpbmdsZSByZS1JTlZJVEUgY2FuIG1vZGlmeSB0aGUgZGlhbG9nIGFuZCB0aGVcbiAgICogICAgcGFyYW1ldGVycyBvZiB0aGUgc2Vzc2lvbiBhdCB0aGUgc2FtZSB0aW1lLlxuICAgKlxuICAgKiBFaXRoZXIgdGhlIGNhbGxlciBvciBjYWxsZWUgY2FuIG1vZGlmeSBhbiBleGlzdGluZyBzZXNzaW9uLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE0XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXRcbiAgICovXG4gIHB1YmxpYyBpbnZpdGUoZGVsZWdhdGU/OiBPdXRnb2luZ0ludml0ZVJlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogT3V0Z29pbmdJbnZpdGVSZXF1ZXN0IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYElOVklURSBkaWFsb2cgJHt0aGlzLmlkfSBzZW5kaW5nIElOVklURSByZXF1ZXN0YCk7XG4gICAgaWYgKHRoaXMuZWFybHkpIHtcbiAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgbm90IGNvbmZpcm1lZC5cIik7XG4gICAgfVxuXG4gICAgLy8gTm90ZSB0aGF0IGEgVUFDIE1VU1QgTk9UIGluaXRpYXRlIGEgbmV3IElOVklURSB0cmFuc2FjdGlvbiB3aXRoaW4gYVxuICAgIC8vIGRpYWxvZyB3aGlsZSBhbm90aGVyIElOVklURSB0cmFuc2FjdGlvbiBpcyBpbiBwcm9ncmVzcyBpbiBlaXRoZXJcbiAgICAvLyBkaXJlY3Rpb24uXG4gICAgLy9cbiAgICAvLyAgICAxLiBJZiB0aGVyZSBpcyBhbiBvbmdvaW5nIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24sIHRoZSBUVSBNVVNUXG4gICAgLy8gICAgICAgd2FpdCB1bnRpbCB0aGUgdHJhbnNhY3Rpb24gcmVhY2hlcyB0aGUgY29tcGxldGVkIG9yIHRlcm1pbmF0ZWRcbiAgICAvLyAgICAgICBzdGF0ZSBiZWZvcmUgaW5pdGlhdGluZyB0aGUgbmV3IElOVklURS5cbiAgICAvL1xuICAgIC8vICAgIDIuIElmIHRoZXJlIGlzIGFuIG9uZ29pbmcgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiwgdGhlIFRVIE1VU1RcbiAgICAvLyAgICAgICB3YWl0IHVudGlsIHRoZSB0cmFuc2FjdGlvbiByZWFjaGVzIHRoZSBjb25maXJtZWQgb3IgdGVybWluYXRlZFxuICAgIC8vICAgICAgIHN0YXRlIGJlZm9yZSBpbml0aWF0aW5nIHRoZSBuZXcgSU5WSVRFLlxuICAgIC8vXG4gICAgLy8gSG93ZXZlciwgYSBVQSBNQVkgaW5pdGlhdGUgYSByZWd1bGFyIHRyYW5zYWN0aW9uIHdoaWxlIGFuIElOVklURVxuICAgIC8vIHRyYW5zYWN0aW9uIGlzIGluIHByb2dyZXNzLiAgQSBVQSBNQVkgYWxzbyBpbml0aWF0ZSBhbiBJTlZJVEVcbiAgICAvLyB0cmFuc2FjdGlvbiB3aGlsZSBhIHJlZ3VsYXIgdHJhbnNhY3Rpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNC4xXG4gICAgaWYgKHRoaXMucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQpIHtcbiAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBhbiBvbmdvaW5nIHJlLUlOVklURSBjbGllbnQgdHJhbnNhY3Rpb24uXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlcikge1xuICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIHRocm93IGEgcHJvcGVyIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIGFuIG9uZ29pbmcgcmUtSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbi5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVJbnZpdGVVc2VyQWdlbnRDbGllbnQodGhpcywgZGVsZWdhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBOT1RJRlkgbWVjaGFuaXNtIGRlZmluZWQgaW4gWzJdIE1VU1QgYmUgdXNlZCB0byBpbmZvcm0gdGhlIGFnZW50XG4gICAqIHNlbmRpbmcgdGhlIFJFRkVSIG9mIHRoZSBzdGF0dXMgb2YgdGhlIHJlZmVyZW5jZS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1MTUjc2VjdGlvbi0yLjQuNFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgcHVibGljIG5vdGlmeShkZWxlZ2F0ZT86IE91dGdvaW5nUmVxdWVzdERlbGVnYXRlLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpOiBPdXRnb2luZ05vdGlmeVJlcXVlc3Qge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgSU5WSVRFIGRpYWxvZyAke3RoaXMuaWR9IHNlbmRpbmcgTk9USUZZIHJlcXVlc3RgKTtcbiAgICBpZiAodGhpcy5lYXJseSkge1xuICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIHRocm93IGEgcHJvcGVyIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyBub3QgY29uZmlybWVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOb3RpZnlVc2VyQWdlbnRDbGllbnQodGhpcywgZGVsZWdhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc3VtaW5nIHRoZSByZXNwb25zZSBpcyB0byBiZSB0cmFuc21pdHRlZCByZWxpYWJseSwgdGhlIFVBQyBNVVNUXG4gICAqIGNyZWF0ZSBhIG5ldyByZXF1ZXN0IHdpdGggbWV0aG9kIFBSQUNLLiAgVGhpcyByZXF1ZXN0IGlzIHNlbnQgd2l0aGluXG4gICAqIHRoZSBkaWFsb2cgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aXNpb25hbCByZXNwb25zZSAoaW5kZWVkLCB0aGVcbiAgICogcHJvdmlzaW9uYWwgcmVzcG9uc2UgbWF5IGhhdmUgY3JlYXRlZCB0aGUgZGlhbG9nKS4gIFBSQUNLIHJlcXVlc3RzXG4gICAqIE1BWSBjb250YWluIGJvZGllcywgd2hpY2ggYXJlIGludGVycHJldGVkIGFjY29yZGluZyB0byB0aGVpciB0eXBlIGFuZFxuICAgKiBkaXNwb3NpdGlvbi5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi00XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBwdWJsaWMgcHJhY2soZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogT3V0Z29pbmdQcmFja1JlcXVlc3Qge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgSU5WSVRFIGRpYWxvZyAke3RoaXMuaWR9IHNlbmRpbmcgUFJBQ0sgcmVxdWVzdGApO1xuICAgIHJldHVybiBuZXcgUHJhY2tVc2VyQWdlbnRDbGllbnQodGhpcywgZGVsZWdhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJFRkVSIGlzIGEgU0lQIHJlcXVlc3QgYW5kIGlzIGNvbnN0cnVjdGVkIGFzIGRlZmluZWQgaW4gWzFdLiAgQSBSRUZFUlxuICAgKiByZXF1ZXN0IE1VU1QgY29udGFpbiBleGFjdGx5IG9uZSBSZWZlci1UbyBoZWFkZXIgZmllbGQgdmFsdWUuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTE1I3NlY3Rpb24tMi40LjFcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHB1YmxpYyByZWZlcihkZWxlZ2F0ZT86IE91dGdvaW5nUmVxdWVzdERlbGVnYXRlLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpOiBPdXRnb2luZ1JlZmVyUmVxdWVzdCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBJTlZJVEUgZGlhbG9nICR7dGhpcy5pZH0gc2VuZGluZyBSRUZFUiByZXF1ZXN0YCk7XG4gICAgaWYgKHRoaXMuZWFybHkpIHtcbiAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgbm90IGNvbmZpcm1lZC5cIik7XG4gICAgfVxuICAgIC8vIEZJWE1FOiBUT0RPOiBWYWxpZGF0ZSBSZWZlci1UbyBoZWFkZXIgZmllbGQgdmFsdWUuXG4gICAgcmV0dXJuIG5ldyBSZWZlclVzZXJBZ2VudENsaWVudCh0aGlzLCBkZWxlZ2F0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdHMgc2VudCB3aXRoaW4gYSBkaWFsb2csIGFzIGFueSBvdGhlciByZXF1ZXN0cywgYXJlIGF0b21pYy4gIElmXG4gICAqIGEgcGFydGljdWxhciByZXF1ZXN0IGlzIGFjY2VwdGVkIGJ5IHRoZSBVQVMsIGFsbCB0aGUgc3RhdGUgY2hhbmdlc1xuICAgKiBhc3NvY2lhdGVkIHdpdGggaXQgYXJlIHBlcmZvcm1lZC4gIElmIHRoZSByZXF1ZXN0IGlzIHJlamVjdGVkLCBub25lXG4gICAqIG9mIHRoZSBzdGF0ZSBjaGFuZ2VzIGFyZSBwZXJmb3JtZWQuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlIHdpdGhpbiB0aGlzIGRpYWxvZy5cbiAgICovXG4gIHB1YmxpYyByZWNlaXZlUmVxdWVzdChtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBJTlZJVEUgZGlhbG9nICR7dGhpcy5pZH0gcmVjZWl2ZWQgJHttZXNzYWdlLm1ldGhvZH0gcmVxdWVzdGApO1xuXG4gICAgLy8gUmVzcG9uc2UgcmV0cmFuc21pc3Npb25zIGNlYXNlIHdoZW4gYW4gQUNLIHJlcXVlc3QgZm9yIHRoZVxuICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkLiAgVGhpcyBpcyBpbmRlcGVuZGVudCBvZiB3aGF0ZXZlciB0cmFuc3BvcnRcbiAgICAvLyBwcm90b2NvbHMgYXJlIHVzZWQgdG8gc2VuZCB0aGUgcmVzcG9uc2UuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjFcbiAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IEMuQUNLKSB7XG4gICAgICAvLyBJZiBhY2tXYWl0IGlzIHRydWUsIHRoZW4gdGhpcyBpcyB0aGUgQUNLIHRvIHRoZSBpbml0aWFsIElOVklURSxcbiAgICAgIC8vIG90aGVyd2lzZSB0aGlzIGlzIGFuIEFDSyB0byBhbiBpbiBkaWFsb2cgSU5WSVRFLiBJbiBlaXRoZXIgY2FzZSxcbiAgICAgIC8vIGd1YXJkIHRvIG1ha2Ugc3VyZSB0aGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBBQ0sgbWF0Y2hlcyB0aGUgSU5WSVRFLlxuICAgICAgaWYgKHRoaXMuYWNrV2FpdCkge1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsVHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYElOVklURSBkaWFsb2cgJHt0aGlzLmlkfSByZWNlaXZlZCB1bmV4cGVjdGVkICR7bWVzc2FnZS5tZXRob2R9IHJlcXVlc3QsIGRyb3BwaW5nLmApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVHJhbnNhY3Rpb24ucmVxdWVzdC5jc2VxICE9PSBtZXNzYWdlLmNzZXEpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBJTlZJVEUgZGlhbG9nICR7dGhpcy5pZH0gcmVjZWl2ZWQgdW5leHBlY3RlZCAke21lc3NhZ2UubWV0aG9kfSByZXF1ZXN0LCBkcm9wcGluZy5gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGJlZm9yZSB0aGUgZGVsZWdhdGUgaGFzIGEgY2hhbmNlIHRvIGhhbmRsZSB0aGVcbiAgICAgICAgLy8gbWVzc2FnZSBhcyBkZWxlZ2F0ZSBtYXkgY2FsbGJhY2sgaW50byB0aGlzIGRpYWxvZy5cbiAgICAgICAgdGhpcy5hY2tXYWl0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBJTlZJVEUgZGlhbG9nICR7dGhpcy5pZH0gcmVjZWl2ZWQgdW5leHBlY3RlZCAke21lc3NhZ2UubWV0aG9kfSByZXF1ZXN0LCBkcm9wcGluZy5gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIudHJhbnNhY3Rpb24ucmVxdWVzdC5jc2VxICE9PSBtZXNzYWdlLmNzZXEpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBJTlZJVEUgZGlhbG9nICR7dGhpcy5pZH0gcmVjZWl2ZWQgdW5leHBlY3RlZCAke21lc3NhZ2UubWV0aG9kfSByZXF1ZXN0LCBkcm9wcGluZy5gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkFjaykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLm9uQWNrKHsgbWVzc2FnZSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXF1ZXN0IHdpdGhpbiBhIGRpYWxvZyBvdXQgb2Ygc2VxdWVuY2UgZ3VhcmQuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICBpZiAoIXRoaXMuc2VxdWVuY2VHdWFyZChtZXNzYWdlKSkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKGBJTlZJVEUgZGlhbG9nICR7dGhpcy5pZH0gcmVqZWN0ZWQgb3V0IG9mIG9yZGVyICR7bWVzc2FnZS5tZXRob2R9IHJlcXVlc3QuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBDLklOVklURSkge1xuICAgICAgLy8gQSBVQVMgdGhhdCByZWNlaXZlcyBhIHNlY29uZCBJTlZJVEUgYmVmb3JlIGl0IHNlbmRzIHRoZSBmaW5hbFxuICAgICAgLy8gcmVzcG9uc2UgdG8gYSBmaXJzdCBJTlZJVEUgd2l0aCBhIGxvd2VyIENTZXEgc2VxdWVuY2UgbnVtYmVyIG9uIHRoZVxuICAgICAgLy8gc2FtZSBkaWFsb2cgTVVTVCByZXR1cm4gYSA1MDAgKFNlcnZlciBJbnRlcm5hbCBFcnJvcikgcmVzcG9uc2UgdG8gdGhlXG4gICAgICAvLyBzZWNvbmQgSU5WSVRFIGFuZCBNVVNUIGluY2x1ZGUgYSBSZXRyeS1BZnRlciBoZWFkZXIgZmllbGQgd2l0aCBhXG4gICAgICAvLyByYW5kb21seSBjaG9zZW4gdmFsdWUgb2YgYmV0d2VlbiAwIGFuZCAxMCBzZWNvbmRzLlxuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNC4yXG4gICAgICBpZiAodGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlcikge1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTIwLjMzXG4gICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogMTApKSArIDE7XG4gICAgICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9IFtgUmV0cnktQWZ0ZXI6ICR7cmV0cnlBZnRlcn1gXTtcbiAgICAgICAgdGhpcy5jb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNTAwLCBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQSBVQVMgdGhhdCByZWNlaXZlcyBhbiBJTlZJVEUgb24gYSBkaWFsb2cgd2hpbGUgYW4gSU5WSVRFIGl0IGhhZCBzZW50XG4gICAgICAvLyBvbiB0aGF0IGRpYWxvZyBpcyBpbiBwcm9ncmVzcyBNVVNUIHJldHVybiBhIDQ5MSAoUmVxdWVzdCBQZW5kaW5nKVxuICAgICAgLy8gcmVzcG9uc2UgdG8gdGhlIHJlY2VpdmVkIElOVklURS5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTQuMlxuICAgICAgaWYgKHRoaXMucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDkxIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVxdWVzdCB3aXRoaW4gYSBkaWFsb2cgY29tbW9uIHByb2Nlc3NpbmcuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICBzdXBlci5yZWNlaXZlUmVxdWVzdChtZXNzYWdlKTtcblxuICAgIC8vIFJlcXVlc3RzIHdpdGhpbiBhIGRpYWxvZyBNQVkgY29udGFpbiBSZWNvcmQtUm91dGUgYW5kIENvbnRhY3QgaGVhZGVyXG4gICAgLy8gZmllbGRzLiAgSG93ZXZlciwgdGhlc2UgcmVxdWVzdHMgZG8gbm90IGNhdXNlIHRoZSBkaWFsb2cncyByb3V0ZSBzZXRcbiAgICAvLyB0byBiZSBtb2RpZmllZCwgYWx0aG91Z2ggdGhleSBtYXkgbW9kaWZ5IHRoZSByZW1vdGUgdGFyZ2V0IFVSSS5cbiAgICAvLyBTcGVjaWZpY2FsbHksIHJlcXVlc3RzIHRoYXQgYXJlIG5vdCB0YXJnZXQgcmVmcmVzaCByZXF1ZXN0cyBkbyBub3RcbiAgICAvLyBtb2RpZnkgdGhlIGRpYWxvZydzIHJlbW90ZSB0YXJnZXQgVVJJLCBhbmQgcmVxdWVzdHMgdGhhdCBhcmUgdGFyZ2V0XG4gICAgLy8gcmVmcmVzaCByZXF1ZXN0cyBkby4gIEZvciBkaWFsb2dzIHRoYXQgaGF2ZSBiZWVuIGVzdGFibGlzaGVkIHdpdGggYW5cbiAgICAvLyBJTlZJVEUsIHRoZSBvbmx5IHRhcmdldCByZWZyZXNoIHJlcXVlc3QgZGVmaW5lZCBpcyByZS1JTlZJVEUgKHNlZVxuICAgIC8vIFNlY3Rpb24gMTQpLiAgT3RoZXIgZXh0ZW5zaW9ucyBtYXkgZGVmaW5lIGRpZmZlcmVudCB0YXJnZXQgcmVmcmVzaFxuICAgIC8vIHJlcXVlc3RzIGZvciBkaWFsb2dzIGVzdGFibGlzaGVkIGluIG90aGVyIHdheXMuXG4gICAgLy9cbiAgICAvLyAgICBOb3RlIHRoYXQgYW4gQUNLIGlzIE5PVCBhIHRhcmdldCByZWZyZXNoIHJlcXVlc3QuXG4gICAgLy9cbiAgICAvLyBUYXJnZXQgcmVmcmVzaCByZXF1ZXN0cyBvbmx5IHVwZGF0ZSB0aGUgZGlhbG9nJ3MgcmVtb3RlIHRhcmdldCBVUkksXG4gICAgLy8gYW5kIG5vdCB0aGUgcm91dGUgc2V0IGZvcm1lZCBmcm9tIHRoZSBSZWNvcmQtUm91dGUuICBVcGRhdGluZyB0aGVcbiAgICAvLyBsYXR0ZXIgd291bGQgaW50cm9kdWNlIHNldmVyZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwcm9ibGVtcyB3aXRoXG4gICAgLy8gUkZDIDI1NDMtY29tcGxpYW50IHN5c3RlbXMuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNVxuICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gQy5JTlZJVEUpIHtcbiAgICAgIC8vIEZJWE1FOiBwYXJzZXIgbmVlZHMgdG8gYmUgdHlwZWQuLi5cbiAgICAgIGNvbnN0IGNvbnRhY3QgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiY29udGFjdFwiKTtcbiAgICAgIGlmICghY29udGFjdCkgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFjdCB1bmRlZmluZWQuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEoY29udGFjdCBpbnN0YW5jZW9mIE5hbWVBZGRySGVhZGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWN0IG5vdCBpbnN0YW5jZSBvZiBOYW1lQWRkckhlYWRlci5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLmRpYWxvZ1N0YXRlLnJlbW90ZVRhcmdldCA9IGNvbnRhY3QudXJpO1xuICAgIH1cblxuICAgIC8vIFN3aXRjaCBvbiBtZXRob2QgYW5kIHRoZW4gZGVsZWdhdGUuXG4gICAgc3dpdGNoIChtZXNzYWdlLm1ldGhvZCkge1xuICAgICAgY2FzZSBDLkJZRTpcbiAgICAgICAgLy8gQSBVQVMgY29yZSByZWNlaXZpbmcgYSBCWUUgcmVxdWVzdCBmb3IgYW4gZXhpc3RpbmcgZGlhbG9nIE1VU1QgZm9sbG93XG4gICAgICAgIC8vIHRoZSBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gMTIuMi4yIHRvIHByb2Nlc3MgdGhlIHJlcXVlc3QuICBPbmNlIGRvbmUsXG4gICAgICAgIC8vIHRoZSBVQVMgU0hPVUxEIHRlcm1pbmF0ZSB0aGUgc2Vzc2lvbiAoYW5kIHRoZXJlZm9yZSBzdG9wIHNlbmRpbmcgYW5kXG4gICAgICAgIC8vIGxpc3RlbmluZyBmb3IgbWVkaWEpLiAgVGhlIG9ubHkgY2FzZSB3aGVyZSBpdCBjYW4gZWxlY3Qgbm90IHRvIGFyZVxuICAgICAgICAvLyBtdWx0aWNhc3Qgc2Vzc2lvbnMsIHdoZXJlIHBhcnRpY2lwYXRpb24gaXMgcG9zc2libGUgZXZlbiBpZiB0aGUgb3RoZXJcbiAgICAgICAgLy8gcGFydGljaXBhbnQgaW4gdGhlIGRpYWxvZyBoYXMgdGVybWluYXRlZCBpdHMgaW52b2x2ZW1lbnQgaW4gdGhlXG4gICAgICAgIC8vIHNlc3Npb24uICBXaGV0aGVyIG9yIG5vdCBpdCBlbmRzIGl0cyBwYXJ0aWNpcGF0aW9uIG9uIHRoZSBzZXNzaW9uLFxuICAgICAgICAvLyB0aGUgVUFTIGNvcmUgTVVTVCBnZW5lcmF0ZSBhIDJ4eCByZXNwb25zZSB0byB0aGUgQllFLCBhbmQgTVVTVCBwYXNzXG4gICAgICAgIC8vIHRoYXQgdG8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBmb3IgdHJhbnNtaXNzaW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgVUFTIE1VU1Qgc3RpbGwgcmVzcG9uZCB0byBhbnkgcGVuZGluZyByZXF1ZXN0cyByZWNlaXZlZCBmb3IgdGhhdFxuICAgICAgICAvLyBkaWFsb2cuICBJdCBpcyBSRUNPTU1FTkRFRCB0aGF0IGEgNDg3IChSZXF1ZXN0IFRlcm1pbmF0ZWQpIHJlc3BvbnNlXG4gICAgICAgIC8vIGJlIGdlbmVyYXRlZCB0byB0aG9zZSBwZW5kaW5nIHJlcXVlc3RzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE1LjEuMlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgdWFzID0gbmV3IEJ5ZVVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25CeWUgP1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkJ5ZSh1YXMpIDpcbiAgICAgICAgICAgIHVhcy5hY2NlcHQoKTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5JTkZPOlxuICAgICAgICAvLyBJZiBhIFVBIHJlY2VpdmVzIGFuIElORk8gcmVxdWVzdCBhc3NvY2lhdGVkIHdpdGggYW4gSW5mbyBQYWNrYWdlIHRoYXRcbiAgICAgICAgLy8gdGhlIFVBIGhhcyBub3QgaW5kaWNhdGVkIHdpbGxpbmduZXNzIHRvIHJlY2VpdmUsIHRoZSBVQSBNVVNUIHNlbmQgYVxuICAgICAgICAvLyA0NjkgKEJhZCBJbmZvIFBhY2thZ2UpIHJlc3BvbnNlIChzZWUgU2VjdGlvbiAxMS42KSwgd2hpY2ggY29udGFpbnMgYVxuICAgICAgICAvLyBSZWN2LUluZm8gaGVhZGVyIGZpZWxkIHdpdGggSW5mbyBQYWNrYWdlcyBmb3Igd2hpY2ggdGhlIFVBIGlzIHdpbGxpbmdcbiAgICAgICAgLy8gdG8gcmVjZWl2ZSBJTkZPIHJlcXVlc3RzLlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgdWFzID0gbmV3IEluZm9Vc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uSW5mbyA/XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uSW5mbyh1YXMpIDpcbiAgICAgICAgICAgIHVhcy5yZWplY3Qoe1xuICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0NjksXG4gICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogW1wiUmVjdi1JbmZvIDpcIl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLklOVklURTpcbiAgICAgICAgLy8gSWYgdGhlIG5ldyBzZXNzaW9uIGRlc2NyaXB0aW9uIGlzIG5vdCBhY2NlcHRhYmxlLCB0aGUgVUFTIGNhbiByZWplY3RcbiAgICAgICAgLy8gaXQgYnkgcmV0dXJuaW5nIGEgNDg4IChOb3QgQWNjZXB0YWJsZSBIZXJlKSByZXNwb25zZSBmb3IgdGhlIHJlLVxuICAgICAgICAvLyBJTlZJVEUuICBUaGlzIHJlc3BvbnNlIFNIT1VMRCBpbmNsdWRlIGEgV2FybmluZyBoZWFkZXIgZmllbGQuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTQuMlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgdWFzID0gbmV3IFJlSW52aXRlVXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSA/XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uSW52aXRlKHVhcykgOlxuICAgICAgICAgICAgdWFzLnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4OCB9KTsgLy8gVE9ETzogV2FybmluZyBoZWFkZXIgZmllbGQuXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuTk9USUZZOlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzUxNSNzZWN0aW9uLTIuNC40XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB1YXMgPSBuZXcgTm90aWZ5VXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSA/XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5KHVhcykgOlxuICAgICAgICAgICAgdWFzLmFjY2VwdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlBSQUNLOlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTRcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHVhcyA9IG5ldyBQcmFja1VzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25QcmFjayA/XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUHJhY2sodWFzKSA6XG4gICAgICAgICAgICB1YXMuYWNjZXB0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuUkVGRVI6XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTE1I3NlY3Rpb24tMi40LjJcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHVhcyA9IG5ldyBSZWZlclVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWZlciA/XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVmZXIodWFzKSA6XG4gICAgICAgICAgICB1YXMucmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBJTlZJVEUgZGlhbG9nICR7dGhpcy5pZH0gcmVjZWl2ZWQgdW5pbXBsZW1lbnRlZCAke21lc3NhZ2UubWV0aG9kfSByZXF1ZXN0YCk7XG4gICAgICAgICAgdGhpcy5jb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNTAxIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWxpYWJsZVNlcXVlbmNlR3VhcmQobWVzc2FnZTogSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpOiBib29sZWFuIHtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gbWVzc2FnZS5zdGF0dXNDb2RlO1xuICAgIGlmICghc3RhdHVzQ29kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdHVzIGNvZGUgdW5kZWZpbmVkXCIpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXNDb2RlID4gMTAwICYmIHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIC8vIElmIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UgaXMgcmVjZWl2ZWQgZm9yIGFuIGluaXRpYWwgcmVxdWVzdCwgYW5kXG4gICAgICAvLyB0aGF0IHJlc3BvbnNlIGNvbnRhaW5zIGEgUmVxdWlyZSBoZWFkZXIgZmllbGQgY29udGFpbmluZyB0aGUgb3B0aW9uXG4gICAgICAvLyB0YWcgMTAwcmVsLCB0aGUgcmVzcG9uc2UgaXMgdG8gYmUgc2VudCByZWxpYWJseS4gIElmIHRoZSByZXNwb25zZSBpc1xuICAgICAgLy8gYSAxMDAgKFRyeWluZykgKGFzIG9wcG9zZWQgdG8gMTAxIHRvIDE5OSksIHRoaXMgb3B0aW9uIHRhZyBNVVNUIGJlXG4gICAgICAvLyBpZ25vcmVkLCBhbmQgdGhlIHByb2NlZHVyZXMgYmVsb3cgTVVTVCBOT1QgYmUgdXNlZC5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNFxuICAgICAgY29uc3QgcmVxdWlyZUhlYWRlciA9IG1lc3NhZ2UuZ2V0SGVhZGVyKFwicmVxdWlyZVwiKTtcbiAgICAgIGNvbnN0IHJzZXFIZWFkZXIgPSBtZXNzYWdlLmdldEhlYWRlcihcInJzZXFcIik7XG4gICAgICBjb25zdCByc2VxID0gcmVxdWlyZUhlYWRlciAmJiByZXF1aXJlSGVhZGVyLmluY2x1ZGVzKFwiMTAwcmVsXCIpICYmIHJzZXFIZWFkZXIgPyBOdW1iZXIocnNlcUhlYWRlcikgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAocnNlcSkge1xuICAgICAgICAvLyBIYW5kbGluZyBvZiBzdWJzZXF1ZW50IHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBmb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gaW5pdGlhbCByZXF1ZXN0IGZvbGxvd3MgdGhlIHNhbWUgcnVsZXMgYXMgYWJvdmUsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyBkaWZmZXJlbmNlOiByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZXMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgaW5cbiAgICAgICAgLy8gb3JkZXIuICBBcyBhIHJlc3VsdCwgaWYgdGhlIFVBQyByZWNlaXZlcyBhbm90aGVyIHJlbGlhYmxlIHByb3Zpc2lvbmFsXG4gICAgICAgIC8vIHJlc3BvbnNlIHRvIHRoZSBzYW1lIHJlcXVlc3QsIGFuZCBpdHMgUlNlcSB2YWx1ZSBpcyBub3Qgb25lIGhpZ2hlclxuICAgICAgICAvLyB0aGFuIHRoZSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2UgbnVtYmVyLCB0aGF0IHJlc3BvbnNlIE1VU1QgTk9UIGJlXG4gICAgICAgIC8vIGFja25vd2xlZGdlZCB3aXRoIGEgUFJBQ0ssIGFuZCBNVVNUIE5PVCBiZSBwcm9jZXNzZWQgZnVydGhlciBieSB0aGVcbiAgICAgICAgLy8gVUFDLiAgQW4gaW1wbGVtZW50YXRpb24gTUFZIGRpc2NhcmQgdGhlIHJlc3BvbnNlLCBvciBNQVkgY2FjaGUgdGhlXG4gICAgICAgIC8vIHJlc3BvbnNlIGluIHRoZSBob3BlcyBvZiByZWNlaXZpbmcgdGhlIG1pc3NpbmcgcmVzcG9uc2VzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTRcbiAgICAgICAgaWYgKHRoaXMucnNlcSAmJiB0aGlzLnJzZXEgKyAxICE9PSByc2VxKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25jZSBhIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGlzIHJlY2VpdmVkLCByZXRyYW5zbWlzc2lvbnMgb2ZcbiAgICAgICAgLy8gdGhhdCByZXNwb25zZSBNVVNUIGJlIGRpc2NhcmRlZC4gIEEgcmVzcG9uc2UgaXMgYSByZXRyYW5zbWlzc2lvbiB3aGVuXG4gICAgICAgIC8vIGl0cyBkaWFsb2cgSUQsIENTZXEsIGFuZCBSU2VxIG1hdGNoIHRoZSBvcmlnaW5hbCByZXNwb25zZS4gIFRoZSBVQUNcbiAgICAgICAgLy8gTVVTVCBtYWludGFpbiBhIHNlcXVlbmNlIG51bWJlciB0aGF0IGluZGljYXRlcyB0aGUgbW9zdCByZWNlbnRseVxuICAgICAgICAvLyByZWNlaXZlZCBpbi1vcmRlciByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSBmb3IgdGhlIGluaXRpYWxcbiAgICAgICAgLy8gcmVxdWVzdC4gIFRoaXMgc2VxdWVuY2UgbnVtYmVyIE1VU1QgYmUgbWFpbnRhaW5lZCB1bnRpbCBhIGZpbmFsXG4gICAgICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkIGZvciB0aGUgaW5pdGlhbCByZXF1ZXN0LiAgSXRzIHZhbHVlIE1VU1QgYmVcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgdG8gdGhlIFJTZXEgaGVhZGVyIGZpZWxkIGluIHRoZSBmaXJzdCByZWxpYWJsZVxuICAgICAgICAvLyBwcm92aXNpb25hbCByZXNwb25zZSByZWNlaXZlZCBmb3IgdGhlIGluaXRpYWwgcmVxdWVzdC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi00XG4gICAgICAgIGlmICghdGhpcy5yc2VxKSB7XG4gICAgICAgICAgdGhpcy5yc2VxID0gcnNlcTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIG5vdCBpbiBhIHN0YWJsZSBzaWduYWxpbmcgc3RhdGUsIHJvbGxiYWNrIHRvIHByaW9yIHN0YWJsZSBzaWduYWxpbmcgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgc2lnbmFsaW5nU3RhdGVSb2xsYmFjaygpOiB2b2lkIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9PT0gU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXIgfHxcbiAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09IFNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcikge1xuICAgICAgaWYgKHRoaXMuX3JvbGxiYWNrT2ZmZXIgJiYgdGhpcy5fcm9sbGJhY2tBbnN3ZXIpIHtcbiAgICAgICAgdGhpcy5fc2lnbmFsaW5nU3RhdGUgPSBTaWduYWxpbmdTdGF0ZS5TdGFibGU7XG4gICAgICAgIHRoaXMuX29mZmVyID0gdGhpcy5fcm9sbGJhY2tPZmZlcjtcbiAgICAgICAgdGhpcy5fYW5zd2VyID0gdGhpcy5fcm9sbGJhY2tBbnN3ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2lnbmFsaW5nIHN0YXRlIG9mIHRoZSBkaWFsb2cuXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gYmFzZSB0aGUgdXBkYXRlIG9mZiBvZi5cbiAgICovXG4gIHB1YmxpYyBzaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24oXG4gICAgbWVzc2FnZTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSB8IEluY29taW5nUmVzcG9uc2VNZXNzYWdlIHwgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSB8IEJvZHlcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgYm9keSA9IGdldEJvZHkobWVzc2FnZSk7XG5cbiAgICAvLyBObyBib2R5LCBubyBzZXNzaW9uLiBObywgd29tYW4sIG5vIGNyeS5cbiAgICBpZiAoIWJvZHkgfHwgYm9keS5jb250ZW50RGlzcG9zaXRpb24gIT09IFwic2Vzc2lvblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UndmUgZ290IGFuIGV4aXN0aW5nIG9mZmVyIGFuZCBhbnN3ZXIgd2hpY2ggd2UgbWF5IHdpc2ggdG8gcm9sbGJhY2sgdG9cbiAgICBpZiAodGhpcy5fc2lnbmFsaW5nU3RhdGUgPT09IFNpZ25hbGluZ1N0YXRlLlN0YWJsZSkge1xuICAgICAgdGhpcy5fcm9sbGJhY2tPZmZlciA9IHRoaXMuX29mZmVyO1xuICAgICAgdGhpcy5fcm9sbGJhY2tBbnN3ZXIgPSB0aGlzLl9hbnN3ZXI7XG4gICAgfVxuXG4gICAgLy8gV2UncmUgaW4gVUFTIHJvbGUsIHJlY2VpdmluZyBpbmNvbWluZyByZXF1ZXN0IHdpdGggc2Vzc2lvbiBkZXNjcmlwdGlvblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgc3dpdGNoICh0aGlzLl9zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkluaXRpYWw6XG4gICAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuU3RhYmxlOlxuICAgICAgICAgIHRoaXMuX3NpZ25hbGluZ1N0YXRlID0gU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyO1xuICAgICAgICAgIHRoaXMuX29mZmVyID0gYm9keTtcbiAgICAgICAgICB0aGlzLl9hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXI6XG4gICAgICAgICAgdGhpcy5fc2lnbmFsaW5nU3RhdGUgPSBTaWduYWxpbmdTdGF0ZS5TdGFibGU7XG4gICAgICAgICAgdGhpcy5fYW5zd2VyID0gYm9keTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXI6XG4gICAgICAgICAgLy8gWW91IGNhbm5vdCBtYWtlIGEgbmV3IG9mZmVyIHdoaWxlIG9uZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IHRvIGRvIGhlcmU/XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc2lnbmFsaW5nIHN0YXRlLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSdyZSBpbiBVQUMgcm9sZSwgcmVjZWl2aW5nIGluY29taW5nIHJlc3BvbnNlIHdpdGggc2Vzc2lvbiBkZXNjcmlwdGlvblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5Jbml0aWFsOlxuICAgICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLlN0YWJsZTpcbiAgICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IFNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjtcbiAgICAgICAgICB0aGlzLl9vZmZlciA9IGJvZHk7XG4gICAgICAgICAgdGhpcy5fYW5zd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyOlxuICAgICAgICAgIHRoaXMuX3NpZ25hbGluZ1N0YXRlID0gU2lnbmFsaW5nU3RhdGUuU3RhYmxlO1xuICAgICAgICAgIHRoaXMuX2Fuc3dlciA9IGJvZHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyOlxuICAgICAgICAgIC8vIFlvdSBjYW5ub3QgbWFrZSBhIG5ldyBvZmZlciB3aGlsZSBvbmUgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAvLyBGSVhNRTogV2hhdCB0byBkbyBoZXJlP1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkNsb3NlZDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHNpZ25hbGluZyBzdGF0ZS5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2UncmUgaW4gVUFDIHJvbGUsIHNlbmRpbmcgb3V0Z29pbmcgcmVxdWVzdCB3aXRoIHNlc3Npb24gZGVzY3JpcHRpb25cbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5Jbml0aWFsOlxuICAgICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLlN0YWJsZTpcbiAgICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IFNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyO1xuICAgICAgICAgIHRoaXMuX29mZmVyID0gYm9keTtcbiAgICAgICAgICB0aGlzLl9hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXI6XG4gICAgICAgICAgLy8gWW91IGNhbm5vdCBtYWtlIGEgbmV3IG9mZmVyIHdoaWxlIG9uZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IHRvIGRvIGhlcmU/XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyOlxuICAgICAgICAgIHRoaXMuX3NpZ25hbGluZ1N0YXRlID0gU2lnbmFsaW5nU3RhdGUuU3RhYmxlO1xuICAgICAgICAgIHRoaXMuX2Fuc3dlciA9IGJvZHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc2lnbmFsaW5nIHN0YXRlLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSdyZSBpbiBVQVMgcm9sZSwgc2VuZGluZyBvdXRnb2luZyByZXNwb25zZSB3aXRoIHNlc3Npb24gZGVzY3JpcHRpb25cbiAgICBpZiAoaXNCb2R5KG1lc3NhZ2UpKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3NpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgIGNhc2UgU2lnbmFsaW5nU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgY2FzZSBTaWduYWxpbmdTdGF0ZS5TdGFibGU6XG4gICAgICAgICAgdGhpcy5fc2lnbmFsaW5nU3RhdGUgPSBTaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjtcbiAgICAgICAgICB0aGlzLl9vZmZlciA9IGJvZHk7XG4gICAgICAgICAgdGhpcy5fYW5zd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyOlxuICAgICAgICAgIC8vIFlvdSBjYW5ub3QgbWFrZSBhIG5ldyBvZmZlciB3aGlsZSBvbmUgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAvLyBGSVhNRTogV2hhdCB0byBkbyBoZXJlP1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjpcbiAgICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IFNpZ25hbGluZ1N0YXRlLlN0YWJsZTtcbiAgICAgICAgICB0aGlzLl9hbnN3ZXIgPSBib2R5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNpZ25hbGluZ1N0YXRlLkNsb3NlZDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHNpZ25hbGluZyBzdGF0ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGFydDJ4eFJldHJhbnNtaXNzaW9uVGltZXIoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbFRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5pbml0aWFsVHJhbnNhY3Rpb247XG5cbiAgICAgIC8vIE9uY2UgdGhlIHJlc3BvbnNlIGhhcyBiZWVuIGNvbnN0cnVjdGVkLCBpdCBpcyBwYXNzZWQgdG8gdGhlIElOVklURVxuICAgICAgLy8gc2VydmVyIHRyYW5zYWN0aW9uLiAgSW4gb3JkZXIgdG8gZW5zdXJlIHJlbGlhYmxlIGVuZC10by1lbmRcbiAgICAgIC8vIHRyYW5zcG9ydCBvZiB0aGUgcmVzcG9uc2UsIGl0IGlzIG5lY2Vzc2FyeSB0byBwZXJpb2RpY2FsbHkgcGFzc1xuICAgICAgLy8gdGhlIHJlc3BvbnNlIGRpcmVjdGx5IHRvIHRoZSB0cmFuc3BvcnQgdW50aWwgdGhlIEFDSyBhcnJpdmVzLiAgVGhlXG4gICAgICAvLyAyeHggcmVzcG9uc2UgaXMgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnQgd2l0aCBhbiBpbnRlcnZhbCB0aGF0XG4gICAgICAvLyBzdGFydHMgYXQgVDEgc2Vjb25kcyBhbmQgZG91YmxlcyBmb3IgZWFjaCByZXRyYW5zbWlzc2lvbiB1bnRpbCBpdFxuICAgICAgLy8gcmVhY2hlcyBUMiBzZWNvbmRzIChUMSBhbmQgVDIgYXJlIGRlZmluZWQgaW4gU2VjdGlvbiAxNykuXG4gICAgICAvLyBSZXNwb25zZSByZXRyYW5zbWlzc2lvbnMgY2Vhc2Ugd2hlbiBhbiBBQ0sgcmVxdWVzdCBmb3IgdGhlXG4gICAgICAvLyByZXNwb25zZSBpcyByZWNlaXZlZC4gIFRoaXMgaXMgaW5kZXBlbmRlbnQgb2Ygd2hhdGV2ZXIgdHJhbnNwb3J0XG4gICAgICAvLyBwcm90b2NvbHMgYXJlIHVzZWQgdG8gc2VuZCB0aGUgcmVzcG9uc2UuXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguMVxuICAgICAgbGV0IHRpbWVvdXQgPSBUaW1lcnMuVDE7XG4gICAgICBjb25zdCByZXRyYW5zbWlzc2lvbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmFja1dhaXQpIHtcbiAgICAgICAgICB0aGlzLmludml0ZTJ4eFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJObyBBQ0sgZm9yIDJ4eCByZXNwb25zZSByZWNlaXZlZCwgYXR0ZW1wdGluZyByZXRyYW5zbWlzc2lvblwiKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmV0cmFuc21pdEFjY2VwdGVkUmVzcG9uc2UoKTtcbiAgICAgICAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQgKiAyLCBUaW1lcnMuVDIpO1xuICAgICAgICB0aGlzLmludml0ZTJ4eFRpbWVyID0gc2V0VGltZW91dChyZXRyYW5zbWlzc2lvbiwgdGltZW91dCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5pbnZpdGUyeHhUaW1lciA9IHNldFRpbWVvdXQocmV0cmFuc21pc3Npb24sIHRpbWVvdXQpO1xuXG4gICAgICAvLyBJZiB0aGUgc2VydmVyIHJldHJhbnNtaXRzIHRoZSAyeHggcmVzcG9uc2UgZm9yIDY0KlQxIHNlY29uZHMgd2l0aG91dFxuICAgICAgLy8gcmVjZWl2aW5nIGFuIEFDSywgdGhlIGRpYWxvZyBpcyBjb25maXJtZWQsIGJ1dCB0aGUgc2Vzc2lvbiBTSE9VTEQgYmVcbiAgICAgIC8vIHRlcm1pbmF0ZWQuICBUaGlzIGlzIGFjY29tcGxpc2hlZCB3aXRoIGEgQllFLCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiAxNS5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjRcbiAgICAgIGNvbnN0IHN0YXRlQ2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5yZW1vdmVMaXN0ZW5lcihcInN0YXRlQ2hhbmdlZFwiLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgIGlmICh0aGlzLmludml0ZTJ4eFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmludml0ZTJ4eFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5hY2tXYWl0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uQWNrVGltZW91dCkge1xuICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uQWNrVGltZW91dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5ieWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0cmFuc2FjdGlvbi5hZGRMaXN0ZW5lcihcInN0YXRlQ2hhbmdlZFwiLCBzdGF0ZUNoYW5nZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZJWE1FOiBSZWZhY3RvclxuICBwcml2YXRlIHN0YXJ0UmVJbnZpdGUyeHhSZXRyYW5zbWlzc2lvblRpbWVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyICAmJiB0aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlci50cmFuc2FjdGlvbjtcblxuICAgICAgLy8gT25jZSB0aGUgcmVzcG9uc2UgaGFzIGJlZW4gY29uc3RydWN0ZWQsIGl0IGlzIHBhc3NlZCB0byB0aGUgSU5WSVRFXG4gICAgICAvLyBzZXJ2ZXIgdHJhbnNhY3Rpb24uICBJbiBvcmRlciB0byBlbnN1cmUgcmVsaWFibGUgZW5kLXRvLWVuZFxuICAgICAgLy8gdHJhbnNwb3J0IG9mIHRoZSByZXNwb25zZSwgaXQgaXMgbmVjZXNzYXJ5IHRvIHBlcmlvZGljYWxseSBwYXNzXG4gICAgICAvLyB0aGUgcmVzcG9uc2UgZGlyZWN0bHkgdG8gdGhlIHRyYW5zcG9ydCB1bnRpbCB0aGUgQUNLIGFycml2ZXMuICBUaGVcbiAgICAgIC8vIDJ4eCByZXNwb25zZSBpcyBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCB3aXRoIGFuIGludGVydmFsIHRoYXRcbiAgICAgIC8vIHN0YXJ0cyBhdCBUMSBzZWNvbmRzIGFuZCBkb3VibGVzIGZvciBlYWNoIHJldHJhbnNtaXNzaW9uIHVudGlsIGl0XG4gICAgICAvLyByZWFjaGVzIFQyIHNlY29uZHMgKFQxIGFuZCBUMiBhcmUgZGVmaW5lZCBpbiBTZWN0aW9uIDE3KS5cbiAgICAgIC8vIFJlc3BvbnNlIHJldHJhbnNtaXNzaW9ucyBjZWFzZSB3aGVuIGFuIEFDSyByZXF1ZXN0IGZvciB0aGVcbiAgICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkLiAgVGhpcyBpcyBpbmRlcGVuZGVudCBvZiB3aGF0ZXZlciB0cmFuc3BvcnRcbiAgICAgIC8vIHByb3RvY29scyBhcmUgdXNlZCB0byBzZW5kIHRoZSByZXNwb25zZS5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC4xXG4gICAgICBsZXQgdGltZW91dCA9IFRpbWVycy5UMTtcbiAgICAgIGNvbnN0IHJldHJhbnNtaXNzaW9uID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIpIHtcbiAgICAgICAgICB0aGlzLmludml0ZTJ4eFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJObyBBQ0sgZm9yIDJ4eCByZXNwb25zZSByZWNlaXZlZCwgYXR0ZW1wdGluZyByZXRyYW5zbWlzc2lvblwiKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmV0cmFuc21pdEFjY2VwdGVkUmVzcG9uc2UoKTtcbiAgICAgICAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQgKiAyLCBUaW1lcnMuVDIpO1xuICAgICAgICB0aGlzLmludml0ZTJ4eFRpbWVyID0gc2V0VGltZW91dChyZXRyYW5zbWlzc2lvbiwgdGltZW91dCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5pbnZpdGUyeHhUaW1lciA9IHNldFRpbWVvdXQocmV0cmFuc21pc3Npb24sIHRpbWVvdXQpO1xuXG4gICAgICAvLyBJZiB0aGUgc2VydmVyIHJldHJhbnNtaXRzIHRoZSAyeHggcmVzcG9uc2UgZm9yIDY0KlQxIHNlY29uZHMgd2l0aG91dFxuICAgICAgLy8gcmVjZWl2aW5nIGFuIEFDSywgdGhlIGRpYWxvZyBpcyBjb25maXJtZWQsIGJ1dCB0aGUgc2Vzc2lvbiBTSE9VTEQgYmVcbiAgICAgIC8vIHRlcm1pbmF0ZWQuICBUaGlzIGlzIGFjY29tcGxpc2hlZCB3aXRoIGEgQllFLCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiAxNS5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjRcbiAgICAgIGNvbnN0IHN0YXRlQ2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5yZW1vdmVMaXN0ZW5lcihcInN0YXRlQ2hhbmdlZFwiLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgIGlmICh0aGlzLmludml0ZTJ4eFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmludml0ZTJ4eFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlcikge1xuICAgICAgICAgICAgLy8gRklYTUU6IFRPRE86IFdoYXQgdG8gZG8gaGVyZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZExpc3RlbmVyKFwic3RhdGVDaGFuZ2VkXCIsIHN0YXRlQ2hhbmdlZCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQge1xuICBDLFxuICBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICBOYW1lQWRkckhlYWRlcixcbiAgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0LFxuICBPdXRnb2luZ1N1YnNjcmliZVJlcXVlc3REZWxlZ2F0ZSxcbiAgUmVxdWVzdE9wdGlvbnNcbn0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIFN1YnNjcmlwdGlvbkRlbGVnYXRlLCBTdWJzY3JpcHRpb25TdGF0ZSB9IGZyb20gXCIuLi9zdWJzY3JpcHRpb25cIjtcbmltcG9ydCB7IFRpbWVycyB9IGZyb20gXCIuLi90aW1lcnNcIjtcbmltcG9ydCB7IEFsbG93ZWRNZXRob2RzIH0gZnJvbSBcIi4uL3VzZXItYWdlbnQtY29yZS9hbGxvd2VkLW1ldGhvZHNcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENvcmUgfSBmcm9tIFwiLi4vdXNlci1hZ2VudC1jb3JlL3VzZXItYWdlbnQtY29yZVwiO1xuaW1wb3J0IHsgTm90aWZ5VXNlckFnZW50U2VydmVyIH0gZnJvbSBcIi4uL3VzZXItYWdlbnRzL25vdGlmeS11c2VyLWFnZW50LXNlcnZlclwiO1xuaW1wb3J0IHsgUmVTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQgfSBmcm9tIFwiLi4vdXNlci1hZ2VudHMvcmUtc3Vic2NyaWJlLXVzZXItYWdlbnQtY2xpZW50XCI7XG5pbXBvcnQgeyBEaWFsb2cgfSBmcm9tIFwiLi9kaWFsb2dcIjtcbmltcG9ydCB7IERpYWxvZ1N0YXRlIH0gZnJvbSBcIi4vZGlhbG9nLXN0YXRlXCI7XG5cbi8qKlxuICogU3Vic2NyaXB0aW9uIERpYWxvZy5cbiAqIEByZW1hcmtzXG4gKiBTSVAtU3BlY2lmaWMgRXZlbnQgTm90aWZpY2F0aW9uXG4gKlxuICogQWJzdHJhY3RcbiAqXG4gKiAgICBUaGlzIGRvY3VtZW50IGRlc2NyaWJlcyBhbiBleHRlbnNpb24gdG8gdGhlIFNlc3Npb24gSW5pdGlhdGlvblxuICogICAgUHJvdG9jb2wgKFNJUCkgZGVmaW5lZCBieSBSRkMgMzI2MS4gIFRoZSBwdXJwb3NlIG9mIHRoaXMgZXh0ZW5zaW9uIGlzXG4gKiAgICB0byBwcm92aWRlIGFuIGV4dGVuc2libGUgZnJhbWV3b3JrIGJ5IHdoaWNoIFNJUCBub2RlcyBjYW4gcmVxdWVzdFxuICogICAgbm90aWZpY2F0aW9uIGZyb20gcmVtb3RlIG5vZGVzIGluZGljYXRpbmcgdGhhdCBjZXJ0YWluIGV2ZW50cyBoYXZlXG4gKiAgICBvY2N1cnJlZC5cbiAqXG4gKiAgICBOb3RlIHRoYXQgdGhlIGV2ZW50IG5vdGlmaWNhdGlvbiBtZWNoYW5pc21zIGRlZmluZWQgaGVyZWluIGFyZSBOT1RcbiAqICAgIGludGVuZGVkIHRvIGJlIGEgZ2VuZXJhbC1wdXJwb3NlIGluZnJhc3RydWN0dXJlIGZvciBhbGwgY2xhc3NlcyBvZlxuICogICAgZXZlbnQgc3Vic2NyaXB0aW9uIGFuZCBub3RpZmljYXRpb24uXG4gKlxuICogICAgVGhpcyBkb2N1bWVudCByZXByZXNlbnRzIGEgYmFja3dhcmRzLWNvbXBhdGlibGUgaW1wcm92ZW1lbnQgb24gdGhlXG4gKiAgICBvcmlnaW5hbCBtZWNoYW5pc20gZGVzY3JpYmVkIGJ5IFJGQyAzMjY1LCB0YWtpbmcgaW50byBhY2NvdW50IHNldmVyYWxcbiAqICAgIHllYXJzIG9mIGltcGxlbWVudGF0aW9uIGV4cGVyaWVuY2UuICBBY2NvcmRpbmdseSwgdGhpcyBkb2N1bWVudFxuICogICAgb2Jzb2xldGVzIFJGQyAzMjY1LiAgVGhpcyBkb2N1bWVudCBhbHNvIHVwZGF0ZXMgUkZDIDQ2NjAgc2xpZ2h0bHkgdG9cbiAqICAgIGFjY29tbW9kYXRlIHNvbWUgc21hbGwgY2hhbmdlcyB0byB0aGUgbWVjaGFuaXNtIHRoYXQgd2VyZSBkaXNjdXNzZWRcbiAqICAgIGluIHRoYXQgZG9jdW1lbnQuXG4gKlxuICogIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1XG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzY3JpcHRpb25EaWFsb2cgZXh0ZW5kcyBEaWFsb2cgaW1wbGVtZW50cyBTdWJzY3JpcHRpb24ge1xuXG4gIC8qKlxuICAgKiBXaGVuIGEgVUFDIHJlY2VpdmVzIGEgcmVzcG9uc2UgdGhhdCBlc3RhYmxpc2hlcyBhIGRpYWxvZywgaXRcbiAgICogY29uc3RydWN0cyB0aGUgc3RhdGUgb2YgdGhlIGRpYWxvZy4gIFRoaXMgc3RhdGUgTVVTVCBiZSBtYWludGFpbmVkXG4gICAqIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGRpYWxvZy5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjJcbiAgICogQHBhcmFtIG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgLSBPdXRnb2luZyByZXF1ZXN0IG1lc3NhZ2UgZm9yIGRpYWxvZy5cbiAgICogQHBhcmFtIGluY29taW5nUmVzcG9uc2VNZXNzYWdlIC0gSW5jb21pbmcgcmVzcG9uc2UgbWVzc2FnZSBjcmVhdGluZyBkaWFsb2cuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGluaXRpYWxEaWFsb2dTdGF0ZUZvclN1YnNjcmlwdGlvbihcbiAgICBvdXRnb2luZ1N1YnNjcmliZVJlcXVlc3RNZXNzYWdlOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGluY29taW5nTm90aWZ5UmVxdWVzdE1lc3NhZ2U6IEluY29taW5nUmVxdWVzdE1lc3NhZ2VcbiAgKTogRGlhbG9nU3RhdGUge1xuICAgIC8vIElmIHRoZSByZXF1ZXN0IHdhcyBzZW50IG92ZXIgVExTLCBhbmQgdGhlIFJlcXVlc3QtVVJJIGNvbnRhaW5lZCBhXG4gICAgLy8gU0lQUyBVUkksIHRoZSBcInNlY3VyZVwiIGZsYWcgaXMgc2V0IHRvIFRSVUUuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjJcbiAgICBjb25zdCBzZWN1cmUgPSBmYWxzZTsgLy8gRklYTUU6IEN1cnJlbnRseSBubyBzdXBwb3J0IGZvciBUTFMuXG5cbiAgICAvLyBUaGUgcm91dGUgc2V0IE1VU1QgYmUgc2V0IHRvIHRoZSBsaXN0IG9mIFVSSXMgaW4gdGhlIFJlY29yZC1Sb3V0ZVxuICAgIC8vIGhlYWRlciBmaWVsZCBmcm9tIHRoZSByZXNwb25zZSwgdGFrZW4gaW4gcmV2ZXJzZSBvcmRlciBhbmQgcHJlc2VydmluZ1xuICAgIC8vIGFsbCBVUkkgcGFyYW1ldGVycy4gIElmIG5vIFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGQgaXMgcHJlc2VudCBpblxuICAgIC8vIHRoZSByZXNwb25zZSwgdGhlIHJvdXRlIHNldCBNVVNUIGJlIHNldCB0byB0aGUgZW1wdHkgc2V0LiAgVGhpcyByb3V0ZVxuICAgIC8vIHNldCwgZXZlbiBpZiBlbXB0eSwgb3ZlcnJpZGVzIGFueSBwcmUtZXhpc3Rpbmcgcm91dGUgc2V0IGZvciBmdXR1cmVcbiAgICAvLyByZXF1ZXN0cyBpbiB0aGlzIGRpYWxvZy4gIFRoZSByZW1vdGUgdGFyZ2V0IE1VU1QgYmUgc2V0IHRvIHRoZSBVUklcbiAgICAvLyBmcm9tIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBvZiB0aGUgcmVzcG9uc2UuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjJcbiAgICBjb25zdCByb3V0ZVNldCA9IGluY29taW5nTm90aWZ5UmVxdWVzdE1lc3NhZ2UuZ2V0SGVhZGVycyhcInJlY29yZC1yb3V0ZVwiKTtcbiAgICBjb25zdCBjb250YWN0ID0gaW5jb21pbmdOb3RpZnlSZXF1ZXN0TWVzc2FnZS5wYXJzZUhlYWRlcihcImNvbnRhY3RcIik7XG4gICAgaWYgKCFjb250YWN0KSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFjdCB1bmRlZmluZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIShjb250YWN0IGluc3RhbmNlb2YgTmFtZUFkZHJIZWFkZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWN0IG5vdCBpbnN0YW5jZSBvZiBOYW1lQWRkckhlYWRlci5cIik7XG4gICAgfVxuICAgIGNvbnN0IHJlbW90ZVRhcmdldCA9IGNvbnRhY3QudXJpO1xuXG4gICAgLy8gVGhlIGxvY2FsIHNlcXVlbmNlIG51bWJlciBNVVNUIGJlIHNldCB0byB0aGUgdmFsdWUgb2YgdGhlIHNlcXVlbmNlXG4gICAgLy8gbnVtYmVyIGluIHRoZSBDU2VxIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdC4gIFRoZSByZW1vdGUgc2VxdWVuY2VcbiAgICAvLyBudW1iZXIgTVVTVCBiZSBlbXB0eSAoaXQgaXMgZXN0YWJsaXNoZWQgd2hlbiB0aGUgcmVtb3RlIFVBIHNlbmRzIGFcbiAgICAvLyByZXF1ZXN0IHdpdGhpbiB0aGUgZGlhbG9nKS4gIFRoZSBjYWxsIGlkZW50aWZpZXIgY29tcG9uZW50IG9mIHRoZVxuICAgIC8vIGRpYWxvZyBJRCBNVVNUIGJlIHNldCB0byB0aGUgdmFsdWUgb2YgdGhlIENhbGwtSUQgaW4gdGhlIHJlcXVlc3QuXG4gICAgLy8gVGhlIGxvY2FsIHRhZyBjb21wb25lbnQgb2YgdGhlIGRpYWxvZyBJRCBNVVNUIGJlIHNldCB0byB0aGUgdGFnIGluXG4gICAgLy8gdGhlIEZyb20gZmllbGQgaW4gdGhlIHJlcXVlc3QsIGFuZCB0aGUgcmVtb3RlIHRhZyBjb21wb25lbnQgb2YgdGhlXG4gICAgLy8gZGlhbG9nIElEIE1VU1QgYmUgc2V0IHRvIHRoZSB0YWcgaW4gdGhlIFRvIGZpZWxkIG9mIHRoZSByZXNwb25zZS4gIEFcbiAgICAvLyBVQUMgTVVTVCBiZSBwcmVwYXJlZCB0byByZWNlaXZlIGEgcmVzcG9uc2Ugd2l0aG91dCBhIHRhZyBpbiB0aGUgVG9cbiAgICAvLyBmaWVsZCwgaW4gd2hpY2ggY2FzZSB0aGUgdGFnIGlzIGNvbnNpZGVyZWQgdG8gaGF2ZSBhIHZhbHVlIG9mIG51bGwuXG4gICAgLy9cbiAgICAvLyAgICBUaGlzIGlzIHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggUkZDIDI1NDMsIHdoaWNoXG4gICAgLy8gICAgZGlkIG5vdCBtYW5kYXRlIFRvIHRhZ3MuXG4gICAgLy9cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgIGNvbnN0IGxvY2FsU2VxdWVuY2VOdW1iZXIgPSBvdXRnb2luZ1N1YnNjcmliZVJlcXVlc3RNZXNzYWdlLmNzZXE7XG4gICAgY29uc3QgcmVtb3RlU2VxdWVuY2VOdW1iZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgY2FsbElkID0gb3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0TWVzc2FnZS5jYWxsSWQ7XG4gICAgY29uc3QgbG9jYWxUYWcgPSBvdXRnb2luZ1N1YnNjcmliZVJlcXVlc3RNZXNzYWdlLmZyb21UYWc7XG4gICAgY29uc3QgcmVtb3RlVGFnID0gaW5jb21pbmdOb3RpZnlSZXF1ZXN0TWVzc2FnZS5mcm9tVGFnO1xuICAgIGlmICghY2FsbElkKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbCBpZCB1bmRlZmluZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIWxvY2FsVGFnKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB0YWcgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFyZW1vdGVUYWcpIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUbyB0YWcgdW5kZWZpbmVkLlwiKTsgLy8gRklYTUU6IE5vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggUkZDIDI1NDNcbiAgICB9XG5cbiAgICAvLyBUaGUgcmVtb3RlIFVSSSBNVVNUIGJlIHNldCB0byB0aGUgVVJJIGluIHRoZSBUbyBmaWVsZCwgYW5kIHRoZSBsb2NhbFxuICAgIC8vIFVSSSBNVVNUIGJlIHNldCB0byB0aGUgVVJJIGluIHRoZSBGcm9tIGZpZWxkLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgaWYgKCFvdXRnb2luZ1N1YnNjcmliZVJlcXVlc3RNZXNzYWdlLmZyb20pIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcm9tIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIGlmICghb3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0TWVzc2FnZS50bykgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsVVJJID0gb3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0TWVzc2FnZS5mcm9tLnVyaTtcbiAgICBjb25zdCByZW1vdGVVUkkgPSBvdXRnb2luZ1N1YnNjcmliZVJlcXVlc3RNZXNzYWdlLnRvLnVyaTtcblxuICAgIC8vIEEgZGlhbG9nIGNhbiBhbHNvIGJlIGluIHRoZSBcImVhcmx5XCIgc3RhdGUsIHdoaWNoIG9jY3VycyB3aGVuIGl0IGlzXG4gICAgLy8gY3JlYXRlZCB3aXRoIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UsIGFuZCB0aGVuIHRyYW5zaXRpb24gdG8gdGhlXG4gICAgLy8gXCJjb25maXJtZWRcIiBzdGF0ZSB3aGVuIGEgMnh4IGZpbmFsIHJlc3BvbnNlIGFycml2ZXMuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMlxuICAgIGNvbnN0IGVhcmx5ID0gZmFsc2U7XG5cbiAgICBjb25zdCBkaWFsb2dTdGF0ZTogRGlhbG9nU3RhdGUgPSB7XG4gICAgICBpZDogY2FsbElkICsgbG9jYWxUYWcgKyByZW1vdGVUYWcsXG4gICAgICBlYXJseSxcbiAgICAgIGNhbGxJZCxcbiAgICAgIGxvY2FsVGFnLFxuICAgICAgcmVtb3RlVGFnLFxuICAgICAgbG9jYWxTZXF1ZW5jZU51bWJlcixcbiAgICAgIHJlbW90ZVNlcXVlbmNlTnVtYmVyLFxuICAgICAgbG9jYWxVUkksXG4gICAgICByZW1vdGVVUkksXG4gICAgICByZW1vdGVUYXJnZXQsXG4gICAgICByb3V0ZVNldCxcbiAgICAgIHNlY3VyZVxuICAgIH07XG4gICAgcmV0dXJuIGRpYWxvZ1N0YXRlO1xuICB9XG5cbiAgcHVibGljIGRlbGVnYXRlOiBTdWJzY3JpcHRpb25EZWxlZ2F0ZSB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIF9hdXRvUmVmcmVzaDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uRXZlbnQ6IHN0cmluZztcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uRXhwaXJlczogbnVtYmVyO1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb25FeHBpcmVzSW5pdGlhbDogbnVtYmVyO1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb25FeHBpcmVzTGFzdFNldDogbnVtYmVyO1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb25SZWZyZXNoOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvblJlZnJlc2hMYXN0U2V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvblN0YXRlOiBTdWJzY3JpcHRpb25TdGF0ZTtcblxuICBwcml2YXRlIGxvZ2dlcjogTG9nZ2VyO1xuICBwcml2YXRlIE46IGFueSB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSByZWZyZXNoVGltZXI6IGFueSB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBzdWJzY3JpcHRpb25FdmVudDogc3RyaW5nLFxuICAgIHN1YnNjcmlwdGlvbkV4cGlyZXM6IG51bWJlcixcbiAgICBzdWJzY3JpcHRpb25TdGF0ZTogU3Vic2NyaXB0aW9uU3RhdGUsXG4gICAgY29yZTogVXNlckFnZW50Q29yZSxcbiAgICBzdGF0ZTogRGlhbG9nU3RhdGUsXG4gICAgZGVsZWdhdGU/OiBTdWJzY3JpcHRpb25EZWxlZ2F0ZVxuICApIHtcbiAgICBzdXBlcihjb3JlLCBzdGF0ZSk7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgIHRoaXMuX2F1dG9SZWZyZXNoID0gZmFsc2U7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRXZlbnQgPSBzdWJzY3JpcHRpb25FdmVudDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25FeHBpcmVzID0gc3Vic2NyaXB0aW9uRXhwaXJlcztcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25FeHBpcmVzSW5pdGlhbCA9IHN1YnNjcmlwdGlvbkV4cGlyZXM7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRXhwaXJlc0xhc3RTZXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25SZWZyZXNoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2hMYXN0U2V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlID0gc3Vic2NyaXB0aW9uU3RhdGU7XG4gICAgdGhpcy5sb2dnZXIgPSBjb3JlLmxvZ2dlckZhY3RvcnkuZ2V0TG9nZ2VyKFwic2lwLnN1YnNjcmliZS1kaWFsb2dcIik7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBTVUJTQ1JJQkUgZGlhbG9nICR7dGhpcy5pZH0gY29uc3RydWN0ZWRgKTtcbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICBpZiAodGhpcy5OKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5OKTtcbiAgICAgIHRoaXMuTiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoVGltZXJDbGVhcigpO1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgU1VCU0NSSUJFIGRpYWxvZyAke3RoaXMuaWR9IGRlc3Ryb3llZGApO1xuICB9XG5cbiAgZ2V0IGF1dG9SZWZyZXNoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9hdXRvUmVmcmVzaDtcbiAgfVxuXG4gIHNldCBhdXRvUmVmcmVzaChhdXRvUmVmcmVzaDogYm9vbGVhbikge1xuICAgIHRoaXMuX2F1dG9SZWZyZXNoID0gdHJ1ZTtcbiAgICB0aGlzLnJlZnJlc2hUaW1lclNldCgpO1xuICB9XG5cbiAgZ2V0IHN1YnNjcmlwdGlvbkV2ZW50KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbkV2ZW50O1xuICB9XG5cbiAgLyoqIE51bWJlciBvZiBzZWNvbmRzIHVudGlsIHN1YnNjcmlwdGlvbiBleHBpcmVzLiAqL1xuICBnZXQgc3Vic2NyaXB0aW9uRXhwaXJlcygpOiBudW1iZXIge1xuICAgIGNvbnN0IHNlY29uZHNTaW5jZUxhc3RTZXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAtIHRoaXMuX3N1YnNjcmlwdGlvbkV4cGlyZXNMYXN0U2V0O1xuICAgIGNvbnN0IHNlY29uZHNVbnRpbEV4cGlyZXMgPSB0aGlzLl9zdWJzY3JpcHRpb25FeHBpcmVzIC0gc2Vjb25kc1NpbmNlTGFzdFNldDtcbiAgICByZXR1cm4gTWF0aC5tYXgoc2Vjb25kc1VudGlsRXhwaXJlcywgMCk7XG4gIH1cblxuICBzZXQgc3Vic2NyaXB0aW9uRXhwaXJlcyhleHBpcmVzOiBudW1iZXIpIHtcbiAgICBpZiAoZXhwaXJlcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGlyZXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVyby5cIik7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkV4cGlyZXMgPSBleHBpcmVzO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkV4cGlyZXNMYXN0U2V0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgaWYgKHRoaXMuYXV0b1JlZnJlc2gpIHtcbiAgICAgIGNvbnN0IHJlZnJlc2ggPSB0aGlzLnN1YnNjcmlwdGlvblJlZnJlc2g7XG4gICAgICBpZiAocmVmcmVzaCA9PT0gdW5kZWZpbmVkIHx8IHJlZnJlc2ggPj0gZXhwaXJlcykge1xuICAgICAgICB0aGlzLnJlZnJlc2hUaW1lclNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBzdWJzY3JpcHRpb25FeHBpcmVzSW5pdGlhbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25FeHBpcmVzSW5pdGlhbDtcbiAgfVxuXG4gIC8qKiBOdW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCBzdWJzY3JpcHRpb24gYXV0byByZWZyZXNoLiAqL1xuICBnZXQgc3Vic2NyaXB0aW9uUmVmcmVzaCgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25SZWZyZXNoID09PSB1bmRlZmluZWQgfHwgdGhpcy5fc3Vic2NyaXB0aW9uUmVmcmVzaExhc3RTZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc2Vjb25kc1NpbmNlTGFzdFNldCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gdGhpcy5fc3Vic2NyaXB0aW9uUmVmcmVzaExhc3RTZXQ7XG4gICAgY29uc3Qgc2Vjb25kc1VudGlsRXhwaXJlcyA9IHRoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2ggLSBzZWNvbmRzU2luY2VMYXN0U2V0O1xuICAgIHJldHVybiBNYXRoLm1heChzZWNvbmRzVW50aWxFeHBpcmVzLCAwKTtcbiAgfVxuXG4gIGdldCBzdWJzY3JpcHRpb25TdGF0ZSgpOiBTdWJzY3JpcHRpb25TdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY2VpdmUgaW4gZGlhbG9nIHJlcXVlc3QgbWVzc2FnZSBmcm9tIHRyYW5zcG9ydC5cbiAgICogQHBhcmFtIG1lc3NhZ2UgLSAgVGhlIGluY29taW5nIHJlcXVlc3QgbWVzc2FnZS5cbiAgICovXG4gIHB1YmxpYyByZWNlaXZlUmVxdWVzdChtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBTVUJTQ1JJQkUgZGlhbG9nICR7dGhpcy5pZH0gcmVjZWl2ZWQgJHttZXNzYWdlLm1ldGhvZH0gcmVxdWVzdGApO1xuXG4gICAgLy8gUmVxdWVzdCB3aXRoaW4gYSBkaWFsb2cgb3V0IG9mIHNlcXVlbmNlIGd1YXJkLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgaWYgKCF0aGlzLnNlcXVlbmNlR3VhcmQobWVzc2FnZSkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgU1VCU0NSSUJFIGRpYWxvZyAke3RoaXMuaWR9IHJlamVjdGVkIG91dCBvZiBvcmRlciAke21lc3NhZ2UubWV0aG9kfSByZXF1ZXN0LmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlcXVlc3Qgd2l0aGluIGEgZGlhbG9nIGNvbW1vbiBwcm9jZXNzaW5nLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgc3VwZXIucmVjZWl2ZVJlcXVlc3QobWVzc2FnZSk7XG5cbiAgICAvLyBTd2l0Y2ggb24gbWV0aG9kIGFuZCB0aGVuIGRlbGVnYXRlLlxuICAgIHN3aXRjaCAobWVzc2FnZS5tZXRob2QpIHtcbiAgICAgIGNhc2UgQy5OT1RJRlk6XG4gICAgICAgIHRoaXMub25Ob3RpZnkobWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBTVUJTQ1JJQkUgZGlhbG9nICR7dGhpcy5pZH0gcmVjZWl2ZWQgdW5pbXBsZW1lbnRlZCAke21lc3NhZ2UubWV0aG9kfSByZXF1ZXN0YCk7XG4gICAgICAgIHRoaXMuY29yZS5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDUwMSB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIDQuMS4yLjIuICBSZWZyZXNoaW5nIG9mIFN1YnNjcmlwdGlvbnNcbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4yXG4gICAqL1xuICBwdWJsaWMgcmVmcmVzaCgpOiBPdXRnb2luZ1N1YnNjcmliZVJlcXVlc3Qge1xuICAgIGNvbnN0IGFsbG93SGVhZGVyID0gXCJBbGxvdzogXCIgKyBBbGxvd2VkTWV0aG9kcy50b1N0cmluZygpO1xuICAgIGNvbnN0IG9wdGlvbnM6IFJlcXVlc3RPcHRpb25zID0ge307XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChhbGxvd0hlYWRlcik7XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkV2ZW50OiBcIiArIHRoaXMuc3Vic2NyaXB0aW9uRXZlbnQpO1xuICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goXCJFeHBpcmVzOiBcIiArIHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlc0luaXRpYWwpO1xuICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goXCJDb250YWN0OiBcIiArIHRoaXMuY29yZS5jb25maWd1cmF0aW9uLmNvbnRhY3QudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogNC4xLjIuMi4gIFJlZnJlc2hpbmcgb2YgU3Vic2NyaXB0aW9uc1xuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjJcbiAgICogQHBhcmFtIGRlbGVnYXRlIC0gRGVsZWdhdGUgdG8gaGFuZGxlIHJlc3BvbnNlcy5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHB1YmxpYyBzdWJzY3JpYmUoXG4gICAgZGVsZWdhdGU/OiBPdXRnb2luZ1N1YnNjcmliZVJlcXVlc3REZWxlZ2F0ZSxcbiAgICBvcHRpb25zOiBSZXF1ZXN0T3B0aW9ucyA9IHt9XG4gICk6IE91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdCB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IFN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmcgJiYgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gU3Vic2NyaXB0aW9uU3RhdGUuQWN0aXZlKSB7XG4gICAgICAvLyBGSVhNRTogVGhpcyBuZWVkcyB0byBiZSBhIHByb3BlciBleGNlcHRpb25cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgc3RhdGUgJHt0aGlzLnN1YnNjcmlwdGlvblN0YXRlfS4gTWF5IG9ubHkgcmUtc3Vic2NyaWJlIHdoaWxlIGluIHN0YXRlIFwicGVuZGluZ1wiIG9yIFwiYWN0aXZlXCIuYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIubG9nKGBTVUJTQ1JJQkUgZGlhbG9nICR7dGhpcy5pZH0gc2VuZGluZyBTVUJTQ1JJQkUgcmVxdWVzdGApO1xuICAgIGNvbnN0IHVhYyA9IG5ldyBSZVN1YnNjcmliZVVzZXJBZ2VudENsaWVudCh0aGlzLCBkZWxlZ2F0ZSwgb3B0aW9ucyk7XG4gICAgLy8gV2hlbiByZWZyZXNoaW5nIGEgc3Vic2NyaXB0aW9uLCBhIHN1YnNjcmliZXIgc3RhcnRzIFRpbWVyIE4sIHNldCB0b1xuICAgIC8vIDY0KlQxLCB3aGVuIGl0IHNlbmRzIHRoZSBTVUJTQ1JJQkUgcmVxdWVzdC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjJcbiAgICB0aGlzLk4gPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMudGltZXJfTigpLCBUaW1lcnMuVElNRVJfTik7XG4gICAgcmV0dXJuIHVhYztcbiAgfVxuXG4gIC8qKlxuICAgKiA0LjQuMS4gIERpYWxvZyBDcmVhdGlvbiBhbmQgVGVybWluYXRpb25cbiAgICogQSBzdWJzY3JpcHRpb24gaXMgZGVzdHJveWVkIGFmdGVyIGEgbm90aWZpZXIgc2VuZHMgYSBOT1RJRlkgcmVxdWVzdFxuICAgKiB3aXRoIGEgXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBvZiBcInRlcm1pbmF0ZWRcIiwgb3IgaW4gY2VydGFpbiBlcnJvclxuICAgKiBzaXR1YXRpb25zIGRlc2NyaWJlZCBlbHNld2hlcmUgaW4gdGhpcyBkb2N1bWVudC5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjQuMVxuICAgKi9cbiAgcHVibGljIHRlcm1pbmF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICB0aGlzLm9uVGVybWluYXRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIDQuMS4yLjMuICBVbnN1YnNjcmliaW5nXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuM1xuICAgKi9cbiAgcHVibGljIHVuc3Vic2NyaWJlKCk6IE91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdCB7XG4gICAgY29uc3QgYWxsb3dIZWFkZXIgPSBcIkFsbG93OiBcIiArIEFsbG93ZWRNZXRob2RzLnRvU3RyaW5nKCk7XG4gICAgY29uc3Qgb3B0aW9uczogUmVxdWVzdE9wdGlvbnMgPSB7fTtcbiAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKGFsbG93SGVhZGVyKTtcbiAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiRXZlbnQ6IFwiICsgdGhpcy5zdWJzY3JpcHRpb25FdmVudCk7XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkV4cGlyZXM6IDBcIik7XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24uY29udGFjdC50b1N0cmluZygpKTtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUodW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgaW4gZGlhbG9nIE5PVElGWSByZXF1ZXN0cy5cbiAgICogVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBmaXJzdCBOT1RJRlkgd2hpY2ggY3JlYXRlZCB0aGUgZGlhbG9nLlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBpbmNvbWluZyBOT1RJRlkgcmVxdWVzdCBtZXNzYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSBvbk5vdGlmeShtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlKTogdm9pZCB7XG4gICAgLy8gSWYsIGZvciBzb21lIHJlYXNvbiwgdGhlIGV2ZW50IHBhY2thZ2UgZGVzaWduYXRlZCBpbiB0aGUgXCJFdmVudFwiXG4gICAgLy8gaGVhZGVyIGZpZWxkIG9mIHRoZSBOT1RJRlkgcmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkLCB0aGUgc3Vic2NyaWJlclxuICAgIC8vIHdpbGwgcmVzcG9uZCB3aXRoIGEgNDg5IChCYWQgRXZlbnQpIHJlc3BvbnNlLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjNcbiAgICBjb25zdCBldmVudDogc3RyaW5nID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcIkV2ZW50XCIpLmV2ZW50O1xuICAgIGlmICghZXZlbnQgfHwgZXZlbnQgIT09IHRoaXMuc3Vic2NyaXB0aW9uRXZlbnQpIHtcbiAgICAgIHRoaXMuY29yZS5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQ4OSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbiB0aGUgc3RhdGUgZGlhZ3JhbSwgXCJSZS1zdWJzY3JpcHRpb24gdGltZXMgb3V0XCIgbWVhbnMgdGhhdCBhblxuICAgIC8vIGF0dGVtcHQgdG8gcmVmcmVzaCBvciB1cGRhdGUgdGhlIHN1YnNjcmlwdGlvbiB1c2luZyBhIG5ldyBTVUJTQ1JJQkVcbiAgICAvLyByZXF1ZXN0IGRvZXMgbm90IHJlc3VsdCBpbiBhIE5PVElGWSByZXF1ZXN0IGJlZm9yZSB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIFRpbWVyIE4gZXhwaXJlcy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yXG4gICAgaWYgKHRoaXMuTikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuTik7XG4gICAgICB0aGlzLk4gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gTk9USUZZIHJlcXVlc3RzIE1VU1QgY29udGFpbiBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIGhlYWRlciBmaWVsZHMgdGhhdFxuICAgIC8vIGluZGljYXRlIHRoZSBzdGF0dXMgb2YgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4zXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uU3RhdGUgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIpO1xuICAgIGlmICghc3Vic2NyaXB0aW9uU3RhdGUgfHwgIXN1YnNjcmlwdGlvblN0YXRlLnN0YXRlKSB7XG4gICAgICB0aGlzLmNvcmUucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0ODkgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlOiBcInBlbmRpbmdcIiB8IFwiYWN0aXZlXCIgfCBcInRlcm1pbmF0ZWRcIiA9IHN1YnNjcmlwdGlvblN0YXRlLnN0YXRlO1xuICAgIGNvbnN0IGV4cGlyZXMgPSBzdWJzY3JpcHRpb25TdGF0ZS5leHBpcmVzID8gTWF0aC5tYXgoc3Vic2NyaXB0aW9uU3RhdGUuZXhwaXJlcywgMCkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBVcGRhdGUgb3VyIHN0YXRlIGFuZCBleHBpcmF0aW9uLlxuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmcsIGV4cGlyZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhY3RpdmVcIjpcbiAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oU3Vic2NyaXB0aW9uU3RhdGUuQWN0aXZlLCBleHBpcmVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidGVybWluYXRlZFwiOlxuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkLCBleHBpcmVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVW5yZWNvZ25pemVkIHN1YnNjcmlwdGlvbiBzdGF0ZS5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIERlbGVnYXRlIHJlbWFpbmRlciBvZiBOT1RJRlkgaGFuZGxpbmcuXG4gICAgY29uc3QgdWFzID0gbmV3IE5vdGlmeVVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5KSB7XG4gICAgICB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5KHVhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVhcy5hY2NlcHQoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uUmVmcmVzaChyZXF1ZXN0OiBPdXRnb2luZ1N1YnNjcmliZVJlcXVlc3QpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uUmVmcmVzaCkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZnJlc2gocmVxdWVzdCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvblRlcm1pbmF0ZWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblRlcm1pbmF0ZWQpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUub25UZXJtaW5hdGVkKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWZyZXNoVGltZXJDbGVhcigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5yZWZyZXNoVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlZnJlc2hUaW1lcik7XG4gICAgICB0aGlzLnJlZnJlc2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlZnJlc2hUaW1lclNldCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlZnJlc2hUaW1lckNsZWFyKCk7XG4gICAgaWYgKHRoaXMuYXV0b1JlZnJlc2ggJiYgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzID4gMCkge1xuICAgICAgY29uc3QgcmVmcmVzaCA9IHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcyAqIDkwMDtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2ggPSBNYXRoLmZsb29yKHJlZnJlc2ggLyAxMDAwKTtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2hMYXN0U2V0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICB0aGlzLnJlZnJlc2hUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnJlZnJlc2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVmcmVzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVmcmVzaExhc3RTZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub25SZWZyZXNoKHRoaXMucmVmcmVzaCgpKTtcbiAgICAgIH0sIHJlZnJlc2gpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGVUcmFuc2l0aW9uKG5ld1N0YXRlOiBTdWJzY3JpcHRpb25TdGF0ZSwgbmV3RXhwaXJlcz86IG51bWJlcik6IHZvaWQge1xuICAgIC8vIEFzc2VydCB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9ucy5cbiAgICBjb25zdCBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgSW52YWxpZCBzdWJzY3JpcHRpb24gc3RhdGUgdHJhbnNpdGlvbiBmcm9tICR7dGhpcy5zdWJzY3JpcHRpb25TdGF0ZX0gdG8gJHtuZXdTdGF0ZX1gKTtcbiAgICB9O1xuXG4gICAgc3dpdGNoIChuZXdTdGF0ZSkge1xuICAgICAgY2FzZSBTdWJzY3JpcHRpb25TdGF0ZS5Jbml0aWFsOlxuICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdDpcbiAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmc6XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBTdWJzY3JpcHRpb25TdGF0ZS5Ob3RpZnlXYWl0ICYmXG4gICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZ1xuICAgICAgICApIHtcbiAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmU6XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBTdWJzY3JpcHRpb25TdGF0ZS5Ob3RpZnlXYWl0ICYmXG4gICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZyAmJlxuICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IFN1YnNjcmlwdGlvblN0YXRlLkFjdGl2ZVxuICAgICAgICApIHtcbiAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdCAmJlxuICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IFN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmcgJiZcbiAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBTdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmVcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIHZhbHVlIGlzIFwicGVuZGluZ1wiLCB0aGUgc3Vic2NyaXB0aW9uIGhhc1xuICAgIC8vIGJlZW4gcmVjZWl2ZWQgYnkgdGhlIG5vdGlmaWVyLCBidXQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IHBvbGljeVxuICAgIC8vIGluZm9ybWF0aW9uIHRvIGdyYW50IG9yIGRlbnkgdGhlIHN1YnNjcmlwdGlvbiB5ZXQuICBJZiB0aGUgaGVhZGVyXG4gICAgLy8gZmllbGQgYWxzbyBjb250YWlucyBhbiBcImV4cGlyZXNcIiBwYXJhbWV0ZXIsIHRoZSBzdWJzY3JpYmVyIFNIT1VMRFxuICAgIC8vIHRha2UgaXQgYXMgdGhlIGF1dGhvcml0YXRpdmUgc3Vic2NyaXB0aW9uIGR1cmF0aW9uIGFuZCBhZGp1c3RcbiAgICAvLyBhY2NvcmRpbmdseS4gIE5vIGZ1cnRoZXIgYWN0aW9uIGlzIG5lY2Vzc2FyeSBvbiB0aGUgcGFydCBvZiB0aGVcbiAgICAvLyBzdWJzY3JpYmVyLiAgVGhlIFwicmV0cnktYWZ0ZXJcIiBhbmQgXCJyZWFzb25cIiBwYXJhbWV0ZXJzIGhhdmUgbm9cbiAgICAvLyBzZW1hbnRpY3MgZm9yIFwicGVuZGluZ1wiLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjNcbiAgICBpZiAobmV3U3RhdGUgPT09IFN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmcpIHtcbiAgICAgIGlmIChuZXdFeHBpcmVzKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcyA9IG5ld0V4cGlyZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIgaGVhZGVyIGZpZWxkIHZhbHVlIGlzIFwiYWN0aXZlXCIsIGl0IG1lYW5zXG4gICAgLy8gdGhhdCB0aGUgc3Vic2NyaXB0aW9uIGhhcyBiZWVuIGFjY2VwdGVkIGFuZCAoaW4gZ2VuZXJhbCkgaGFzIGJlZW5cbiAgICAvLyBhdXRob3JpemVkLiAgSWYgdGhlIGhlYWRlciBmaWVsZCBhbHNvIGNvbnRhaW5zIGFuIFwiZXhwaXJlc1wiXG4gICAgLy8gcGFyYW1ldGVyLCB0aGUgc3Vic2NyaWJlciBTSE9VTEQgdGFrZSBpdCBhcyB0aGUgYXV0aG9yaXRhdGl2ZVxuICAgIC8vIHN1YnNjcmlwdGlvbiBkdXJhdGlvbiBhbmQgYWRqdXN0IGFjY29yZGluZ2x5LiAgVGhlIFwicmV0cnktYWZ0ZXJcIiBhbmRcbiAgICAvLyBcInJlYXNvblwiIHBhcmFtZXRlcnMgaGF2ZSBubyBzZW1hbnRpY3MgZm9yIFwiYWN0aXZlXCIuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuM1xuICAgIGlmIChuZXdTdGF0ZSA9PT0gU3Vic2NyaXB0aW9uU3RhdGUuQWN0aXZlKSB7XG4gICAgICBpZiAobmV3RXhwaXJlcykge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXMgPSBuZXdFeHBpcmVzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIHZhbHVlIGlzIFwidGVybWluYXRlZFwiLCB0aGUgc3Vic2NyaWJlclxuICAgIC8vIE1VU1QgY29uc2lkZXIgdGhlIHN1YnNjcmlwdGlvbiB0ZXJtaW5hdGVkLiAgVGhlIFwiZXhwaXJlc1wiIHBhcmFtZXRlclxuICAgIC8vIGhhcyBubyBzZW1hbnRpY3MgZm9yIFwidGVybWluYXRlZFwiIC0tIG5vdGlmaWVycyBTSE9VTEQgTk9UIGluY2x1ZGUgYW5cbiAgICAvLyBcImV4cGlyZXNcIiBwYXJhbWV0ZXIgb24gYSBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIGhlYWRlciBmaWVsZCB3aXRoIGFcbiAgICAvLyB2YWx1ZSBvZiBcInRlcm1pbmF0ZWRcIiwgYW5kIHN1YnNjcmliZXJzIE1VU1QgaWdub3JlIGFueSBzdWNoXG4gICAgLy8gcGFyYW1ldGVyLCBpZiBwcmVzZW50LlxuICAgIGlmIChuZXdTdGF0ZSA9PT0gU3Vic2NyaXB0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHJlZnJlc2hpbmcgYSBzdWJzY3JpcHRpb24sIGEgc3Vic2NyaWJlciBzdGFydHMgVGltZXIgTiwgc2V0IHRvXG4gICAqIDY0KlQxLCB3aGVuIGl0IHNlbmRzIHRoZSBTVUJTQ1JJQkUgcmVxdWVzdC4gIElmIHRoaXMgVGltZXIgTiBleHBpcmVzXG4gICAqIHByaW9yIHRvIHRoZSByZWNlaXB0IG9mIGEgTk9USUZZIHJlcXVlc3QsIHRoZSBzdWJzY3JpYmVyIGNvbnNpZGVyc1xuICAgKiB0aGUgc3Vic2NyaXB0aW9uIHRlcm1pbmF0ZWQuICBJZiB0aGUgc3Vic2NyaWJlciByZWNlaXZlcyBhIHN1Y2Nlc3NcbiAgICogcmVzcG9uc2UgdG8gdGhlIFNVQlNDUklCRSByZXF1ZXN0IHRoYXQgaW5kaWNhdGVzIHRoYXQgbm8gTk9USUZZXG4gICAqIHJlcXVlc3Qgd2lsbCBiZSBnZW5lcmF0ZWQgLS0gc3VjaCBhcyB0aGUgMjA0IHJlc3BvbnNlIGRlZmluZWQgZm9yIHVzZVxuICAgKiB3aXRoIHRoZSBvcHRpb25hbCBleHRlbnNpb24gZGVzY3JpYmVkIGluIFtSRkM1ODM5XSAtLSB0aGVuIGl0IE1VU1RcbiAgICogY2FuY2VsIFRpbWVyIE4uXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMlxuICAgKi9cbiAgcHJpdmF0ZSB0aW1lcl9OKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBTdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihTdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgIHRoaXMub25UZXJtaW5hdGVkKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEFuIEV4Y2VwdGlvbiBpcyBjb25zaWRlcmVkIGEgY29uZGl0aW9uIHRoYXQgYSByZWFzb25hYmxlIGFwcGxpY2F0aW9uIG1heSB3aXNoIHRvIGNhdGNoLlxuICogQW4gRXJyb3IgaW5kaWNhdGVzIHNlcmlvdXMgcHJvYmxlbXMgdGhhdCBhIHJlYXNvbmFibGUgYXBwbGljYXRpb24gc2hvdWxkIG5vdCB0cnkgdG8gY2F0Y2guXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7IC8vICdFcnJvcicgYnJlYWtzIHByb3RvdHlwZSBjaGFpbiBoZXJlXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW5cbiAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSBcIi4vZXhjZXB0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90cmFuc2FjdGlvbi1zdGF0ZS1lcnJvclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHJhbnNwb3J0LWVycm9yXCI7XG4iLCJpbXBvcnQgeyBFeGNlcHRpb24gfSBmcm9tIFwiLi9leGNlcHRpb25cIjtcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBjb21wbGV0ZWQgZ2l2ZW4gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gc3RhdGUuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvblN0YXRlRXJyb3IgZXh0ZW5kcyBFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSA/IG1lc3NhZ2UgOiBcIlRyYW5zYWN0aW9uIHN0YXRlIGVycm9yLlwiKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXhjZXB0aW9uIH0gZnJvbSBcIi4vZXhjZXB0aW9uXCI7XG5cbi8qKlxuICogVHJhbnNwb3J0IGVycm9yLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVHJhbnNwb3J0RXJyb3IgZXh0ZW5kcyBFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSA/IG1lc3NhZ2UgOiBcIlVuc3BlY2lmaWVkIHRyYW5zcG9ydCBlcnJvci5cIik7XG4gIH1cbn1cbiIsIi8qKlxuICogQSBjb3JlIGxpYnJhcnkgaW1wbGVtZW50aW5nIGxvdyBsZXZlbCBTSVAgcHJvdG9jb2wgZWxlbWVudHMuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG4gLy8gRGlyZWN0b3JpZXNcbmV4cG9ydCAqIGZyb20gXCIuL2RpYWxvZ3NcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2V4Y2VwdGlvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xvZ1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWVzc2FnZXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Nlc3Npb25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N1YnNjcmlwdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHJhbnNhY3Rpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91c2VyLWFnZW50LWNvcmVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3VzZXItYWdlbnRzXCI7XG5cbi8vIEZpbGVzXG5leHBvcnQgKiBmcm9tIFwiLi90aW1lcnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RyYW5zcG9ydFwiO1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vbGV2ZWxzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9sb2dnZXItZmFjdG9yeVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbG9nZ2VyXCI7XG4iLCIvKipcbiAqIExvZyBsZXZlbHMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBlbnVtIExldmVscyB7XG4gIGVycm9yLFxuICB3YXJuLFxuICBsb2csXG4gIGRlYnVnXG59XG4iLCJpbXBvcnQgeyBMZXZlbHMgfSBmcm9tIFwiLi9sZXZlbHNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuL2xvZ2dlclwiO1xuXG4vKipcbiAqIExvZ2dlci5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIExvZ2dlckZhY3Rvcnkge1xuICBwdWJsaWMgYnVpbHRpbkVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHByaXZhdGUgX2xldmVsOiBMZXZlbHMgPSBMZXZlbHMubG9nO1xuICBwcml2YXRlIF9jb25uZWN0b3I6ICgobGV2ZWw6IHN0cmluZywgY2F0ZWdvcnk6IHN0cmluZywgbGFiZWw6IHN0cmluZ8KgfCB1bmRlZmluZWQsIGNvbnRlbnQ6IGFueSkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBsb2dnZXJzOiBhbnkgPSB7fTtcbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxvZ2dlciA9IHRoaXMuZ2V0TG9nZ2VyKFwic2lwOmxvZ2dlcmZhY3RvcnlcIik7XG4gIH1cblxuICBnZXQgbGV2ZWwoKTogTGV2ZWxzIHsgcmV0dXJuIHRoaXMuX2xldmVsOyB9XG4gIHNldCBsZXZlbChuZXdMZXZlbDogTGV2ZWxzKSB7XG4gICAgaWYgKG5ld0xldmVsID49IDAgJiYgbmV3TGV2ZWwgPD0gMykge1xuICAgICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9IGVsc2UgaWYgKG5ld0xldmVsID4gMykge1xuICAgICAgdGhpcy5fbGV2ZWwgPSAzO1xuICAgIH0gZWxzZSBpZiAoTGV2ZWxzLmhhc093blByb3BlcnR5KG5ld0xldmVsKSkge1xuICAgICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJpbnZhbGlkICdsZXZlbCcgcGFyYW1ldGVyIHZhbHVlOiBcIiArIEpTT04uc3RyaW5naWZ5KG5ld0xldmVsKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvbm5lY3RvcigpOiAoKGxldmVsOiBzdHJpbmcsIGNhdGVnb3J5OiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRlbnQ6IGFueSkgPT4gdm9pZCkgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0b3I7XG4gIH1cbiAgc2V0IGNvbm5lY3Rvcih2YWx1ZTogKFxuICAgIChsZXZlbDogc3RyaW5nLCBjYXRlZ29yeTogc3RyaW5nLCBsYWJlbDogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZW50OiBhbnkpID0+IHZvaWRcbiAgKSB8IHVuZGVmaW5lZCkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHRoaXMuX2Nvbm5lY3RvciA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLl9jb25uZWN0b3IgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJpbnZhbGlkICdjb25uZWN0b3InIHBhcmFtZXRlciB2YWx1ZTogXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRMb2dnZXIoY2F0ZWdvcnk6IHN0cmluZywgbGFiZWw/OiBzdHJpbmcpOiBMb2dnZXIge1xuICAgIGlmIChsYWJlbCAmJiB0aGlzLmxldmVsID09PSAzKSB7XG4gICAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLCBjYXRlZ29yeSwgbGFiZWwpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sb2dnZXJzW2NhdGVnb3J5XSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9nZ2Vyc1tjYXRlZ29yeV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodGhpcywgY2F0ZWdvcnkpO1xuICAgICAgdGhpcy5sb2dnZXJzW2NhdGVnb3J5XSA9IGxvZ2dlcjtcbiAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdlbmVyaWNMb2cobGV2ZWxUb0xvZzogTGV2ZWxzLCBjYXRlZ29yeTogc3RyaW5nLCBsYWJlbDogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZW50OiBhbnkpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5sZXZlbCA+PSBsZXZlbFRvTG9nKSB7XG4gICAgICBpZiAodGhpcy5idWlsdGluRW5hYmxlZCkge1xuICAgICAgICB0aGlzLnByaW50KGxldmVsVG9Mb2csIGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29ubmVjdG9yKSB7XG4gICAgICB0aGlzLmNvbm5lY3RvcihMZXZlbHNbbGV2ZWxUb0xvZ10sIGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcmludChsZXZlbFRvTG9nOiBMZXZlbHMsIGNhdGVnb3J5OiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRlbnQ6IGFueSk6IHZvaWQge1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgcHJlZml4OiBBcnJheTxhbnk+ID0gW25ldyBEYXRlKCksIGNhdGVnb3J5XTtcbiAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICBwcmVmaXgucHVzaChsYWJlbCk7XG4gICAgICB9XG4gICAgICBjb250ZW50ID0gcHJlZml4LmNvbmNhdChjb250ZW50KS5qb2luKFwiIHwgXCIpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGxldmVsVG9Mb2cpIHtcbiAgICAgIGNhc2UgTGV2ZWxzLmVycm9yOlxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yKGNvbnRlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGV2ZWxzLndhcm46XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2Fybihjb250ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExldmVscy5sb2c6XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nKGNvbnRlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGV2ZWxzLmRlYnVnOlxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmRlYnVnKGNvbnRlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgTGV2ZWxzIH0gZnJvbSBcIi4vbGV2ZWxzXCI7XG5pbXBvcnQgeyBMb2dnZXJGYWN0b3J5IH0gZnJvbSBcIi4vbG9nZ2VyLWZhY3RvcnlcIjtcblxuLyoqXG4gKiBMb2dnZXIuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dnZXIge1xuICBwcml2YXRlIGxvZ2dlcjogTG9nZ2VyRmFjdG9yeTtcbiAgcHJpdmF0ZSBjYXRlZ29yeTogc3RyaW5nO1xuICBwcml2YXRlIGxhYmVsOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IobG9nZ2VyOiBMb2dnZXJGYWN0b3J5LCBjYXRlZ29yeTogc3RyaW5nLCBsYWJlbD86IHN0cmluZykge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuY2F0ZWdvcnkgPSBjYXRlZ29yeTtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gIH1cblxuICBwdWJsaWMgZXJyb3IoY29udGVudDogc3RyaW5nKTogdm9pZCB7IHRoaXMuZ2VuZXJpY0xvZyhMZXZlbHMuZXJyb3IsIGNvbnRlbnQpOyB9XG4gIHB1YmxpYyB3YXJuKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQgeyB0aGlzLmdlbmVyaWNMb2coTGV2ZWxzLndhcm4sIGNvbnRlbnQpOyB9XG4gIHB1YmxpYyBsb2coY29udGVudDogc3RyaW5nKTogdm9pZCB7IHRoaXMuZ2VuZXJpY0xvZyhMZXZlbHMubG9nLCBjb250ZW50KTsgfVxuICBwdWJsaWMgZGVidWcoY29udGVudDogc3RyaW5nKTogdm9pZCB7IHRoaXMuZ2VuZXJpY0xvZyhMZXZlbHMuZGVidWcsIGNvbnRlbnQpOyB9XG5cbiAgcHJpdmF0ZSBnZW5lcmljTG9nKGxldmVsOiBMZXZlbHMsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMubG9nZ2VyLmdlbmVyaWNMb2cobGV2ZWwsIHRoaXMuY2F0ZWdvcnksIHRoaXMubGFiZWwsIGNvbnRlbnQpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlIH0gZnJvbSBcIi4vaW5jb21pbmctcmVxdWVzdC1tZXNzYWdlXCI7XG5pbXBvcnQgeyBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSB9IGZyb20gXCIuL2luY29taW5nLXJlc3BvbnNlLW1lc3NhZ2VcIjtcbmltcG9ydCB7IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgfSBmcm9tIFwiLi9vdXRnb2luZy1yZXF1ZXN0LW1lc3NhZ2VcIjtcblxuLyoqXG4gKiBNZXNzYWdlIGJvZHkuXG4gKiBAcmVtYXJrc1xuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi03LjRcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCb2R5IHtcbiAgLyoqXG4gICAqIElmIHRoZSBDb250ZW50LURpc3Bvc2l0aW9uIGhlYWRlciBmaWVsZCBpcyBtaXNzaW5nLCBib2RpZXMgb2ZcbiAgICogQ29udGVudC1UeXBlIGFwcGxpY2F0aW9uL3NkcCBpbXBseSB0aGUgZGlzcG9zaXRpb24gXCJzZXNzaW9uXCIsIHdoaWxlXG4gICAqIG90aGVyIGNvbnRlbnQgdHlwZXMgaW1wbHkgXCJyZW5kZXJcIi5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICogRm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHksIGlmIHRoZSBDb250ZW50LURpc3Bvc2l0aW9uIGhlYWRlciBmaWVsZFxuICAgKiBpcyBtaXNzaW5nLCB0aGUgc2VydmVyIFNIT1VMRCBhc3N1bWUgYm9kaWVzIG9mIENvbnRlbnQtVHlwZVxuICAgKiBhcHBsaWNhdGlvbi9zZHAgYXJlIHRoZSBkaXNwb3NpdGlvbiBcInNlc3Npb25cIiwgd2hpbGUgb3RoZXIgY29udGVudFxuICAgKiB0eXBlcyBhcmUgXCJyZW5kZXJcIi5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0yMC4xMVxuICAgKi9cbiAgY29udGVudERpc3Bvc2l0aW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBDb250ZW50LVR5cGUgaGVhZGVyIGZpZWxkIGluZGljYXRlcyB0aGUgbWVkaWEgdHlwZSBvZiB0aGVcbiAgICogbWVzc2FnZS1ib2R5IHNlbnQgdG8gdGhlIHJlY2lwaWVudC4gIFRoZSBDb250ZW50LVR5cGUgaGVhZGVyIGZpZWxkXG4gICAqIE1VU1QgYmUgcHJlc2VudCBpZiB0aGUgYm9keSBpcyBub3QgZW1wdHkuICBJZiB0aGUgYm9keSBpcyBlbXB0eSxcbiAgICogYW5kIGEgQ29udGVudC1UeXBlIGhlYWRlciBmaWVsZCBpcyBwcmVzZW50LCBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgYm9keVxuICAgKiBvZiB0aGUgc3BlY2lmaWMgdHlwZSBoYXMgemVybyBsZW5ndGggKGZvciBleGFtcGxlLCBhbiBlbXB0eSBhdWRpbyBmaWxlKS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0yMC4xNVxuICAgKi9cbiAgY29udGVudFR5cGU6IHN0cmluZztcblxuICAvKipcbiAgICogUmVxdWVzdHMsIGluY2x1ZGluZyBuZXcgcmVxdWVzdHMgZGVmaW5lZCBpbiBleHRlbnNpb25zIHRvIHRoaXNcbiAgICogc3BlY2lmaWNhdGlvbiwgTUFZIGNvbnRhaW4gbWVzc2FnZSBib2RpZXMgdW5sZXNzIG90aGVyd2lzZSBub3RlZC5cbiAgICogVGhlIGludGVycHJldGF0aW9uIG9mIHRoZSBib2R5IGRlcGVuZHMgb24gdGhlIHJlcXVlc3QgbWV0aG9kLlxuICAgKiBGb3IgcmVzcG9uc2UgbWVzc2FnZXMsIHRoZSByZXF1ZXN0IG1ldGhvZCBhbmQgdGhlIHJlc3BvbnNlIHN0YXR1c1xuICAgKiBjb2RlIGRldGVybWluZSB0aGUgdHlwZSBhbmQgaW50ZXJwcmV0YXRpb24gb2YgYW55IG1lc3NhZ2UgYm9keS4gIEFsbFxuICAgKiByZXNwb25zZXMgTUFZIGluY2x1ZGUgYSBib2R5LlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTcuNFxuICAgKi9cbiAgY29udGVudDogc3RyaW5nO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIEJvZHkgZ2l2ZW4gYSBsZWdhY3kgYm9keSB0eXBlLlxuICogQHBhcmFtIGJvZHlMZWdhY3kgLSBCb2R5IE9iamVjdFxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQm9keUxlZ2FjeShib2R5TGVnYWN5OiBzdHJpbmcgfCB7IGJvZHk6IHN0cmluZywgY29udGVudFR5cGU6IHN0cmluZyB9KTogQm9keSB7XG4gIGNvbnN0IGNvbnRlbnQgPSAodHlwZW9mIGJvZHlMZWdhY3kgPT09IFwic3RyaW5nXCIpID8gYm9keUxlZ2FjeSA6IGJvZHlMZWdhY3kuYm9keTtcbiAgY29uc3QgY29udGVudFR5cGUgPSAodHlwZW9mIGJvZHlMZWdhY3kgPT09IFwic3RyaW5nXCIpID8gXCJhcHBsaWNhdGlvbi9zZHBcIiA6IGJvZHlMZWdhY3kuY29udGVudFR5cGU7XG4gIGNvbnN0IGNvbnRlbnREaXNwb3NpdGlvbiA9IGNvbnRlbnRUeXBlVG9Db250ZW50RGlzcG9zaXRpb24oY29udGVudFR5cGUpO1xuICBjb25zdCBib2R5OiBCb2R5ID0geyBjb250ZW50RGlzcG9zaXRpb24sIGNvbnRlbnRUeXBlLCBjb250ZW50IH07XG4gIHJldHVybiBib2R5O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgbWVzc2FnZSwgZ2V0IGEgbm9ybWFsaXplZCBib2R5LlxuICogVGhlIGNvbnRlbnQgZGlzcG9zaXRpb24gaXMgaW5mZXJyZWQgaWYgbm90IHNldC5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvZHkoXG4gIG1lc3NhZ2U6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UgfCBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSB8IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgfCBCb2R5XG4pOiBCb2R5IHwgdW5kZWZpbmVkIHtcbiAgbGV0IGNvbnRlbnREaXNwb3NpdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBsZXQgY29udGVudFR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgbGV0IGNvbnRlbnQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvLyBXZSdyZSBpbiBVQVMgcm9sZSwgcmVjZWl2aW5nIGluY29taW5nIHJlcXVlc3RcbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuYm9keSkge1xuICAgICAgLy8gRklYTUU6IFBhcnNpbmcgbmVlZHMgdHlwaW5nXG4gICAgICBjb25zdCBwYXJzZSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuICAgICAgY29udGVudERpc3Bvc2l0aW9uID0gcGFyc2UgPyBwYXJzZS50eXBlIDogdW5kZWZpbmVkO1xuICAgICAgY29udGVudFR5cGUgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgY29udGVudCA9IG1lc3NhZ2UuYm9keTtcbiAgICB9XG4gIH1cblxuICAvLyBXZSdyZSBpbiBVQUMgcm9sZSwgcmVjZWl2aW5nIGluY29taW5nIHJlc3BvbnNlXG4gIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5ib2R5KSB7XG4gICAgICAvLyBGSVhNRTogUGFyc2luZyBuZWVkcyB0eXBpbmdcbiAgICAgIGNvbnN0IHBhcnNlID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gICAgICBjb250ZW50RGlzcG9zaXRpb24gPSBwYXJzZSA/IHBhcnNlLnR5cGUgOiB1bmRlZmluZWQ7XG4gICAgICBjb250ZW50VHlwZSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICBjb250ZW50ID0gbWVzc2FnZS5ib2R5O1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlJ3JlIGluIFVBQyByb2xlLCBzZW5kaW5nIG91dGdvaW5nIHJlcXVlc3RcbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuYm9keSkge1xuICAgICAgY29udGVudERpc3Bvc2l0aW9uID0gbWVzc2FnZS5nZXRIZWFkZXIoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuICAgICAgY29udGVudFR5cGUgPSBtZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEZJWE1FOiBPdXRnb2luZ1JlcXVlc3Qgc2hvdWxkIG5vdCBhbGxvdyBhIFwic3RyaW5nXCIgYm9keSB3aXRob3V0IGEgXCJDb250ZW50LVR5cGVcIiBoZWFkZXIuXG4gICAgICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXIgY29udGVudCB0eXBlIGhlYWRlciBkb2VzIG5vdCBlcXVhbCBib2R5IGNvbnRlbnQgdHlwZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IG1lc3NhZ2UuYm9keTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZJWE1FOiBPdXRnb2luZ1JlcXVlc3Qgc2hvdWxkIG5vdCBhbGxvdyB0aGUgXCJDb250ZW50LVR5cGVcIiBoZWFkZXIgbm90IHRvIG1hdGNoIHRoIGJvZHkgY29udGVudCB0eXBlXG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZSAhPT0gbWVzc2FnZS5ib2R5LmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVyIGNvbnRlbnQgdHlwZSBoZWFkZXIgZG9lcyBub3QgZXF1YWwgYm9keSBjb250ZW50IHR5cGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnRUeXBlID0gbWVzc2FnZS5ib2R5LmNvbnRlbnRUeXBlO1xuICAgICAgICBjb250ZW50ID0gbWVzc2FnZS5ib2R5LmJvZHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2UncmUgaW4gVUFTIHJvbGUsIHNlbmRpbmcgb3V0Z29pbmcgcmVzcG9uc2VcbiAgaWYgKGlzQm9keShtZXNzYWdlKSkge1xuICAgIGNvbnRlbnREaXNwb3NpdGlvbiA9IG1lc3NhZ2UuY29udGVudERpc3Bvc2l0aW9uO1xuICAgIGNvbnRlbnRUeXBlID0gbWVzc2FnZS5jb250ZW50VHlwZTtcbiAgICBjb250ZW50ID0gbWVzc2FnZS5jb250ZW50O1xuICB9XG5cbiAgLy8gTm8gY29udGVudCwgbm8gYm9keS5cbiAgaWYgKCFjb250ZW50KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChjb250ZW50VHlwZSAmJiAhY29udGVudERpc3Bvc2l0aW9uKSB7XG4gICAgY29udGVudERpc3Bvc2l0aW9uID0gY29udGVudFR5cGVUb0NvbnRlbnREaXNwb3NpdGlvbihjb250ZW50VHlwZSk7XG4gIH1cbiAgaWYgKCFjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZW50IGRpc3Bvc2l0aW9uIHVuZGVmaW5lZC5cIik7XG4gIH1cbiAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRlbnQgdHlwZSB1bmRlZmluZWQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb250ZW50RGlzcG9zaXRpb24sXG4gICAgY29udGVudFR5cGUsXG4gICAgY29udGVudFxuICB9O1xufVxuXG4vKipcbiAqIFVzZXItRGVmaW5lZCBUeXBlIEd1YXJkIGZvciBCb2R5LlxuICogQHBhcmFtIGJvZHkgLSBCb2R5IHRvIGNoZWNrLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0JvZHkoYm9keTogYW55KTogYm9keSBpcyBCb2R5IHtcbiAgcmV0dXJuIGJvZHkgJiZcbiAgICB0eXBlb2YgYm9keS5jb250ZW50ID09PSBcInN0cmluZ1wiICYmXG4gICAgdHlwZW9mIGJvZHkuY29udGVudFR5cGUgPT09IFwic3RyaW5nXCIgJiZcbiAgICBib2R5LmNvbnRlbnREaXNwb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHR5cGVvZiBib2R5LmNvbnRlbnREaXNwb3NpdGlvbiA9PT0gXCJzdHJpbmdcIjtcbn1cblxuLy8gSWYgdGhlIENvbnRlbnQtRGlzcG9zaXRpb24gaGVhZGVyIGZpZWxkIGlzIG1pc3NpbmcsIGJvZGllcyBvZlxuLy8gQ29udGVudC1UeXBlIGFwcGxpY2F0aW9uL3NkcCBpbXBseSB0aGUgZGlzcG9zaXRpb24gXCJzZXNzaW9uXCIsIHdoaWxlXG4vLyBvdGhlciBjb250ZW50IHR5cGVzIGltcGx5IFwicmVuZGVyXCIuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuZnVuY3Rpb24gY29udGVudFR5cGVUb0NvbnRlbnREaXNwb3NpdGlvbihjb250ZW50VHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKGNvbnRlbnRUeXBlID09PSBcImFwcGxpY2F0aW9uL3NkcFwiKSB7XG4gICAgcmV0dXJuIFwic2Vzc2lvblwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcInJlbmRlclwiO1xuICB9XG59XG4iLCJpbXBvcnQgTUQ1IGZyb20gXCJjcnlwdG8tanMvbWQ1XCI7XG5cbmltcG9ydCB7IExvZ2dlciwgTG9nZ2VyRmFjdG9yeSB9IGZyb20gXCIuLi9sb2dcIjtcbmltcG9ydCB7IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgfSBmcm9tIFwiLi9vdXRnb2luZy1yZXF1ZXN0LW1lc3NhZ2VcIjtcbmltcG9ydCB7IFVSSSB9IGZyb20gXCIuL3VyaVwiO1xuaW1wb3J0IHsgY3JlYXRlUmFuZG9tVG9rZW4gfSBmcm9tIFwiLi91dGlsc1wiO1xuXG4vKipcbiAqIERpZ2VzdCBBdXRoZW50aWNhdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgRGlnZXN0QXV0aGVudGljYXRpb24ge1xuICBwdWJsaWMgc3RhbGU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcbiAgcHJpdmF0ZSB1c2VybmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIHBhc3N3b3JkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgY25vbmNlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgbmM6IG51bWJlcjtcbiAgcHJpdmF0ZSBuY0hleDogc3RyaW5nO1xuICBwcml2YXRlIHJlc3BvbnNlOiBhbnkgfCB1bmRlZmluZWQ7IC8vIENyeXB0b0pTLldvcmRBcnJheVxuICBwcml2YXRlIGFsZ29yaXRobTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIHJlYWxtOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgbm9uY2U6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBvcGFxdWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBxb3A6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBtZXRob2Q6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSB1cmk6IHN0cmluZyB8IFVSSSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSBsb2dnZXJGYWN0b3J5IC0gTG9nZ2VyRmFjdG9yeS5cbiAgICogQHBhcmFtIHVzZXJuYW1lIC0gVXNlcm5hbWUuXG4gICAqIEBwYXJhbSBwYXNzd29yZCAtIFBhc3N3b3JkLlxuICAgKi9cbiAgY29uc3RydWN0b3IobG9nZ2VyRmFjdG9yeTogTG9nZ2VyRmFjdG9yeSwgdXNlcm5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgcGFzc3dvcmQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyRmFjdG9yeS5nZXRMb2dnZXIoXCJzaXBqcy5kaWdlc3RhdXRoZW50aWNhdGlvblwiKTtcbiAgICB0aGlzLnVzZXJuYW1lID0gdXNlcm5hbWU7XG4gICAgdGhpcy5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgIHRoaXMubmMgPSAwO1xuICAgIHRoaXMubmNIZXggPSBcIjAwMDAwMDAwXCI7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgRGlnZXN0IGF1dGhlbnRpY2F0aW9uIGdpdmVuIGEgU0lQIHJlcXVlc3QgYW5kIHRoZSBjaGFsbGVuZ2VcbiAgICogcmVjZWl2ZWQgaW4gYSByZXNwb25zZSB0byB0aGF0IHJlcXVlc3QuXG4gICAqIEBwYXJhbSByZXF1ZXN0IC1cbiAgICogQHBhcmFtIGNoYWxsZW5nZSAtXG4gICAqIEByZXR1cm5zIHRydWUgaWYgY3JlZGVudGlhbHMgd2VyZSBzdWNjZXNzZnVsbHkgZ2VuZXJhdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBwdWJsaWMgYXV0aGVudGljYXRlKHJlcXVlc3Q6IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UsIGNoYWxsZW5nZTogYW55LCBib2R5Pzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gSW5zcGVjdCBhbmQgdmFsaWRhdGUgdGhlIGNoYWxsZW5nZS5cblxuICAgIHRoaXMuYWxnb3JpdGhtID0gY2hhbGxlbmdlLmFsZ29yaXRobTtcbiAgICB0aGlzLnJlYWxtID0gY2hhbGxlbmdlLnJlYWxtO1xuICAgIHRoaXMubm9uY2UgPSBjaGFsbGVuZ2Uubm9uY2U7XG4gICAgdGhpcy5vcGFxdWUgPSBjaGFsbGVuZ2Uub3BhcXVlO1xuICAgIHRoaXMuc3RhbGUgPSBjaGFsbGVuZ2Uuc3RhbGU7XG5cbiAgICBpZiAodGhpcy5hbGdvcml0aG0pIHtcbiAgICAgIGlmICh0aGlzLmFsZ29yaXRobSAhPT0gXCJNRDVcIikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiY2hhbGxlbmdlIHdpdGggRGlnZXN0IGFsZ29yaXRobSBkaWZmZXJlbnQgdGhhbiAnTUQ1JywgYXV0aGVudGljYXRpb24gYWJvcnRlZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFsZ29yaXRobSA9IFwiTUQ1XCI7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJlYWxtKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiY2hhbGxlbmdlIHdpdGhvdXQgRGlnZXN0IHJlYWxtLCBhdXRoZW50aWNhdGlvbiBhYm9ydGVkXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghIHRoaXMubm9uY2UpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJjaGFsbGVuZ2Ugd2l0aG91dCBEaWdlc3Qgbm9uY2UsIGF1dGhlbnRpY2F0aW9uIGFib3J0ZWRcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gJ3FvcCcgY2FuIGNvbnRhaW4gYSBsaXN0IG9mIHZhbHVlcyAoQXJyYXkpLiBMZXQncyBjaG9vc2UganVzdCBvbmUuXG4gICAgaWYgKGNoYWxsZW5nZS5xb3ApIHtcbiAgICAgIGlmIChjaGFsbGVuZ2UucW9wLmluZGV4T2YoXCJhdXRoXCIpID4gLTEpIHtcbiAgICAgICAgdGhpcy5xb3AgPSBcImF1dGhcIjtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbGxlbmdlLnFvcC5pbmRleE9mKFwiYXV0aC1pbnRcIikgPiAtMSkge1xuICAgICAgICB0aGlzLnFvcCA9IFwiYXV0aC1pbnRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSAncW9wJyBpcyBwcmVzZW50IGJ1dCBkb2VzIG5vdCBjb250YWluICdhdXRoJyBvciAnYXV0aC1pbnQnLCBzbyBhYm9ydCBoZXJlLlxuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiY2hhbGxlbmdlIHdpdGhvdXQgRGlnZXN0IHFvcCBkaWZmZXJlbnQgdGhhbiAnYXV0aCcgb3IgJ2F1dGgtaW50JywgYXV0aGVudGljYXRpb24gYWJvcnRlZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnFvcCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBGaWxsIG90aGVyIGF0dHJpYnV0ZXMuXG5cbiAgICB0aGlzLm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIHRoaXMudXJpID0gcmVxdWVzdC5ydXJpO1xuICAgIHRoaXMuY25vbmNlID0gY3JlYXRlUmFuZG9tVG9rZW4oMTIpO1xuICAgIHRoaXMubmMgKz0gMTtcbiAgICB0aGlzLnVwZGF0ZU5jSGV4KCk7XG5cbiAgICAvLyBuYy12YWx1ZSA9IDhMSEVYLiBNYXggdmFsdWUgPSAnRkZGRkZGRkYnLlxuICAgIGlmICh0aGlzLm5jID09PSA0Mjk0OTY3Mjk2KSB7XG4gICAgICB0aGlzLm5jID0gMTtcbiAgICAgIHRoaXMubmNIZXggPSBcIjAwMDAwMDAxXCI7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBEaWdlc3QgXCJyZXNwb25zZVwiIHZhbHVlLlxuICAgIHRoaXMuY2FsY3VsYXRlUmVzcG9uc2UoYm9keSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIFByb3h5LUF1dGhvcml6YXRpb24gb3IgV1dXLUF1dGhvcml6YXRpb24gaGVhZGVyIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3QgYXV0aFBhcmFtczogQXJyYXk8c3RyaW5nPiA9IFtdO1xuXG4gICAgaWYgKCEgdGhpcy5yZXNwb25zZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzcG9uc2UgZmllbGQgZG9lcyBub3QgZXhpc3QsIGNhbm5vdCBnZW5lcmF0ZSBBdXRob3JpemF0aW9uIGhlYWRlclwiKTtcbiAgICB9XG5cbiAgICBhdXRoUGFyYW1zLnB1c2goXCJhbGdvcml0aG09XCIgKyB0aGlzLmFsZ29yaXRobSk7XG4gICAgYXV0aFBhcmFtcy5wdXNoKCd1c2VybmFtZT1cIicgKyB0aGlzLnVzZXJuYW1lICsgJ1wiJyk7XG4gICAgYXV0aFBhcmFtcy5wdXNoKCdyZWFsbT1cIicgKyB0aGlzLnJlYWxtICsgJ1wiJyk7XG4gICAgYXV0aFBhcmFtcy5wdXNoKCdub25jZT1cIicgKyB0aGlzLm5vbmNlICsgJ1wiJyk7XG4gICAgYXV0aFBhcmFtcy5wdXNoKCd1cmk9XCInICsgdGhpcy51cmkgKyAnXCInKTtcbiAgICBhdXRoUGFyYW1zLnB1c2goJ3Jlc3BvbnNlPVwiJyArIHRoaXMucmVzcG9uc2UgKyAnXCInKTtcbiAgICBpZiAodGhpcy5vcGFxdWUpIHtcbiAgICAgIGF1dGhQYXJhbXMucHVzaCgnb3BhcXVlPVwiJyArIHRoaXMub3BhcXVlICsgJ1wiJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnFvcCkge1xuICAgICAgYXV0aFBhcmFtcy5wdXNoKFwicW9wPVwiICsgdGhpcy5xb3ApO1xuICAgICAgYXV0aFBhcmFtcy5wdXNoKCdjbm9uY2U9XCInICsgdGhpcy5jbm9uY2UgKyAnXCInKTtcbiAgICAgIGF1dGhQYXJhbXMucHVzaChcIm5jPVwiICsgdGhpcy5uY0hleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiRGlnZXN0IFwiICsgYXV0aFBhcmFtcy5qb2luKFwiLCBcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHRoZSAnbmMnIHZhbHVlIGFzIHJlcXVpcmVkIGJ5IERpZ2VzdCBpbiB0aGlzLm5jSGV4IGJ5IHJlYWRpbmcgdGhpcy5uYy5cbiAgICovXG4gIHByaXZhdGUgdXBkYXRlTmNIZXgoKTogdm9pZCB7XG4gICAgY29uc3QgaGV4ID0gTnVtYmVyKHRoaXMubmMpLnRvU3RyaW5nKDE2KTtcbiAgICB0aGlzLm5jSGV4ID0gXCIwMDAwMDAwMFwiLnN1YnN0cigwLCA4IC0gaGV4Lmxlbmd0aCkgKyBoZXg7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgRGlnZXN0ICdyZXNwb25zZScgdmFsdWUuXG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZVJlc3BvbnNlKGJvZHk/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsZXQgaGEyO1xuXG4gICAgLy8gSEExID0gTUQ1KEExKSA9IE1ENSh1c2VybmFtZTpyZWFsbTpwYXNzd29yZClcbiAgICBjb25zdCBoYTEgPSBNRDUodGhpcy51c2VybmFtZSArIFwiOlwiICsgdGhpcy5yZWFsbSArIFwiOlwiICsgdGhpcy5wYXNzd29yZCk7XG5cbiAgICBpZiAodGhpcy5xb3AgPT09IFwiYXV0aFwiKSB7XG4gICAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkkpXG4gICAgICBoYTIgPSBNRDUodGhpcy5tZXRob2QgKyBcIjpcIiArIHRoaXMudXJpKTtcbiAgICAgIC8vIHJlc3BvbnNlID0gTUQ1KEhBMTpub25jZTpub25jZUNvdW50OmNyZWRlbnRpYWxzTm9uY2U6cW9wOkhBMilcbiAgICAgIHRoaXMucmVzcG9uc2UgPSBNRDUoaGExICsgXCI6XCIgKyB0aGlzLm5vbmNlICsgXCI6XCIgKyB0aGlzLm5jSGV4ICsgXCI6XCIgKyB0aGlzLmNub25jZSArIFwiOmF1dGg6XCIgKyBoYTIpO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLnFvcCA9PT0gXCJhdXRoLWludFwiKSB7XG4gICAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkk6TUQ1KGVudGl0eUJvZHkpKVxuICAgICAgaGEyID0gTUQ1KHRoaXMubWV0aG9kICsgXCI6XCIgKyB0aGlzLnVyaSArIFwiOlwiICsgTUQ1KGJvZHkgPyBib2R5IDogXCJcIikpO1xuICAgICAgLy8gcmVzcG9uc2UgPSBNRDUoSEExOm5vbmNlOm5vbmNlQ291bnQ6Y3JlZGVudGlhbHNOb25jZTpxb3A6SEEyKVxuICAgICAgdGhpcy5yZXNwb25zZSA9IE1ENShoYTEgKyBcIjpcIiArIHRoaXMubm9uY2UgKyBcIjpcIiArIHRoaXMubmNIZXggKyBcIjpcIiArIHRoaXMuY25vbmNlICsgXCI6YXV0aC1pbnQ6XCIgKyBoYTIpO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLnFvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkkpXG4gICAgICBoYTIgPSBNRDUodGhpcy5tZXRob2QgKyBcIjpcIiArIHRoaXMudXJpKTtcbiAgICAgIC8vIHJlc3BvbnNlID0gTUQ1KEhBMTpub25jZTpIQTIpXG4gICAgICB0aGlzLnJlc3BvbnNlID0gTUQ1KGhhMSArIFwiOlwiICsgdGhpcy5ub25jZSArIFwiOlwiICsgaGEyKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHBlZ0dyYW1tYXIgZnJvbSBcIi4uLy4uL2dyYW1tYXIvZGlzdC9ncmFtbWFyXCI7XG5cbmltcG9ydCB7IE5hbWVBZGRySGVhZGVyIH0gZnJvbSBcIi4vbmFtZS1hZGRyLWhlYWRlclwiO1xuaW1wb3J0IHsgVVJJIH0gZnJvbSBcIi4vdXJpXCI7XG5cbi8qKlxuICogR3JhbW1hci5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgbmFtZXNwYWNlIEdyYW1tYXIge1xuXG4gIC8qKlxuICAgKiBQYXJzZS5cbiAgICogQHBhcmFtIGlucHV0IC1cbiAgICogQHBhcmFtIHN0YXJ0UnVsZSAtXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcGFyc2UoaW5wdXQ6IHN0cmluZywgc3RhcnRSdWxlOiBzdHJpbmcpOiBhbnkge1xuICAgIGNvbnN0IG9wdGlvbnM6IGFueSA9IHtzdGFydFJ1bGV9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHBlZ0dyYW1tYXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9wdGlvbnMuZGF0YSA9IC0xO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgYSBTSVAuTmFtZUFkZHJIZWFkZXIgaW5zdGFuY2Ugb3IgdW5kZWZpbmVkIGlmXG4gICAqIGl0IGlzIGFuIGludmFsaWQgTmFtZUFkZHJIZWFkZXIuXG4gICAqIEBwYXJhbSBuYW1lX2FkZHJfaGVhZGVyIC1cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBuYW1lQWRkckhlYWRlclBhcnNlKG5hbWVBZGRySGVhZGVyOiBzdHJpbmcpOiBOYW1lQWRkckhlYWRlciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGFyc2VkTmFtZUFkZHJIZWFkZXI6IGFueSA9IEdyYW1tYXIucGFyc2UobmFtZUFkZHJIZWFkZXIsIFwiTmFtZV9BZGRyX0hlYWRlclwiKTtcblxuICAgIHJldHVybiBwYXJzZWROYW1lQWRkckhlYWRlciAhPT0gLTEgPyAocGFyc2VkTmFtZUFkZHJIZWFkZXIgYXMgTmFtZUFkZHJIZWFkZXIpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgYSBTSVAuVVJJIGluc3RhbmNlIG9yIHVuZGVmaW5lZCBpZlxuICAgKiBpdCBpcyBhbiBpbnZhbGlkIFVSSS5cbiAgICogQHBhcmFtIHVyaSAtXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gVVJJUGFyc2UodXJpOiBzdHJpbmcpOiBVUkkgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBhcnNlZFVyaTogYW55ID0gR3JhbW1hci5wYXJzZSh1cmksIFwiU0lQX1VSSVwiKTtcblxuICAgIHJldHVybiBwYXJzZWRVcmkgIT09IC0xID8gKHBhcnNlZFVyaSBhcyBVUkkpIDogdW5kZWZpbmVkO1xuICB9XG59XG4iLCJpbXBvcnQgeyBHcmFtbWFyIH0gZnJvbSBcIi4vZ3JhbW1hclwiO1xuaW1wb3J0IHsgTmFtZUFkZHJIZWFkZXIgfSBmcm9tIFwiLi9uYW1lLWFkZHItaGVhZGVyXCI7XG5pbXBvcnQgeyBoZWFkZXJpemUgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG4vKipcbiAqIEluY29taW5nIG1lc3NhZ2UuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmNvbWluZ01lc3NhZ2Uge1xuICBwdWJsaWMgdmlhQnJhbmNoITogc3RyaW5nO1xuICBwdWJsaWMgbWV0aG9kITogc3RyaW5nO1xuICBwdWJsaWMgYm9keSE6IHN0cmluZztcbiAgcHVibGljIHRvVGFnITogc3RyaW5nO1xuICBwdWJsaWMgdG8hOiBOYW1lQWRkckhlYWRlcjtcbiAgcHVibGljIGZyb21UYWchOiBzdHJpbmc7XG4gIHB1YmxpYyBmcm9tITogTmFtZUFkZHJIZWFkZXI7XG4gIHB1YmxpYyBjYWxsSWQhOiBzdHJpbmc7XG4gIHB1YmxpYyBjc2VxITogbnVtYmVyO1xuICBwdWJsaWMgdmlhIToge2hvc3Q6IHN0cmluZywgcG9ydDogbnVtYmVyfTtcbiAgcHVibGljIGhlYWRlcnM6IHtbbmFtZTogc3RyaW5nXTogQXJyYXk8eyBwYXJzZWQ/OiBhbnksIHJhdzogc3RyaW5nIH0+fSA9IHt9O1xuICBwdWJsaWMgcmVmZXJUbzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgZGF0YSE6IHN0cmluZztcblxuICAvKipcbiAgICogSW5zZXJ0IGEgaGVhZGVyIG9mIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZSBpbnRvIHRoZSBsYXN0IHBvc2l0aW9uIG9mIHRoZVxuICAgKiBoZWFkZXIgYXJyYXkuXG4gICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICogQHBhcmFtIHZhbHVlIC0gaGVhZGVyIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgYWRkSGVhZGVyKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGhlYWRlciA9IHsgcmF3OiB2YWx1ZSB9O1xuICAgIG5hbWUgPSBoZWFkZXJpemUobmFtZSk7XG5cbiAgICBpZiAodGhpcy5oZWFkZXJzW25hbWVdKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbmFtZV0ucHVzaChoZWFkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbmFtZV0gPSBbaGVhZGVyXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyIG5hbWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHNwZWNpZmllZCBoZWFkZXIsIHVuZGVmaW5lZCBpZiBoZWFkZXIgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBnZXRIZWFkZXIobmFtZTogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbaGVhZGVyaXplKG5hbWUpXTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGlmIChoZWFkZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlclswXS5yYXc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBoZWFkZXIvcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyBBcnJheSAtIHdpdGggYWxsIHRoZSBoZWFkZXJzIG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICovXG4gIHB1YmxpYyBnZXRIZWFkZXJzKG5hbWU6IHN0cmluZyk6IEFycmF5PHN0cmluZz4ge1xuICAgIGNvbnN0IGhlYWRlcjogQXJyYXk8YW55PiA9IHRoaXMuaGVhZGVyc1toZWFkZXJpemUobmFtZSldO1xuICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuXG4gICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBoZWFkZXJQYXJ0IG9mIGhlYWRlcikge1xuICAgICAgcmVzdWx0LnB1c2goaGVhZGVyUGFydC5yYXcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGUgZXhpc3RlbmNlIG9mIHRoZSBnaXZlbiBoZWFkZXIuXG4gICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBoZWFkZXIgd2l0aCBnaXZlbiBuYW1lIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBwdWJsaWMgaGFzSGVhZGVyKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuaGVhZGVyc1toZWFkZXJpemUobmFtZSldO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgb24gdGhlIGdpdmVuIGluZGV4LlxuICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAqIEBwYXJhbSBpZHggLSBoZWFkZXIgaW5kZXhcbiAgICogQHJldHVybnMgUGFyc2VkIGhlYWRlciBvYmplY3QsIHVuZGVmaW5lZCBpZiB0aGVcbiAgICogICBoZWFkZXIgaXMgbm90IHByZXNlbnQgb3IgaW4gY2FzZSBvZiBhIHBhcnNpbmcgZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgcGFyc2VIZWFkZXIobmFtZTogc3RyaW5nLCBpZHg6IG51bWJlciA9IDApOiBhbnkgfCB1bmRlZmluZWQge1xuICAgIG5hbWUgPSBoZWFkZXJpemUobmFtZSk7XG5cbiAgICBpZiAoIXRoaXMuaGVhZGVyc1tuYW1lXSkge1xuICAgICAgLy8gdGhpcy5sb2dnZXIubG9nKFwiaGVhZGVyICdcIiArIG5hbWUgKyBcIicgbm90IHByZXNlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpZHggPj0gdGhpcy5oZWFkZXJzW25hbWVdLmxlbmd0aCkge1xuICAgICAgLy8gdGhpcy5sb2dnZXIubG9nKFwibm90IHNvIG1hbnkgJ1wiICsgbmFtZSArIFwiJyBoZWFkZXJzIHByZXNlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGVyID0gdGhpcy5oZWFkZXJzW25hbWVdW2lkeF07XG4gICAgY29uc3QgdmFsdWUgPSBoZWFkZXIucmF3O1xuXG4gICAgaWYgKGhlYWRlci5wYXJzZWQpIHtcbiAgICAgIHJldHVybiBoZWFkZXIucGFyc2VkO1xuICAgIH1cblxuICAgIC8vIHN1YnN0aXR1dGUgJy0nIGJ5ICdfJyBmb3IgZ3JhbW1hciBydWxlIG1hdGNoaW5nLlxuICAgIGNvbnN0IHBhcnNlZDogc3RyaW5nIHwgLTEgPSBHcmFtbWFyLnBhcnNlKHZhbHVlLCBuYW1lLnJlcGxhY2UoLy0vZywgXCJfXCIpKTtcblxuICAgIGlmIChwYXJzZWQgPT09IC0xKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbmFtZV0uc3BsaWNlKGlkeCwgMSk7IC8vIGRlbGV0ZSBmcm9tIGhlYWRlcnNcbiAgICAgIC8vIHRoaXMubG9nZ2VyLndhcm4oJ2Vycm9yIHBhcnNpbmcgXCInICsgbmFtZSArICdcIiBoZWFkZXIgZmllbGQgd2l0aCB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIicpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIucGFyc2VkID0gcGFyc2VkO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWVzc2FnZSBIZWFkZXIgYXR0cmlidXRlIHNlbGVjdG9yLiBBbGlhcyBvZiBwYXJzZUhlYWRlci5cbiAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgKiBAcGFyYW0gaWR4IC0gaGVhZGVyIGluZGV4XG4gICAqIEByZXR1cm5zIFBhcnNlZCBoZWFkZXIgb2JqZWN0LCB1bmRlZmluZWQgaWYgdGhlXG4gICAqICAgaGVhZGVyIGlzIG5vdCBwcmVzZW50IG9yIGluIGNhc2Ugb2YgYSBwYXJzaW5nIGVycm9yLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBtZXNzYWdlLnMoJ3ZpYScsMykucG9ydFxuICAgKi9cbiAgcHVibGljIHMobmFtZTogc3RyaW5nLCBpZHg6IG51bWJlciA9IDApOiBhbnkgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnBhcnNlSGVhZGVyKG5hbWUsIGlkeCk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGhlYWRlciBieSB0aGUgdmFsdWUuXG4gICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICogQHBhcmFtIHZhbHVlIC0gaGVhZGVyIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgc2V0SGVhZGVyKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuaGVhZGVyc1toZWFkZXJpemUobmFtZSldID0gW3sgcmF3OiB2YWx1ZSB9XTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cbiIsImltcG9ydCB7IFVSSSB9IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgSW5jb21pbmdNZXNzYWdlIH0gZnJvbSBcIi4vaW5jb21pbmctbWVzc2FnZVwiO1xuXG4vKipcbiAqIEluY29taW5nIHJlcXVlc3QgbWVzc2FnZS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEluY29taW5nUmVxdWVzdE1lc3NhZ2UgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICBwdWJsaWMgcnVyaTogVVJJIHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluY29taW5nTWVzc2FnZSB9IGZyb20gXCIuL2luY29taW5nLW1lc3NhZ2VcIjtcblxuLyoqXG4gKiBJbmNvbWluZyByZXNwb25zZSBtZXNzYWdlLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICBwdWJsaWMgc3RhdHVzQ29kZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgcmVhc29uUGhyYXNlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuIiwiLy8gRGlyZWN0b3JpZXNcbmV4cG9ydCAqIGZyb20gXCIuL21ldGhvZHNcIjtcblxuLy8gRmlsZXNcbmV4cG9ydCAqIGZyb20gXCIuL2JvZHlcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RpZ2VzdC1hdXRoZW50aWNhdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vZ3JhbW1hclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW5jb21pbmctbWVzc2FnZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW5jb21pbmctcmVxdWVzdC1tZXNzYWdlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbmNvbWluZy1yZXF1ZXN0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbmNvbWluZy1yZXNwb25zZS1tZXNzYWdlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbmNvbWluZy1yZXNwb25zZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbmFtZS1hZGRyLWhlYWRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vb3V0Z29pbmctcmVxdWVzdC1tZXNzYWdlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9vdXRnb2luZy1yZXF1ZXN0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9vdXRnb2luZy1yZXNwb25zZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcGFyYW1ldGVyc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vcGFyc2VyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91cmlcIjtcbiIsIi8qKlxuICogU0lQIE1ldGhvZHNcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgbmFtZXNwYWNlIEMge1xuICBleHBvcnQgY29uc3QgQUNLID0gXCJBQ0tcIjtcbiAgZXhwb3J0IGNvbnN0IEJZRSA9IFwiQllFXCI7XG4gIGV4cG9ydCBjb25zdCBDQU5DRUwgPSBcIkNBTkNFTFwiO1xuICBleHBvcnQgY29uc3QgSU5GTyA9IFwiSU5GT1wiO1xuICBleHBvcnQgY29uc3QgSU5WSVRFID0gXCJJTlZJVEVcIjtcbiAgZXhwb3J0IGNvbnN0IE1FU1NBR0UgPSBcIk1FU1NBR0VcIjtcbiAgZXhwb3J0IGNvbnN0IE5PVElGWSA9IFwiTk9USUZZXCI7XG4gIGV4cG9ydCBjb25zdCBPUFRJT05TID0gXCJPUFRJT05TXCI7XG4gIGV4cG9ydCBjb25zdCBSRUdJU1RFUiA9IFwiUkVHSVNURVJcIjtcbiAgZXhwb3J0IGNvbnN0IFVQREFURSA9IFwiVVBEQVRFXCI7XG4gIGV4cG9ydCBjb25zdCBTVUJTQ1JJQkUgPSBcIlNVQlNDUklCRVwiO1xuICBleHBvcnQgY29uc3QgUFVCTElTSCA9IFwiUFVCTElTSFwiO1xuICBleHBvcnQgY29uc3QgUkVGRVIgPSBcIlJFRkVSXCI7XG4gIGV4cG9ydCBjb25zdCBQUkFDSyA9IFwiUFJBQ0tcIjtcbn1cbiIsImV4cG9ydCAqIGZyb20gXCIuL2NvbnN0YW50c1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vYWNrXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ieWVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NhbmNlbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW5mb1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW52aXRlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tZXNzYWdlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ub3RpZnlcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3ByYWNrXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wdWJsaXNoXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZWdpc3RlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmVmZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N1YnNjcmliZVwiO1xuIiwiaW1wb3J0IHsgUGFyYW1ldGVycyB9IGZyb20gXCIuL3BhcmFtZXRlcnNcIjtcbmltcG9ydCB7IFVSSSB9IGZyb20gXCIuL3VyaVwiO1xuXG4vKipcbiAqIE5hbWUgQWRkcmVzcyBTSVAgaGVhZGVyLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgTmFtZUFkZHJIZWFkZXIgZXh0ZW5kcyBQYXJhbWV0ZXJzIHtcbiAgcHVibGljIHVyaTogVVJJO1xuXG4gIHByaXZhdGUgX2Rpc3BsYXlOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB1cmkgLVxuICAgKiBAcGFyYW0gZGlzcGxheU5hbWUgLVxuICAgKiBAcGFyYW0gcGFyYW1ldGVycyAtXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1cmk6IFVSSSwgZGlzcGxheU5hbWU6IHN0cmluZywgcGFyYW1ldGVyczogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0pIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICB0aGlzLl9kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgZ2V0IGZyaWVuZGx5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmRpc3BsYXlOYW1lIHx8IHRoaXMudXJpLmFvcjtcbiAgfVxuXG4gIGdldCBkaXNwbGF5TmFtZSgpIHsgcmV0dXJuIHRoaXMuX2Rpc3BsYXlOYW1lOyB9XG4gIHNldCBkaXNwbGF5TmFtZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fZGlzcGxheU5hbWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBOYW1lQWRkckhlYWRlciB7XG4gICAgcmV0dXJuIG5ldyBOYW1lQWRkckhlYWRlcihcbiAgICAgIHRoaXMudXJpLmNsb25lKCksXG4gICAgICB0aGlzLl9kaXNwbGF5TmFtZSxcbiAgICAgIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJhbWV0ZXJzKSkpO1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgbGV0IGJvZHk6IHN0cmluZyA9ICh0aGlzLmRpc3BsYXlOYW1lIHx8IHRoaXMuZGlzcGxheU5hbWUgPT09IFwiMFwiKSA/ICdcIicgKyB0aGlzLmRpc3BsYXlOYW1lICsgJ1wiICcgOiBcIlwiO1xuICAgIGJvZHkgKz0gXCI8XCIgKyB0aGlzLnVyaS50b1N0cmluZygpICsgXCI+XCI7XG5cbiAgICBmb3IgKGNvbnN0IHBhcmFtZXRlciBpbiB0aGlzLnBhcmFtZXRlcnMpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICBib2R5ICs9IFwiO1wiICsgcGFyYW1ldGVyO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXSAhPT0gbnVsbCkge1xuICAgICAgICAgIGJvZHkgKz0gXCI9XCIgKyB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBib2R5O1xuICB9XG59XG4iLCJpbXBvcnQgeyBCb2R5IH0gZnJvbSBcIi4vYm9keVwiO1xuaW1wb3J0IHsgTmFtZUFkZHJIZWFkZXIgfSBmcm9tIFwiLi9uYW1lLWFkZHItaGVhZGVyXCI7XG5pbXBvcnQgeyBVUkkgfSBmcm9tIFwiLi91cmlcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZVJhbmRvbVRva2VuLFxuICBoZWFkZXJpemUsXG4gIG5ld1RhZyxcbiAgc3RyX3V0ZjhfbGVuZ3RoXG59IGZyb20gXCIuL3V0aWxzXCI7XG5cbi8qKlxuICogT3V0Z29pbmcgcmVxdWVzdCBtZXNzYWdlIG9wdGlvbnMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZU9wdGlvbnMge1xuICBjYWxsSWQ/OiBzdHJpbmc7XG4gIGNhbGxJZFByZWZpeD86IHN0cmluZztcbiAgY3NlcT86IG51bWJlcjtcbiAgdG9EaXNwbGF5TmFtZT86IHN0cmluZztcbiAgdG9UYWc/OiBzdHJpbmc7XG4gIGZyb21EaXNwbGF5TmFtZT86IHN0cmluZztcbiAgZnJvbVRhZz86IHN0cmluZztcbiAgZm9yY2VScG9ydD86IGJvb2xlYW47XG4gIGhhY2tWaWFUY3A/OiBib29sZWFuO1xuICBvcHRpb25UYWdzPzogQXJyYXk8c3RyaW5nPjtcbiAgcm91dGVTZXQ/OiBBcnJheTxzdHJpbmc+O1xuICB1c2VyQWdlbnRTdHJpbmc/OiBzdHJpbmc7XG4gIHZpYUhvc3Q/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogT3V0Z29pbmcgU0lQIHJlcXVlc3QgbWVzc2FnZS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2Uge1xuXG4gIC8qKiBHZXQgYSBjb3B5IG9mIHRoZSBkZWZhdWx0IG9wdGlvbnMuICovXG4gIHByaXZhdGUgc3RhdGljIGdldERlZmF1bHRPcHRpb25zKCk6IFJlcXVpcmVkPE91dGdvaW5nUmVxdWVzdE1lc3NhZ2VPcHRpb25zPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbGxJZDogXCJcIixcbiAgICAgIGNhbGxJZFByZWZpeDogXCJcIixcbiAgICAgIGNzZXE6IDEsXG4gICAgICB0b0Rpc3BsYXlOYW1lOiBcIlwiLFxuICAgICAgdG9UYWc6IFwiXCIsXG4gICAgICBmcm9tRGlzcGxheU5hbWU6IFwiXCIsXG4gICAgICBmcm9tVGFnOiBcIlwiLFxuICAgICAgZm9yY2VScG9ydDogZmFsc2UsXG4gICAgICBoYWNrVmlhVGNwOiBmYWxzZSxcbiAgICAgIG9wdGlvblRhZ3M6IFtcIm91dGJvdW5kXCJdLFxuICAgICAgcm91dGVTZXQ6IFtdLFxuICAgICAgdXNlckFnZW50U3RyaW5nOiBcInNpcC5qc1wiLFxuICAgICAgdmlhSG9zdDogXCJcIlxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBtYWtlTmFtZUFkZHJIZWFkZXIodXJpOiBVUkksIGRpc3BsYXlOYW1lOiBzdHJpbmcsIHRhZzogc3RyaW5nKTogTmFtZUFkZHJIZWFkZXIge1xuICAgIGNvbnN0IHBhcmFtZXRlcnM6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHBhcmFtZXRlcnMudGFnID0gdGFnO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5hbWVBZGRySGVhZGVyKHVyaSwgZGlzcGxheU5hbWUsIHBhcmFtZXRlcnMpO1xuICB9XG5cbiAgcHVibGljIHJlYWRvbmx5IGhlYWRlcnM6IHtbbmFtZTogc3RyaW5nXTogQXJyYXk8c3RyaW5nPn0gPSB7fTtcblxuICBwdWJsaWMgcmVhZG9ubHkgbWV0aG9kOiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBydXJpOiBVUkk7XG4gIHB1YmxpYyByZWFkb25seSBmcm9tOiBOYW1lQWRkckhlYWRlcjtcbiAgcHVibGljIHJlYWRvbmx5IGZyb21UYWc6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGZyb21VUkk6IFVSSTtcbiAgcHVibGljIHJlYWRvbmx5IHRvOiBOYW1lQWRkckhlYWRlcjtcbiAgcHVibGljIHJlYWRvbmx5IHRvVGFnOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHB1YmxpYyByZWFkb25seSB0b1VSSTogVVJJO1xuICBwdWJsaWMgYnJhbmNoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHB1YmxpYyByZWFkb25seSBjYWxsSWQ6IHN0cmluZztcbiAgcHVibGljIGNzZXE6IG51bWJlcjtcbiAgcHVibGljIGV4dHJhSGVhZGVyczogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICBwdWJsaWMgYm9keTogeyBib2R5OiBzdHJpbmcsIGNvbnRlbnRUeXBlOiBzdHJpbmcgfSB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIG9wdGlvbnM6IFJlcXVpcmVkPE91dGdvaW5nUmVxdWVzdE1lc3NhZ2VPcHRpb25zPiA9IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuZ2V0RGVmYXVsdE9wdGlvbnMoKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICBydXJpOiBVUkksXG4gICAgZnJvbVVSSTogVVJJLFxuICAgIHRvVVJJOiBVUkksXG4gICAgb3B0aW9ucz86IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2VPcHRpb25zLFxuICAgIGV4dHJhSGVhZGVycz86IEFycmF5PHN0cmluZz4sXG4gICAgYm9keT86IEJvZHlcbiAgKSB7XG4gICAgLy8gT3B0aW9ucyAtIG1lcmdlIGEgZGVlcCBjb3B5XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcHRpb25UYWdzICYmIHRoaXMub3B0aW9ucy5vcHRpb25UYWdzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub3B0aW9uVGFncyA9IHRoaXMub3B0aW9ucy5vcHRpb25UYWdzLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJvdXRlU2V0ICYmIHRoaXMub3B0aW9ucy5yb3V0ZVNldC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnJvdXRlU2V0ID0gdGhpcy5vcHRpb25zLnJvdXRlU2V0LnNsaWNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXh0cmEgaGVhZGVycyAtIGRlZXAgY29weVxuICAgIGlmIChleHRyYUhlYWRlcnMgJiYgZXh0cmFIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnMuc2xpY2UoKTtcbiAgICB9XG5cbiAgICAvLyBCb2R5IC0gZGVlcCBjb3B5XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIC8vIFRPRE86IGludGVybmFsIHJlcHJlc2VudGF0aW9uIHNob3VsZCBiZSBCb2R5XG4gICAgICAvLyB0aGlzLmJvZHkgPSB7IC4uLmJvZHkgfTtcbiAgICAgIHRoaXMuYm9keSA9IHtcbiAgICAgICAgYm9keTogYm9keS5jb250ZW50LFxuICAgICAgICBjb250ZW50VHlwZTogYm9keS5jb250ZW50VHlwZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNZXRob2RcbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcblxuICAgIC8vIFJVUklcbiAgICB0aGlzLnJ1cmkgPSBydXJpLmNsb25lKCk7XG5cbiAgICAvLyBGcm9tXG4gICAgdGhpcy5mcm9tVVJJID0gZnJvbVVSSS5jbG9uZSgpO1xuICAgIHRoaXMuZnJvbVRhZyA9IHRoaXMub3B0aW9ucy5mcm9tVGFnID8gdGhpcy5vcHRpb25zLmZyb21UYWcgOiBuZXdUYWcoKTtcbiAgICB0aGlzLmZyb20gPSBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLm1ha2VOYW1lQWRkckhlYWRlcih0aGlzLmZyb21VUkksIHRoaXMub3B0aW9ucy5mcm9tRGlzcGxheU5hbWUsIHRoaXMuZnJvbVRhZyk7XG5cbiAgICAvLyBUb1xuICAgIHRoaXMudG9VUkkgPSB0b1VSSS5jbG9uZSgpO1xuICAgIHRoaXMudG9UYWcgPSB0aGlzLm9wdGlvbnMudG9UYWc7XG4gICAgdGhpcy50byA9IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UubWFrZU5hbWVBZGRySGVhZGVyKHRoaXMudG9VUkksIHRoaXMub3B0aW9ucy50b0Rpc3BsYXlOYW1lLCB0aGlzLnRvVGFnKTtcblxuICAgIC8vIENhbGwtSURcbiAgICB0aGlzLmNhbGxJZCA9IHRoaXMub3B0aW9ucy5jYWxsSWQgPyB0aGlzLm9wdGlvbnMuY2FsbElkIDogdGhpcy5vcHRpb25zLmNhbGxJZFByZWZpeCArIGNyZWF0ZVJhbmRvbVRva2VuKDE1KTtcblxuICAgIC8vIENTZXFcbiAgICB0aGlzLmNzZXEgPSB0aGlzLm9wdGlvbnMuY3NlcTtcblxuICAgIC8vIFRoZSByZWxhdGl2ZSBvcmRlciBvZiBoZWFkZXIgZmllbGRzIHdpdGggZGlmZmVyZW50IGZpZWxkIG5hbWVzIGlzIG5vdFxuICAgIC8vIHNpZ25pZmljYW50LiAgSG93ZXZlciwgaXQgaXMgUkVDT01NRU5ERUQgdGhhdCBoZWFkZXIgZmllbGRzIHdoaWNoIGFyZVxuICAgIC8vIG5lZWRlZCBmb3IgcHJveHkgcHJvY2Vzc2luZyAoVmlhLCBSb3V0ZSwgUmVjb3JkLVJvdXRlLCBQcm94eS1SZXF1aXJlLFxuICAgIC8vIE1heC1Gb3J3YXJkcywgYW5kIFByb3h5LUF1dGhvcml6YXRpb24sIGZvciBleGFtcGxlKSBhcHBlYXIgdG93YXJkc1xuICAgIC8vIHRoZSB0b3Agb2YgdGhlIG1lc3NhZ2UgdG8gZmFjaWxpdGF0ZSByYXBpZCBwYXJzaW5nLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tNy4zLjFcbiAgICB0aGlzLnNldEhlYWRlcihcInJvdXRlXCIsIHRoaXMub3B0aW9ucy5yb3V0ZVNldCk7XG4gICAgdGhpcy5zZXRIZWFkZXIoXCJ2aWFcIiwgXCJcIik7XG4gICAgdGhpcy5zZXRIZWFkZXIoXCJ0b1wiLCB0aGlzLnRvLnRvU3RyaW5nKCkpO1xuICAgIHRoaXMuc2V0SGVhZGVyKFwiZnJvbVwiLCB0aGlzLmZyb20udG9TdHJpbmcoKSk7XG4gICAgdGhpcy5zZXRIZWFkZXIoXCJjc2VxXCIsIHRoaXMuY3NlcSArIFwiIFwiICsgdGhpcy5tZXRob2QpO1xuICAgIHRoaXMuc2V0SGVhZGVyKFwiY2FsbC1pZFwiLCB0aGlzLmNhbGxJZCk7XG4gICAgdGhpcy5zZXRIZWFkZXIoXCJtYXgtZm9yd2FyZHNcIiwgXCI3MFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBoZWFkZXIgbmFtZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMgUmV0dXJucyB0aGUgc3BlY2lmaWVkIGhlYWRlciwgdW5kZWZpbmVkIGlmIGhlYWRlciBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIGdldEhlYWRlcihuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGhlYWRlcjogQXJyYXk8c3RyaW5nPiA9IHRoaXMuaGVhZGVyc1toZWFkZXJpemUobmFtZSldO1xuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGlmIChoZWFkZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlclswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVnZXhwOiBSZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKlwiICsgbmFtZSArIFwiXFxcXHMqOlwiLCBcImlcIik7XG4gICAgICBmb3IgKGNvbnN0IGV4SGVhZGVyIG9mIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIGlmIChyZWdleHAudGVzdChleEhlYWRlcikpIHtcbiAgICAgICAgICByZXR1cm4gZXhIZWFkZXIuc3Vic3RyaW5nKGV4SGVhZGVyLmluZGV4T2YoXCI6XCIpICsgMSkudHJpbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVhZGVyL3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMgQXJyYXkgd2l0aCBhbGwgdGhlIGhlYWRlcnMgb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgKi9cbiAgcHVibGljIGdldEhlYWRlcnMobmFtZTogc3RyaW5nKTogQXJyYXk8c3RyaW5nPiB7XG4gICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgY29uc3QgaGVhZGVyQXJyYXk6IEFycmF5PHN0cmluZz4gPSB0aGlzLmhlYWRlcnNbaGVhZGVyaXplKG5hbWUpXTtcblxuICAgIGlmIChoZWFkZXJBcnJheSkge1xuICAgICAgZm9yIChjb25zdCBoZWFkZXJQYXJ0IG9mIGhlYWRlckFycmF5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGhlYWRlclBhcnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWdleHA6IFJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXFxcXHMqXCIgKyBuYW1lICsgXCJcXFxccyo6XCIsIFwiaVwiKTtcbiAgICAgIGZvciAoY29uc3QgZXhIZWFkZXIgb2YgdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KGV4SGVhZGVyKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGV4SGVhZGVyLnN1YnN0cmluZyhleEhlYWRlci5pbmRleE9mKFwiOlwiKSArIDEpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyLlxuICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHRydWUgaWYgaGVhZGVyIHdpdGggZ2l2ZW4gbmFtZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgcHVibGljIGhhc0hlYWRlcihuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5oZWFkZXJzW2hlYWRlcml6ZShuYW1lKV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWdleHA6IFJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXFxcXHMqXCIgKyBuYW1lICsgXCJcXFxccyo6XCIsIFwiaVwiKTtcbiAgICAgIGZvciAoY29uc3QgZXh0cmFIZWFkZXIgb2YgdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KGV4dHJhSGVhZGVyKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIHRoZSBnaXZlbiBoZWFkZXIgYnkgdGhlIGdpdmVuIHZhbHVlLlxuICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAqIEBwYXJhbSB2YWx1ZSAtIGhlYWRlciB2YWx1ZVxuICAgKi9cbiAgcHVibGljIHNldEhlYWRlcihuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgdGhpcy5oZWFkZXJzW2hlYWRlcml6ZShuYW1lKV0gPSAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gIH1cblxuICAvKipcbiAgICogVGhlIFZpYSBoZWFkZXIgZmllbGQgaW5kaWNhdGVzIHRoZSB0cmFuc3BvcnQgdXNlZCBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqIGFuZCBpZGVudGlmaWVzIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgcmVzcG9uc2UgaXMgdG8gYmUgc2VudC4gIEEgVmlhXG4gICAqIGhlYWRlciBmaWVsZCB2YWx1ZSBpcyBhZGRlZCBvbmx5IGFmdGVyIHRoZSB0cmFuc3BvcnQgdGhhdCB3aWxsIGJlXG4gICAqIHVzZWQgdG8gcmVhY2ggdGhlIG5leHQgaG9wIGhhcyBiZWVuIHNlbGVjdGVkICh3aGljaCBtYXkgaW52b2x2ZSB0aGVcbiAgICogdXNhZ2Ugb2YgdGhlIHByb2NlZHVyZXMgaW4gWzRdKS5cbiAgICpcbiAgICogV2hlbiB0aGUgVUFDIGNyZWF0ZXMgYSByZXF1ZXN0LCBpdCBNVVNUIGluc2VydCBhIFZpYSBpbnRvIHRoYXRcbiAgICogcmVxdWVzdC4gIFRoZSBwcm90b2NvbCBuYW1lIGFuZCBwcm90b2NvbCB2ZXJzaW9uIGluIHRoZSBoZWFkZXIgZmllbGRcbiAgICogTVVTVCBiZSBTSVAgYW5kIDIuMCwgcmVzcGVjdGl2ZWx5LiAgVGhlIFZpYSBoZWFkZXIgZmllbGQgdmFsdWUgTVVTVFxuICAgKiBjb250YWluIGEgYnJhbmNoIHBhcmFtZXRlci4gIFRoaXMgcGFyYW1ldGVyIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlXG4gICAqIHRyYW5zYWN0aW9uIGNyZWF0ZWQgYnkgdGhhdCByZXF1ZXN0LiAgVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCBieSBib3RoXG4gICAqIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjEuN1xuICAgKiBAcGFyYW0gYnJhbmNoUGFyYW1ldGVyIC0gVGhlIGJyYW5jaCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB0cmFuc3BvcnQgLSBUaGUgc2VudCBwcm90b2NvbCB0cmFuc3BvcnQuXG4gICAqL1xuICBwdWJsaWMgc2V0VmlhSGVhZGVyKGJyYW5jaDogc3RyaW5nLCB0cmFuc3BvcnQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIEZJWE1FOiBIYWNrXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYWNrVmlhVGNwKSB7XG4gICAgICB0cmFuc3BvcnQgPSBcIlRDUFwiO1xuICAgIH1cbiAgICBsZXQgdmlhID0gXCJTSVAvMi4wL1wiICsgdHJhbnNwb3J0O1xuICAgIHZpYSArPSBcIiBcIiArIHRoaXMub3B0aW9ucy52aWFIb3N0ICsgXCI7YnJhbmNoPVwiICsgYnJhbmNoO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VScG9ydCkge1xuICAgICAgdmlhICs9IFwiO3Jwb3J0XCI7XG4gICAgfVxuICAgIHRoaXMuc2V0SGVhZGVyKFwidmlhXCIsIHZpYSk7XG4gICAgdGhpcy5icmFuY2ggPSBicmFuY2g7XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBsZXQgbXNnOiBzdHJpbmcgPSBcIlwiO1xuXG4gICAgbXNnICs9IHRoaXMubWV0aG9kICsgXCIgXCIgKyB0aGlzLnJ1cmkudG9SYXcoKSArIFwiIFNJUC8yLjBcXHJcXG5cIjtcblxuICAgIGZvciAoY29uc3QgaGVhZGVyIGluIHRoaXMuaGVhZGVycykge1xuICAgICAgaWYgKHRoaXMuaGVhZGVyc1toZWFkZXJdKSB7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyUGFydCBvZiB0aGlzLmhlYWRlcnNbaGVhZGVyXSkge1xuICAgICAgICAgIG1zZyArPSBoZWFkZXIgKyBcIjogXCIgKyBoZWFkZXJQYXJ0ICsgXCJcXHJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICBtc2cgKz0gaGVhZGVyLnRyaW0oKSArIFwiXFxyXFxuXCI7XG4gICAgfVxuXG4gICAgbXNnICs9IFwiU3VwcG9ydGVkOiBcIiArIHRoaXMub3B0aW9ucy5vcHRpb25UYWdzLmpvaW4oXCIsIFwiKSArIFwiXFxyXFxuXCI7XG4gICAgbXNnICs9IFwiVXNlci1BZ2VudDogXCIgKyB0aGlzLm9wdGlvbnMudXNlckFnZW50U3RyaW5nICsgXCJcXHJcXG5cIjtcblxuICAgIGlmICh0aGlzLmJvZHkpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1zZyArPSBcIkNvbnRlbnQtTGVuZ3RoOiBcIiArIHN0cl91dGY4X2xlbmd0aCh0aGlzLmJvZHkpICsgXCJcXHJcXG5cXHJcXG5cIjtcbiAgICAgICAgbXNnICs9IHRoaXMuYm9keTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkuYm9keSAmJiB0aGlzLmJvZHkuY29udGVudFR5cGUpIHtcbiAgICAgICAgICBtc2cgKz0gXCJDb250ZW50LVR5cGU6IFwiICsgdGhpcy5ib2R5LmNvbnRlbnRUeXBlICsgXCJcXHJcXG5cIjtcbiAgICAgICAgICBtc2cgKz0gXCJDb250ZW50LUxlbmd0aDogXCIgKyBzdHJfdXRmOF9sZW5ndGgodGhpcy5ib2R5LmJvZHkpICsgXCJcXHJcXG5cXHJcXG5cIjtcbiAgICAgICAgICBtc2cgKz0gdGhpcy5ib2R5LmJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXNnICs9IFwiQ29udGVudC1MZW5ndGg6IFwiICsgMCArIFwiXFxyXFxuXFxyXFxuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbXNnICs9IFwiQ29udGVudC1MZW5ndGg6IFwiICsgMCArIFwiXFxyXFxuXFxyXFxuXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1zZztcbiAgfVxufVxuIiwiaW1wb3J0IHsgQm9keSB9IGZyb20gXCIuL2JvZHlcIjtcbmltcG9ydCB7IEluY29taW5nUmVxdWVzdE1lc3NhZ2UgfSBmcm9tIFwiLi9pbmNvbWluZy1yZXF1ZXN0LW1lc3NhZ2VcIjtcbmltcG9ydCB7IGdldFJlYXNvblBocmFzZSwgbmV3VGFnLCBzdHJfdXRmOF9sZW5ndGggfSBmcm9tIFwiLi91dGlsc1wiO1xuXG4vKipcbiAqIEEgU0lQIG1lc3NhZ2Ugc2VudCBmcm9tIGEgbG9jYWwgc2VydmVyIHRvIGEgcmVtb3RlIGNsaWVudC5cbiAqIEByZW1hcmtzXG4gKiBGb3IgaW5kaWNhdGluZyB0aGUgc3RhdHVzIG9mIGEgcmVxdWVzdCBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi03LjJcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPdXRnb2luZ1Jlc3BvbnNlIHtcbiAgLyoqIFRoZSBvdXRnb2luZyBtZXNzYWdlLiAqL1xuICByZWFkb25seSBtZXNzYWdlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVzcG9uc2Ugb3B0aW9ucyBidWNrZXQuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VPcHRpb25zIHtcbiAgLyoqIFN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZS4gKi9cbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICAvKiogUmVhc29uIHBocmFzZSBvZiB0aGUgcmVzcG9uc2UuICovXG4gIHJlYXNvblBocmFzZT86IHN0cmluZztcbiAgLyoqIFRvIHRhZyBvZiB0aGUgcmVzcG9uc2UuIElmIG5vdCBwcm92aWRlZCwgb25lIGlzIGdlbmVyYXRlZC4gKi9cbiAgdG9UYWc/OiBzdHJpbmc7XG4gIC8qKiBVc2VyIGFnZW50IHN0cmluZyBmb3IgVXNlci1BZ2VudCBoZWFkZXIuICovXG4gIHVzZXJBZ2VudD86IHN0cmluZztcbiAgLyoqIFN1cHBvcnQgb3B0aW9ucyB0YWdzIGZvciBTdXBwb3J0ZWQgaGVhZGVyLiAqL1xuICBzdXBwb3J0ZWQ/OiBBcnJheTxzdHJpbmc+O1xuICAvKiogRXh0cmEgaGVhZGVycyB0byBpbmNsdWRlIGluIHRoZSBtZXNzYWdlLiAqL1xuICBleHRyYUhlYWRlcnM/OiBBcnJheTxzdHJpbmc+O1xuICAvKiogQm9keSB0byBpbmNsdWRlIGluIHRoZSBtZXNzYWdlLiAqL1xuICBib2R5PzogQm9keTtcbn1cblxuLyoqXG4gKiBXaGVuIGEgVUFTIHdpc2hlcyB0byBjb25zdHJ1Y3QgYSByZXNwb25zZSB0byBhIHJlcXVlc3QsIGl0IGZvbGxvd3NcbiAqIHRoZSBnZW5lcmFsIHByb2NlZHVyZXMgZGV0YWlsZWQgaW4gdGhlIGZvbGxvd2luZyBzdWJzZWN0aW9ucy5cbiAqIEFkZGl0aW9uYWwgYmVoYXZpb3JzIHNwZWNpZmljIHRvIHRoZSByZXNwb25zZSBjb2RlIGluIHF1ZXN0aW9uLCB3aGljaFxuICogYXJlIG5vdCBkZXRhaWxlZCBpbiB0aGlzIHNlY3Rpb24sIG1heSBhbHNvIGJlIHJlcXVpcmVkLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RPdXRnb2luZ1Jlc3BvbnNlKFxuICBtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICBvcHRpb25zOiBSZXNwb25zZU9wdGlvbnNcbik6IE91dGdvaW5nUmVzcG9uc2Uge1xuICBjb25zdCBDUkxGID0gXCJcXHJcXG5cIjtcblxuICBpZiAob3B0aW9ucy5zdGF0dXNDb2RlIDwgMTAwIHx8IG9wdGlvbnMuc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHN0YXR1c0NvZGU6IFwiICsgb3B0aW9ucy5zdGF0dXNDb2RlKTtcbiAgfVxuICBjb25zdCByZWFzb25QaHJhc2UgPSBvcHRpb25zLnJlYXNvblBocmFzZSA/IG9wdGlvbnMucmVhc29uUGhyYXNlIDogZ2V0UmVhc29uUGhyYXNlKG9wdGlvbnMuc3RhdHVzQ29kZSk7XG5cbiAgLy8gU0lQIHJlc3BvbnNlcyBhcmUgZGlzdGluZ3Vpc2hlZCBmcm9tIHJlcXVlc3RzIGJ5IGhhdmluZyBhIFN0YXR1cy1MaW5lXG4gIC8vIGFzIHRoZWlyIHN0YXJ0LWxpbmUuICBBIFN0YXR1cy1MaW5lIGNvbnNpc3RzIG9mIHRoZSBwcm90b2NvbCB2ZXJzaW9uXG4gIC8vIGZvbGxvd2VkIGJ5IGEgbnVtZXJpYyBTdGF0dXMtQ29kZSBhbmQgaXRzIGFzc29jaWF0ZWQgdGV4dHVhbCBwaHJhc2UsXG4gIC8vIHdpdGggZWFjaCBlbGVtZW50IHNlcGFyYXRlZCBieSBhIHNpbmdsZSBTUCBjaGFyYWN0ZXIuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tNy4yXG4gIGxldCByZXNwb25zZSA9IFwiU0lQLzIuMCBcIiArIG9wdGlvbnMuc3RhdHVzQ29kZSArIFwiIFwiICsgcmVhc29uUGhyYXNlICsgQ1JMRjtcblxuICAvLyBPbmUgbGFyZ2VseSBub24tbWV0aG9kLXNwZWNpZmljIGd1aWRlbGluZSBmb3IgdGhlIGdlbmVyYXRpb24gb2ZcbiAgLy8gcmVzcG9uc2VzIGlzIHRoYXQgVUFTcyBTSE9VTEQgTk9UIGlzc3VlIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UgZm9yIGFcbiAgLy8gbm9uLUlOVklURSByZXF1ZXN0LiAgUmF0aGVyLCBVQVNzIFNIT1VMRCBnZW5lcmF0ZSBhIGZpbmFsIHJlc3BvbnNlIHRvXG4gIC8vIGEgbm9uLUlOVklURSByZXF1ZXN0IGFzIHNvb24gYXMgcG9zc2libGUuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjYuMVxuICBpZiAob3B0aW9ucy5zdGF0dXNDb2RlID49IDEwMCAmJiBvcHRpb25zLnN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyBXaGVuIGEgMTAwIChUcnlpbmcpIHJlc3BvbnNlIGlzIGdlbmVyYXRlZCwgYW55IFRpbWVzdGFtcCBoZWFkZXIgZmllbGRcbiAgLy8gcHJlc2VudCBpbiB0aGUgcmVxdWVzdCBNVVNUIGJlIGNvcGllZCBpbnRvIHRoaXMgMTAwIChUcnlpbmcpXG4gIC8vIHJlc3BvbnNlLiAgSWYgdGhlcmUgaXMgYSBkZWxheSBpbiBnZW5lcmF0aW5nIHRoZSByZXNwb25zZSwgdGhlIFVBU1xuICAvLyBTSE9VTEQgYWRkIGEgZGVsYXkgdmFsdWUgaW50byB0aGUgVGltZXN0YW1wIHZhbHVlIGluIHRoZSByZXNwb25zZS5cbiAgLy8gVGhpcyB2YWx1ZSBNVVNUIGNvbnRhaW4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdGltZSBvZiBzZW5kaW5nIG9mXG4gIC8vIHRoZSByZXNwb25zZSBhbmQgcmVjZWlwdCBvZiB0aGUgcmVxdWVzdCwgbWVhc3VyZWQgaW4gc2Vjb25kcy5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNi4xXG4gIGlmIChvcHRpb25zLnN0YXR1c0NvZGUgPT09IDEwMCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIFRoZSBGcm9tIGZpZWxkIG9mIHRoZSByZXNwb25zZSBNVVNUIGVxdWFsIHRoZSBGcm9tIGhlYWRlciBmaWVsZCBvZlxuICAvLyB0aGUgcmVxdWVzdC4gIFRoZSBDYWxsLUlEIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVzcG9uc2UgTVVTVCBlcXVhbCB0aGVcbiAgLy8gQ2FsbC1JRCBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3QuICBUaGUgQ1NlcSBoZWFkZXIgZmllbGQgb2YgdGhlXG4gIC8vIHJlc3BvbnNlIE1VU1QgZXF1YWwgdGhlIENTZXEgZmllbGQgb2YgdGhlIHJlcXVlc3QuICBUaGUgVmlhIGhlYWRlclxuICAvLyBmaWVsZCB2YWx1ZXMgaW4gdGhlIHJlc3BvbnNlIE1VU1QgZXF1YWwgdGhlIFZpYSBoZWFkZXIgZmllbGQgdmFsdWVzXG4gIC8vIGluIHRoZSByZXF1ZXN0IGFuZCBNVVNUIG1haW50YWluIHRoZSBzYW1lIG9yZGVyaW5nLlxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi42LjJcbiAgY29uc3QgZnJvbUhlYWRlciA9IFwiRnJvbTogXCIgKyBtZXNzYWdlLmdldEhlYWRlcihcIkZyb21cIikgKyBDUkxGO1xuICBjb25zdCBjYWxsSWRIZWFkZXIgPSBcIkNhbGwtSUQ6IFwiICsgbWVzc2FnZS5jYWxsSWQgKyBDUkxGO1xuICBjb25zdCBjU2VxSGVhZGVyID0gXCJDU2VxOiBcIiArIG1lc3NhZ2UuY3NlcSArIFwiIFwiICsgbWVzc2FnZS5tZXRob2QgKyBDUkxGO1xuICBjb25zdCB2aWFIZWFkZXJzID0gbWVzc2FnZS5nZXRIZWFkZXJzKFwidmlhXCIpLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICByZXR1cm4gcHJldmlvdXMgKyBcIlZpYTogXCIgKyBjdXJyZW50ICsgQ1JMRjtcbiAgfSwgXCJcIik7XG5cbiAgLy8gSWYgYSByZXF1ZXN0IGNvbnRhaW5lZCBhIFRvIHRhZyBpbiB0aGUgcmVxdWVzdCwgdGhlIFRvIGhlYWRlciBmaWVsZFxuICAvLyBpbiB0aGUgcmVzcG9uc2UgTVVTVCBlcXVhbCB0aGF0IG9mIHRoZSByZXF1ZXN0LiAgSG93ZXZlciwgaWYgdGhlIFRvXG4gIC8vIGhlYWRlciBmaWVsZCBpbiB0aGUgcmVxdWVzdCBkaWQgbm90IGNvbnRhaW4gYSB0YWcsIHRoZSBVUkkgaW4gdGhlIFRvXG4gIC8vIGhlYWRlciBmaWVsZCBpbiB0aGUgcmVzcG9uc2UgTVVTVCBlcXVhbCB0aGUgVVJJIGluIHRoZSBUbyBoZWFkZXJcbiAgLy8gZmllbGQ7IGFkZGl0aW9uYWxseSwgdGhlIFVBUyBNVVNUIGFkZCBhIHRhZyB0byB0aGUgVG8gaGVhZGVyIGZpZWxkIGluXG4gIC8vIHRoZSByZXNwb25zZSAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSAxMDAgKFRyeWluZykgcmVzcG9uc2UsIGluXG4gIC8vIHdoaWNoIGEgdGFnIE1BWSBiZSBwcmVzZW50KS4gIFRoaXMgc2VydmVzIHRvIGlkZW50aWZ5IHRoZSBVQVMgdGhhdCBpc1xuICAvLyByZXNwb25kaW5nLCBwb3NzaWJseSByZXN1bHRpbmcgaW4gYSBjb21wb25lbnQgb2YgYSBkaWFsb2cgSUQuICBUaGVcbiAgLy8gc2FtZSB0YWcgTVVTVCBiZSB1c2VkIGZvciBhbGwgcmVzcG9uc2VzIHRvIHRoYXQgcmVxdWVzdCwgYm90aCBmaW5hbFxuICAvLyBhbmQgcHJvdmlzaW9uYWwgKGFnYWluIGV4Y2VwdGluZyB0aGUgMTAwIChUcnlpbmcpKS5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNi4yXG4gIGxldCB0b0hlYWRlciA9IFwiVG86IFwiICsgbWVzc2FnZS5nZXRIZWFkZXIoXCJ0b1wiKTtcbiAgaWYgKG9wdGlvbnMuc3RhdHVzQ29kZSA+IDEwMCAmJiAhbWVzc2FnZS5wYXJzZUhlYWRlcihcInRvXCIpLmhhc1BhcmFtKFwidGFnXCIpKSB7XG4gICAgbGV0IHRvVGFnID0gb3B0aW9ucy50b1RhZztcbiAgICBpZiAoIXRvVGFnKSB7XG4gICAgICAvLyBTdGF0ZWxlc3MgVUFTIEJlaGF2aW9yLi4uXG4gICAgICAvLyBvICBUbyBoZWFkZXIgdGFncyBNVVNUIGJlIGdlbmVyYXRlZCBmb3IgcmVzcG9uc2VzIGluIGEgc3RhdGVsZXNzXG4gICAgICAvLyAgICBtYW5uZXIgLSBpbiBhIG1hbm5lciB0aGF0IHdpbGwgZ2VuZXJhdGUgdGhlIHNhbWUgdGFnIGZvciB0aGVcbiAgICAgIC8vICAgIHNhbWUgcmVxdWVzdCBjb25zaXN0ZW50bHkuICBGb3IgaW5mb3JtYXRpb24gb24gdGFnIGNvbnN0cnVjdGlvblxuICAgICAgLy8gICAgc2VlIFNlY3Rpb24gMTkuMy5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjdcbiAgICAgIHRvVGFnID0gbmV3VGFnKCk7IC8vIEZJWE1FOiBuZXdUYWcoKSBjdXJyZW50bHkgZ2VuZXJhdGVzIHJhbmRvbSB0YWdzXG4gICAgfVxuICAgIHRvSGVhZGVyICs9IFwiO3RhZz1cIiArIHRvVGFnO1xuICB9XG4gIHRvSGVhZGVyICs9IENSTEY7XG5cbiAgLy8gRklYTUU6IFRPRE86IG5lZWRzIHJldmlldy4uLiBtb3ZlZCB0byBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIgKGFzIGl0IGlzIHNwZWNpZmljIHRvIHRoYXQpXG4gIC8vIGxldCByZWNvcmRSb3V0ZUhlYWRlcnMgPSBcIlwiO1xuICAvLyBpZiAocmVxdWVzdC5tZXRob2QgPT09IEMuSU5WSVRFICYmIHN0YXR1c0NvZGUgPiAxMDAgJiYgc3RhdHVzQ29kZSA8PSAyMDApIHtcbiAgLy8gICByZWNvcmRSb3V0ZUhlYWRlcnMgPSByZXF1ZXN0LmdldEhlYWRlcnMoXCJyZWNvcmQtcm91dGVcIikucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAvLyAgICAgcmV0dXJuIHByZXZpb3VzICsgXCJSZWNvcmQtUm91dGU6IFwiICsgY3VycmVudCArIENSTEY7XG4gIC8vICAgfSwgXCJcIik7XG4gIC8vIH1cblxuICAvLyBGSVhNRTogVE9ETzogbmVlZHMgcmV2aWV3Li4uXG4gIGxldCBzdXBwb3J0ZWRIZWFkZXIgPSBcIlwiO1xuICBpZiAob3B0aW9ucy5zdXBwb3J0ZWQpIHtcbiAgICBzdXBwb3J0ZWRIZWFkZXIgPSBcIlN1cHBvcnRlZDogXCIgKyBvcHRpb25zLnN1cHBvcnRlZC5qb2luKFwiLCBcIikgKyBDUkxGO1xuICB9XG5cbiAgLy8gRklYTUU6IFRPRE86IG5lZWRzIHJldmlldy4uLlxuICBsZXQgdXNlckFnZW50SGVhZGVyID0gXCJcIjtcbiAgaWYgKG9wdGlvbnMudXNlckFnZW50KSB7XG4gICAgdXNlckFnZW50SGVhZGVyID0gXCJVc2VyLUFnZW50OiBcIiArIG9wdGlvbnMudXNlckFnZW50ICsgQ1JMRjtcbiAgfVxuXG4gIGxldCBleHRlbnNpb25IZWFkZXJzID0gXCJcIjtcbiAgaWYgKG9wdGlvbnMuZXh0cmFIZWFkZXJzKSB7XG4gICAgZXh0ZW5zaW9uSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICAgIHJldHVybiBwcmV2aW91cyArIGN1cnJlbnQudHJpbSgpICsgQ1JMRjtcbiAgICB9LCBcIlwiKTtcbiAgfVxuXG4gIC8vIFRoZSByZWxhdGl2ZSBvcmRlciBvZiBoZWFkZXIgZmllbGRzIHdpdGggZGlmZmVyZW50IGZpZWxkIG5hbWVzIGlzIG5vdFxuICAvLyBzaWduaWZpY2FudC4gIEhvd2V2ZXIsIGl0IGlzIFJFQ09NTUVOREVEIHRoYXQgaGVhZGVyIGZpZWxkcyB3aGljaCBhcmVcbiAgLy8gbmVlZGVkIGZvciBwcm94eSBwcm9jZXNzaW5nIChWaWEsIFJvdXRlLCBSZWNvcmQtUm91dGUsIFByb3h5LVJlcXVpcmUsXG4gIC8vIE1heC1Gb3J3YXJkcywgYW5kIFByb3h5LUF1dGhvcml6YXRpb24sIGZvciBleGFtcGxlKSBhcHBlYXIgdG93YXJkc1xuICAvLyB0aGUgdG9wIG9mIHRoZSBtZXNzYWdlIHRvIGZhY2lsaXRhdGUgcmFwaWQgcGFyc2luZy5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi03LjMuMVxuICAvLyByZXNwb25zZSArPSByZWNvcmRSb3V0ZUhlYWRlcnM7XG4gIHJlc3BvbnNlICs9IHZpYUhlYWRlcnM7XG4gIHJlc3BvbnNlICs9IGZyb21IZWFkZXI7XG4gIHJlc3BvbnNlICs9IHRvSGVhZGVyO1xuICByZXNwb25zZSArPSBjU2VxSGVhZGVyO1xuICByZXNwb25zZSArPSBjYWxsSWRIZWFkZXI7XG4gIHJlc3BvbnNlICs9IHN1cHBvcnRlZEhlYWRlcjtcbiAgcmVzcG9uc2UgKz0gdXNlckFnZW50SGVhZGVyO1xuICByZXNwb25zZSArPSBleHRlbnNpb25IZWFkZXJzO1xuXG4gIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICByZXNwb25zZSArPSBcIkNvbnRlbnQtVHlwZTogXCIgKyBvcHRpb25zLmJvZHkuY29udGVudFR5cGUgKyBDUkxGO1xuICAgIHJlc3BvbnNlICs9IFwiQ29udGVudC1MZW5ndGg6IFwiICsgc3RyX3V0ZjhfbGVuZ3RoKG9wdGlvbnMuYm9keS5jb250ZW50KSArIENSTEYgKyBDUkxGO1xuICAgIHJlc3BvbnNlICs9IG9wdGlvbnMuYm9keS5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJlc3BvbnNlICs9IFwiQ29udGVudC1MZW5ndGg6IFwiICsgMCArIENSTEYgKyBDUkxGO1xuICB9XG5cbiAgcmV0dXJuIHsgbWVzc2FnZTogcmVzcG9uc2UgfTtcbn1cbiIsIi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJhbWV0ZXJzIHtcbiAgcHVibGljIHBhcmFtZXRlcnM6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnM6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSkge1xuICAgIGZvciAoY29uc3QgcGFyYW0gaW4gcGFyYW1ldGVycykge1xuICAgICAgaWYgKHBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocGFyYW0pKSB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW0ocGFyYW0sIHBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0UGFyYW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICB0aGlzLnBhcmFtZXRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWx1ZSA9PT0gbnVsbCkgPyBudWxsIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0UGFyYW0oa2V5OiBzdHJpbmcpIHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaGFzUGFyYW0oa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICByZXR1cm4gISF0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoa2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlUGFyYW0ocGFyYW1ldGVyOiBzdHJpbmcpOiBhbnkge1xuICAgIHBhcmFtZXRlciA9IHBhcmFtZXRlci50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2xlYXJQYXJhbXMoKTogdm9pZCB7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge307XG4gIH1cbn1cbiIsImltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2cvbG9nZ2VyXCI7XG5pbXBvcnQgeyBHcmFtbWFyIH0gZnJvbSBcIi4vZ3JhbW1hclwiO1xuaW1wb3J0IHsgSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSB9IGZyb20gXCIuL2luY29taW5nLXJlcXVlc3QtbWVzc2FnZVwiO1xuaW1wb3J0IHsgSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UgfSBmcm9tIFwiLi9pbmNvbWluZy1yZXNwb25zZS1tZXNzYWdlXCI7XG5cbi8qKlxuICogRXh0cmFjdCBhbmQgcGFyc2UgZXZlcnkgaGVhZGVyIG9mIGEgU0lQIG1lc3NhZ2UuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBQYXJzZXIge1xuXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRIZWFkZXIoZGF0YTogYW55LCBoZWFkZXJTdGFydDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAvLyAnc3RhcnQnIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgbGV0IHN0YXJ0OiBudW1iZXIgPSBoZWFkZXJTdGFydDtcbiAgICAvLyAnZW5kJyBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyLlxuICAgIGxldCBlbmQ6IG51bWJlciA9IDA7XG4gICAgLy8gJ3BhcnRpYWwgZW5kJyBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyLlxuICAgIGxldCBwYXJ0aWFsRW5kOiBudW1iZXIgPSAwO1xuXG4gICAgLy8gRW5kIG9mIG1lc3NhZ2UuXG4gICAgaWYgKGRhdGEuc3Vic3RyaW5nKHN0YXJ0LCBzdGFydCArIDIpLm1hdGNoKC8oXlxcclxcbikvKSkge1xuICAgICAgcmV0dXJuIC0yO1xuICAgIH1cblxuICAgIHdoaWxlIChlbmQgPT09IDApIHtcbiAgICAgIC8vIFBhcnRpYWwgRW5kIG9mIEhlYWRlci5cbiAgICAgIHBhcnRpYWxFbmQgPSBkYXRhLmluZGV4T2YoXCJcXHJcXG5cIiwgc3RhcnQpO1xuXG4gICAgICAvLyAnaW5kZXhPZicgcmV0dXJucyAtMSBpZiB0aGUgdmFsdWUgdG8gYmUgZm91bmQgbmV2ZXIgb2NjdXJzLlxuICAgICAgaWYgKHBhcnRpYWxFbmQgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwYXJ0aWFsRW5kO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEuc3Vic3RyaW5nKHBhcnRpYWxFbmQgKyAyLCBwYXJ0aWFsRW5kICsgNCkubWF0Y2goLyheXFxyXFxuKS8pICYmXG4gICAgICAgIGRhdGEuY2hhckF0KHBhcnRpYWxFbmQgKyAyKS5tYXRjaCgvKF5cXHMrKS8pKSB7XG4gICAgICAgIC8vIE5vdCB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlLiBDb250aW51ZSBmcm9tIHRoZSBuZXh0IHBvc2l0aW9uLlxuICAgICAgICBzdGFydCA9IHBhcnRpYWxFbmQgKyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gcGFydGlhbEVuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW5kO1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSGVhZGVyKFxuICAgIG1lc3NhZ2U6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UgfCBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSxcbiAgICBkYXRhOiBhbnksXG4gICAgaGVhZGVyU3RhcnQ6IG51bWJlcixcbiAgICBoZWFkZXJFbmQ6IG51bWJlclxuICApOiBib29sZWFuIHwgeyBlcnJvcjogc3RyaW5nIH0ge1xuICAgIGNvbnN0IGhjb2xvbkluZGV4OiBudW1iZXIgPSBkYXRhLmluZGV4T2YoXCI6XCIsIGhlYWRlclN0YXJ0KTtcbiAgICBjb25zdCBoZWFkZXJOYW1lOiBzdHJpbmcgPSBkYXRhLnN1YnN0cmluZyhoZWFkZXJTdGFydCwgaGNvbG9uSW5kZXgpLnRyaW0oKTtcbiAgICBjb25zdCBoZWFkZXJWYWx1ZTogc3RyaW5nID0gZGF0YS5zdWJzdHJpbmcoaGNvbG9uSW5kZXggKyAxLCBoZWFkZXJFbmQpLnRyaW0oKTtcblxuICAgIGxldCBwYXJzZWQ6IGFueTtcbiAgICAvLyBJZiBoZWFkZXItZmllbGQgaXMgd2VsbC1rbm93biwgcGFyc2UgaXQuXG4gICAgc3dpdGNoIChoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJ2aWFcIjpcbiAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKFwidmlhXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZ2V0SGVhZGVycyhcInZpYVwiKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiVmlhXCIpO1xuICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UudmlhID0gcGFyc2VkO1xuICAgICAgICAgICAgbWVzc2FnZS52aWFCcmFuY2ggPSBwYXJzZWQuYnJhbmNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZyb21cIjpcbiAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwiZnJvbVwiLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJmcm9tXCIpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgbWVzc2FnZS5mcm9tID0gcGFyc2VkO1xuICAgICAgICAgIG1lc3NhZ2UuZnJvbVRhZyA9IHBhcnNlZC5nZXRQYXJhbShcInRhZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b1wiOlxuICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoXCJ0b1wiLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJ0b1wiKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgIG1lc3NhZ2UudG8gPSBwYXJzZWQ7XG4gICAgICAgICAgbWVzc2FnZS50b1RhZyA9IHBhcnNlZC5nZXRQYXJhbShcInRhZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZWNvcmQtcm91dGVcIjpcbiAgICAgICAgcGFyc2VkID0gR3JhbW1hci5wYXJzZShoZWFkZXJWYWx1ZSwgXCJSZWNvcmRfUm91dGVcIik7XG5cbiAgICAgICAgaWYgKHBhcnNlZCA9PT0gLTEpIHtcbiAgICAgICAgICBwYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocGFyc2VkIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgcGFyc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmZvckVhY2goKGhlYWRlcikgPT4ge1xuICAgICAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKFwicmVjb3JkLXJvdXRlXCIsIGhlYWRlclZhbHVlLnN1YnN0cmluZyhoZWFkZXIucG9zaXRpb24sIGhlYWRlci5vZmZzZXQpKTtcbiAgICAgICAgICBtZXNzYWdlLmhlYWRlcnNbXCJSZWNvcmQtUm91dGVcIl1bbWVzc2FnZS5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpLmxlbmd0aCAtIDFdLnBhcnNlZCA9IGhlYWRlci5wYXJzZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjYWxsLWlkXCI6XG4gICAgICBjYXNlIFwiaVwiOlxuICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcImNhbGwtaWRcIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiY2FsbC1pZFwiKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgIG1lc3NhZ2UuY2FsbElkID0gaGVhZGVyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY29udGFjdFwiOlxuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgcGFyc2VkID0gR3JhbW1hci5wYXJzZShoZWFkZXJWYWx1ZSwgXCJDb250YWN0XCIpO1xuXG4gICAgICAgIGlmIChwYXJzZWQgPT09IC0xKSB7XG4gICAgICAgICAgcGFyc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHBhcnNlZCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgIHBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5mb3JFYWNoKChoZWFkZXIpID0+IHtcbiAgICAgICAgICBtZXNzYWdlLmFkZEhlYWRlcihcImNvbnRhY3RcIiwgaGVhZGVyVmFsdWUuc3Vic3RyaW5nKGhlYWRlci5wb3NpdGlvbiwgaGVhZGVyLm9mZnNldCkpO1xuICAgICAgICAgIG1lc3NhZ2UuaGVhZGVycy5Db250YWN0W21lc3NhZ2UuZ2V0SGVhZGVycyhcImNvbnRhY3RcIikubGVuZ3RoIC0gMV0ucGFyc2VkID0gaGVhZGVyLnBhcnNlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNvbnRlbnQtbGVuZ3RoXCI6XG4gICAgICBjYXNlIFwibFwiOlxuICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcImNvbnRlbnQtbGVuZ3RoXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb250ZW50LXR5cGVcIjpcbiAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY3NlcVwiOlxuICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcImNzZXFcIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiY3NlcVwiKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgIG1lc3NhZ2UuY3NlcSA9IHBhcnNlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEluY29taW5nUmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgICAgbWVzc2FnZS5tZXRob2QgPSBwYXJzZWQubWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1heC1mb3J3YXJkc1wiOlxuICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcIm1heC1mb3J3YXJkc1wiLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJtYXgtZm9yd2FyZHNcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInd3dy1hdXRoZW50aWNhdGVcIjpcbiAgICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoXCJ3d3ctYXV0aGVudGljYXRlXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcInd3dy1hdXRoZW50aWNhdGVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByb3h5LWF1dGhlbnRpY2F0ZVwiOlxuICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcInByb3h5LWF1dGhlbnRpY2F0ZVwiLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJwcm94eS1hdXRoZW50aWNhdGVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlZmVyLXRvXCI6XG4gICAgICBjYXNlIFwiclwiOlxuICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcInJlZmVyLXRvXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcInJlZmVyLXRvXCIpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgbWVzc2FnZS5yZWZlclRvID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRG8gbm90IHBhcnNlIHRoaXMgaGVhZGVyLlxuICAgICAgICBtZXNzYWdlLmFkZEhlYWRlcihoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCksIGhlYWRlclZhbHVlKTtcbiAgICAgICAgcGFyc2VkID0gMDtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBcImVycm9yIHBhcnNpbmcgaGVhZGVyICdcIiArIGhlYWRlck5hbWUgKyBcIidcIlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWVzc2FnZShcbiAgICBkYXRhOiBzdHJpbmcsXG4gICAgbG9nZ2VyOiBMb2dnZXJcbiAgKTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSB8IEluY29taW5nUmVzcG9uc2VNZXNzYWdlIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgaGVhZGVyU3RhcnQ6IG51bWJlciA9IDA7XG4gICAgbGV0IGhlYWRlckVuZDogbnVtYmVyID0gZGF0YS5pbmRleE9mKFwiXFxyXFxuXCIpO1xuXG4gICAgaWYgKGhlYWRlckVuZCA9PT0gLTEpIHtcbiAgICAgIGxvZ2dlci53YXJuKFwibm8gQ1JMRiBmb3VuZCwgbm90IGEgU0lQIG1lc3NhZ2UsIGRpc2NhcmRlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBmaXJzdCBsaW5lLiBDaGVjayBpZiBpdCBpcyBhIFJlcXVlc3Qgb3IgYSBSZXBseS5cbiAgICBjb25zdCBmaXJzdExpbmU6IHN0cmluZyA9IGRhdGEuc3Vic3RyaW5nKDAsIGhlYWRlckVuZCk7XG4gICAgY29uc3QgcGFyc2VkOiBhbnkgPSBHcmFtbWFyLnBhcnNlKGZpcnN0TGluZSwgXCJSZXF1ZXN0X1Jlc3BvbnNlXCIpO1xuICAgIGxldCBtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlIHwgSW5jb21pbmdSZXNwb25zZU1lc3NhZ2U7XG5cbiAgICBpZiAocGFyc2VkID09PSAtMSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ2Vycm9yIHBhcnNpbmcgZmlyc3QgbGluZSBvZiBTSVAgbWVzc2FnZTogXCInICsgZmlyc3RMaW5lICsgJ1wiJyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICghcGFyc2VkLnN0YXR1c19jb2RlKSB7XG4gICAgICBtZXNzYWdlID0gbmV3IEluY29taW5nUmVxdWVzdE1lc3NhZ2UoKTtcbiAgICAgIG1lc3NhZ2UubWV0aG9kID0gcGFyc2VkLm1ldGhvZDtcbiAgICAgIG1lc3NhZ2UucnVyaSA9IHBhcnNlZC51cmk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgPSBuZXcgSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UoKTtcbiAgICAgIG1lc3NhZ2Uuc3RhdHVzQ29kZSA9IHBhcnNlZC5zdGF0dXNfY29kZTtcbiAgICAgIG1lc3NhZ2UucmVhc29uUGhyYXNlID0gcGFyc2VkLnJlYXNvbl9waHJhc2U7XG4gICAgfVxuXG4gICAgbWVzc2FnZS5kYXRhID0gZGF0YTtcbiAgICBoZWFkZXJTdGFydCA9IGhlYWRlckVuZCArIDI7XG5cbiAgICAvLyBMb29wIG92ZXIgZXZlcnkgbGluZSBpbiBkYXRhLiBEZXRlY3QgdGhlIGVuZCBvZiBlYWNoIGhlYWRlciBhbmQgcGFyc2VcbiAgICAvLyBpdCBvciBzaW1wbHkgYWRkIHRvIHRoZSBoZWFkZXJzIGNvbGxlY3Rpb24uXG4gICAgbGV0IGJvZHlTdGFydDogbnVtYmVyO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBoZWFkZXJFbmQgPSBnZXRIZWFkZXIoZGF0YSwgaGVhZGVyU3RhcnQpO1xuXG4gICAgICAvLyBUaGUgU0lQIG1lc3NhZ2UgaGFzIG5vcm1hbGx5IGZpbmlzaGVkLlxuICAgICAgaWYgKGhlYWRlckVuZCA9PT0gLTIpIHtcbiAgICAgICAgYm9keVN0YXJ0ID0gaGVhZGVyU3RhcnQgKyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoaGVhZGVyRW5kID09PSAtMSkge1xuICAgICAgICAvLyBkYXRhLmluZGV4T2YgcmV0dXJuZWQgLTEgZHVlIHRvIGEgbWFsZm9ybWVkIG1lc3NhZ2UuXG4gICAgICAgIGxvZ2dlci5lcnJvcihcIm1hbGZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZEhlYWRlcjogYW55ID0gcGFyc2VIZWFkZXIobWVzc2FnZSwgZGF0YSwgaGVhZGVyU3RhcnQsIGhlYWRlckVuZCk7XG5cbiAgICAgIGlmIChwYXJzZWRIZWFkZXIgIT09IHRydWUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKHBhcnNlZC5lcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaGVhZGVyU3RhcnQgPSBoZWFkZXJFbmQgKyAyO1xuICAgIH1cblxuICAgIC8vIFJGQzMyNjEgMTguMy5cbiAgICAvLyBJZiB0aGVyZSBhcmUgYWRkaXRpb25hbCBieXRlcyBpbiB0aGUgdHJhbnNwb3J0IHBhY2tldFxuICAgIC8vIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBib2R5LCB0aGV5IE1VU1QgYmUgZGlzY2FyZGVkLlxuICAgIGlmIChtZXNzYWdlLmhhc0hlYWRlcihcImNvbnRlbnQtbGVuZ3RoXCIpKSB7XG4gICAgICBtZXNzYWdlLmJvZHkgPSBkYXRhLnN1YnN0cihib2R5U3RhcnQsIE51bWJlcihtZXNzYWdlLmdldEhlYWRlcihcImNvbnRlbnQtbGVuZ3RoXCIpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UuYm9keSA9IGRhdGEuc3Vic3RyaW5nKGJvZHlTdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcmFtZXRlcnMgfSBmcm9tIFwiLi9wYXJhbWV0ZXJzXCI7XG5cbmludGVyZmFjZSBVUklPYmplY3Qge1xuICBzY2hlbWU6IHN0cmluZztcbiAgdXNlcjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBob3N0OiBzdHJpbmc7XG4gIHBvcnQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBVUkkuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBVUkkgZXh0ZW5kcyBQYXJhbWV0ZXJzIHtcbiAgcHJpdmF0ZSBoZWFkZXJzOiB7W25hbWU6IHN0cmluZ106IGFueX0gPSB7fTtcbiAgcHJpdmF0ZSBub3JtYWw6IFVSSU9iamVjdDtcbiAgcHJpdmF0ZSByYXc6IFVSSU9iamVjdDtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHNjaGVtZSAtXG4gICAqIEBwYXJhbSB1c2VyIC1cbiAgICogQHBhcmFtIGhvc3QgLVxuICAgKiBAcGFyYW0gcG9ydCAtXG4gICAqIEBwYXJhbSBwYXJhbWV0ZXJzIC1cbiAgICogQHBhcmFtIGhlYWRlcnMgLVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc2NoZW1lOiBzdHJpbmcsXG4gICAgdXNlcjogc3RyaW5nLFxuICAgIGhvc3Q6IHN0cmluZyxcbiAgICBwb3J0PzogbnVtYmVyLFxuICAgIHBhcmFtZXRlcnM/OiBhbnksXG4gICAgaGVhZGVycz86IGFueVxuICApIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAvLyBDaGVja3NcbiAgICBpZiAoIWhvc3QpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3Npbmcgb3IgaW52YWxpZCBcImhvc3RcIiBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHBhcmFtZXRlcnNcbiAgICBzY2hlbWUgPSBzY2hlbWUgfHwgXCJzaXBcIjtcblxuICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgICAgdGhpcy5zZXRIZWFkZXIoaGVhZGVyLCBoZWFkZXJzW2hlYWRlcl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJhdyBVUklcbiAgICB0aGlzLnJhdyA9IHtcbiAgICAgIHNjaGVtZSxcbiAgICAgIHVzZXIsXG4gICAgICBob3N0LFxuICAgICAgcG9ydFxuICAgIH07XG5cbiAgICAvLyBOb3JtYWxpemVkIFVSSVxuICAgIHRoaXMubm9ybWFsID0ge1xuICAgICAgc2NoZW1lOiBzY2hlbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgIHVzZXIsXG4gICAgICBob3N0OiBob3N0LnRvTG93ZXJDYXNlKCksXG4gICAgICBwb3J0XG4gICAgfTtcbiAgfVxuXG4gIGdldCBzY2hlbWUoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMubm9ybWFsLnNjaGVtZTsgfVxuICBzZXQgc2NoZW1lKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnJhdy5zY2hlbWUgPSB2YWx1ZTtcbiAgICB0aGlzLm5vcm1hbC5zY2hlbWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgZ2V0IHVzZXIoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXMubm9ybWFsLnVzZXI7IH1cbiAgc2V0IHVzZXIodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMubm9ybWFsLnVzZXIgPSB0aGlzLnJhdy51c2VyID0gdmFsdWU7XG4gIH1cblxuICBnZXQgaG9zdCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5ub3JtYWwuaG9zdDsgfVxuICBzZXQgaG9zdCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5yYXcuaG9zdCA9IHZhbHVlO1xuICAgIHRoaXMubm9ybWFsLmhvc3QgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgZ2V0IGFvcigpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5ub3JtYWwudXNlciArIFwiQFwiICsgdGhpcy5ub3JtYWwuaG9zdDsgfVxuXG4gIGdldCBwb3J0KCk6IG51bWJlciB8IHVuZGVmaW5lZCB7IHJldHVybiB0aGlzLm5vcm1hbC5wb3J0OyB9XG4gIHNldCBwb3J0KHZhbHVlOiBudW1iZXIgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLm5vcm1hbC5wb3J0ID0gdGhpcy5yYXcucG9ydCA9IHZhbHVlID09PSAwID8gdmFsdWUgOiB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRIZWFkZXIobmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5oZWFkZXJzW3RoaXMuaGVhZGVyaXplKG5hbWUpXSA9ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRIZWFkZXIobmFtZTogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1t0aGlzLmhlYWRlcml6ZShuYW1lKV07XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGhhc0hlYWRlcihuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISFuYW1lICYmICEhdGhpcy5oZWFkZXJzLmhhc093blByb3BlcnR5KHRoaXMuaGVhZGVyaXplKG5hbWUpKTtcbiAgfVxuXG4gIHB1YmxpYyBkZWxldGVIZWFkZXIoaGVhZGVyOiBzdHJpbmcpOiBhbnkge1xuICAgIGhlYWRlciA9IHRoaXMuaGVhZGVyaXplKGhlYWRlcik7XG5cbiAgICBpZiAodGhpcy5oZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgIGNvbnN0IHZhbHVlOiBhbnkgPSB0aGlzLmhlYWRlcnNbaGVhZGVyXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmhlYWRlcnNbaGVhZGVyXTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2xlYXJIZWFkZXJzKCk6IHZvaWQge1xuICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IFVSSSB7XG4gICAgcmV0dXJuIG5ldyBVUkkoXG4gICAgICB0aGlzLl9yYXcuc2NoZW1lLFxuICAgICAgdGhpcy5fcmF3LnVzZXIgfHwgXCJcIixcbiAgICAgIHRoaXMuX3Jhdy5ob3N0LFxuICAgICAgdGhpcy5fcmF3LnBvcnQsXG4gICAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGFyYW1ldGVycykpLFxuICAgICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmhlYWRlcnMpKSk7XG4gIH1cblxuICBwdWJsaWMgdG9SYXcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fdG9TdHJpbmcodGhpcy5fcmF3KTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl90b1N0cmluZyh0aGlzLl9ub3JtYWwpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgX25vcm1hbCgpOiBVUklPYmplY3QgeyByZXR1cm4gdGhpcy5ub3JtYWw7IH1cblxuICBwcml2YXRlIGdldCBfcmF3KCk6IFVSSU9iamVjdCB7IHJldHVybiB0aGlzLnJhdzsgfVxuXG4gIHByaXZhdGUgX3RvU3RyaW5nKHVyaTogYW55KTogc3RyaW5nIHtcbiAgICBsZXQgdXJpU3RyaW5nOiBzdHJpbmcgID0gdXJpLnNjaGVtZSArIFwiOlwiO1xuICAgIC8vIGFkZCBzbGFzaGVzIGlmIGl0J3Mgbm90IGEgc2lwKHMpIFVSSVxuICAgIGlmICghdXJpLnNjaGVtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKFwiXnNpcHM/JFwiKSkge1xuICAgICAgdXJpU3RyaW5nICs9IFwiLy9cIjtcbiAgICB9XG4gICAgaWYgKHVyaS51c2VyKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gdGhpcy5lc2NhcGVVc2VyKHVyaS51c2VyKSArIFwiQFwiO1xuICAgIH1cbiAgICB1cmlTdHJpbmcgKz0gdXJpLmhvc3Q7XG4gICAgaWYgKHVyaS5wb3J0IHx8IHVyaS5wb3J0ID09PSAwKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gXCI6XCIgKyB1cmkucG9ydDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHBhcmFtZXRlciBpbiB0aGlzLnBhcmFtZXRlcnMpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICB1cmlTdHJpbmcgKz0gXCI7XCIgKyBwYXJhbWV0ZXI7XG5cbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdICE9PSBudWxsKSB7XG4gICAgICAgICAgdXJpU3RyaW5nICs9IFwiPVwiICsgdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXJzOiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgZm9yIChjb25zdCBoZWFkZXIgaW4gdGhpcy5oZWFkZXJzKSB7XG4gICAgICBpZiAodGhpcy5oZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZHggaW4gdGhpcy5oZWFkZXJzW2hlYWRlcl0pIHtcbiAgICAgICAgICBpZiAodGhpcy5oZWFkZXJzW2hlYWRlcl0uaGFzT3duUHJvcGVydHkoaWR4KSkge1xuICAgICAgICAgICAgaGVhZGVycy5wdXNoKGhlYWRlciArIFwiPVwiICsgdGhpcy5oZWFkZXJzW2hlYWRlcl1baWR4XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdXJpU3RyaW5nICs9IFwiP1wiICsgaGVhZGVycy5qb2luKFwiJlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJpU3RyaW5nO1xuICB9XG5cbiAgLypcbiAgICogSGV4LWVzY2FwZSBhIFNJUCBVUkkgdXNlci5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAgICovXG4gIHByaXZhdGUgZXNjYXBlVXNlcih1c2VyOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCBkZWNvZGVkVXNlcjogc3RyaW5nO1xuXG4gICAgLy8gRklYTUU6IFRoaXMgaXMgY2FsbGVkIGJ5IHRvU3RyaW5nIGFib3ZlIHdoaWNoIHNob3VsZCBuZXZlciB0aHJvdywgYnV0XG4gICAgLy8gZGVjb2RlVVJJQ29tcG9uZW50IGNhbiB0aHJvdyBhbmQgSSd2ZSBzZWVuIG9uZSBjYXNlIGluIHByb2R1Y3Rpb24gd2hlcmVcbiAgICAvLyBpdCBkaWQgdGhyb3cgcmVzdWx0aW5nIGluIGEgY2FzY2FkaW5nIGZhaWx1cmUuIFRoaXMgY2xhc3Mgc2hvdWxkIGJlXG4gICAgLy8gZml4ZWQgc28gdGhhdCBkZWNvZGVVUklDb21wb25lbnQgaXMgbm90IGNhbGxlZCBhdCB0aGlzIHBvaW50IChpbiB0b1N0cmluZykuXG4gICAgLy8gVGhlIHVzZXIgc2hvdWxkIGJlIGRlY29kZWQgd2hlbiB0aGUgVVJJIGlzIGNvbnN0cnVjdG9yIG9yIHNvbWUgb3RoZXJcbiAgICAvLyBwbGFjZSB3aGVyZSB3ZSBjYW4gY2F0Y2ggdGhlIGVycm9yIGJlZm9yZSB0aGUgVVJJIGlzIGNyZWF0ZWQgb3Igc29tZXN1Y2guXG4gICAgdHJ5IHtcbiAgICAgIGRlY29kZWRVc2VyID0gZGVjb2RlVVJJQ29tcG9uZW50KHVzZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBoZXgtZXNjYXBlICc6JyAoJTNBKSwgJysnICglMkIpLCAnPycgKCUzRlwiKSwgJy8nICglMkYpLlxuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlZFVzZXIpXG4gICAgICAucmVwbGFjZSgvJTNBL2lnLCBcIjpcIilcbiAgICAgIC5yZXBsYWNlKC8lMkIvaWcsIFwiK1wiKVxuICAgICAgLnJlcGxhY2UoLyUzRi9pZywgXCI/XCIpXG4gICAgICAucmVwbGFjZSgvJTJGL2lnLCBcIi9cIik7XG4gIH1cblxuICBwcml2YXRlIGhlYWRlcml6ZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZXhjZXB0aW9uczogYW55ID0ge1xuICAgICAgXCJDYWxsLUlkXCI6IFwiQ2FsbC1JRFwiLFxuICAgICAgXCJDc2VxXCI6IFwiQ1NlcVwiLFxuICAgICAgXCJNaW4tU2VcIjogXCJNaW4tU0VcIixcbiAgICAgIFwiUmFja1wiOiBcIlJBY2tcIixcbiAgICAgIFwiUnNlcVwiOiBcIlJTZXFcIixcbiAgICAgIFwiV3d3LUF1dGhlbnRpY2F0ZVwiOiBcIldXVy1BdXRoZW50aWNhdGVcIixcbiAgICB9O1xuICAgIGNvbnN0IG5hbWU6IEFycmF5PHN0cmluZz4gPSBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9fL2csIFwiLVwiKS5zcGxpdChcIi1cIik7XG4gICAgY29uc3QgcGFydHM6IG51bWJlciA9IG5hbWUubGVuZ3RoO1xuICAgIGxldCBobmFtZTogc3RyaW5nID0gXCJcIjtcblxuICAgIGZvciAobGV0IHBhcnQgPSAwOyBwYXJ0IDwgcGFydHM7IHBhcnQrKykge1xuICAgICAgaWYgKHBhcnQgIT09IDApIHtcbiAgICAgICAgaG5hbWUgKz0gXCItXCI7XG4gICAgICB9XG4gICAgICBobmFtZSArPSBuYW1lW3BhcnRdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZVtwYXJ0XS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmIChleGNlcHRpb25zW2huYW1lXSkge1xuICAgICAgaG5hbWUgPSBleGNlcHRpb25zW2huYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIGhuYW1lO1xuICB9XG59XG4iLCIvKipcbiAqIEBwYXJhbSBzaXplIC1cbiAqIEBwYXJhbSBiYXNlIC1cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmFuZG9tVG9rZW4oc2l6ZTogbnVtYmVyLCBiYXNlOiBudW1iZXIgPSAzMik6IHN0cmluZyB7XG4gIGxldCB0b2tlbjogc3RyaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBjb25zdCByOiBudW1iZXIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBiYXNlKTtcbiAgICB0b2tlbiArPSByLnRvU3RyaW5nKGJhc2UpO1xuICB9XG4gIHJldHVybiB0b2tlbjtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlYXNvblBocmFzZShjb2RlOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gUkVBU09OX1BIUkFTRVtjb2RlXSB8fCBcIlwiO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmV3VGFnKCk6IHN0cmluZyB7XG4gIHJldHVybiBjcmVhdGVSYW5kb21Ub2tlbigxMCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHN0ciAtXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlYWRlcml6ZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGV4Y2VwdGlvbnM6IGFueSA9IHtcbiAgICBcIkNhbGwtSWRcIjogXCJDYWxsLUlEXCIsXG4gICAgXCJDc2VxXCI6IFwiQ1NlcVwiLFxuICAgIFwiTWluLVNlXCI6IFwiTWluLVNFXCIsXG4gICAgXCJSYWNrXCI6IFwiUkFja1wiLFxuICAgIFwiUnNlcVwiOiBcIlJTZXFcIixcbiAgICBcIld3dy1BdXRoZW50aWNhdGVcIjogXCJXV1ctQXV0aGVudGljYXRlXCIsXG4gIH07XG4gIGNvbnN0IG5hbWU6IEFycmF5PHN0cmluZz4gPSBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9fL2csIFwiLVwiKS5zcGxpdChcIi1cIik7XG4gIGNvbnN0IHBhcnRzOiBudW1iZXIgPSBuYW1lLmxlbmd0aDtcbiAgbGV0IGhuYW1lOiBzdHJpbmcgPSBcIlwiO1xuXG4gIGZvciAobGV0IHBhcnQgPSAwOyBwYXJ0IDwgcGFydHM7IHBhcnQrKykge1xuICAgIGlmIChwYXJ0ICE9PSAwKSB7XG4gICAgICBobmFtZSArPSBcIi1cIjtcbiAgICB9XG4gICAgaG5hbWUgKz0gbmFtZVtwYXJ0XS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWVbcGFydF0uc3Vic3RyaW5nKDEpO1xuICB9XG4gIGlmIChleGNlcHRpb25zW2huYW1lXSkge1xuICAgIGhuYW1lID0gZXhjZXB0aW9uc1tobmFtZV07XG4gIH1cbiAgcmV0dXJuIGhuYW1lO1xufVxuXG4vKipcbiAqIEBwYXJhbSBzdHIgLVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJfdXRmOF9sZW5ndGgoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvJVtBLUZcXGRdezJ9L2csIFwiVVwiKS5sZW5ndGg7XG59XG5cbi8qKlxuICogU0lQIFJlc3BvbnNlIFJlYXNvbnNcbiAqIERPQzogaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zaXAtcGFyYW1ldGVyc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFJFQVNPTl9QSFJBU0U6IHsgW2NvZGU6IG51bWJlcl06IHN0cmluZyB9ID0ge1xuICAxMDA6IFwiVHJ5aW5nXCIsXG4gIDE4MDogXCJSaW5naW5nXCIsXG4gIDE4MTogXCJDYWxsIElzIEJlaW5nIEZvcndhcmRlZFwiLFxuICAxODI6IFwiUXVldWVkXCIsXG4gIDE4MzogXCJTZXNzaW9uIFByb2dyZXNzXCIsXG4gIDE5OTogXCJFYXJseSBEaWFsb2cgVGVybWluYXRlZFwiLCAgLy8gZHJhZnQtaWV0Zi1zaXBjb3JlLTE5OVxuICAyMDA6IFwiT0tcIixcbiAgMjAyOiBcIkFjY2VwdGVkXCIsICAvLyBSRkMgMzI2NVxuICAyMDQ6IFwiTm8gTm90aWZpY2F0aW9uXCIsICAvLyBSRkMgNTgzOVxuICAzMDA6IFwiTXVsdGlwbGUgQ2hvaWNlc1wiLFxuICAzMDE6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgMzAyOiBcIk1vdmVkIFRlbXBvcmFyaWx5XCIsXG4gIDMwNTogXCJVc2UgUHJveHlcIixcbiAgMzgwOiBcIkFsdGVybmF0aXZlIFNlcnZpY2VcIixcbiAgNDAwOiBcIkJhZCBSZXF1ZXN0XCIsXG4gIDQwMTogXCJVbmF1dGhvcml6ZWRcIixcbiAgNDAyOiBcIlBheW1lbnQgUmVxdWlyZWRcIixcbiAgNDAzOiBcIkZvcmJpZGRlblwiLFxuICA0MDQ6IFwiTm90IEZvdW5kXCIsXG4gIDQwNTogXCJNZXRob2QgTm90IEFsbG93ZWRcIixcbiAgNDA2OiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gIDQwNzogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICA0MDg6IFwiUmVxdWVzdCBUaW1lb3V0XCIsXG4gIDQxMDogXCJHb25lXCIsXG4gIDQxMjogXCJDb25kaXRpb25hbCBSZXF1ZXN0IEZhaWxlZFwiLCAgLy8gUkZDIDM5MDNcbiAgNDEzOiBcIlJlcXVlc3QgRW50aXR5IFRvbyBMYXJnZVwiLFxuICA0MTQ6IFwiUmVxdWVzdC1VUkkgVG9vIExvbmdcIixcbiAgNDE1OiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgNDE2OiBcIlVuc3VwcG9ydGVkIFVSSSBTY2hlbWVcIixcbiAgNDE3OiBcIlVua25vd24gUmVzb3VyY2UtUHJpb3JpdHlcIiwgIC8vIFJGQyA0NDEyXG4gIDQyMDogXCJCYWQgRXh0ZW5zaW9uXCIsXG4gIDQyMTogXCJFeHRlbnNpb24gUmVxdWlyZWRcIixcbiAgNDIyOiBcIlNlc3Npb24gSW50ZXJ2YWwgVG9vIFNtYWxsXCIsICAvLyBSRkMgNDAyOFxuICA0MjM6IFwiSW50ZXJ2YWwgVG9vIEJyaWVmXCIsXG4gIDQyODogXCJVc2UgSWRlbnRpdHkgSGVhZGVyXCIsICAvLyBSRkMgNDQ3NFxuICA0Mjk6IFwiUHJvdmlkZSBSZWZlcnJlciBJZGVudGl0eVwiLCAgLy8gUkZDIDM4OTJcbiAgNDMwOiBcIkZsb3cgRmFpbGVkXCIsICAvLyBSRkMgNTYyNlxuICA0MzM6IFwiQW5vbnltaXR5IERpc2FsbG93ZWRcIiwgIC8vIFJGQyA1MDc5XG4gIDQzNjogXCJCYWQgSWRlbnRpdHktSW5mb1wiLCAgLy8gUkZDIDQ0NzRcbiAgNDM3OiBcIlVuc3VwcG9ydGVkIENlcnRpZmljYXRlXCIsICAvLyBSRkMgNDc0NFxuICA0Mzg6IFwiSW52YWxpZCBJZGVudGl0eSBIZWFkZXJcIiwgIC8vIFJGQyA0NzQ0XG4gIDQzOTogXCJGaXJzdCBIb3AgTGFja3MgT3V0Ym91bmQgU3VwcG9ydFwiLCAgLy8gUkZDIDU2MjZcbiAgNDQwOiBcIk1heC1CcmVhZHRoIEV4Y2VlZGVkXCIsICAvLyBSRkMgNTM5M1xuICA0Njk6IFwiQmFkIEluZm8gUGFja2FnZVwiLCAgLy8gZHJhZnQtaWV0Zi1zaXBjb3JlLWluZm8tZXZlbnRzXG4gIDQ3MDogXCJDb25zZW50IE5lZWRlZFwiLCAgLy8gUkZDIDUzNjBcbiAgNDc4OiBcIlVucmVzb2x2YWJsZSBEZXN0aW5hdGlvblwiLCAgLy8gQ3VzdG9tIGNvZGUgY29waWVkIGZyb20gS2FtYWlsaW8uXG4gIDQ4MDogXCJUZW1wb3JhcmlseSBVbmF2YWlsYWJsZVwiLFxuICA0ODE6IFwiQ2FsbC9UcmFuc2FjdGlvbiBEb2VzIE5vdCBFeGlzdFwiLFxuICA0ODI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICA0ODM6IFwiVG9vIE1hbnkgSG9wc1wiLFxuICA0ODQ6IFwiQWRkcmVzcyBJbmNvbXBsZXRlXCIsXG4gIDQ4NTogXCJBbWJpZ3VvdXNcIixcbiAgNDg2OiBcIkJ1c3kgSGVyZVwiLFxuICA0ODc6IFwiUmVxdWVzdCBUZXJtaW5hdGVkXCIsXG4gIDQ4ODogXCJOb3QgQWNjZXB0YWJsZSBIZXJlXCIsXG4gIDQ4OTogXCJCYWQgRXZlbnRcIiwgIC8vIFJGQyAzMjY1XG4gIDQ5MTogXCJSZXF1ZXN0IFBlbmRpbmdcIixcbiAgNDkzOiBcIlVuZGVjaXBoZXJhYmxlXCIsXG4gIDQ5NDogXCJTZWN1cml0eSBBZ3JlZW1lbnQgUmVxdWlyZWRcIiwgIC8vIFJGQyAzMzI5XG4gIDUwMDogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgNTAxOiBcIk5vdCBJbXBsZW1lbnRlZFwiLFxuICA1MDI6IFwiQmFkIEdhdGV3YXlcIixcbiAgNTAzOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgNTA0OiBcIlNlcnZlciBUaW1lLW91dFwiLFxuICA1MDU6IFwiVmVyc2lvbiBOb3QgU3VwcG9ydGVkXCIsXG4gIDUxMzogXCJNZXNzYWdlIFRvbyBMYXJnZVwiLFxuICA1ODA6IFwiUHJlY29uZGl0aW9uIEZhaWx1cmVcIiwgIC8vIFJGQyAzMzEyXG4gIDYwMDogXCJCdXN5IEV2ZXJ5d2hlcmVcIixcbiAgNjAzOiBcIkRlY2xpbmVcIixcbiAgNjA0OiBcIkRvZXMgTm90IEV4aXN0IEFueXdoZXJlXCIsXG4gIDYwNjogXCJOb3QgQWNjZXB0YWJsZVwiXG59O1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vc2Vzc2lvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2Vzc2lvbi1kZWxlZ2F0ZVwiO1xuIiwiaW1wb3J0IHtcbiAgQm9keSxcbiAgT3V0Z29pbmdCeWVSZXF1ZXN0LFxuICBPdXRnb2luZ0luZm9SZXF1ZXN0LFxuICBPdXRnb2luZ0ludml0ZVJlcXVlc3QsXG4gIE91dGdvaW5nSW52aXRlUmVxdWVzdERlbGVnYXRlLFxuICBPdXRnb2luZ05vdGlmeVJlcXVlc3QsXG4gIE91dGdvaW5nUHJhY2tSZXF1ZXN0LFxuICBPdXRnb2luZ1JlZmVyUmVxdWVzdCxcbiAgT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGUsXG4gIFJlcXVlc3RPcHRpb25zLFxuICBVUklcbn0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBTZXNzaW9uRGVsZWdhdGUgfSBmcm9tIFwiLi9zZXNzaW9uLWRlbGVnYXRlXCI7XG5cbi8qKlxuICogU2Vzc2lvbi5cbiAqIEByZW1hcmtzXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbiB7XG4gIC8qKiBTZXNzaW9uIGRlbGVnYXRlLiAqL1xuICBkZWxlZ2F0ZTogU2Vzc2lvbkRlbGVnYXRlIHwgdW5kZWZpbmVkO1xuICAvKiogVGhlIHNlc3Npb24gaWQuIEVxdWFsIHRvIGNhbGxJZCArIGxvY2FsVGFnICsgcmVtb3RlVGFnLiAqL1xuICByZWFkb25seSBpZDogc3RyaW5nO1xuICAvKiogQ2FsbCBJZC4gKi9cbiAgcmVhZG9ubHkgY2FsbElkOiBzdHJpbmc7XG4gIC8qKiBMb2NhbCBUYWcuICovXG4gIHJlYWRvbmx5IGxvY2FsVGFnOiBzdHJpbmc7XG4gIC8qKiBMb2NhbCBVUkkuICovXG4gIHJlYWRvbmx5IGxvY2FsVVJJOiBVUkk7XG4gIC8qKiBSZW1vdGUgVGFnLiAqL1xuICByZWFkb25seSByZW1vdGVUYWc6IHN0cmluZztcbiAgLyoqIFJlbW90ZSBUYXJnZXQuICovXG4gIHJlYWRvbmx5IHJlbW90ZVRhcmdldDogVVJJO1xuICAvKiogUmVtb3RlIFVSSS4gKi9cbiAgcmVhZG9ubHkgcmVtb3RlVVJJOiBVUkk7XG4gIC8qKiBTZXNzaW9uIHN0YXRlLiAqL1xuICByZWFkb25seSBzZXNzaW9uU3RhdGU6IFNlc3Npb25TdGF0ZTtcbiAgLyoqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIG9mZmVyL2Fuc3dlciBleGNoYW5nZS4gKi9cbiAgcmVhZG9ubHkgc2lnbmFsaW5nU3RhdGU6IFNpZ25hbGluZ1N0YXRlO1xuICAvKiogVGhlIGN1cnJlbnQgYW5zd2VyIGlmIHNpZ25hbGluZ1N0YXRlIGlzIHN0YWJsZS4gT3RoZXJ3aXNlIHVuZGVmaW5lZC4gKi9cbiAgcmVhZG9ubHkgYW5zd2VyOiBCb2R5IHwgdW5kZWZpbmVkO1xuICAvKiogVGhlIGN1cnJlbnQgb2ZmZXIgaWYgc2lnbmFsaW5nU3RhdGUgaXMgbm90IGluaXRpYWwgb3IgY2xvc2VkLiBPdGhlcndpc2UgdW5kZWZpbmVkLiAqL1xuICByZWFkb25seSBvZmZlcjogQm9keSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRGVzdHJveSBzZXNzaW9uLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBTZW5kIGEgQllFIHJlcXVlc3QuXG4gICAqIFRlcm1pbmF0aW5nIGEgc2Vzc2lvbi5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNVxuICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgYnllKGRlbGVnYXRlPzogT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGUsIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyk6IE91dGdvaW5nQnllUmVxdWVzdDtcblxuICAvKipcbiAgICogU2VuZCBhbiBJTkZPIHJlcXVlc3QuXG4gICAqIEV4Y2hhbmdlIGluZm9ybWF0aW9uIGR1cmluZyBhIHNlc3Npb24uXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDg2I3NlY3Rpb24tNC4yLjFcbiAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIGluZm8oZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogT3V0Z29pbmdJbmZvUmVxdWVzdDtcblxuICAvKipcbiAgICogU2VuZCByZS1JTlZJVEUgcmVxdWVzdC5cbiAgICogTW9kaWZ5aW5nIGEgc2Vzc2lvbi5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNC4xXG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBpbnZpdGUoZGVsZWdhdGU/OiBPdXRnb2luZ0ludml0ZVJlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogT3V0Z29pbmdJbnZpdGVSZXF1ZXN0O1xuXG4gIC8qKlxuICAgKiBTZW5kIE5PVElGWSByZXF1ZXN0LlxuICAgKiBJbmZvcm0gcmVmZXJyZXIgb2YgdHJhbnNmZXIgcHJvZ3Jlc3MuXG4gICAqIFRoZSB1c2Ugb2YgdGhpcyBpcyBsaW1pdGVkIHRvIHRoZSBpbXBsaWNpdCBjcmVhdGlvbiBvZiBzdWJzY3JpcHRpb24gYnkgUkVGRVIgKGhpc3RvcmljYWwpLlxuICAgKiBPdGhlcndpc2UsIG5vdGlmaWVycyBNVVNUIE5PVCBjcmVhdGUgc3Vic2NyaXB0aW9ucyBleGNlcHQgdXBvbiByZWNlaXB0IG9mIGEgU1VCU0NSSUJFIHJlcXVlc3QuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTE1I3NlY3Rpb24tMy43XG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBub3RpZnkoZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogT3V0Z29pbmdOb3RpZnlSZXF1ZXN0O1xuXG4gIC8qKlxuICAgKiBTZW5kIFBSQUNLIHJlcXVlc3QuXG4gICAqIEFja25vd2xlZGdlIGEgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNFxuICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgcHJhY2soZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogT3V0Z29pbmdQcmFja1JlcXVlc3Q7XG5cbiAgLyoqXG4gICAqIFNlbmQgUkVGRVIgcmVxdWVzdCAoaW4gZGlhbG9nKS5cbiAgICogVHJhbnNmZXIgYSBzZXNzaW9uLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzUxNSNzZWN0aW9uLTIuNC4xXG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICByZWZlcihkZWxlZ2F0ZT86IE91dGdvaW5nUmVxdWVzdERlbGVnYXRlLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpOiBPdXRnb2luZ1JlZmVyUmVxdWVzdDtcbn1cblxuLyoqXG4gKiBTZXNzaW9uIHN0YXRlLlxuICogQHJlbWFya3NcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGVudW0gU2Vzc2lvblN0YXRlIHtcbiAgSW5pdGlhbCA9IFwiSW5pdGlhbFwiLFxuICBFYXJseSA9IFwiRWFybHlcIixcbiAgQWNrV2FpdCA9IFwiQWNrV2FpdFwiLFxuICBDb25maXJtZWQgPSBcIkNvbmZpcm1lZFwiLFxuICBUZXJtaW5hdGVkID0gXCJUZXJtaW5hdGVkXCJcbn1cblxuLyoqXG4gKiBPZmZlci9BbnN3ZXIgc3RhdGUuXG4gKiBAcmVtYXJrc1xuICogYGBgdHh0XG4gKiAgICAgICAgIE9mZmVyICAgICAgICAgICAgICAgIEFuc3dlciAgICAgICAgICAgICBSRkMgICAgSW5pIEVzdCBFYXJseVxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICAxLiBJTlZJVEUgUmVxLiAgICAgICAgICAyeHggSU5WSVRFIFJlc3AuICAgICBSRkMgMzI2MSAgWSAgIFkgICAgTlxuICogIDIuIDJ4eCBJTlZJVEUgUmVzcC4gICAgIEFDSyBSZXEuICAgICAgICAgICAgIFJGQyAzMjYxICBZICAgWSAgICBOXG4gKiAgMy4gSU5WSVRFIFJlcS4gICAgICAgICAgMXh4LXJlbCBJTlZJVEUgUmVzcC4gUkZDIDMyNjIgIFkgICBZICAgIE5cbiAqICA0LiAxeHgtcmVsIElOVklURSBSZXNwLiBQUkFDSyBSZXEuICAgICAgICAgICBSRkMgMzI2MiAgWSAgIFkgICAgTlxuICogIDUuIFBSQUNLIFJlcS4gICAgICAgICAgIDIwMCBQUkFDSyBSZXNwLiAgICAgIFJGQyAzMjYyICBOICAgWSAgICBZXG4gKiAgNi4gVVBEQVRFIFJlcS4gICAgICAgICAgMnh4IFVQREFURSBSZXNwLiAgICAgUkZDIDMzMTEgIE4gICBZICAgIFlcbiAqXG4gKiAgICAgICBUYWJsZSAxOiBTdW1tYXJ5IG9mIFNJUCBVc2FnZSBvZiB0aGUgT2ZmZXIvQW5zd2VyIE1vZGVsXG4gKiBgYGBcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MzM3I3NlY3Rpb24tMi4yXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBlbnVtIFNpZ25hbGluZ1N0YXRlIHtcbiAgSW5pdGlhbCA9IFwiSW5pdGlhbFwiLCAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZVxuICBIYXZlTG9jYWxPZmZlciA9IFwiSGF2ZUxvY2FsT2ZmZXJcIiwgICAvLyBQYXR0ZXJucyAxLCAzLCA1LCA2XG4gIEhhdmVSZW1vdGVPZmZlciA9IFwiSGF2ZVJlbW90ZU9mZmVyXCIsIC8vIFBhdHRlcm5zIDIsIDRcbiAgU3RhYmxlID0gXCJTdGFibGVcIixcbiAgQ2xvc2VkID0gXCJDbG9zZWRcIlxufVxuIiwiZXhwb3J0ICogZnJvbSBcIi4vc3Vic2NyaXB0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zdWJzY3JpcHRpb24tZGVsZWdhdGVcIjtcbiIsImltcG9ydCB7XG4gIE91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdCxcbiAgT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0RGVsZWdhdGUsXG4gIFJlcXVlc3RPcHRpb25zXG59IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uRGVsZWdhdGUgfSBmcm9tIFwiLi9zdWJzY3JpcHRpb24tZGVsZWdhdGVcIjtcblxuLyoqXG4gKiBTdWJzY3JpcHRpb24uXG4gKiBAcmVtYXJrc1xuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpcHRpb24ge1xuICAvKiogU3Vic2NyaXB0aW9uIGRlbGVnYXRlLiAqL1xuICBkZWxlZ2F0ZTogU3Vic2NyaXB0aW9uRGVsZWdhdGUgfCB1bmRlZmluZWQ7XG4gIC8qKiBUaGUgc3Vic2NyaXB0aW9uIGlkLiAqL1xuICByZWFkb25seSBpZDogc3RyaW5nO1xuICAvKiogU3Vic2NyaXB0aW9uIGV4cGlyZXMuIE51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzdWJzY3JpcHRpb24gZXhwaXJlcy4gKi9cbiAgcmVhZG9ubHkgc3Vic2NyaXB0aW9uRXhwaXJlczogbnVtYmVyO1xuICAvKiogU3Vic2NyaXB0aW9uIHN0YXRlLiAqL1xuICByZWFkb25seSBzdWJzY3JpcHRpb25TdGF0ZTogU3Vic2NyaXB0aW9uU3RhdGU7XG4gIC8qKiBJZiB0cnVlLCByZWZyZXNoIHN1YnNjcmlwdGlvbiBwcmlvciB0byBleHBpcmF0aW9uLiBEZWZhdWx0IGlzIGZhbHNlLiAqL1xuICBhdXRvUmVmcmVzaDogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGVzdHJveSBzdWJzY3JpcHRpb24uXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFNlbmQgcmUtU1VCU0NSSUJFIHJlcXVlc3QuXG4gICAqIFJlZnJlc2hpbmcgYSBzdWJzY3JpcHRpb24gYW5kIHVuc3Vic2NyaWJpbmcuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMlxuICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0XG4gICAqL1xuICBzdWJzY3JpYmUoZGVsZWdhdGU/OiBPdXRnb2luZ1N1YnNjcmliZVJlcXVlc3REZWxlZ2F0ZSwgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0O1xuXG4gIC8qKlxuICAgKiA0LjEuMi4yLiAgUmVmcmVzaGluZyBvZiBTdWJzY3JpcHRpb25zXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMlxuICAgKi9cbiAgcmVmcmVzaCgpOiBPdXRnb2luZ1N1YnNjcmliZVJlcXVlc3Q7XG5cbiAgLyoqXG4gICAqIDQuMS4yLjMuICBVbnN1YnNjcmliaW5nXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuM1xuICAgKi9cbiAgdW5zdWJzY3JpYmUoKTogT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0O1xufVxuXG4vKipcbiAqIFN1YnNjcmlwdGlvbiBzdGF0ZS5cbiAqIEByZW1hcmtzXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBlbnVtIFN1YnNjcmlwdGlvblN0YXRlIHtcbiAgSW5pdGlhbCA9IFwiSW5pdGlhbFwiLFxuICBOb3RpZnlXYWl0ID0gXCJOb3RpZnlXYWl0XCIsXG4gIFBlbmRpbmcgPSBcIlBlbmRpbmdcIixcbiAgQWN0aXZlID0gXCJBY3RpdmVcIixcbiAgVGVybWluYXRlZCA9IFwiVGVybWluYXRlZFwiXG59XG4iLCJjb25zdCBUMTogbnVtYmVyID0gNTAwO1xuY29uc3QgVDI6IG51bWJlciA9IDQwMDA7XG5jb25zdCBUNDogbnVtYmVyID0gNTAwMDtcblxuLyoqXG4gKiBUaW1lcnMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBUaW1lcnMgPSB7XG4gIFQxLFxuICBUMixcbiAgVDQsXG4gIFRJTUVSX0I6IDY0ICogVDEsXG4gIFRJTUVSX0Q6IDAgICogVDEsIC8vIE5vdCBjb3JyZWN0IGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHNcbiAgVElNRVJfRjogNjQgKiBUMSxcbiAgVElNRVJfSDogNjQgKiBUMSxcbiAgVElNRVJfSTogMCAgKiBUNCwgLy8gTm90IGNvcnJlY3QgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0c1xuICBUSU1FUl9KOiAwICAqIFQxLCAvLyBOb3QgY29ycmVjdCBmb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzXG4gIFRJTUVSX0s6IDAgICogVDQsIC8vIE5vdCBjb3JyZWN0IGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHNcbiAgVElNRVJfTDogNjQgKiBUMSxcbiAgVElNRVJfTTogNjQgKiBUMSxcbiAgVElNRVJfTjogNjQgKiBUMSxcbiAgUFJPVklTSU9OQUxfUkVTUE9OU0VfSU5URVJWQUw6IDYwMDAwICAvLyBTZWUgUkZDIDMyNjEgU2VjdGlvbiAxMy4zLjEuMVxufTtcbiIsImltcG9ydCB7IEluY29taW5nUmVzcG9uc2VNZXNzYWdlLCBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBUcmFuc3BvcnQgfSBmcm9tIFwiLi4vdHJhbnNwb3J0XCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gXCIuL3RyYW5zYWN0aW9uXCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXRlIH0gZnJvbSBcIi4vdHJhbnNhY3Rpb24tc3RhdGVcIjtcbmltcG9ydCB7IENsaWVudFRyYW5zYWN0aW9uVXNlciB9IGZyb20gXCIuL3RyYW5zYWN0aW9uLXVzZXJcIjtcblxuLyoqXG4gKiBDbGllbnQgVHJhbnNhY3Rpb24uXG4gKiBAcmVtYXJrc1xuICogVGhlIGNsaWVudCB0cmFuc2FjdGlvbiBwcm92aWRlcyBpdHMgZnVuY3Rpb25hbGl0eSB0aHJvdWdoIHRoZVxuICogbWFpbnRlbmFuY2Ugb2YgYSBzdGF0ZSBtYWNoaW5lLlxuICpcbiAqIFRoZSBUVSBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIHRocm91Z2ggYSBzaW1wbGVcbiAqIGludGVyZmFjZS4gIFdoZW4gdGhlIFRVIHdpc2hlcyB0byBpbml0aWF0ZSBhIG5ldyB0cmFuc2FjdGlvbiwgaXRcbiAqIGNyZWF0ZXMgYSBjbGllbnQgdHJhbnNhY3Rpb24gYW5kIHBhc3NlcyBpdCB0aGUgU0lQIHJlcXVlc3QgdG8gc2VuZFxuICogYW5kIGFuIElQIGFkZHJlc3MsIHBvcnQsIGFuZCB0cmFuc3BvcnQgdG8gd2hpY2ggdG8gc2VuZCBpdC4gIFRoZVxuICogY2xpZW50IHRyYW5zYWN0aW9uIGJlZ2lucyBleGVjdXRpb24gb2YgaXRzIHN0YXRlIG1hY2hpbmUuICBWYWxpZFxuICogcmVzcG9uc2VzIGFyZSBwYXNzZWQgdXAgdG8gdGhlIFRVIGZyb20gdGhlIGNsaWVudCB0cmFuc2FjdGlvbi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2xpZW50VHJhbnNhY3Rpb24gZXh0ZW5kcyBUcmFuc2FjdGlvbiB7XG4gIHByaXZhdGUgc3RhdGljIG1ha2VJZChyZXF1ZXN0OiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKTogc3RyaW5nIHtcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFwiQ0FOQ0VMXCIpIHtcbiAgICAgIGlmICghcmVxdWVzdC5icmFuY2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3V0Z29pbmcgQ0FOQ0VMIHJlcXVlc3Qgd2l0aG91dCBhIGJyYW5jaC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdC5icmFuY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIno5aEc0YktcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfcmVxdWVzdDogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICB0cmFuc3BvcnQ6IFRyYW5zcG9ydCxcbiAgICBwcm90ZWN0ZWQgdXNlcjogQ2xpZW50VHJhbnNhY3Rpb25Vc2VyLFxuICAgIHN0YXRlOiBUcmFuc2FjdGlvblN0YXRlLFxuICAgIGxvZ2dlckNhdGVnb3J5OiBzdHJpbmcsXG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgdHJhbnNwb3J0LFxuICAgICAgdXNlcixcbiAgICAgIENsaWVudFRyYW5zYWN0aW9uLm1ha2VJZChfcmVxdWVzdCksXG4gICAgICBzdGF0ZSxcbiAgICAgIGxvZ2dlckNhdGVnb3J5XG4gICAgKTtcbiAgICAvLyBUaGUgVmlhIGhlYWRlciBmaWVsZCBpbmRpY2F0ZXMgdGhlIHRyYW5zcG9ydCB1c2VkIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAvLyBhbmQgaWRlbnRpZmllcyB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIHJlc3BvbnNlIGlzIHRvIGJlIHNlbnQuICBBIFZpYVxuICAgIC8vIGhlYWRlciBmaWVsZCB2YWx1ZSBpcyBhZGRlZCBvbmx5IGFmdGVyIHRoZSB0cmFuc3BvcnQgdGhhdCB3aWxsIGJlXG4gICAgLy8gdXNlZCB0byByZWFjaCB0aGUgbmV4dCBob3AgaGFzIGJlZW4gc2VsZWN0ZWQgKHdoaWNoIG1heSBpbnZvbHZlIHRoZVxuICAgIC8vIHVzYWdlIG9mIHRoZSBwcm9jZWR1cmVzIGluIFs0XSkuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMS43XG4gICAgX3JlcXVlc3Quc2V0VmlhSGVhZGVyKHRoaXMuaWQsIHRyYW5zcG9ydC5wcm90b2NvbCk7XG4gIH1cblxuICAvKiogVGhlIG91dGdvaW5nIHJlcXVlc3QgdGhlIHRyYW5zYWN0aW9uIGhhbmRsaW5nLiAqL1xuICBnZXQgcmVxdWVzdCgpOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNlaXZlIGluY29taW5nIHJlc3BvbnNlcyBmcm9tIHRoZSB0cmFuc3BvcnQgd2hpY2ggbWF0Y2ggdGhpcyB0cmFuc2FjdGlvbi5cbiAgICogUmVzcG9uc2VzIHdpbGwgYmUgZGVsaXZlcmVkIHRvIHRoZSB0cmFuc2FjdGlvbiB1c2VyIGFzIG5lY2Vzc2FyeS5cbiAgICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIGluY29taW5nIHJlc3BvbnNlLlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHJlY2VpdmVSZXNwb25zZShyZXNwb25zZTogSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBBIDQwOCB0byBub24tSU5WSVRFIHdpbGwgYWx3YXlzIGFycml2ZSB0b28gbGF0ZSB0byBiZSB1c2VmdWwgKFszXSksXG4gICAqIFRoZSBjbGllbnQgYWxyZWFkeSBoYXMgZnVsbCBrbm93bGVkZ2Ugb2YgdGhlIHRpbWVvdXQuIFRoZSBvbmx5XG4gICAqIGluZm9ybWF0aW9uIHRoaXMgbWVzc2FnZSB3b3VsZCBjb252ZXkgaXMgd2hldGhlciBvciBub3QgdGhlIHNlcnZlclxuICAgKiBiZWxpZXZlZCB0aGUgdHJhbnNhY3Rpb24gdGltZWQgb3V0LiBIb3dldmVyLCB3aXRoIHRoZSBjdXJyZW50IGRlc2lnblxuICAgKiBvZiB0aGUgTklULCBhIGNsaWVudCBjYW5ub3QgZG8gYW55dGhpbmcgd2l0aCB0aGlzIGtub3dsZWRnZS4gVGh1cyxcbiAgICogdGhlIDQwOCBpcyBzaW1wbHkgd2FzdGluZyBuZXR3b3JrIHJlc291cmNlcyBhbmQgY29udHJpYnV0ZXMgdG8gdGhlXG4gICAqIHJlc3BvbnNlIGJvbWJhcmRtZW50IGlsbHVzdHJhdGVkIGluIFszXS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQzMjAjc2VjdGlvbi00LjFcbiAgICovXG4gIHByb3RlY3RlZCBvblJlcXVlc3RUaW1lb3V0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnVzZXIub25SZXF1ZXN0VGltZW91dCkge1xuICAgICAgdGhpcy51c2VyLm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gXCIuL2NsaWVudC10cmFuc2FjdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW52aXRlLWNsaWVudC10cmFuc2FjdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW52aXRlLXNlcnZlci10cmFuc2FjdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbm9uLWludml0ZS1jbGllbnQtdHJhbnNhY3Rpb25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL25vbi1pbnZpdGUtc2VydmVyLXRyYW5zYWN0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbnZpdGUtY2xpZW50LXRyYW5zYWN0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXJ2ZXItdHJhbnNhY3Rpb25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL3RyYW5zYWN0aW9uLXN0YXRlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90cmFuc2FjdGlvbi11c2VyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90cmFuc2FjdGlvblwiO1xuIiwiaW1wb3J0IHsgVHJhbnNwb3J0RXJyb3IgfSBmcm9tIFwiLi4vZXhjZXB0aW9uc1wiO1xuXG5pbXBvcnQgeyBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSwgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgVGltZXJzIH0gZnJvbSBcIi4uL3RpbWVyc1wiO1xuaW1wb3J0IHsgVHJhbnNwb3J0IH0gZnJvbSBcIi4uL3RyYW5zcG9ydFwiO1xuaW1wb3J0IHsgQ2xpZW50VHJhbnNhY3Rpb24gfSBmcm9tIFwiLi9jbGllbnQtdHJhbnNhY3Rpb25cIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdGUgfSBmcm9tIFwiLi90cmFuc2FjdGlvbi1zdGF0ZVwiO1xuaW1wb3J0IHsgQ2xpZW50VHJhbnNhY3Rpb25Vc2VyIH0gZnJvbSBcIi4vdHJhbnNhY3Rpb24tdXNlclwiO1xuXG4vKipcbiAqIElOVklURSBDbGllbnQgVHJhbnNhY3Rpb24uXG4gKiBAcmVtYXJrc1xuICogVGhlIElOVklURSB0cmFuc2FjdGlvbiBjb25zaXN0cyBvZiBhIHRocmVlLXdheSBoYW5kc2hha2UuICBUaGUgY2xpZW50XG4gKiB0cmFuc2FjdGlvbiBzZW5kcyBhbiBJTlZJVEUsIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gc2VuZHMgcmVzcG9uc2VzLFxuICogYW5kIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gc2VuZHMgYW4gQUNLLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjFcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEludml0ZUNsaWVudFRyYW5zYWN0aW9uIGV4dGVuZHMgQ2xpZW50VHJhbnNhY3Rpb24ge1xuICBwcml2YXRlIEI6IGFueSB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBEOiBhbnkgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgTTogYW55IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgMnh4IHRvLXRhZyB0byBBQ0suXG4gICAqIElmIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQsIHZhbHVlIGlzIHRoZSBBQ0sgd2hpY2ggd2FzIHNlbnQuXG4gICAqIElmIGtleSBleGlzdHMgYnV0IHZhbHVlIGlzIHVuZGVmaW5lZCwgYSAyeHggd2FzIHJlY2VpdmVkIGJ1dCB0aGUgQUNLIG5vdCB5ZXQgc2VudC5cbiAgICogT3RoZXJ3aXNlLCBhIDJ4eCB3YXMgbm90ICh5ZXQpIHJlY2VpdmVkIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhY2tSZXRyYW5zbWlzc2lvbkNhY2hlOiBNYXA8c3RyaW5nLCBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlIHwgdW5kZWZpbmVkPiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqIFVwb24gY29uc3RydWN0aW9uLCB0aGUgb3V0Z29pbmcgcmVxdWVzdCdzIFZpYSBoZWFkZXIgaXMgdXBkYXRlZCBieSBjYWxsaW5nIGBzZXRWaWFIZWFkZXJgLlxuICAgKiBUaGVuIGB0b1N0cmluZ2AgaXMgY2FsbGVkIG9uIHRoZSBvdXRnb2luZyByZXF1ZXN0IGFuZCB0aGUgbWVzc2FnZSBpcyBzZW50IHZpYSB0aGUgdHJhbnNwb3J0LlxuICAgKiBBZnRlciBjb25zdHJ1Y3Rpb24gdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgaW4gdGhlIFwiY2FsbGluZ1wiIHN0YXRlIGFuZCB0aGUgdHJhbnNhY3Rpb24gaWRcbiAgICogd2lsbCBlcXVhbCB0aGUgYnJhbmNoIHBhcmFtZXRlciBzZXQgaW4gdGhlIFZpYSBoZWFkZXIgb2YgdGhlIG91dGdvaW5nIHJlcXVlc3QuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIG91dGdvaW5nIElOVklURSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gdHJhbnNwb3J0IC0gVGhlIHRyYW5zcG9ydC5cbiAgICogQHBhcmFtIHVzZXIgLSBUaGUgdHJhbnNhY3Rpb24gdXNlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlcXVlc3Q6IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UsIHRyYW5zcG9ydDogVHJhbnNwb3J0LCB1c2VyOiBDbGllbnRUcmFuc2FjdGlvblVzZXIpIHtcbiAgICBzdXBlcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0cmFuc3BvcnQsXG4gICAgICB1c2VyLFxuICAgICAgVHJhbnNhY3Rpb25TdGF0ZS5DYWxsaW5nLFxuICAgICAgXCJzaXAudHJhbnNhY3Rpb24uaWN0XCJcbiAgICApO1xuICAgIC8vIEZJWE1FOiBUaW1lciBBIGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydCBub3QgaW1wbGVtZW50ZWRcbiAgICAvL1xuICAgIC8vIElmIGFuIHVucmVsaWFibGUgdHJhbnNwb3J0IGlzIGJlaW5nIHVzZWQsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb25cbiAgICAvLyBNVVNUIHN0YXJ0IHRpbWVyIEEgd2l0aCBhIHZhbHVlIG9mIFQxLiBJZiBhIHJlbGlhYmxlIHRyYW5zcG9ydCBpcyBiZWluZyB1c2VkLFxuICAgIC8vIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gU0hPVUxEIE5PVCBzdGFydCB0aW1lciBBIChUaW1lciBBIGNvbnRyb2xzIHJlcXVlc3QgcmV0cmFuc21pc3Npb25zKS5cbiAgICAvLyBGb3IgYW55IHRyYW5zcG9ydCwgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIHN0YXJ0IHRpbWVyIEIgd2l0aCBhIHZhbHVlXG4gICAgLy8gb2YgNjQqVDEgc2Vjb25kcyAoVGltZXIgQiBjb250cm9scyB0cmFuc2FjdGlvbiB0aW1lb3V0cykuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjEuMlxuICAgIC8vXG4gICAgLy8gV2hpbGUgbm90IHNwZWxsZWQgb3V0IGluIHRoZSBSRkMsIFRpbWVyIEIgaXMgdGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdGhhdCBhIHNlbmRlclxuICAgIC8vIHdpbGwgd2FpdCBmb3IgYW4gSU5WSVRFIG1lc3NhZ2UgdG8gYmUgYWNrbm93bGVkZ2VkIChhIFNJUCByZXNwb25zZSBtZXNzYWdlIGlzIHJlY2VpdmVkKS5cbiAgICAvLyBTbyBUaW1lciBCIHNob3VsZCBiZSBjbGVhcmVkIHdoZW4gdGhlIHRyYW5zYWN0aW9uIHN0YXRlIHByb2NlZWRzIGZyb20gXCJDYWxsaW5nXCIuXG4gICAgdGhpcy5CID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnRpbWVyX0IoKSwgVGltZXJzLlRJTUVSX0IpO1xuICAgIHRoaXMuc2VuZChyZXF1ZXN0LnRvU3RyaW5nKCkpLmNhdGNoKChlcnJvcjogVHJhbnNwb3J0RXJyb3IpID0+IHtcbiAgICAgIHRoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgaW5pdGlhbCBvdXRnb2luZyByZXF1ZXN0LlwiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cnVjdG9yLlxuICAgKi9cbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuQikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuQik7XG4gICAgICB0aGlzLkIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLkQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLkQpO1xuICAgICAgdGhpcy5EID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5NKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5NKTtcbiAgICAgIHRoaXMuTSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uIGtpbmQuIERlcHJlY2F0ZWQuICovXG4gIGdldCBraW5kKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwiaWN0XCI7XG4gIH1cblxuICAvKipcbiAgICogQUNLIGEgMnh4IGZpbmFsIHJlc3BvbnNlLlxuICAgKlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gaW5jbHVkZXMgdGhlIEFDSyBvbmx5IGlmIHRoZSBmaW5hbCByZXNwb25zZSB3YXMgbm90IGEgMnh4IHJlc3BvbnNlICh0aGVcbiAgICogdHJhbnNhY3Rpb24gd2lsbCBnZW5lcmF0ZSBhbmQgc2VuZCB0aGUgQUNLIHRvIHRoZSB0cmFuc3BvcnQgYXV0b21hZ2ljYWxseSkuIElmIHRoZVxuICAgKiBmaW5hbCByZXNwb25zZSB3YXMgYSAyeHgsIHRoZSBBQ0sgaXMgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgdHJhbnNhY3Rpb24gKHRoZVxuICAgKiB0cmFuc2FjdGlvbiB1c2VyIG5lZWRzIHRvIGdlbmVyYXRlIGFuZCBzZW5kIHRoZSBBQ0spLlxuICAgKlxuICAgKiBUaGlzIGxpYnJhcnkgaXMgbm90IHN0cmljdGx5IFJGQyBjb21wbGlhbnQgd2l0aCByZWdhcmQgdG8gQUNLIGhhbmRsaW5nIGZvciAyeHggZmluYWxcbiAgICogcmVzcG9uc2VzLiBTcGVjaWZpY2FsbHksIHJldHJhbnNtaXNzaW9ucyBvZiBBQ0tzIHRvIGEgMnh4IGZpbmFsIHJlc3BvbnNlcyBpcyBoYW5kbGVkXG4gICAqIGJ5IHRoZSB0cmFuc2FjdGlvbiBsYXllciAoaW5zdGVhZCBvZiB0aGUgVUFDIGNvcmUpLiBUaGUgXCJzdGFuZGFyZFwiIGFwcHJvYWNoIGlzIGZvclxuICAgKiB0aGUgVUFDIGNvcmUgdG8gcmVjZWl2ZSBhbGwgMnh4IHJlc3BvbnNlcyBhbmQgbWFuYWdlIHNlbmRpbmcgQUNLIHJldHJhbnNtaXNzaW9ucyB0b1xuICAgKiB0aGUgdHJhbnNwb3J0IGRpcmVjdGx5LiBIZXJlaW4gdGhlIHRyYW5zYWN0aW9uIGxheWVyIG1hbmFnZXMgc2VuZGluZyBBQ0tzIHRvIDJ4eCByZXNwb25zZXNcbiAgICogYW5kIGFueSByZXRyYW5zbWlzc2lvbnMgb2YgdGhvc2UgQUNLcyBhcyBuZWVkZWQuXG4gICAqXG4gICAqIEBwYXJhbSBhY2sgLSBUaGUgb3V0Z29pbmcgQUNLIHJlcXVlc3QuXG4gICAqL1xuICBwdWJsaWMgYWNrUmVzcG9uc2UoYWNrOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKTogdm9pZCB7XG4gICAgY29uc3QgdG9UYWcgPSBhY2sudG9UYWc7XG4gICAgaWYgKCF0b1RhZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gdGFnIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gXCJ6OWhHNGJLXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCk7XG4gICAgYWNrLnNldFZpYUhlYWRlcihpZCwgdGhpcy50cmFuc3BvcnQucHJvdG9jb2wpO1xuICAgIHRoaXMuYWNrUmV0cmFuc21pc3Npb25DYWNoZS5zZXQodG9UYWcsIGFjayk7IC8vIEFkZCB0byBBQ0sgcmV0cmFuc21pc3Npb24gY2FjaGVcbiAgICB0aGlzLnNlbmQoYWNrLnRvU3RyaW5nKCkpLmNhdGNoKChlcnJvcjogVHJhbnNwb3J0RXJyb3IpID0+IHtcbiAgICAgIHRoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgQUNLIHRvIDJ4eCByZXNwb25zZS5cIik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgaW5jb21pbmcgcmVzcG9uc2VzIGZyb20gdGhlIHRyYW5zcG9ydCB3aGljaCBtYXRjaCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgaW5jb21pbmcgcmVzcG9uc2UuXG4gICAqL1xuICBwdWJsaWMgcmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlOiBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSk6IHZvaWQge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgIGlmICghc3RhdHVzQ29kZSB8fCBzdGF0dXNDb2RlIDwgMTAwIHx8IHN0YXR1c0NvZGUgPiA2OTkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9YCk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuQ2FsbGluZzpcbiAgICAgICAgLy8gSWYgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiByZWNlaXZlcyBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdoaWxlIGluXG4gICAgICAgIC8vIHRoZSBcIkNhbGxpbmdcIiBzdGF0ZSwgaXQgdHJhbnNpdGlvbnMgdG8gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLiBJbiB0aGVcbiAgICAgICAgLy8gXCJQcm9jZWVkaW5nXCIgc3RhdGUsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gU0hPVUxEIE5PVCByZXRyYW5zbWl0IHRoZVxuICAgICAgICAvLyByZXF1ZXN0IGFueSBsb25nZXIuIEZ1cnRoZXJtb3JlLCB0aGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgTVVTVCBiZVxuICAgICAgICAvLyBwYXNzZWQgdG8gdGhlIFRVLiAgQW55IGZ1cnRoZXIgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIE1VU1QgYmUgcGFzc2VkXG4gICAgICAgIC8vIHVwIHRvIHRoZSBUVSB3aGlsZSBpbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xLjJcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMTAwICYmIHN0YXR1c0NvZGUgPD0gMTk5KSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nKTtcbiAgICAgICAgICBpZiAodGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZSkge1xuICAgICAgICAgICAgdGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIGEgMnh4IHJlc3BvbnNlIGlzIHJlY2VpdmVkIHdoaWxlIGluIGVpdGhlciB0aGUgXCJDYWxsaW5nXCIgb3JcbiAgICAgICAgLy8gXCJQcm9jZWVkaW5nXCIgc3RhdGVzLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0b1xuICAgICAgICAvLyB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlLi4uIFRoZSAyeHggcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdXAgdG8gdGhlIFRVLlxuICAgICAgICAvLyBUaGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgTk9UIGdlbmVyYXRlIGFuIEFDSyB0byB0aGUgMnh4IHJlc3BvbnNlIC0tIGl0c1xuICAgICAgICAvLyBoYW5kbGluZyBpcyBkZWxlZ2F0ZWQgdG8gdGhlIFRVLiBBIFVBQyBjb3JlIHdpbGwgc2VuZCBhbiBBQ0sgdG9cbiAgICAgICAgLy8gdGhlIDJ4eCByZXNwb25zZSB1c2luZyBhIG5ldyB0cmFuc2FjdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPD0gMjk5KSB7XG4gICAgICAgICAgdGhpcy5hY2tSZXRyYW5zbWlzc2lvbkNhY2hlLnNldChyZXNwb25zZS50b1RhZywgdW5kZWZpbmVkKTsgLy8gUHJpbWUgdGhlIEFDSyBjYWNoZVxuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpO1xuICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gaW4gZWl0aGVyIHRoZSBcIkNhbGxpbmdcIiBvciBcIlByb2NlZWRpbmdcIiBzdGF0ZXMsIHJlY2VwdGlvbiBvZlxuICAgICAgICAvLyBhIHJlc3BvbnNlIHdpdGggc3RhdHVzIGNvZGUgZnJvbSAzMDAtNjk5IE1VU1QgY2F1c2UgdGhlIGNsaWVudFxuICAgICAgICAvLyB0cmFuc2FjdGlvbiB0byB0cmFuc2l0aW9uIHRvIFwiQ29tcGxldGVkXCIuIFRoZSBjbGllbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgLy8gTVVTVCBwYXNzIHRoZSByZWNlaXZlZCByZXNwb25zZSB1cCB0byB0aGUgVFUsIGFuZCB0aGUgY2xpZW50XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIE1VU1QgZ2VuZXJhdGUgYW4gQUNLIHJlcXVlc3QsIGV2ZW4gaWYgdGhlIHRyYW5zcG9ydCBpc1xuICAgICAgICAvLyByZWxpYWJsZSAoZ3VpZGVsaW5lcyBmb3IgY29uc3RydWN0aW5nIHRoZSBBQ0sgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgLy8gYXJlIGdpdmVuIGluIFNlY3Rpb24gMTcuMS4xLjMpLCBhbmQgdGhlbiBwYXNzIHRoZSBBQ0sgdG8gdGhlXG4gICAgICAgIC8vIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLiBUaGUgQUNLIE1VU1QgYmUgc2VudCB0byB0aGVcbiAgICAgICAgLy8gc2FtZSBhZGRyZXNzLCBwb3J0LCBhbmQgdHJhbnNwb3J0IHRvIHdoaWNoIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHdhcyBzZW50LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguNFxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgdGhpcy5hY2socmVzcG9uc2UpO1xuICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc6XG4gICAgICAgIC8vIEluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgTk9UIHJldHJhbnNtaXQgdGhlXG4gICAgICAgIC8vIHJlcXVlc3QgYW55IGxvbmdlci4gRnVydGhlcm1vcmUsIHRoZSBwcm92aXNpb25hbCByZXNwb25zZSBNVVNUIGJlXG4gICAgICAgIC8vIHBhc3NlZCB0byB0aGUgVFUuICBBbnkgZnVydGhlciBwcm92aXNpb25hbCByZXNwb25zZXMgTVVTVCBiZSBwYXNzZWRcbiAgICAgICAgLy8gdXAgdG8gdGhlIFRVIHdoaWxlIGluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjEuMlxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAxMDAgJiYgc3RhdHVzQ29kZSA8PSAxOTkpIHtcbiAgICAgICAgICBpZiAodGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZSkge1xuICAgICAgICAgICAgdGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIGEgMnh4IHJlc3BvbnNlIGlzIHJlY2VpdmVkIHdoaWxlIGluIGVpdGhlciB0aGUgXCJDYWxsaW5nXCIgb3IgXCJQcm9jZWVkaW5nXCIgc3RhdGVzLFxuICAgICAgICAvLyB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlLi4uXG4gICAgICAgIC8vIFRoZSAyeHggcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdXAgdG8gdGhlIFRVLiBUaGUgY2xpZW50XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIE1VU1QgTk9UIGdlbmVyYXRlIGFuIEFDSyB0byB0aGUgMnh4IHJlc3BvbnNlIC0tIGl0c1xuICAgICAgICAvLyBoYW5kbGluZyBpcyBkZWxlZ2F0ZWQgdG8gdGhlIFRVLiBBIFVBQyBjb3JlIHdpbGwgc2VuZCBhbiBBQ0sgdG9cbiAgICAgICAgLy8gdGhlIDJ4eCByZXNwb25zZSB1c2luZyBhIG5ldyB0cmFuc2FjdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPD0gMjk5KSB7XG4gICAgICAgICAgdGhpcy5hY2tSZXRyYW5zbWlzc2lvbkNhY2hlLnNldChyZXNwb25zZS50b1RhZywgdW5kZWZpbmVkKTsgLy8gUHJpbWUgdGhlIEFDSyBjYWNoZVxuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpO1xuICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gaW4gZWl0aGVyIHRoZSBcIkNhbGxpbmdcIiBvciBcIlByb2NlZWRpbmdcIiBzdGF0ZXMsIHJlY2VwdGlvbiBvZlxuICAgICAgICAvLyBhIHJlc3BvbnNlIHdpdGggc3RhdHVzIGNvZGUgZnJvbSAzMDAtNjk5IE1VU1QgY2F1c2UgdGhlIGNsaWVudFxuICAgICAgICAvLyB0cmFuc2FjdGlvbiB0byB0cmFuc2l0aW9uIHRvIFwiQ29tcGxldGVkXCIuIFRoZSBjbGllbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgLy8gTVVTVCBwYXNzIHRoZSByZWNlaXZlZCByZXNwb25zZSB1cCB0byB0aGUgVFUsIGFuZCB0aGUgY2xpZW50XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIE1VU1QgZ2VuZXJhdGUgYW4gQUNLIHJlcXVlc3QsIGV2ZW4gaWYgdGhlIHRyYW5zcG9ydCBpc1xuICAgICAgICAvLyByZWxpYWJsZSAoZ3VpZGVsaW5lcyBmb3IgY29uc3RydWN0aW5nIHRoZSBBQ0sgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgLy8gYXJlIGdpdmVuIGluIFNlY3Rpb24gMTcuMS4xLjMpLCBhbmQgdGhlbiBwYXNzIHRoZSBBQ0sgdG8gdGhlXG4gICAgICAgIC8vIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLiBUaGUgQUNLIE1VU1QgYmUgc2VudCB0byB0aGVcbiAgICAgICAgLy8gc2FtZSBhZGRyZXNzLCBwb3J0LCBhbmQgdHJhbnNwb3J0IHRvIHdoaWNoIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHdhcyBzZW50LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguNFxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgdGhpcy5hY2socmVzcG9uc2UpO1xuICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkOlxuICAgICAgICAvLyBUaGUgcHVycG9zZSBvZiB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlIGlzIHRvIGFsbG93IHRoZSBjbGllbnRcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gdG8gY29udGludWUgdG8gZXhpc3QgdG8gcmVjZWl2ZSwgYW5kIHBhc3MgdG8gdGhlIFRVLFxuICAgICAgICAvLyBhbnkgcmV0cmFuc21pc3Npb25zIG9mIHRoZSAyeHggcmVzcG9uc2UgYW5kIGFueSBhZGRpdGlvbmFsIDJ4eFxuICAgICAgICAvLyByZXNwb25zZXMgZnJvbSBvdGhlciBicmFuY2hlcyBvZiB0aGUgSU5WSVRFIGlmIGl0IGZvcmtlZFxuICAgICAgICAvLyBkb3duc3RyZWFtLiBUaW1lciBNIHJlZmxlY3RzIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IHRoZVxuICAgICAgICAvLyB0cmFuc2FjdGlvbiB1c2VyIHdpbGwgd2FpdCBmb3Igc3VjaCBtZXNzYWdlcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQW55IDJ4eCByZXNwb25zZXMgdGhhdCBtYXRjaCB0aGlzIGNsaWVudCB0cmFuc2FjdGlvbiBhbmQgdGhhdCBhcmVcbiAgICAgICAgLy8gcmVjZWl2ZWQgd2hpbGUgaW4gdGhlIFwiQWNjZXB0ZWRcIiBzdGF0ZSBNVVNUIGJlIHBhc3NlZCB1cCB0byB0aGVcbiAgICAgICAgLy8gVFUuIFRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCBOT1QgZ2VuZXJhdGUgYW4gQUNLIHRvIHRoZSAyeHhcbiAgICAgICAgLy8gcmVzcG9uc2UuIFRoZSBjbGllbnQgdHJhbnNhY3Rpb24gdGFrZXMgbm8gZnVydGhlciBhY3Rpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC40XG4gICAgICAgIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IDI5OSkge1xuICAgICAgICAgIC8vIE5PVEU6IFRoaXMgaW1wbGVtZW50YXRpb24gaGVyZWluIGlzIGludGVudGlvbmFsbHkgbm90IFJGQyBjb21wbGlhbnQuXG4gICAgICAgICAgLy8gV2hpbGUgdGhlIGZpcnN0IDJ4eCByZXNwb25zZSBmb3IgYSBnaXZlbiBicmFuY2ggaXMgcGFzc2VkIHVwIHRvIHRoZSBUVSxcbiAgICAgICAgICAvLyByZXRyYW5zbWlzc2lvbnMgb2YgMnh4IHJlc3BvbnNlcyBhcmUgYWJzb3JiZWQgYW5kIHRoZSBBQ0sgYXNzb2NpYXRlZFxuICAgICAgICAgIC8vIHdpdGggdGhlIG9yaWdpbmFsIHJlc3BvbnNlIGlzIHJlc2VudC4gVGhpcyBhcHByb2FjaCBpcyB0YWtlbiBiZWNhdXNlXG4gICAgICAgICAgLy8gb3VyIGN1cnJlbnQgdHJhbnNhY3Rpb24gdXNlcnMgYXJlIG5vdCBjdXJyZW50bHkgaW4gYSBnb29kIHBvc2l0aW9uIHRvXG4gICAgICAgICAgLy8gZGVhbCB3aXRoIDJ4eCByZXRyYW5zbWlzc2lvbi4gVGhpcyBTSE9VTEQgTk9UIGNhdXNlIGFueSBjb21wbGlhbmNlIGlzc3VlcyAtIDspXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2FjaGUgaGl0LCBwYXNzIHRoZSByZXNwb25zZSB0byB0aGUgVFUuXG4gICAgICAgICAgaWYgKCF0aGlzLmFja1JldHJhbnNtaXNzaW9uQ2FjaGUuaGFzKHJlc3BvbnNlLnRvVGFnKSkge1xuICAgICAgICAgICAgdGhpcy5hY2tSZXRyYW5zbWlzc2lvbkNhY2hlLnNldChyZXNwb25zZS50b1RhZywgdW5kZWZpbmVkKTsgLy8gUHJpbWUgdGhlIEFDSyBjYWNoZVxuICAgICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBjYWNoZSBoaXQsIHRyeSBwdWxsaW5nIHRoZSBBQ0sgZnJvbSBjYWNoZSBhbmQgcmV0cmFuc21pdHRpbmcgaXQuXG4gICAgICAgICAgY29uc3QgYWNrID0gdGhpcy5hY2tSZXRyYW5zbWlzc2lvbkNhY2hlLmdldChyZXNwb25zZS50b1RhZyk7XG4gICAgICAgICAgaWYgKGFjaykge1xuICAgICAgICAgICAgdGhpcy5zZW5kKGFjay50b1N0cmluZygpKS5jYXRjaCgoZXJyb3I6IFRyYW5zcG9ydEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgcmV0cmFuc21pc3Npb24gb2YgQUNLIHRvIDJ4eCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgYW4gQUNLIHdhcyBub3QgZm91bmQgaW4gY2FjaGUgdGhlbiB3ZSBoYXZlIHJlY2VpdmVkIGEgcmV0cmFuc21pdHRlZCAyeHhcbiAgICAgICAgICAvLyByZXNwb25zZSBiZWZvcmUgdGhlIFRVIHJlc3BvbmRlZCB0byB0aGUgb3JpZ2luYWwgcmVzcG9uc2UgKHdlIGRvbid0IGhhdmUgYW4gQUNLIHlldCkuXG4gICAgICAgICAgLy8gU28gZGlzY2FyZCB0aGlzIHJlc3BvbnNlIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhlIFRVIHdpbGwgZXZlbnR1YWxseVxuICAgICAgICAgIC8vIGdldCB1cyBhIEFDSyBmb3IgdGhlIG9yaWdpbmFsIHJlc3BvbnNlLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgIC8vIEFueSByZXRyYW5zbWlzc2lvbnMgb2YgYSByZXNwb25zZSB3aXRoIHN0YXR1cyBjb2RlIDMwMC02OTkgdGhhdFxuICAgICAgICAvLyBhcmUgcmVjZWl2ZWQgd2hpbGUgaW4gdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUgTVVTVCBjYXVzZSB0aGUgQUNLIHRvXG4gICAgICAgIC8vIGJlIHJlLXBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciByZXRyYW5zbWlzc2lvbiwgYnV0IHRoZVxuICAgICAgICAvLyBuZXdseSByZWNlaXZlZCByZXNwb25zZSBNVVNUIE5PVCBiZSBwYXNzZWQgdXAgdG8gdGhlIFRVLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguNFxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICB0aGlzLmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlICR7dGhpcy5zdGF0ZX1gKTtcbiAgICB9XG5cbiAgICAvLyBBbnkgcmVzcG9uc2UgcmVjZWl2ZWQgdGhhdCBkb2VzIG5vdCBtYXRjaCBhbiBleGlzdGluZyBjbGllbnRcbiAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSBtYWNoaW5lIGlzIHNpbXBseSBkcm9wcGVkLiAoSW1wbGVtZW50YXRpb25zIGFyZSxcbiAgICAvLyBvZiBjb3Vyc2UsIGZyZWUgdG8gbG9nIG9yIGRvIG90aGVyIGltcGxlbWVudGF0aW9uLXNwZWNpZmljIHRoaW5nc1xuICAgIC8vIHdpdGggc3VjaCByZXNwb25zZXMsIGJ1dCB0aGUgaW1wbGVtZW50ZXIgc2hvdWxkIGJlIHN1cmUgdG8gY29uc2lkZXJcbiAgICAvLyB0aGUgaW1wYWN0IG9mIGxhcmdlIG51bWJlcnMgb2YgbWFsaWNpb3VzIHN0cmF5IHJlc3BvbnNlcy4pXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi03LjJcbiAgICBjb25zdCBtZXNzYWdlID0gYFJlY2VpdmVkIHVuZXhwZWN0ZWQgJHtzdGF0dXNDb2RlfSByZXNwb25zZSB3aGlsZSBpbiBzdGF0ZSAke3RoaXMuc3RhdGV9LmA7XG4gICAgdGhpcy5sb2dnZXIud2FybihtZXNzYWdlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgaW5mb3JtIHRoZSBUVSB0aGF0IGEgdHJhbnNwb3J0IGZhaWx1cmVcbiAgICogaGFzIG9jY3VycmVkLCBhbmQgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgdHJhbnNpdGlvbiBkaXJlY3RseVxuICAgKiB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuICBUaGUgVFUgd2lsbCBoYW5kbGUgdGhlIGZhaWxvdmVyXG4gICAqIG1lY2hhbmlzbXMgZGVzY3JpYmVkIGluIFs0XS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjRcbiAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yLlxuICAgKi9cbiAgcHJvdGVjdGVkIG9uVHJhbnNwb3J0RXJyb3IoZXJyb3I6IFRyYW5zcG9ydEVycm9yKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudXNlci5vblRyYW5zcG9ydEVycm9yKSB7XG4gICAgICB0aGlzLnVzZXIub25UcmFuc3BvcnRFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCwgdHJ1ZSk7XG4gIH1cblxuICAvKiogRm9yIGxvZ2dpbmcuICovXG4gIHByb3RlY3RlZCB0eXBlVG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uXCI7XG4gIH1cblxuICBwcml2YXRlIGFjayhyZXNwb25zZTogSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpOiB2b2lkIHtcbiAgICAvLyBUaGUgQUNLIHJlcXVlc3QgY29uc3RydWN0ZWQgYnkgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIGNvbnRhaW5cbiAgICAvLyB2YWx1ZXMgZm9yIHRoZSBDYWxsLUlELCBGcm9tLCBhbmQgUmVxdWVzdC1VUkkgdGhhdCBhcmUgZXF1YWwgdG8gdGhlXG4gICAgLy8gdmFsdWVzIG9mIHRob3NlIGhlYWRlciBmaWVsZHMgaW4gdGhlIHJlcXVlc3QgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnRcbiAgICAvLyBieSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIChjYWxsIHRoaXMgdGhlIFwib3JpZ2luYWwgcmVxdWVzdFwiKS4gVGhlIFRvXG4gICAgLy8gaGVhZGVyIGZpZWxkIGluIHRoZSBBQ0sgTVVTVCBlcXVhbCB0aGUgVG8gaGVhZGVyIGZpZWxkIGluIHRoZVxuICAgIC8vIHJlc3BvbnNlIGJlaW5nIGFja25vd2xlZGdlZCwgYW5kIHRoZXJlZm9yZSB3aWxsIHVzdWFsbHkgZGlmZmVyIGZyb21cbiAgICAvLyB0aGUgVG8gaGVhZGVyIGZpZWxkIGluIHRoZSBvcmlnaW5hbCByZXF1ZXN0IGJ5IHRoZSBhZGRpdGlvbiBvZiB0aGVcbiAgICAvLyB0YWcgcGFyYW1ldGVyLiBUaGUgQUNLIE1VU1QgY29udGFpbiBhIHNpbmdsZSBWaWEgaGVhZGVyIGZpZWxkLCBhbmRcbiAgICAvLyB0aGlzIE1VU1QgYmUgZXF1YWwgdG8gdGhlIHRvcCBWaWEgaGVhZGVyIGZpZWxkIG9mIHRoZSBvcmlnaW5hbFxuICAgIC8vIHJlcXVlc3QuIFRoZSBDU2VxIGhlYWRlciBmaWVsZCBpbiB0aGUgQUNLIE1VU1QgY29udGFpbiB0aGUgc2FtZVxuICAgIC8vIHZhbHVlIGZvciB0aGUgc2VxdWVuY2UgbnVtYmVyIGFzIHdhcyBwcmVzZW50IGluIHRoZSBvcmlnaW5hbCByZXF1ZXN0LFxuICAgIC8vIGJ1dCB0aGUgbWV0aG9kIHBhcmFtZXRlciBNVVNUIGJlIGVxdWFsIHRvIFwiQUNLXCIuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgSU5WSVRFIHJlcXVlc3Qgd2hvc2UgcmVzcG9uc2UgaXMgYmVpbmcgYWNrbm93bGVkZ2VkIGhhZCBSb3V0ZVxuICAgIC8vIGhlYWRlciBmaWVsZHMsIHRob3NlIGhlYWRlciBmaWVsZHMgTVVTVCBhcHBlYXIgaW4gdGhlIEFDSy4gVGhpcyBpc1xuICAgIC8vIHRvIGVuc3VyZSB0aGF0IHRoZSBBQ0sgY2FuIGJlIHJvdXRlZCBwcm9wZXJseSB0aHJvdWdoIGFueSBkb3duc3RyZWFtXG4gICAgLy8gc3RhdGVsZXNzIHByb3hpZXMuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjEuM1xuICAgIGNvbnN0IHJ1cmkgPSB0aGlzLnJlcXVlc3QucnVyaTtcbiAgICBjb25zdCBjYWxsSWQgPSB0aGlzLnJlcXVlc3QuY2FsbElkO1xuICAgIGNvbnN0IGNzZXEgPSB0aGlzLnJlcXVlc3QuY3NlcTtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5yZXF1ZXN0LmdldEhlYWRlcihcImZyb21cIik7XG4gICAgY29uc3QgdG8gPSByZXNwb25zZS5nZXRIZWFkZXIoXCJ0b1wiKTtcbiAgICBjb25zdCB2aWEgPSB0aGlzLnJlcXVlc3QuZ2V0SGVhZGVyKFwidmlhXCIpO1xuICAgIGNvbnN0IHJvdXRlID0gdGhpcy5yZXF1ZXN0LmdldEhlYWRlcihcInJvdXRlXCIpO1xuICAgIGlmICghZnJvbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB1bmRlZmluZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUbyB1bmRlZmluZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXZpYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlhIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuXG4gICAgbGV0IGFjayA9IGBBQ0sgJHtydXJpfSBTSVAvMi4wXFxyXFxuYDtcbiAgICBpZiAocm91dGUpIHtcbiAgICAgIGFjayArPSBgUm91dGU6ICR7cm91dGV9XFxyXFxuYDtcbiAgICB9XG4gICAgYWNrICs9IGBWaWE6ICR7dmlhfVxcclxcbmA7XG4gICAgYWNrICs9IGBUbzogJHt0b31cXHJcXG5gO1xuICAgIGFjayArPSBgRnJvbTogJHtmcm9tfVxcclxcbmA7XG4gICAgYWNrICs9IGBDYWxsLUlEOiAke2NhbGxJZH1cXHJcXG5gO1xuICAgIGFjayArPSBgQ1NlcTogJHtjc2VxfSBBQ0tcXHJcXG5gO1xuICAgIGFjayArPSBgTWF4LUZvcndhcmRzOiA3MFxcclxcbmA7XG4gICAgYWNrICs9IGBDb250ZW50LUxlbmd0aDogMFxcclxcblxcclxcbmA7XG5cbiAgICAvLyBUT09POiBcIlVzZXItQWdlbnRcIiBoZWFkZXJcblxuICAgIHRoaXMuc2VuZChhY2spLmNhdGNoKChlcnJvcjogVHJhbnNwb3J0RXJyb3IpID0+IHtcbiAgICAgIHRoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgQUNLIHRvIG5vbi0yeHggcmVzcG9uc2UuXCIpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgc3RhdGUgdHJhbnNpdGlvbi5cbiAgICogQHBhcmFtIG5ld1N0YXRlIC0gTmV3IHN0YXRlLlxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0ZVRyYW5zaXRpb24obmV3U3RhdGU6IFRyYW5zYWN0aW9uU3RhdGUsIGR1ZVRvVHJhbnNwb3J0RXJyb3IgPSBmYWxzZSk6IHZvaWQge1xuICAgIC8vIEFzc2VydCB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9ucy5cbiAgICBjb25zdCBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gZnJvbSAke3RoaXMuc3RhdGV9IHRvICR7bmV3U3RhdGV9YCk7XG4gICAgfTtcblxuICAgIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5DYWxsaW5nOlxuICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBUcmFuc2FjdGlvblN0YXRlLkNhbGxpbmcpIHtcbiAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQ6XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gVHJhbnNhY3Rpb25TdGF0ZS5DYWxsaW5nICYmXG4gICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nXG4gICAgICAgICkge1xuICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gVHJhbnNhY3Rpb25TdGF0ZS5DYWxsaW5nICYmXG4gICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZCAmJlxuICAgICAgICAgIHRoaXMuc3RhdGUgIT09IFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICghZHVlVG9UcmFuc3BvcnRFcnJvcikge1xuICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBXaGlsZSBub3Qgc3BlbGxlZCBvdXQgaW4gdGhlIFJGQywgVGltZXIgQiBpcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0aGF0IGEgc2VuZGVyXG4gICAgLy8gd2lsbCB3YWl0IGZvciBhbiBJTlZJVEUgbWVzc2FnZSB0byBiZSBhY2tub3dsZWRnZWQgKGEgU0lQIHJlc3BvbnNlIG1lc3NhZ2UgaXMgcmVjZWl2ZWQpLlxuICAgIC8vIFNvIFRpbWVyIEIgc2hvdWxkIGJlIGNsZWFyZWQgd2hlbiB0aGUgdHJhbnNhY3Rpb24gc3RhdGUgcHJvY2VlZHMgZnJvbSBcIkNhbGxpbmdcIi5cbiAgICBpZiAodGhpcy5CKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5CKTtcbiAgICAgIHRoaXMuQiA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAobmV3U3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgLy8gVGltZXJzIGhhdmUgbm8gZWZmZWN0IG9uIFwiUHJvY2VlZGluZ1wiIHN0YXRlLlxuICAgICAgLy8gSW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uXG4gICAgICAvLyBTSE9VTEQgTk9UIHJldHJhbnNtaXQgdGhlIHJlcXVlc3QgYW55IGxvbmdlci5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xLjJcbiAgICB9XG5cbiAgICAvLyBUaGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1Qgc3RhcnQgVGltZXIgRCB3aGVuIGl0IGVudGVycyB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZVxuICAgIC8vIGZvciBhbnkgcmVhc29uLCB3aXRoIGEgdmFsdWUgb2YgYXQgbGVhc3QgMzIgc2Vjb25kcyBmb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzLFxuICAgIC8vIGFuZCBhIHZhbHVlIG9mIHplcm8gc2Vjb25kcyBmb3IgcmVsaWFibGUgdHJhbnNwb3J0cy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguNFxuICAgIGlmIChuZXdTdGF0ZSA9PT0gVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuRCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy50aW1lcl9EKCksIFRpbWVycy5USU1FUl9EKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlLFxuICAgIC8vIGFuZCBUaW1lciBNIE1VU1QgYmUgc3RhcnRlZCB3aXRoIGEgdmFsdWUgb2YgNjQqVDEuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICBpZiAobmV3U3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpIHtcbiAgICAgIHRoaXMuTSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy50aW1lcl9NKCksIFRpbWVycy5USU1FUl9NKTtcbiAgICB9XG5cbiAgICAvLyBPbmNlIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUsIGl0IE1VU1QgYmUgZGVzdHJveWVkIGltbWVkaWF0ZWx5LlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC43XG4gICAgaWYgKG5ld1N0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzdGF0ZS5cbiAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRpbWVyIEEgZmlyZXMsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCByZXRyYW5zbWl0IHRoZVxuICAgKiByZXF1ZXN0IGJ5IHBhc3NpbmcgaXQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciwgYW5kIE1VU1QgcmVzZXQgdGhlXG4gICAqIHRpbWVyIHdpdGggYSB2YWx1ZSBvZiAyKlQxLlxuICAgKiBXaGVuIHRpbWVyIEEgZmlyZXMgMipUMSBzZWNvbmRzIGxhdGVyLCB0aGUgcmVxdWVzdCBNVVNUIGJlXG4gICAqIHJldHJhbnNtaXR0ZWQgYWdhaW4gKGFzc3VtaW5nIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gaXMgc3RpbGwgaW4gdGhpc1xuICAgKiBzdGF0ZSkuIFRoaXMgcHJvY2VzcyBNVVNUIGNvbnRpbnVlIHNvIHRoYXQgdGhlIHJlcXVlc3QgaXNcbiAgICogcmV0cmFuc21pdHRlZCB3aXRoIGludGVydmFscyB0aGF0IGRvdWJsZSBhZnRlciBlYWNoIHRyYW5zbWlzc2lvbi5cbiAgICogVGhlc2UgcmV0cmFuc21pc3Npb25zIFNIT1VMRCBvbmx5IGJlIGRvbmUgd2hpbGUgdGhlIGNsaWVudFxuICAgKiB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJDYWxsaW5nXCIgc3RhdGUuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xLjJcbiAgICovXG4gIHByaXZhdGUgdGltZXJfQSgpOiB2b2lkIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBpcyBzdGlsbCBpbiB0aGUgXCJDYWxsaW5nXCIgc3RhdGUgd2hlbiB0aW1lclxuICAgKiBCIGZpcmVzLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIFNIT1VMRCBpbmZvcm0gdGhlIFRVIHRoYXQgYSB0aW1lb3V0XG4gICAqIGhhcyBvY2N1cnJlZC4gIFRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCBOT1QgZ2VuZXJhdGUgYW4gQUNLLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMS4yXG4gICAqL1xuICBwcml2YXRlIHRpbWVyX0IoKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYFRpbWVyIEIgZXhwaXJlZCBmb3IgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAke3RoaXMuaWR9LmApO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLkNhbGxpbmcpIHtcbiAgICAgIHRoaXMub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgVGltZXIgRCBmaXJlcyB3aGlsZSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIGlzIGluIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLFxuICAgKiB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgbW92ZSB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC40XG4gICAqL1xuICBwcml2YXRlIHRpbWVyX0QoKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYFRpbWVyIEQgZXhwaXJlZCBmb3IgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAke3RoaXMuaWR9LmApO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgVGltZXIgTSBmaXJlcyB3aGlsZSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIGlzIGluIHRoZSBcIkFjY2VwdGVkXCJcbiAgICogc3RhdGUsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCBtb3ZlIHRvIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICovXG4gIHByaXZhdGUgdGltZXJfTSgpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgVGltZXIgTSBleHBpcmVkIGZvciBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICR7dGhpcy5pZH0uYCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpIHtcbiAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBUcmFuc3BvcnRFcnJvciB9IGZyb20gXCIuLi9leGNlcHRpb25zXCI7XG5pbXBvcnQgeyBDLCBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBUaW1lcnMgfSBmcm9tIFwiLi4vdGltZXJzXCI7XG5pbXBvcnQgeyBUcmFuc3BvcnQgfSBmcm9tIFwiLi4vdHJhbnNwb3J0XCI7XG5pbXBvcnQgeyBTZXJ2ZXJUcmFuc2FjdGlvbiB9IGZyb20gXCIuL3NlcnZlci10cmFuc2FjdGlvblwiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0ZSB9IGZyb20gXCIuL3RyYW5zYWN0aW9uLXN0YXRlXCI7XG5pbXBvcnQgeyBTZXJ2ZXJUcmFuc2FjdGlvblVzZXIgfSBmcm9tIFwiLi90cmFuc2FjdGlvbi11c2VyXCI7XG5cbi8qKlxuICogSU5WSVRFIFNlcnZlciBUcmFuc2FjdGlvbi5cbiAqIEByZW1hcmtzXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gZXh0ZW5kcyBTZXJ2ZXJUcmFuc2FjdGlvbiB7XG4gIHByaXZhdGUgbGFzdEZpbmFsUmVzcG9uc2U6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBsYXN0UHJvdmlzaW9uYWxSZXNwb25zZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIEg6IGFueSB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBJOiBhbnkgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgTDogYW55IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBGSVhNRTogVGhpcyBzaG91bGQgbm90IGJlIGhlcmUuIEl0IHNob3VsZCBiZSBpbiB0aGUgVUFTLlxuICAgKlxuICAgKiBJZiB0aGUgVUFTIGRlc2lyZXMgYW4gZXh0ZW5kZWQgcGVyaW9kIG9mIHRpbWUgdG8gYW5zd2VyIHRoZSBJTlZJVEUsXG4gICAqIGl0IHdpbGwgbmVlZCB0byBhc2sgZm9yIGFuIFwiZXh0ZW5zaW9uXCIgaW4gb3JkZXIgdG8gcHJldmVudCBwcm94aWVzXG4gICAqIGZyb20gY2FuY2VsaW5nIHRoZSB0cmFuc2FjdGlvbi4gIEEgcHJveHkgaGFzIHRoZSBvcHRpb24gb2YgY2FuY2VsaW5nXG4gICAqIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSBpcyBhIGdhcCBvZiAzIG1pbnV0ZXMgYmV0d2VlbiByZXNwb25zZXMgaW4gYVxuICAgKiB0cmFuc2FjdGlvbi4gIFRvIHByZXZlbnQgY2FuY2VsbGF0aW9uLCB0aGUgVUFTIE1VU1Qgc2VuZCBhIG5vbi0xMDBcbiAgICogcHJvdmlzaW9uYWwgcmVzcG9uc2UgYXQgZXZlcnkgbWludXRlLCB0byBoYW5kbGUgdGhlIHBvc3NpYmlsaXR5IG9mXG4gICAqIGxvc3QgcHJvdmlzaW9uYWwgcmVzcG9uc2VzLlxuICAgKlxuICAgKiAgIEFuIElOVklURSB0cmFuc2FjdGlvbiBjYW4gZ28gb24gZm9yIGV4dGVuZGVkIGR1cmF0aW9ucyB3aGVuIHRoZVxuICAgKiAgIHVzZXIgaXMgcGxhY2VkIG9uIGhvbGQsIG9yIHdoZW4gaW50ZXJ3b3JraW5nIHdpdGggUFNUTiBzeXN0ZW1zXG4gICAqICAgd2hpY2ggYWxsb3cgY29tbXVuaWNhdGlvbnMgdG8gdGFrZSBwbGFjZSB3aXRob3V0IGFuc3dlcmluZyB0aGVcbiAgICogICBjYWxsLiAgVGhlIGxhdHRlciBpcyBjb21tb24gaW4gSW50ZXJhY3RpdmUgVm9pY2UgUmVzcG9uc2UgKElWUilcbiAgICogICBzeXN0ZW1zLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS4xXG4gICAqL1xuICBwcml2YXRlIHByb2dyZXNzRXh0ZW5zaW9uVGltZXI6IGFueSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqIFVwb24gY29uc3RydWN0aW9uLCBhIFwiMTAwIFRyeWluZ1wiIHJlcGx5IHdpbGwgYmUgaW1tZWRpYXRlbHkgc2VudC5cbiAgICogQWZ0ZXIgY29uc3RydWN0aW9uIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIGluIHRoZSBcInByb2NlZWRpbmdcIiBzdGF0ZSBhbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAqIGBpZGAgd2lsbCBlcXVhbCB0aGUgYnJhbmNoIHBhcmFtZXRlciBzZXQgaW4gdGhlIFZpYSBoZWFkZXIgb2YgdGhlIGluY29taW5nIHJlcXVlc3QuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4xXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gSW5jb21pbmcgSU5WSVRFIHJlcXVlc3QgZnJvbSB0aGUgdHJhbnNwb3J0LlxuICAgKiBAcGFyYW0gdHJhbnNwb3J0IC0gVGhlIHRyYW5zcG9ydC5cbiAgICogQHBhcmFtIHVzZXIgLSBUaGUgdHJhbnNhY3Rpb24gdXNlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlcXVlc3Q6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UsIHRyYW5zcG9ydDogVHJhbnNwb3J0LCB1c2VyOiBTZXJ2ZXJUcmFuc2FjdGlvblVzZXIpIHtcbiAgICBzdXBlcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0cmFuc3BvcnQsXG4gICAgICB1c2VyLFxuICAgICAgVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nLFxuICAgICAgXCJzaXAudHJhbnNhY3Rpb24uaXN0XCJcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3RydWN0b3IuXG4gICAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnN0b3BQcm9ncmVzc0V4dGVuc2lvblRpbWVyKCk7XG4gICAgaWYgKHRoaXMuSCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuSCk7XG4gICAgICB0aGlzLkggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLkkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLkkpO1xuICAgICAgdGhpcy5JID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5MKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5MKTtcbiAgICAgIHRoaXMuTCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uIGtpbmQuIERlcHJlY2F0ZWQuICovXG4gIGdldCBraW5kKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwiaXN0XCI7XG4gIH1cblxuICAvKipcbiAgICogUmVjZWl2ZSByZXF1ZXN0cyBmcm9tIHRyYW5zcG9ydCBtYXRjaGluZyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFJlcXVlc3QgbWF0Y2hpbmcgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICovXG4gIHB1YmxpYyByZWNlaXZlUmVxdWVzdChyZXF1ZXN0OiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlKTogdm9pZCB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgLy8gSWYgYSByZXF1ZXN0IHJldHJhbnNtaXNzaW9uIGlzIHJlY2VpdmVkIHdoaWxlIGluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgdGhlIG1vc3RcbiAgICAgICAgLy8gcmVjZW50IHByb3Zpc2lvbmFsIHJlc3BvbnNlIHRoYXQgd2FzIHJlY2VpdmVkIGZyb20gdGhlIFRVIE1VU1QgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAgICAvLyB0cmFuc3BvcnQgbGF5ZXIgZm9yIHJldHJhbnNtaXNzaW9uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IEMuSU5WSVRFKSB7XG4gICAgICAgICAgaWYgKHRoaXMubGFzdFByb3Zpc2lvbmFsUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZCh0aGlzLmxhc3RQcm92aXNpb25hbFJlc3BvbnNlKS5jYXRjaCgoZXJyb3I6IFRyYW5zcG9ydEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgcmV0cmFuc21pc3Npb24gb2YgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZDpcbiAgICAgICAgLy8gV2hpbGUgaW4gdGhlIFwiQWNjZXB0ZWRcIiBzdGF0ZSwgYW55IHJldHJhbnNtaXNzaW9ucyBvZiB0aGUgSU5WSVRFXG4gICAgICAgIC8vIHJlY2VpdmVkIHdpbGwgbWF0Y2ggdGhpcyB0cmFuc2FjdGlvbiBzdGF0ZSBtYWNoaW5lIGFuZCB3aWxsIGJlXG4gICAgICAgIC8vIGFic29yYmVkIGJ5IHRoZSBtYWNoaW5lIHdpdGhvdXQgY2hhbmdpbmcgaXRzIHN0YXRlLiBUaGVzZVxuICAgICAgICAvLyByZXRyYW5zbWlzc2lvbnMgYXJlIG5vdCBwYXNzZWQgb250byB0aGUgVFUuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tNy4xXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gQy5JTlZJVEUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAvLyBGdXJ0aGVybW9yZSwgd2hpbGUgaW4gdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUsIGlmIGEgcmVxdWVzdCByZXRyYW5zbWlzc2lvbiBpc1xuICAgICAgICAvLyByZWNlaXZlZCwgdGhlIHNlcnZlciBTSE9VTEQgcGFzcyB0aGUgcmVzcG9uc2UgdG8gdGhlIHRyYW5zcG9ydCBmb3IgcmV0cmFuc21pc3Npb24uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4xXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gQy5JTlZJVEUpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubGFzdEZpbmFsUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhc3QgZmluYWwgcmVzcG9uc2UgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZW5kKHRoaXMubGFzdEZpbmFsUmVzcG9uc2UpLmNhdGNoKChlcnJvcjogVHJhbnNwb3J0RXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgcmV0cmFuc21pc3Npb24gb2YgZmluYWwgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhbiBBQ0sgaXMgcmVjZWl2ZWQgd2hpbGUgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSxcbiAgICAgICAgLy8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHRyYW5zaXRpb24gdG8gdGhlIFwiQ29uZmlybWVkXCIgc3RhdGUuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4xXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gQy5BQ0spIHtcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihUcmFuc2FjdGlvblN0YXRlLkNvbmZpcm1lZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLkNvbmZpcm1lZDpcbiAgICAgICAgLy8gVGhlIHB1cnBvc2Ugb2YgdGhlIFwiQ29uZmlybWVkXCIgc3RhdGUgaXMgdG8gYWJzb3JiIGFueSBhZGRpdGlvbmFsIEFDSyBtZXNzYWdlcyB0aGF0IGFycml2ZSxcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGZyb20gcmV0cmFuc21pc3Npb25zIG9mIHRoZSBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBDLklOVklURSB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gQy5BQ0spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgLy8gRm9yIGdvb2QgbWVhc3VyZSBhYnNvcmIgYW55IGFkZGl0aW9uYWwgbWVzc2FnZXMgdGhhdCBhcnJpdmUgKHNob3VsZCBub3QgaGFwcGVuKS5cbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBDLklOVklURSB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gQy5BQ0spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGUgJHt0aGlzLnN0YXRlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgYElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gcmVjZWl2ZWQgdW5leHBlY3RlZCAke3JlcXVlc3QubWV0aG9kfSByZXF1ZXN0IHdoaWxlIGluIHN0YXRlICR7dGhpcy5zdGF0ZX0uYDtcbiAgICB0aGlzLmxvZ2dlci53YXJuKG1lc3NhZ2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNlaXZlIHJlc3BvbnNlcyBmcm9tIFRVIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gc3RhdHVzQ29kZSAtIFN0YXR1cyBjb2RlIG9mIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gcmVzcG9uc2UgLSBSZXNwb25zZS5cbiAgICovXG4gIHB1YmxpYyByZWNlaXZlUmVzcG9uc2Uoc3RhdHVzQ29kZTogbnVtYmVyLCByZXNwb25zZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHN0YXR1c0NvZGUgPCAxMDAgfHwgc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX1gKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nOlxuICAgICAgICAvLyBUaGUgVFUgcGFzc2VzIGFueSBudW1iZXIgb2YgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24uIFNvIGxvbmcgYXMgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBpcyBpbiB0aGVcbiAgICAgICAgLy8gXCJQcm9jZWVkaW5nXCIgc3RhdGUsIGVhY2ggb2YgdGhlc2UgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydFxuICAgICAgICAvLyBsYXllciBmb3IgdHJhbnNtaXNzaW9uLiBUaGV5IGFyZSBub3Qgc2VudCByZWxpYWJseSBieSB0aGVcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gbGF5ZXIgKHRoZXkgYXJlIG5vdCByZXRyYW5zbWl0dGVkIGJ5IGl0KSBhbmQgZG8gbm90IGNhdXNlXG4gICAgICAgIC8vIGEgY2hhbmdlIGluIHRoZSBzdGF0ZSBvZiB0aGUgc2VydmVyIHRyYW5zYWN0aW9uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAxMDAgJiYgc3RhdHVzQ29kZSA8PSAxOTkpIHtcbiAgICAgICAgICB0aGlzLmxhc3RQcm92aXNpb25hbFJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgLy8gU3RhcnQgdGhlIHByb2dyZXNzIGV4dGVuc2lvbiB0aW1lciBvbmx5IGZvciBhIG5vbi0xMDAgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPiAxMDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQcm9ncmVzc0V4dGVuc2lvblRpbWVyKCk7IC8vIEZJWE1FOiByZW1vdmVcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZW5kKHJlc3BvbnNlKS5jYXRjaCgoZXJyb3I6IFRyYW5zcG9ydEVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIDF4eCByZXNwb25zZS5cIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmLCB3aGlsZSBpbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUsIHRoZSBUVSBwYXNzZXMgYSAyeHggcmVzcG9uc2VcbiAgICAgICAgLy8gdG8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiwgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHBhc3MgdGhpc1xuICAgICAgICAvLyByZXNwb25zZSB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24uIEl0IGlzIG5vdFxuICAgICAgICAvLyByZXRyYW5zbWl0dGVkIGJ5IHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb247IHJldHJhbnNtaXNzaW9ucyBvZiAyeHhcbiAgICAgICAgLy8gcmVzcG9uc2VzIGFyZSBoYW5kbGVkIGJ5IHRoZSBUVS4gVGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHRoZW5cbiAgICAgICAgLy8gdHJhbnNpdGlvbiB0byB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguNVxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSAyOTkpIHtcbiAgICAgICAgICB0aGlzLmxhc3RGaW5hbFJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZCk7XG4gICAgICAgICAgdGhpcy5zZW5kKHJlc3BvbnNlKS5jYXRjaCgoZXJyb3I6IFRyYW5zcG9ydEVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIDJ4eCByZXNwb25zZS5cIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoaWxlIGluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgaWYgdGhlIFRVIHBhc3NlcyBhIHJlc3BvbnNlIHdpdGhcbiAgICAgICAgLy8gc3RhdHVzIGNvZGUgZnJvbSAzMDAgdG8gNjk5IHRvIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24sIHRoZSByZXNwb25zZVxuICAgICAgICAvLyBNVVNUIGJlIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24sIGFuZCB0aGUgc3RhdGVcbiAgICAgICAgLy8gbWFjaGluZSBNVVNUIGVudGVyIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICB0aGlzLmxhc3RGaW5hbFJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpO1xuICAgICAgICAgIHRoaXMuc2VuZChyZXNwb25zZSkuY2F0Y2goKGVycm9yOiBUcmFuc3BvcnRFcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCBub24tMnh4IGZpbmFsIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQ6XG4gICAgICAgIC8vIFdoaWxlIGluIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUsIGlmIHRoZSBUVSBwYXNzZXMgYSAyeHggcmVzcG9uc2UsXG4gICAgICAgIC8vIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gTVVTVCBwYXNzIHRoZSByZXNwb25zZSB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC43XG4gICAgICAgIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IDI5OSkge1xuICAgICAgICAgIHRoaXMuc2VuZChyZXNwb25zZSkuY2F0Y2goKGVycm9yOiBUcmFuc3BvcnRFcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCAyeHggcmVzcG9uc2UuXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLkNvbmZpcm1lZDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGUgJHt0aGlzLnN0YXRlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgYElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gcmVjZWl2ZWQgdW5leHBlY3RlZCAke3N0YXR1c0NvZGV9IHJlc3BvbnNlIGZyb20gVFUgd2hpbGUgaW4gc3RhdGUgJHt0aGlzLnN0YXRlfS5gO1xuICAgIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyYW5zbWl0IHRoZSBsYXN0IDJ4eCByZXNwb25zZS4gVGhpcyBpcyBhIG5vb3AgaWYgbm90IGluIHRoZSBcImFjY2VwdGVkXCIgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgcmV0cmFuc21pdEFjY2VwdGVkUmVzcG9uc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQgJiYgdGhpcy5sYXN0RmluYWxSZXNwb25zZSkge1xuICAgICAgdGhpcy5zZW5kKHRoaXMubGFzdEZpbmFsUmVzcG9uc2UpLmNhdGNoKChlcnJvcjogVHJhbnNwb3J0RXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCAyeHggcmVzcG9uc2UuXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcnN0LCB0aGUgcHJvY2VkdXJlcyBpbiBbNF0gYXJlIGZvbGxvd2VkLCB3aGljaCBhdHRlbXB0IHRvIGRlbGl2ZXIgdGhlIHJlc3BvbnNlIHRvIGEgYmFja3VwLlxuICAgKiBJZiB0aG9zZSBzaG91bGQgYWxsIGZhaWwsIGJhc2VkIG9uIHRoZSBkZWZpbml0aW9uIG9mIGZhaWx1cmUgaW4gWzRdLCB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIFNIT1VMRFxuICAgKiBpbmZvcm0gdGhlIFRVIHRoYXQgYSBmYWlsdXJlIGhhcyBvY2N1cnJlZCwgYW5kIE1VU1QgcmVtYWluIGluIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguOFxuICAgKi9cbiAgcHJvdGVjdGVkIG9uVHJhbnNwb3J0RXJyb3IoZXJyb3I6IEVycm9yKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudXNlci5vblRyYW5zcG9ydEVycm9yKSB7XG4gICAgICB0aGlzLnVzZXIub25UcmFuc3BvcnRFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqIEZvciBsb2dnaW5nLiAqL1xuICBwcm90ZWN0ZWQgdHlwZVRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwiSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvblwiO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBzdGF0ZSB0cmFuc2l0aW9uLlxuICAgKiBAcGFyYW0gbmV3U3RhdGUgLSBOZXcgc3RhdGUuXG4gICAqL1xuICBwcml2YXRlIHN0YXRlVHJhbnNpdGlvbihuZXdTdGF0ZTogVHJhbnNhY3Rpb25TdGF0ZSk6IHZvaWQge1xuICAgIC8vIEFzc2VydCB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9ucy5cbiAgICBjb25zdCBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gZnJvbSAke3RoaXMuc3RhdGV9IHRvICR7bmV3U3RhdGV9YCk7XG4gICAgfTtcblxuICAgIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nOlxuICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkOlxuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZDpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5Db25maXJtZWQ6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZCAmJlxuICAgICAgICAgIHRoaXMuc3RhdGUgIT09IFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkICYmXG4gICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gVHJhbnNhY3Rpb25TdGF0ZS5Db25maXJtZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgIH1cblxuICAgIC8vIE9uIGFueSBzdGF0ZSB0cmFuc2l0aW9uLCBzdG9wIHJlc2VuZGluZyBwcm92aXNvbmFsIHJlc3BvbnNlc1xuICAgIHRoaXMuc3RvcFByb2dyZXNzRXh0ZW5zaW9uVGltZXIoKTtcblxuICAgIC8vIFRoZSBwdXJwb3NlIG9mIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUgaXMgdG8gYWJzb3JiIHJldHJhbnNtaXNzaW9ucyBvZiBhbiBhY2NlcHRlZCBJTlZJVEUgcmVxdWVzdC5cbiAgICAvLyBBbnkgc3VjaCByZXRyYW5zbWlzc2lvbnMgYXJlIGFic29yYmVkIGVudGlyZWx5IHdpdGhpbiB0aGUgc2VydmVyIHRyYW5zYWN0aW9uLlxuICAgIC8vIFRoZXkgYXJlIG5vdCBwYXNzZWQgdXAgdG8gdGhlIFRVIHNpbmNlIGFueSBkb3duc3RyZWFtIFVBUyBjb3JlcyB0aGF0IGFjY2VwdGVkIHRoZSByZXF1ZXN0IGhhdmVcbiAgICAvLyB0YWtlbiByZXNwb25zaWJpbGl0eSBmb3IgcmVsaWFiaWxpdHkgYW5kIHdpbGwgYWxyZWFkeSByZXRyYW5zbWl0IHRoZWlyIDJ4eCByZXNwb25zZXMgaWYgbmVjZXNzYXJ5LlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC43XG4gICAgaWYgKG5ld1N0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkKSB7XG4gICAgICB0aGlzLkwgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMudGltZXJfTCgpLCBUaW1lcnMuVElNRVJfTCk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSBpcyBlbnRlcmVkLCB0aW1lciBIIE1VU1QgYmUgc2V0IHRvIGZpcmUgaW4gNjQqVDEgc2Vjb25kcyBmb3IgYWxsIHRyYW5zcG9ydHMuXG4gICAgLy8gVGltZXIgSCBkZXRlcm1pbmVzIHdoZW4gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBhYmFuZG9ucyByZXRyYW5zbWl0dGluZyB0aGUgcmVzcG9uc2UuXG4gICAgLy8gSWYgYW4gQUNLIGlzIHJlY2VpdmVkIHdoaWxlIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gaXMgaW4gdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUsXG4gICAgLy8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHRyYW5zaXRpb24gdG8gdGhlIFwiQ29uZmlybWVkXCIgc3RhdGUuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICBpZiAobmV3U3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKSB7XG4gICAgICAvLyBGSVhNRTogTWlzc2luZyB0aW1lciBHIGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHMuXG4gICAgICB0aGlzLkggPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMudGltZXJfSCgpLCBUaW1lcnMuVElNRVJfSCk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHB1cnBvc2Ugb2YgdGhlIFwiQ29uZmlybWVkXCIgc3RhdGUgaXMgdG8gYWJzb3JiIGFueSBhZGRpdGlvbmFsIEFDSyBtZXNzYWdlcyB0aGF0IGFycml2ZSxcbiAgICAvLyB0cmlnZ2VyZWQgZnJvbSByZXRyYW5zbWlzc2lvbnMgb2YgdGhlIGZpbmFsIHJlc3BvbnNlLiBXaGVuIHRoaXMgc3RhdGUgaXMgZW50ZXJlZCwgdGltZXIgSVxuICAgIC8vIGlzIHNldCB0byBmaXJlIGluIFQ0IHNlY29uZHMgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cywgYW5kIHplcm8gc2Vjb25kcyBmb3IgcmVsaWFibGVcbiAgICAvLyB0cmFuc3BvcnRzLiBPbmNlIHRpbWVyIEkgZmlyZXMsIHRoZSBzZXJ2ZXIgTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgIGlmIChuZXdTdGF0ZSA9PT0gVHJhbnNhY3Rpb25TdGF0ZS5Db25maXJtZWQpIHtcbiAgICAgIC8vIEZJWE1FOiBUaGlzIHRpbWVyIGlzIG5vdCBnZXR0aW5nIHNldCBjb3JyZWN0bHkgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cy5cbiAgICAgIHRoaXMuSSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy50aW1lcl9JKCksIFRpbWVycy5USU1FUl9JKTtcbiAgICB9XG5cbiAgICAvLyBPbmNlIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUsIGl0IE1VU1QgYmUgZGVzdHJveWVkIGltbWVkaWF0ZWx5LlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC43XG4gICAgaWYgKG5ld1N0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzdGF0ZS5cbiAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGSVhNRTogVUFTIFByb3Zpc2lvbmFsIFJldHJhbnNtaXNzaW9uIFRpbWVyLiBTZWUgUkZDIDMyNjEgU2VjdGlvbiAxMy4zLjEuMVxuICAgKiBUaGlzIGlzIGluIHRoZSB3cm9uZyBwbGFjZS4gVGhpcyBpcyBub3QgYSB0cmFuc2FjdGlvbiBsZXZlbCB0aGluZy4gSXQncyBhIFVBUyBsZXZlbCB0aGluZy5cbiAgICovXG4gIHByaXZhdGUgc3RhcnRQcm9ncmVzc0V4dGVuc2lvblRpbWVyKCk6IHZvaWQge1xuICAgIC8vIFN0YXJ0IHRoZSBwcm9ncmVzcyBleHRlbnNpb24gdGltZXIgb25seSBmb3IgdGhlIGZpcnN0IG5vbi0xMDAgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NFeHRlbnNpb25UaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnByb2dyZXNzRXh0ZW5zaW9uVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBQcm9ncmVzcyBleHRlbnNpb24gdGltZXIgZXhwaXJlZCBmb3IgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAke3RoaXMuaWR9LmApO1xuICAgICAgICBpZiAoIXRoaXMubGFzdFByb3Zpc2lvbmFsUmVzcG9uc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXN0IHByb3Zpc2lvbmFsIHJlc3BvbnNlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kKHRoaXMubGFzdFByb3Zpc2lvbmFsUmVzcG9uc2UpLmNhdGNoKChlcnJvcjogVHJhbnNwb3J0RXJyb3IpID0+IHtcbiAgICAgICAgICB0aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIHJldHJhbnNtaXNzaW9uIG9mIHByb3Zpc2lvbmFsIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBUaW1lcnMuUFJPVklTSU9OQUxfUkVTUE9OU0VfSU5URVJWQUwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGSVhNRTogVUFTIFByb3Zpc2lvbmFsIFJldHJhbnNtaXNzaW9uIFRpbWVyIGlkLiBTZWUgUkZDIDMyNjEgU2VjdGlvbiAxMy4zLjEuMVxuICAgKiBUaGlzIGlzIGluIHRoZSB3cm9uZyBwbGFjZS4gVGhpcyBpcyBub3QgYSB0cmFuc2FjdGlvbiBsZXZlbCB0aGluZy4gSXQncyBhIFVBUyBsZXZlbCB0aGluZy5cbiAgICovXG4gIHByaXZhdGUgc3RvcFByb2dyZXNzRXh0ZW5zaW9uVGltZXIoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NFeHRlbnNpb25UaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMucHJvZ3Jlc3NFeHRlbnNpb25UaW1lcik7XG4gICAgICB0aGlzLnByb2dyZXNzRXh0ZW5zaW9uVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoaWxlIGluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgaWYgdGhlIFRVIHBhc3NlcyBhIHJlc3BvbnNlIHdpdGggc3RhdHVzIGNvZGVcbiAgICogZnJvbSAzMDAgdG8gNjk5IHRvIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24sIHRoZSByZXNwb25zZSBNVVNUIGJlIHBhc3NlZCB0byB0aGVcbiAgICogdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24sIGFuZCB0aGUgc3RhdGUgbWFjaGluZSBNVVNUIGVudGVyIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLlxuICAgKiBGb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzLCB0aW1lciBHIGlzIHNldCB0byBmaXJlIGluIFQxIHNlY29uZHMsIGFuZCBpcyBub3Qgc2V0IHRvIGZpcmUgZm9yXG4gICAqIHJlbGlhYmxlIHRyYW5zcG9ydHMuIElmIHRpbWVyIEcgZmlyZXMsIHRoZSByZXNwb25zZSBpcyBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBvbmNlXG4gICAqIG1vcmUgZm9yIHJldHJhbnNtaXNzaW9uLCBhbmQgdGltZXIgRyBpcyBzZXQgdG8gZmlyZSBpbiBNSU4oMipUMSwgVDIpIHNlY29uZHMuIEZyb20gdGhlbiBvbixcbiAgICogd2hlbiB0aW1lciBHIGZpcmVzLCB0aGUgcmVzcG9uc2UgaXMgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnQgYWdhaW4gZm9yIHRyYW5zbWlzc2lvbiwgYW5kXG4gICAqIHRpbWVyIEcgaXMgcmVzZXQgd2l0aCBhIHZhbHVlIHRoYXQgZG91YmxlcywgdW5sZXNzIHRoYXQgdmFsdWUgZXhjZWVkcyBUMiwgaW4gd2hpY2ggY2FzZVxuICAgKiBpdCBpcyByZXNldCB3aXRoIHRoZSB2YWx1ZSBvZiBUMi5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICovXG4gIHByaXZhdGUgdGltZXJfRygpOiB2b2lkIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvKipcbiAgICogSWYgdGltZXIgSCBmaXJlcyB3aGlsZSBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSwgaXQgaW1wbGllcyB0aGF0IHRoZSBBQ0sgd2FzIG5ldmVyIHJlY2VpdmVkLlxuICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZSwgYW5kIE1VU1RcbiAgICogaW5kaWNhdGUgdG8gdGhlIFRVIHRoYXQgYSB0cmFuc2FjdGlvbiBmYWlsdXJlIGhhcyBvY2N1cnJlZC5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICovXG4gIHByaXZhdGUgdGltZXJfSCgpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgVGltZXIgSCBleHBpcmVkIGZvciBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICR7dGhpcy5pZH0uYCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQUNLIHRvIG5lZ2F0aXZlIGZpbmFsIHJlc3BvbnNlIHdhcyBuZXZlciByZWNlaXZlZCwgdGVybWluYXRpbmcgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT25jZSB0aW1lciBJIGZpcmVzLCB0aGUgc2VydmVyIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4xXG4gICAqL1xuICBwcml2YXRlIHRpbWVyX0koKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYFRpbWVyIEkgZXhwaXJlZCBmb3IgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAke3RoaXMuaWR9LmApO1xuICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBUaW1lciBMIGZpcmVzIGFuZCB0aGUgc3RhdGUgbWFjaGluZSBpcyBpbiB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlLCB0aGUgbWFjaGluZSBNVVNUXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLiBPbmNlIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUsXG4gICAqIGl0IE1VU1QgYmUgZGVzdHJveWVkIGltbWVkaWF0ZWx5LiBUaW1lciBMIHJlZmxlY3RzIHRoZSBhbW91bnQgb2YgdGltZSB0aGUgc2VydmVyXG4gICAqIHRyYW5zYWN0aW9uIGNvdWxkIHJlY2VpdmUgMnh4IHJlc3BvbnNlcyBmb3IgcmV0cmFuc21pc3Npb24gZnJvbSB0aGVcbiAgICogVFUgd2hpbGUgaXQgaXMgd2FpdGluZyB0byByZWNlaXZlIGFuIEFDSy5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi03LjFcbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjdcbiAgICovXG4gIHByaXZhdGUgdGltZXJfTCgpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgVGltZXIgTCBleHBpcmVkIGZvciBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICR7dGhpcy5pZH0uYCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpIHtcbiAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBUcmFuc3BvcnRFcnJvciB9IGZyb20gXCIuLi9leGNlcHRpb25zXCI7XG5pbXBvcnQgeyBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSwgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgVGltZXJzIH0gZnJvbSBcIi4uL3RpbWVyc1wiO1xuaW1wb3J0IHsgVHJhbnNwb3J0IH0gZnJvbSBcIi4uL3RyYW5zcG9ydFwiO1xuaW1wb3J0IHsgQ2xpZW50VHJhbnNhY3Rpb24gfSBmcm9tIFwiLi9jbGllbnQtdHJhbnNhY3Rpb25cIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdGUgfSBmcm9tIFwiLi90cmFuc2FjdGlvbi1zdGF0ZVwiO1xuaW1wb3J0IHsgQ2xpZW50VHJhbnNhY3Rpb25Vc2VyIH0gZnJvbSBcIi4vdHJhbnNhY3Rpb24tdXNlclwiO1xuXG4vKipcbiAqIE5vbi1JTlZJVEUgQ2xpZW50IFRyYW5zYWN0aW9uLlxuICogQHJlbWFya3NcbiAqIE5vbi1JTlZJVEUgdHJhbnNhY3Rpb25zIGRvIG5vdCBtYWtlIHVzZSBvZiBBQ0suXG4gKiBUaGV5IGFyZSBzaW1wbGUgcmVxdWVzdC1yZXNwb25zZSBpbnRlcmFjdGlvbnMuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gZXh0ZW5kcyBDbGllbnRUcmFuc2FjdGlvbiB7XG4gIHByaXZhdGUgRjogYW55IHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIEs6IGFueSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogVXBvbiBjb25zdHJ1Y3Rpb24sIHRoZSBvdXRnb2luZyByZXF1ZXN0J3MgVmlhIGhlYWRlciBpcyB1cGRhdGVkIGJ5IGNhbGxpbmcgYHNldFZpYUhlYWRlcmAuXG4gICAqIFRoZW4gYHRvU3RyaW5nYCBpcyBjYWxsZWQgb24gdGhlIG91dGdvaW5nIHJlcXVlc3QgYW5kIHRoZSBtZXNzYWdlIGlzIHNlbnQgdmlhIHRoZSB0cmFuc3BvcnQuXG4gICAqIEFmdGVyIGNvbnN0cnVjdGlvbiB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBpbiB0aGUgXCJjYWxsaW5nXCIgc3RhdGUgYW5kIHRoZSB0cmFuc2FjdGlvbiBpZFxuICAgKiB3aWxsIGVxdWFsIHRoZSBicmFuY2ggcGFyYW1ldGVyIHNldCBpbiB0aGUgVmlhIGhlYWRlciBvZiB0aGUgb3V0Z29pbmcgcmVxdWVzdC5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjJcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgb3V0Z29pbmcgTm9uLUlOVklURSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gdHJhbnNwb3J0IC0gVGhlIHRyYW5zcG9ydC5cbiAgICogQHBhcmFtIHVzZXIgLSBUaGUgdHJhbnNhY3Rpb24gdXNlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlcXVlc3Q6IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UsIHRyYW5zcG9ydDogVHJhbnNwb3J0LCB1c2VyOiBDbGllbnRUcmFuc2FjdGlvblVzZXIpIHtcbiAgICBzdXBlcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0cmFuc3BvcnQsXG4gICAgICB1c2VyLFxuICAgICAgVHJhbnNhY3Rpb25TdGF0ZS5UcnlpbmcsXG4gICAgICBcInNpcC50cmFuc2FjdGlvbi5uaWN0XCJcbiAgICApO1xuICAgIC8vIEZJWE1FOiBUaW1lciBFIGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHMgbm90IGltcGxlbWVudGVkLlxuICAgIC8vXG4gICAgLy8gVGhlIFwiVHJ5aW5nXCIgc3RhdGUgaXMgZW50ZXJlZCB3aGVuIHRoZSBUVSBpbml0aWF0ZXMgYSBuZXcgY2xpZW50XG4gICAgLy8gdHJhbnNhY3Rpb24gd2l0aCBhIHJlcXVlc3QuICBXaGVuIGVudGVyaW5nIHRoaXMgc3RhdGUsIHRoZSBjbGllbnRcbiAgICAvLyB0cmFuc2FjdGlvbiBTSE9VTEQgc2V0IHRpbWVyIEYgdG8gZmlyZSBpbiA2NCpUMSBzZWNvbmRzLiBUaGUgcmVxdWVzdFxuICAgIC8vIE1VU1QgYmUgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIgZm9yIHRyYW5zbWlzc2lvbi5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMi4yXG4gICAgdGhpcy5GID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnRpbWVyX0YoKSwgVGltZXJzLlRJTUVSX0YpO1xuICAgIHRoaXMuc2VuZChyZXF1ZXN0LnRvU3RyaW5nKCkpLmNhdGNoKChlcnJvcjogVHJhbnNwb3J0RXJyb3IpID0+IHtcbiAgICAgIHRoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgaW5pdGlhbCBvdXRnb2luZyByZXF1ZXN0LlwiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cnVjdG9yLlxuICAgKi9cbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuRikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuRik7XG4gICAgICB0aGlzLkYgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLkspIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLkspO1xuICAgICAgdGhpcy5LID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24ga2luZC4gRGVwcmVjYXRlZC4gKi9cbiAgZ2V0IGtpbmQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJuaWN0XCI7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgaW5jb21pbmcgcmVzcG9uc2VzIGZyb20gdGhlIHRyYW5zcG9ydCB3aGljaCBtYXRjaCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgaW5jb21pbmcgcmVzcG9uc2UuXG4gICAqL1xuICBwdWJsaWMgcmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlOiBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSk6IHZvaWQge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgIGlmICghc3RhdHVzQ29kZSB8fCBzdGF0dXNDb2RlIDwgMTAwIHx8IHN0YXR1c0NvZGUgPiA2OTkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9YCk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nOlxuICAgICAgICAvLyBJZiBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGlzIHJlY2VpdmVkIHdoaWxlIGluIHRoZSBcIlRyeWluZ1wiIHN0YXRlLCB0aGVcbiAgICAgICAgLy8gcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIFRVLCBhbmQgdGhlbiB0aGUgY2xpZW50IHRyYW5zYWN0aW9uXG4gICAgICAgIC8vIFNIT1VMRCBtb3ZlIHRvIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAxMDAgJiYgc3RhdHVzQ29kZSA8PSAxOTkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihUcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpO1xuICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgZmluYWwgcmVzcG9uc2UgKHN0YXR1cyBjb2RlcyAyMDAtNjk5KSBpcyByZWNlaXZlZCB3aGlsZSBpbiB0aGVcbiAgICAgICAgLy8gXCJUcnlpbmdcIiBzdGF0ZSwgdGhlIHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHRvIHRoZSBUVSwgYW5kIHRoZVxuICAgICAgICAvLyBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMi4yXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IDY5OSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gNDA4KSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgLy8gSWYgYSBwcm92aXNpb25hbCByZXNwb25zZSBpcyByZWNlaXZlZCB3aGlsZSBpbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUsXG4gICAgICAgIC8vIHRoZSByZXNwb25zZSBNVVNUIGJlIHBhc3NlZCB0byB0aGUgVFUuIChGcm9tIEZpZ3VyZSA2KVxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMi4yXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID49IDEwMCAmJiBzdGF0dXNDb2RlIDw9IDE5OSkge1xuICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgZmluYWwgcmVzcG9uc2UgKHN0YXR1cyBjb2RlcyAyMDAtNjk5KSBpcyByZWNlaXZlZCB3aGlsZSBpbiB0aGVcbiAgICAgICAgLy8gXCJQcm9jZWVkaW5nXCIgc3RhdGUsIHRoZSByZXNwb25zZSBNVVNUIGJlIHBhc3NlZCB0byB0aGUgVFUsIGFuZCB0aGVcbiAgICAgICAgLy8gY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDQwOCkge1xuICAgICAgICAgICAgdGhpcy5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAvLyBUaGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSBleGlzdHMgdG8gYnVmZmVyIGFueSBhZGRpdGlvbmFsIHJlc3BvbnNlXG4gICAgICAgIC8vIHJldHJhbnNtaXNzaW9ucyB0aGF0IG1heSBiZSByZWNlaXZlZCAod2hpY2ggaXMgd2h5IHRoZSBjbGllbnRcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gcmVtYWlucyB0aGVyZSBvbmx5IGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHMpLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMi4yXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAvLyBGb3IgZ29vZCBtZWFzdXJlIGp1c3QgYWJzb3JiIGFkZGl0aW9uYWwgcmVzcG9uc2UgcmV0cmFuc21pc3Npb25zLlxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGUgJHt0aGlzLnN0YXRlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgYE5vbi1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uIHJlY2VpdmVkIHVuZXhwZWN0ZWQgJHtzdGF0dXNDb2RlfSByZXNwb25zZSB3aGlsZSBpbiBzdGF0ZSAke3RoaXMuc3RhdGV9LmA7XG4gICAgdGhpcy5sb2dnZXIud2FybihtZXNzYWdlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgaW5mb3JtIHRoZSBUVSB0aGF0IGEgdHJhbnNwb3J0IGZhaWx1cmUgaGFzIG9jY3VycmVkLFxuICAgKiBhbmQgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgdHJhbnNpdGlvbiBkaXJlY3RseSB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAqIFRoZSBUVSB3aWxsIGhhbmRsZSB0aGUgZmFpbG92ZXIgbWVjaGFuaXNtcyBkZXNjcmliZWQgaW4gWzRdLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuNFxuICAgKiBAcGFyYW0gZXJyb3IgLSBUcmFzbnNwb3J0IGVycm9yXG4gICAqL1xuICBwcm90ZWN0ZWQgb25UcmFuc3BvcnRFcnJvcihlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgICBpZiAodGhpcy51c2VyLm9uVHJhbnNwb3J0RXJyb3IpIHtcbiAgICAgIHRoaXMudXNlci5vblRyYW5zcG9ydEVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkLCB0cnVlKTtcbiAgfVxuXG4gIC8qKiBGb3IgbG9nZ2luZy4gKi9cbiAgcHJvdGVjdGVkIHR5cGVUb1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiBcIm5vbi1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uXCI7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHN0YXRlIHRyYW5zaXRpb24uXG4gICAqIEBwYXJhbSBuZXdTdGF0ZSAtIE5ldyBzdGF0ZS5cbiAgICovXG4gIHByaXZhdGUgc3RhdGVUcmFuc2l0aW9uKG5ld1N0YXRlOiBUcmFuc2FjdGlvblN0YXRlLCBkdWVUb1RyYW5zcG9ydEVycm9yID0gZmFsc2UpOiB2b2lkIHtcbiAgICAvLyBBc3NlcnQgdmFsaWQgc3RhdGUgdHJhbnNpdGlvbnMuXG4gICAgY29uc3QgaW52YWxpZFN0YXRlVHJhbnNpdGlvbiA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gJHt0aGlzLnN0YXRlfSB0byAke25ld1N0YXRlfWApO1xuICAgIH07XG5cbiAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nOlxuICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBUcmFuc2FjdGlvblN0YXRlLlRyeWluZykge1xuICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLnN0YXRlICE9PSBUcmFuc2FjdGlvblN0YXRlLlRyeWluZyAmJlxuICAgICAgICAgIHRoaXMuc3RhdGUgIT09IFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZ1xuICAgICAgICApIHtcbiAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuc3RhdGUgIT09IFRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nICYmXG4gICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nICYmXG4gICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKCFkdWVUb1RyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgIH1cblxuICAgIC8vIE9uY2UgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBlbnRlcnMgdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUsIGl0IE1VU1Qgc2V0XG4gICAgLy8gVGltZXIgSyB0byBmaXJlIGluIFQ0IHNlY29uZHMgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cywgYW5kIHplcm9cbiAgICAvLyBzZWNvbmRzIGZvciByZWxpYWJsZSB0cmFuc3BvcnRzICBUaGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSBleGlzdHMgdG9cbiAgICAvLyBidWZmZXIgYW55IGFkZGl0aW9uYWwgcmVzcG9uc2UgcmV0cmFuc21pc3Npb25zIHRoYXQgbWF5IGJlIHJlY2VpdmVkXG4gICAgLy8gKHdoaWNoIGlzIHdoeSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIHJlbWFpbnMgdGhlcmUgb25seSBmb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzKS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMi4yXG4gICAgaWYgKG5ld1N0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgaWYgKHRoaXMuRikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5GKTtcbiAgICAgICAgdGhpcy5GID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhpcy5LID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnRpbWVyX0soKSwgVGltZXJzLlRJTUVSX0spO1xuICAgIH1cblxuICAgIC8vIE9uY2UgdGhlIHRyYW5zYWN0aW9uIGlzIGluIHRoZSB0ZXJtaW5hdGVkIHN0YXRlLCBpdCBNVVNUIGJlIGRlc3Ryb3llZCBpbW1lZGlhdGVseS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMi4yXG4gICAgaWYgKG5ld1N0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzdGF0ZS5cbiAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBUaW1lciBGIGZpcmVzIHdoaWxlIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gaXMgc3RpbGwgaW4gdGhlXG4gICAqIFwiVHJ5aW5nXCIgc3RhdGUsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gU0hPVUxEIGluZm9ybSB0aGUgVFUgYWJvdXQgdGhlXG4gICAqIHRpbWVvdXQsIGFuZCB0aGVuIGl0IFNIT1VMRCBlbnRlciB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAqIElmIHRpbWVyIEYgZmlyZXMgd2hpbGUgaW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLCB0aGUgVFUgTVVTVCBiZSBpbmZvcm1lZCBvZlxuICAgKiBhIHRpbWVvdXQsIGFuZCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgdGVybWluYXRlZCBzdGF0ZS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgKi9cbiAgcHJpdmF0ZSB0aW1lcl9GKCk6IHZvaWQge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBUaW1lciBGIGV4cGlyZWQgZm9yIG5vbi1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICR7dGhpcy5pZH0uYCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nIHx8IHRoaXMuc3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgdGhpcy5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihUcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBUaW1lciBLIGZpcmVzIHdoaWxlIGluIHRoaXMgKENPTVBMRVRFRCkgc3RhdGUsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb25cbiAgICogTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgKi9cbiAgcHJpdmF0ZSB0aW1lcl9LKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IFRyYW5zcG9ydEVycm9yIH0gZnJvbSBcIi4uL2V4Y2VwdGlvbnNcIjtcbmltcG9ydCB7IEluY29taW5nUmVxdWVzdE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IFRpbWVycyB9IGZyb20gXCIuLi90aW1lcnNcIjtcbmltcG9ydCB7IFRyYW5zcG9ydCB9IGZyb20gXCIuLi90cmFuc3BvcnRcIjtcbmltcG9ydCB7IFNlcnZlclRyYW5zYWN0aW9uIH0gZnJvbSBcIi4vc2VydmVyLXRyYW5zYWN0aW9uXCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXRlIH0gZnJvbSBcIi4vdHJhbnNhY3Rpb24tc3RhdGVcIjtcbmltcG9ydCB7IFNlcnZlclRyYW5zYWN0aW9uVXNlciB9IGZyb20gXCIuL3RyYW5zYWN0aW9uLXVzZXJcIjtcblxuLyoqXG4gKiBOb24tSU5WSVRFIFNlcnZlciBUcmFuc2FjdGlvbi5cbiAqIEByZW1hcmtzXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gZXh0ZW5kcyBTZXJ2ZXJUcmFuc2FjdGlvbiB7XG4gIHByaXZhdGUgbGFzdFJlc3BvbnNlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgSjogYW55IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci5cbiAgICogQWZ0ZXIgY29uc3RydWN0aW9uIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIGluIHRoZSBcInRyeWluZ1wiOiBzdGF0ZSBhbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAqIGBpZGAgd2lsbCBlcXVhbCB0aGUgYnJhbmNoIHBhcmFtZXRlciBzZXQgaW4gdGhlIFZpYSBoZWFkZXIgb2YgdGhlIGluY29taW5nIHJlcXVlc3QuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4yXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gSW5jb21pbmcgTm9uLUlOVklURSByZXF1ZXN0IGZyb20gdGhlIHRyYW5zcG9ydC5cbiAgICogQHBhcmFtIHRyYW5zcG9ydCAtIFRoZSB0cmFuc3BvcnQuXG4gICAqIEBwYXJhbSB1c2VyIC0gVGhlIHRyYW5zYWN0aW9uIHVzZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0OiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLCB0cmFuc3BvcnQ6IFRyYW5zcG9ydCwgdXNlcjogU2VydmVyVHJhbnNhY3Rpb25Vc2VyKSB7XG4gICAgc3VwZXIoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdHJhbnNwb3J0LFxuICAgICAgdXNlcixcbiAgICAgIFRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nLFxuICAgICAgXCJzaXAudHJhbnNhY3Rpb24ubmlzdFwiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cnVjdG9yLlxuICAgKi9cbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuSikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuSik7XG4gICAgICB0aGlzLkogPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbiBraW5kLiBEZXByZWNhdGVkLiAqL1xuICBnZXQga2luZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBcIm5pc3RcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNlaXZlIHJlcXVlc3RzIGZyb20gdHJhbnNwb3J0IG1hdGNoaW5nIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gUmVxdWVzdCBtYXRjaGluZyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgcHVibGljIHJlY2VpdmVSZXF1ZXN0KHJlcXVlc3Q6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UpOiB2b2lkIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5Ucnlpbmc6XG4gICAgICAgIC8vIE9uY2UgaW4gdGhlIFwiVHJ5aW5nXCIgc3RhdGUsIGFueSBmdXJ0aGVyIHJlcXVlc3QgcmV0cmFuc21pc3Npb25zIGFyZSBkaXNjYXJkZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4yXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc6XG4gICAgICAgIC8vIElmIGEgcmV0cmFuc21pc3Npb24gb2YgdGhlIHJlcXVlc3QgaXMgcmVjZWl2ZWQgd2hpbGUgaW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLFxuICAgICAgICAvLyB0aGUgbW9zdCByZWNlbnRseSBzZW50IHByb3Zpc2lvbmFsIHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIgZm9yIHJldHJhbnNtaXNzaW9uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAgICBpZiAoIXRoaXMubGFzdFJlc3BvbnNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGFzdCByZXNwb25zZSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZCh0aGlzLmxhc3RSZXNwb25zZSkuY2F0Y2goKGVycm9yOiBUcmFuc3BvcnRFcnJvcikgPT4ge1xuICAgICAgICAgIHRoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgcmV0cmFuc21pc3Npb24gb2YgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAvLyBXaGlsZSBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSwgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHBhc3MgdGhlIGZpbmFsIHJlc3BvbnNlIHRvIHRoZSB0cmFuc3BvcnRcbiAgICAgICAgLy8gbGF5ZXIgZm9yIHJldHJhbnNtaXNzaW9uIHdoZW5ldmVyIGEgcmV0cmFuc21pc3Npb24gb2YgdGhlIHJlcXVlc3QgaXMgcmVjZWl2ZWQuIEFueSBvdGhlciBmaW5hbCByZXNwb25zZXNcbiAgICAgICAgLy8gcGFzc2VkIGJ5IHRoZSBUVSB0byB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIE1VU1QgYmUgZGlzY2FyZGVkIHdoaWxlIGluIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAgICBpZiAoIXRoaXMubGFzdFJlc3BvbnNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGFzdCByZXNwb25zZSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZCh0aGlzLmxhc3RSZXNwb25zZSkuY2F0Y2goKGVycm9yOiBUcmFuc3BvcnRFcnJvcikgPT4ge1xuICAgICAgICAgIHRoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgcmV0cmFuc21pc3Npb24gb2YgZmluYWwgcmVzcG9uc2UuXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGUgJHt0aGlzLnN0YXRlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNlaXZlIHJlc3BvbnNlcyBmcm9tIFRVIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gc3RhdHVzQ29kZSAtIFN0YXR1cyBjb2RlIG9mIHJlcHNvbnNlLiAxMDEtMTk5IG5vdCBhbGxvd2VkIHBlciBSRkMgNDMyMC5cbiAgICogQHBhcmFtIHJlc3BvbnNlIC0gUmVzcG9uc2UgdG8gc2VuZC5cbiAgICovXG4gIHB1YmxpYyByZWNlaXZlUmVzcG9uc2Uoc3RhdHVzQ29kZTogbnVtYmVyLCByZXNwb25zZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHN0YXR1c0NvZGUgPCAxMDAgfHwgc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX1gKTtcbiAgICB9XG5cbiAgICAvLyBBbiBTSVAgZWxlbWVudCBNVVNUIE5PVCBzZW5kIGFueSBwcm92aXNpb25hbCByZXNwb25zZSB3aXRoIGFcbiAgICAvLyBTdGF0dXMtQ29kZSBvdGhlciB0aGFuIDEwMCB0byBhIG5vbi1JTlZJVEUgcmVxdWVzdC5cbiAgICAvLyBBbiBTSVAgZWxlbWVudCBNVVNUIE5PVCByZXNwb25kIHRvIGEgbm9uLUlOVklURSByZXF1ZXN0IHdpdGggYVxuICAgIC8vIFN0YXR1cy1Db2RlIG9mIDEwMCBvdmVyIGFueSB1bnJlbGlhYmxlIHRyYW5zcG9ydCwgc3VjaCBhcyBVRFAsXG4gICAgLy8gYmVmb3JlIHRoZSBhbW91bnQgb2YgdGltZSBpdCB0YWtlcyBhIGNsaWVudCB0cmFuc2FjdGlvbidzIFRpbWVyIEUgdG8gYmUgcmVzZXQgdG8gVDIuXG4gICAgLy8gQW4gU0lQIGVsZW1lbnQgTUFZIHJlc3BvbmQgdG8gYSBub24tSU5WSVRFIHJlcXVlc3Qgd2l0aCBhXG4gICAgLy8gU3RhdHVzLUNvZGUgb2YgMTAwIG92ZXIgYSByZWxpYWJsZSB0cmFuc3BvcnQgYXQgYW55IHRpbWUuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQzMjAjc2VjdGlvbi00LjFcbiAgICBpZiAoc3RhdHVzQ29kZSA+IDEwMCAmJiBzdGF0dXNDb2RlIDw9IDE5OSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlzaW9uYWwgcmVzcG9uc2Ugb3RoZXIgdGhhbiAxMDAgbm90IGFsbG93ZWQuXCIpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLlRyeWluZzpcbiAgICAgICAgLy8gV2hpbGUgaW4gdGhlIFwiVHJ5aW5nXCIgc3RhdGUsIGlmIHRoZSBUVSBwYXNzZXMgYSBwcm92aXNpb25hbCByZXNwb25zZVxuICAgICAgICAvLyB0byB0aGUgc2VydmVyIHRyYW5zYWN0aW9uLCB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIE1VU1QgZW50ZXIgdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLlxuICAgICAgICAvLyBUaGUgcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAgICB0aGlzLmxhc3RSZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAxMDAgJiYgc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZyk7XG4gICAgICAgICAgdGhpcy5zZW5kKHJlc3BvbnNlKS5jYXRjaCgoZXJyb3I6IFRyYW5zcG9ydEVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIHByb3Zpc2lvbmFsIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPD0gNjk5KSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpO1xuICAgICAgICAgIHRoaXMuc2VuZChyZXNwb25zZSkuY2F0Y2goKGVycm9yOiBUcmFuc3BvcnRFcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCBmaW5hbCByZXNwb25zZS5cIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc6XG4gICAgICAgIC8vIEFueSBmdXJ0aGVyIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyB0aGF0IGFyZSByZWNlaXZlZCBmcm9tIHRoZSBUVSB3aGlsZVxuICAgICAgICAvLyBpbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLlxuICAgICAgICAvLyBJZiB0aGUgVFUgcGFzc2VzIGEgZmluYWwgcmVzcG9uc2UgKHN0YXR1cyBjb2RlcyAyMDAtNjk5KSB0byB0aGUgc2VydmVyIHdoaWxlIGluXG4gICAgICAgIC8vIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgdGhlIHRyYW5zYWN0aW9uIE1VU1QgZW50ZXIgdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUsIGFuZFxuICAgICAgICAvLyB0aGUgcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAgICB0aGlzLmxhc3RSZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgdGhpcy5zZW5kKHJlc3BvbnNlKS5jYXRjaCgoZXJyb3I6IFRyYW5zcG9ydEVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIGZpbmFsIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAvLyBBbnkgb3RoZXIgZmluYWwgcmVzcG9uc2VzIHBhc3NlZCBieSB0aGUgVFUgdG8gdGhlIHNlcnZlclxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBNVVNUIGJlIGRpc2NhcmRlZCB3aGlsZSBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjJcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlICR7dGhpcy5zdGF0ZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgIGBOb24tSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiByZWNlaXZlZCB1bmV4cGVjdGVkICR7c3RhdHVzQ29kZX0gcmVzcG9uc2UgZnJvbSBUVSB3aGlsZSBpbiBzdGF0ZSAke3RoaXMuc3RhdGV9LmA7XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcnN0LCB0aGUgcHJvY2VkdXJlcyBpbiBbNF0gYXJlIGZvbGxvd2VkLCB3aGljaCBhdHRlbXB0IHRvIGRlbGl2ZXIgdGhlIHJlc3BvbnNlIHRvIGEgYmFja3VwLlxuICAgKiBJZiB0aG9zZSBzaG91bGQgYWxsIGZhaWwsIGJhc2VkIG9uIHRoZSBkZWZpbml0aW9uIG9mIGZhaWx1cmUgaW4gWzRdLCB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIFNIT1VMRFxuICAgKiBpbmZvcm0gdGhlIFRVIHRoYXQgYSBmYWlsdXJlIGhhcyBvY2N1cnJlZCwgYW5kIFNIT1VMRCB0cmFuc2l0aW9uIHRvIHRoZSB0ZXJtaW5hdGVkIHN0YXRlLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuNFxuICAgKi9cbiAgcHJvdGVjdGVkIG9uVHJhbnNwb3J0RXJyb3IoZXJyb3I6IEVycm9yKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudXNlci5vblRyYW5zcG9ydEVycm9yKSB7XG4gICAgICB0aGlzLnVzZXIub25UcmFuc3BvcnRFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCwgdHJ1ZSk7XG4gIH1cblxuICAvKiogRm9yIGxvZ2dpbmcuICovXG4gIHByb3RlY3RlZCB0eXBlVG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJub24tSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvblwiO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0ZVRyYW5zaXRpb24obmV3U3RhdGU6IFRyYW5zYWN0aW9uU3RhdGUsIGR1ZVRvVHJhbnNwb3J0RXJyb3IgPSBmYWxzZSk6IHZvaWQge1xuICAgIC8vIEFzc2VydCB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9ucy5cbiAgICBjb25zdCBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gZnJvbSAke3RoaXMuc3RhdGV9IHRvICR7bmV3U3RhdGV9YCk7XG4gICAgfTtcblxuICAgIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5Ucnlpbmc6XG4gICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nKSB7XG4gICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZDpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nICYmIHRoaXMuc3RhdGUgIT09IFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nICYmIHRoaXMuc3RhdGUgIT09IFRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKSB7XG4gICAgICAgICAgaWYgKCFkdWVUb1RyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBlbnRlcnMgdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUsIGl0IE1VU1Qgc2V0IFRpbWVyIEogdG8gZmlyZVxuICAgIC8vIGluIDY0KlQxIHNlY29uZHMgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cywgYW5kIHplcm8gc2Vjb25kcyBmb3IgcmVsaWFibGUgdHJhbnNwb3J0cy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgIGlmIChuZXdTdGF0ZSA9PT0gVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuSiA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy50aW1lcl9KKCksIFRpbWVycy5USU1FUl9KKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2VydmVyIHRyYW5zYWN0aW9uIE1VU1QgYmUgZGVzdHJveWVkIHRoZSBpbnN0YW50IGl0IGVudGVycyB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjJcbiAgICBpZiAobmV3U3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNlcnZlciB0cmFuc2FjdGlvbiByZW1haW5zIGluIHRoaXMgc3RhdGUgdW50aWwgVGltZXIgSiBmaXJlcyxcbiAgICogYXQgd2hpY2ggcG9pbnQgaXQgTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjJcbiAgICovXG4gIHByaXZhdGUgdGltZXJfSigpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgVGltZXIgSiBleHBpcmVkIGZvciBOT04tSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAke3RoaXMuaWR9LmApO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IEluY29taW5nUmVxdWVzdE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IFRyYW5zcG9ydCB9IGZyb20gXCIuLi90cmFuc3BvcnRcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4vdHJhbnNhY3Rpb25cIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdGUgfSBmcm9tIFwiLi90cmFuc2FjdGlvbi1zdGF0ZVwiO1xuaW1wb3J0IHsgU2VydmVyVHJhbnNhY3Rpb25Vc2VyIH0gZnJvbSBcIi4vdHJhbnNhY3Rpb24tdXNlclwiO1xuXG4vKipcbiAqIFNlcnZlciBUcmFuc2FjdGlvbi5cbiAqIEByZW1hcmtzXG4gKiBUaGUgc2VydmVyIHRyYW5zYWN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgZGVsaXZlcnkgb2YgcmVxdWVzdHMgdG9cbiAqIHRoZSBUVSBhbmQgdGhlIHJlbGlhYmxlIHRyYW5zbWlzc2lvbiBvZiByZXNwb25zZXMuICBJdCBhY2NvbXBsaXNoZXNcbiAqIHRoaXMgdGhyb3VnaCBhIHN0YXRlIG1hY2hpbmUuICBTZXJ2ZXIgdHJhbnNhY3Rpb25zIGFyZSBjcmVhdGVkIGJ5IHRoZVxuICogY29yZSB3aGVuIGEgcmVxdWVzdCBpcyByZWNlaXZlZCwgYW5kIHRyYW5zYWN0aW9uIGhhbmRsaW5nIGlzIGRlc2lyZWRcbiAqIGZvciB0aGF0IHJlcXVlc3QgKHRoaXMgaXMgbm90IGFsd2F5cyB0aGUgY2FzZSkuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjJcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNlcnZlclRyYW5zYWN0aW9uIGV4dGVuZHMgVHJhbnNhY3Rpb24ge1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfcmVxdWVzdDogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICB0cmFuc3BvcnQ6IFRyYW5zcG9ydCxcbiAgICBwcm90ZWN0ZWQgdXNlcjogU2VydmVyVHJhbnNhY3Rpb25Vc2VyLFxuICAgIHN0YXRlOiBUcmFuc2FjdGlvblN0YXRlLFxuICAgIGxvZ2dlckNhdGVnb3J5OiBzdHJpbmdcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICB0cmFuc3BvcnQsXG4gICAgICB1c2VyLFxuICAgICAgX3JlcXVlc3QudmlhQnJhbmNoLFxuICAgICAgc3RhdGUsXG4gICAgICBsb2dnZXJDYXRlZ29yeVxuICAgICk7XG4gIH1cblxuICAvKiogVGhlIGluY29taW5nIHJlcXVlc3QgdGhlIHRyYW5zYWN0aW9uIGhhbmRsaW5nLiAqL1xuICBnZXQgcmVxdWVzdCgpOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNlaXZlIGluY29taW5nIHJlcXVlc3RzIGZyb20gdGhlIHRyYW5zcG9ydCB3aGljaCBtYXRjaCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBpbmNvbWluZyByZXF1ZXN0LlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHJlY2VpdmVSZXF1ZXN0KHJlcXVlc3Q6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZWNlaXZlIG91dGdvaW5nIHJlc3BvbnNlcyB0byB0aGlzIHJlcXVlc3QgZnJvbSB0aGUgdHJhbnNhY3Rpb24gdXNlci5cbiAgICogUmVzcG9uc2VzIHdpbGwgYmUgZGVsaXZlcmVkIHRvIHRoZSB0cmFuc3BvcnQgYXMgbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0gc3RhdHVzQ29kZSAtIFJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICAgKiBAcGFyYW0gcmVzcG9uc2UgLSBSZXNwb25zZS5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCByZWNlaXZlUmVzcG9uc2Uoc3RhdHVzQ29kZTogbnVtYmVyLCByZXNwb25zZTogc3RyaW5nKTogdm9pZDtcbn1cbiIsIi8qKlxuICogVHJhbnNhY3Rpb24gc3RhdGUuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uU3RhdGUge1xuICBBY2NlcHRlZCA9IFwiQWNjZXB0ZWRcIixcbiAgQ2FsbGluZyA9IFwiQ2FsbGluZ1wiLFxuICBDb21wbGV0ZWQgPSBcIkNvbXBsZXRlZFwiLFxuICBDb25maXJtZWQgPSBcIkNvbmZpcm1lZFwiLFxuICBQcm9jZWVkaW5nID0gXCJQcm9jZWVkaW5nXCIsXG4gIFRlcm1pbmF0ZWQgPSBcIlRlcm1pbmF0ZWRcIixcbiAgVHJ5aW5nID0gXCJUcnlpbmdcIlxufVxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50c1wiO1xuXG5pbXBvcnQgeyBUcmFuc3BvcnRFcnJvciB9IGZyb20gXCIuLi9leGNlcHRpb25zXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQgeyBUcmFuc3BvcnQgfSBmcm9tIFwiLi4vdHJhbnNwb3J0XCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXRlIH0gZnJvbSBcIi4vdHJhbnNhY3Rpb24tc3RhdGVcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uVXNlciB9IGZyb20gXCIuL3RyYW5zYWN0aW9uLXVzZXJcIjtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbi5cbiAqIEByZW1hcmtzXG4gKiBTSVAgaXMgYSB0cmFuc2FjdGlvbmFsIHByb3RvY29sOiBpbnRlcmFjdGlvbnMgYmV0d2VlbiBjb21wb25lbnRzIHRha2VcbiAqIHBsYWNlIGluIGEgc2VyaWVzIG9mIGluZGVwZW5kZW50IG1lc3NhZ2UgZXhjaGFuZ2VzLiAgU3BlY2lmaWNhbGx5LCBhXG4gKiBTSVAgdHJhbnNhY3Rpb24gY29uc2lzdHMgb2YgYSBzaW5nbGUgcmVxdWVzdCBhbmQgYW55IHJlc3BvbnNlcyB0b1xuICogdGhhdCByZXF1ZXN0LCB3aGljaCBpbmNsdWRlIHplcm8gb3IgbW9yZSBwcm92aXNpb25hbCByZXNwb25zZXMgYW5kXG4gKiBvbmUgb3IgbW9yZSBmaW5hbCByZXNwb25zZXMuICBJbiB0aGUgY2FzZSBvZiBhIHRyYW5zYWN0aW9uIHdoZXJlIHRoZVxuICogcmVxdWVzdCB3YXMgYW4gSU5WSVRFIChrbm93biBhcyBhbiBJTlZJVEUgdHJhbnNhY3Rpb24pLCB0aGVcbiAqIHRyYW5zYWN0aW9uIGFsc28gaW5jbHVkZXMgdGhlIEFDSyBvbmx5IGlmIHRoZSBmaW5hbCByZXNwb25zZSB3YXMgbm90XG4gKiBhIDJ4eCByZXNwb25zZS4gIElmIHRoZSByZXNwb25zZSB3YXMgYSAyeHgsIHRoZSBBQ0sgaXMgbm90IGNvbnNpZGVyZWRcbiAqIHBhcnQgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xN1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcm90ZWN0ZWQgbG9nZ2VyOiBMb2dnZXI7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX3RyYW5zcG9ydDogVHJhbnNwb3J0LFxuICAgIHByaXZhdGUgX3VzZXI6IFRyYW5zYWN0aW9uVXNlcixcbiAgICBwcml2YXRlIF9pZDogc3RyaW5nLFxuICAgIHByaXZhdGUgX3N0YXRlOiBUcmFuc2FjdGlvblN0YXRlLFxuICAgIGxvZ2dlckNhdGVnb3J5OiBzdHJpbmcsXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2dnZXIgPSBfdXNlci5sb2dnZXJGYWN0b3J5LmdldExvZ2dlcihsb2dnZXJDYXRlZ29yeSwgX2lkKTtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgQ29uc3RydWN0aW5nICR7dGhpcy50eXBlVG9TdHJpbmcoKX0gd2l0aCBpZCAke3RoaXMuaWR9LmApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3RydWN0b3IuXG4gICAqIE9uY2UgdGhlIHRyYW5zYWN0aW9uIGlzIGluIHRoZSBcInRlcm1pbmF0ZWRcIiBzdGF0ZSwgaXQgaXMgZGVzdHJveWVkXG4gICAqIGltbWVkaWF0ZWx5IGFuZCB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYGRpc3Bvc2VgLiBIb3dldmVyLCBpZiBhXG4gICAqIHRyYW5zYWN0aW9uIG5lZWRzIHRvIGJlIGVuZGVkIHByZW1hdHVyZWx5LCB0aGUgdHJhbnNhY3Rpb24gdXNlciBtYXlcbiAgICogZG8gc28gYnkgY2FsbGluZyB0aGlzIG1ldGhvZCAoZm9yIGV4YW1wbGUsIHBlcmhhcHMgdGhlIFVBIGlzIHNodXR0aW5nIGRvd24pLlxuICAgKiBObyBzdGF0ZSB0cmFuc2l0aW9uIHdpbGwgb2NjdXIgdXBvbiBjYWxsaW5nIHRoaXMgbWV0aG9kLCBhbGwgb3V0c3RhbmRpbmdcbiAgICogdHJhbnNtaXNzaW9uIHRpbWVycyB3aWxsIGJlIGNhbmNlbGxlZCwgYW5kIHVzZSBvZiB0aGUgdHJhbnNhY3Rpb24gYWZ0ZXJcbiAgICogY2FsbGluZyBgZGlzcG9zZWAgaXMgdW5kZWZpbmVkLlxuICAgKi9cbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYERlc3Ryb3llZCAke3RoaXMudHlwZVRvU3RyaW5nKCl9IHdpdGggaWQgJHt0aGlzLmlkfS5gKTtcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbiBpZC4gKi9cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uIGtpbmQuIERlcHJlY2F0ZWQuICovXG4gIGdldCBraW5kKCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBraW5kLlwiKTtcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbiBzdGF0ZS4gKi9cbiAgZ2V0IHN0YXRlKCk6IFRyYW5zYWN0aW9uU3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbiB0cmFuc3BvcnQuICovXG4gIGdldCB0cmFuc3BvcnQoKTogVHJhbnNwb3J0IHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0O1xuICB9XG5cbiAgLyoqIFN1YnNjcmliZSB0byAnc3RhdGVDaGFuZ2VkJyBldmVudC4gKi9cbiAgcHVibGljIG9uKG5hbWU6IFwic3RhdGVDaGFuZ2VkXCIsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdGhpcztcbiAgcHVibGljIG9uKG5hbWU6IHN0cmluZywgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHRoaXMgIHsgcmV0dXJuIHN1cGVyLm9uKG5hbWUsIGNhbGxiYWNrKTsgfVxuXG4gIHByb3RlY3RlZCBsb2dUcmFuc3BvcnRFcnJvcihlcnJvcjogVHJhbnNwb3J0RXJyb3IsIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIHRoaXMubG9nZ2VyLmVycm9yKGBUcmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQgaW4gJHt0aGlzLnR5cGVUb1N0cmluZygpfSB3aXRoIGlkICR7dGhpcy5pZH0uYCk7XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgb25UcmFuc3BvcnRFcnJvcihlcnJvcjogVHJhbnNwb3J0RXJyb3IpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBQYXNzIG1lc3NhZ2UgdG8gdHJhbnNwb3J0IGZvciB0cmFuc21pc3Npb24uIElmIHRyYW5zcG9ydCBmYWlscyxcbiAgICogdGhlIHRyYW5zYWN0aW9uIHVzZXIgaXMgbm90aWZpZWQgYnkgY2FsbGJhY2sgdG8gb25UcmFuc3BvcnRFcnJvcigpLlxuICAgKiBAcmV0dXJuc1xuICAgKiBSZWplY3RzIHdpdGggYFRyYW5zcG9ydEVycm9yYCBpZiB0cmFuc3BvcnQgZmFpbHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgc2VuZChtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuc2VuZChtZXNzYWdlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIC8vIElmIHRoZSB0cmFuc3BvcnQgcmVqZWN0cywgaXQgU0hPVUxEIHJlamVjdCB3aXRoIGEgVHJhbnNwb3J0RXJyb3IuXG4gICAgICAvLyBCdXQgdGhlIHRyYW5zcG9ydCBtYXkgYmUgZXh0ZXJuYWwgY29kZSwgc28gd2UgYXJlIGNhcmVmdWxcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjb252ZXJ0IGl0IHRvIGEgVHJhbnNwb3J0RXJyb3IgaWYgbmVlZCBiZS5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFRyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgbGV0IHRyYW5zcG9ydEVycm9yOiBUcmFuc3BvcnRFcnJvcjtcbiAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cmFuc3BvcnRFcnJvciA9IG5ldyBUcmFuc3BvcnRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zcG9ydEVycm9yID0gbmV3IFRyYW5zcG9ydEVycm9yKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IodHJhbnNwb3J0RXJyb3IpO1xuICAgICAgdGhyb3cgdHJhbnNwb3J0RXJyb3I7XG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0U3RhdGUoc3RhdGU6IFRyYW5zYWN0aW9uU3RhdGUpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3RhdGUgY2hhbmdlIHRvIFwiJHtzdGF0ZX1cIiBvbiAke3RoaXMudHlwZVRvU3RyaW5nKCl9IHdpdGggaWQgJHt0aGlzLmlkfS5gKTtcbiAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgIGlmICh0aGlzLl91c2VyLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHRoaXMuX3VzZXIub25TdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInN0YXRlQ2hhbmdlZFwiKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB0eXBlVG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJVbmtub3duVHlwZVwiO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDIH0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5cbi8qKlxuICogRklYTUU6IFRPRE86IFNob3VsZCBiZSBjb25maWd1cmFibGUvdmFyaWFibGUuXG4gKi9cbmV4cG9ydCBjb25zdCBBbGxvd2VkTWV0aG9kcyA9IFtcbiAgQy5BQ0ssXG4gIEMuQllFLFxuICBDLkNBTkNFTCxcbiAgQy5JTkZPLFxuICBDLklOVklURSxcbiAgQy5NRVNTQUdFLFxuICBDLk5PVElGWSxcbiAgQy5PUFRJT05TLFxuICBDLlBSQUNLLCAvLyBGSVhNRTogT25seSBpZiAxMDByZWwgU3VwcG9ydGVkXG4gIEMuUkVGRVIsXG4gIEMuUkVHSVNURVIsXG4gIEMuU1VCU0NSSUJFXG5dO1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vdXNlci1hZ2VudC1jb3JlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91c2VyLWFnZW50LWNvcmUtY29uZmlndXJhdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdXNlci1hZ2VudC1jb3JlLWRlbGVnYXRlXCI7XG4iLCJpbXBvcnQgeyBEaWFsb2cgfSBmcm9tIFwiLi4vZGlhbG9nc1wiO1xuaW1wb3J0IHsgTG9nZ2VyLCBMb2dnZXJGYWN0b3J5IH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHtcbiAgQm9keSxcbiAgQyxcbiAgY29uc3RydWN0T3V0Z29pbmdSZXNwb25zZSxcbiAgSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UsXG4gIE91dGdvaW5nSW52aXRlUmVxdWVzdCxcbiAgT3V0Z29pbmdJbnZpdGVSZXF1ZXN0RGVsZWdhdGUsXG4gIE91dGdvaW5nTWVzc2FnZVJlcXVlc3QsXG4gIE91dGdvaW5nUHVibGlzaFJlcXVlc3QsXG4gIE91dGdvaW5nUmVnaXN0ZXJSZXF1ZXN0LFxuICBPdXRnb2luZ1JlcXVlc3QsXG4gIE91dGdvaW5nUmVxdWVzdERlbGVnYXRlLFxuICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlT3B0aW9ucyxcbiAgT3V0Z29pbmdSZXNwb25zZSxcbiAgT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0LFxuICBPdXRnb2luZ1N1YnNjcmliZVJlcXVlc3REZWxlZ2F0ZSxcbiAgUmVzcG9uc2VPcHRpb25zLFxuICBVUklcbn0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQge1xuICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbixcbiAgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sXG4gIFRyYW5zYWN0aW9uU3RhdGVcbn0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVHJhbnNwb3J0IH0gZnJvbSBcIi4uL3RyYW5zcG9ydFwiO1xuaW1wb3J0IHtcbiAgSW52aXRlVXNlckFnZW50Q2xpZW50LFxuICBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIsXG4gIE1lc3NhZ2VVc2VyQWdlbnRDbGllbnQsXG4gIE1lc3NhZ2VVc2VyQWdlbnRTZXJ2ZXIsXG4gIE5vdGlmeVVzZXJBZ2VudFNlcnZlcixcbiAgUHVibGlzaFVzZXJBZ2VudENsaWVudCxcbiAgUmVmZXJVc2VyQWdlbnRTZXJ2ZXIsXG4gIFJlZ2lzdGVyVXNlckFnZW50Q2xpZW50LFxuICBSZWdpc3RlclVzZXJBZ2VudFNlcnZlcixcbiAgU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50LFxuICBTdWJzY3JpYmVVc2VyQWdlbnRTZXJ2ZXIsXG4gIFVzZXJBZ2VudENsaWVudCxcbiAgVXNlckFnZW50U2VydmVyXG59IGZyb20gXCIuLi91c2VyLWFnZW50c1wiO1xuaW1wb3J0IHsgQWxsb3dlZE1ldGhvZHMgfSBmcm9tIFwiLi9hbGxvd2VkLW1ldGhvZHNcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4vdXNlci1hZ2VudC1jb3JlLWNvbmZpZ3VyYXRpb25cIjtcbmltcG9ydCB7IFVzZXJBZ2VudENvcmVEZWxlZ2F0ZSB9IGZyb20gXCIuL3VzZXItYWdlbnQtY29yZS1kZWxlZ2F0ZVwiO1xuLyoqXG4gKiBUaGlzIGlzIHBvcnRlZCBmcm9tIFVBLkMuQUNDRVBURURfQk9EWV9UWVBFUy5cbiAqIEZJWE1FOiBUT0RPOiBTaG91bGQgYmUgY29uZmlndXJhYmxlL3ZhcmlhYmxlLlxuICovXG5jb25zdCBhY2NlcHRlZEJvZHlUeXBlcyA9IFtcbiAgXCJhcHBsaWNhdGlvbi9zZHBcIixcbiAgXCJhcHBsaWNhdGlvbi9kdG1mLXJlbGF5XCJcbl07XG5cbi8qKlxuICogVXNlciBBZ2VudCBDb3JlLlxuICogQHJlbWFya3NcbiAqIENvcmUgZGVzaWduYXRlcyB0aGUgZnVuY3Rpb25zIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciB0eXBlXG4gKiBvZiBTSVAgZW50aXR5LCBpLmUuLCBzcGVjaWZpYyB0byBlaXRoZXIgYSBzdGF0ZWZ1bCBvciBzdGF0ZWxlc3NcbiAqIHByb3h5LCBhIHVzZXIgYWdlbnQgb3IgcmVnaXN0cmFyLiAgQWxsIGNvcmVzLCBleGNlcHQgdGhvc2UgZm9yXG4gKiB0aGUgc3RhdGVsZXNzIHByb3h5LCBhcmUgdHJhbnNhY3Rpb24gdXNlcnMuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTZcbiAqXG4gKiBVQUMgQ29yZTogVGhlIHNldCBvZiBwcm9jZXNzaW5nIGZ1bmN0aW9ucyByZXF1aXJlZCBvZiBhIFVBQyB0aGF0XG4gKiByZXNpZGUgYWJvdmUgdGhlIHRyYW5zYWN0aW9uIGFuZCB0cmFuc3BvcnQgbGF5ZXJzLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi02XG4gKlxuICogVUFTIENvcmU6IFRoZSBzZXQgb2YgcHJvY2Vzc2luZyBmdW5jdGlvbnMgcmVxdWlyZWQgYXQgYSBVQVMgdGhhdFxuICogcmVzaWRlcyBhYm92ZSB0aGUgdHJhbnNhY3Rpb24gYW5kIHRyYW5zcG9ydCBsYXllcnMuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTZcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFVzZXJBZ2VudENvcmUge1xuICAvKiogQ29uZmlndXJhdGlvbi4gKi9cbiAgcHVibGljIGNvbmZpZ3VyYXRpb246IFVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uO1xuICAvKiogRGVsZWdhdGUuICovXG4gIHB1YmxpYyBkZWxlZ2F0ZTogVXNlckFnZW50Q29yZURlbGVnYXRlO1xuICAvKiogRGlhbG9ncy4gKi9cbiAgcHVibGljIGRpYWxvZ3M6IE1hcDxzdHJpbmcsIERpYWxvZz47XG4gIC8qKiBTdWJzY3JpYmVycy4gKi9cbiAgcHVibGljIHN1YnNjcmliZXJzOiBNYXA8c3RyaW5nLCBTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQ+O1xuICAvKiogVUFDcy4gKi9cbiAgcHVibGljIHVzZXJBZ2VudENsaWVudHMgPSBuZXcgTWFwPHN0cmluZywgVXNlckFnZW50Q2xpZW50PigpO1xuICAvKiogVUFTcy4gKi9cbiAgcHVibGljIHVzZXJBZ2VudFNlcnZlcnMgPSBuZXcgTWFwPHN0cmluZywgVXNlckFnZW50U2VydmVyPigpO1xuXG4gIHByaXZhdGUgbG9nZ2VyOiBMb2dnZXI7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gY29uZmlndXJhdGlvbiAtIENvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIERlbGVnYXRlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgY29uZmlndXJhdGlvbjogVXNlckFnZW50Q29yZUNvbmZpZ3VyYXRpb24sXG4gICAgZGVsZWdhdGU6IFVzZXJBZ2VudENvcmVEZWxlZ2F0ZSA9IHt9XG4gICkge1xuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgIHRoaXMuZGlhbG9ncyA9IG5ldyBNYXA8c3RyaW5nLCBEaWFsb2c+KCk7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBNYXA8c3RyaW5nLCBTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQ+KCk7XG4gICAgdGhpcy5sb2dnZXIgPSBjb25maWd1cmF0aW9uLmxvZ2dlckZhY3RvcnkuZ2V0TG9nZ2VyKFwic2lwLnVzZXItYWdlbnQtY29yZVwiKTtcbiAgfVxuXG4gIC8qKiBEZXN0cnVjdG9yLiAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICAvKiogUmVzZXQuICovXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmRpYWxvZ3MuZm9yRWFjaCgoZGlhbG9nKSA9PiBkaWFsb2cuZGlzcG9zZSgpKTtcbiAgICB0aGlzLmRpYWxvZ3MuY2xlYXIoKTtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIuZGlzcG9zZSgpKTtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgdGhpcy51c2VyQWdlbnRDbGllbnRzLmZvckVhY2goKHVhYykgPT4gdWFjLmRpc3Bvc2UoKSk7XG4gICAgdGhpcy51c2VyQWdlbnRDbGllbnRzLmNsZWFyKCk7XG4gICAgdGhpcy51c2VyQWdlbnRTZXJ2ZXJzLmZvckVhY2goKHVhYykgPT4gdWFjLmRpc3Bvc2UoKSk7XG4gICAgdGhpcy51c2VyQWdlbnRTZXJ2ZXJzLmNsZWFyKCk7XG4gIH1cblxuICAvKiogTG9nZ2VyIGZhY3RvcnkuICovXG4gIGdldCBsb2dnZXJGYWN0b3J5KCk6IExvZ2dlckZhY3Rvcnkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ubG9nZ2VyRmFjdG9yeTtcbiAgfVxuXG4gIC8qKiBUcmFuc3BvcnQuICovXG4gIGdldCB0cmFuc3BvcnQoKTogVHJhbnNwb3J0IHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLmNvbmZpZ3VyYXRpb24udHJhbnNwb3J0QWNjZXNzb3IoKTtcbiAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0IHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBJTlZJVEUuXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gT3V0Z29pbmcgcmVxdWVzdC5cbiAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICovXG4gIHB1YmxpYyBpbnZpdGUoXG4gICAgcmVxdWVzdDogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICBkZWxlZ2F0ZT86IE91dGdvaW5nSW52aXRlUmVxdWVzdERlbGVnYXRlXG4gICk6IE91dGdvaW5nSW52aXRlUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBJbnZpdGVVc2VyQWdlbnRDbGllbnQodGhpcywgcmVxdWVzdCwgZGVsZWdhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgTUVTU0FHRS5cbiAgICogQHBhcmFtIHJlcXVlc3QgLSBPdXRnb2luZyByZXF1ZXN0LlxuICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgKi9cbiAgcHVibGljIG1lc3NhZ2UoXG4gICAgcmVxdWVzdDogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICBkZWxlZ2F0ZT86IE91dGdvaW5nUmVxdWVzdERlbGVnYXRlXG4gICk6IE91dGdvaW5nTWVzc2FnZVJlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZVVzZXJBZ2VudENsaWVudCh0aGlzLCByZXF1ZXN0LCBkZWxlZ2F0ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBQVUJMSVNILlxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIE91dGdvaW5nIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAqL1xuICBwdWJsaWMgcHVibGlzaChcbiAgICByZXF1ZXN0OiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGRlbGVnYXRlPzogT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGVcbiAgKTogT3V0Z29pbmdQdWJsaXNoUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaXNoVXNlckFnZW50Q2xpZW50KHRoaXMsIHJlcXVlc3QsIGRlbGVnYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIFJFR0lTVEVSLlxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIE91dGdvaW5nIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXIoXG4gICAgcmVxdWVzdDogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICBkZWxlZ2F0ZT86IE91dGdvaW5nUmVxdWVzdERlbGVnYXRlXG4gICk6IE91dGdvaW5nUmVnaXN0ZXJSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IFJlZ2lzdGVyVXNlckFnZW50Q2xpZW50KHRoaXMsIHJlcXVlc3QsIGRlbGVnYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIFNVQlNDUklCRS5cbiAgICogQHBhcmFtIHJlcXVlc3QgLSBPdXRnb2luZyByZXF1ZXN0LlxuICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgKi9cbiAgcHVibGljIHN1YnNjcmliZShcbiAgICByZXF1ZXN0OiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGRlbGVnYXRlPzogT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0RGVsZWdhdGVcbiAgKTogT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZVVzZXJBZ2VudENsaWVudCh0aGlzLCByZXF1ZXN0LCBkZWxlZ2F0ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHJlcXVlc3QuXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gT3V0Z29pbmcgcmVxdWVzdC5cbiAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICovXG4gIHB1YmxpYyByZXF1ZXN0KFxuICAgIHJlcXVlc3Q6IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UsXG4gICAgZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZVxuICApOiBPdXRnb2luZ1JlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgVXNlckFnZW50Q2xpZW50KE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCB0aGlzLCByZXF1ZXN0LCBkZWxlZ2F0ZSk7XG4gIH1cblxuICAvKipcbiAgICogT3V0Z29pbmcgcmVxdWVzdCBtZXNzYWdlIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBtZXRob2QgLSBNZXRob2QuXG4gICAqIEBwYXJhbSByZXF1ZXN0VVJJIC0gUmVxdWVzdC1VUkkuXG4gICAqIEBwYXJhbSBmcm9tVVJJIC0gRnJvbSBVUkkuXG4gICAqIEBwYXJhbSB0b1VSSSAtIFRvIFVSSS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnMuXG4gICAqIEBwYXJhbSBleHRyYUhlYWRlcnMgLSBFeHRyYSBoZWFkZXJzIHRvIGFkZC5cbiAgICogQHBhcmFtIGJvZHkgLSBNZXNzYWdlIGJvZHkuXG4gICAqL1xuICBwdWJsaWMgbWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoXG4gICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgcmVxdWVzdFVSSTogVVJJLFxuICAgIGZyb21VUkk6IFVSSSxcbiAgICB0b1VSSTogVVJJLFxuICAgIG9wdGlvbnM6IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2VPcHRpb25zLFxuICAgIGV4dHJhSGVhZGVycz86IEFycmF5PHN0cmluZz4sXG4gICAgYm9keT86IEJvZHlcbiAgKTogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSB7XG5cbiAgICAvLyBkZWZhdWx0IHZhbHVlcyBmcm9tIHVzZXIgYWdlbnQgY29uZmlndXJhdGlvblxuICAgIGNvbnN0IGNhbGxJZFByZWZpeCA9IHRoaXMuY29uZmlndXJhdGlvbi5zaXBqc0lkO1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IHRoaXMuY29uZmlndXJhdGlvbi5kaXNwbGF5TmFtZTtcbiAgICBjb25zdCBmb3JjZVJwb3J0ID0gdGhpcy5jb25maWd1cmF0aW9uLnZpYUZvcmNlUnBvcnQ7XG4gICAgY29uc3QgaGFja1ZpYVRjcCA9IHRoaXMuY29uZmlndXJhdGlvbi5oYWNrVmlhVGNwO1xuICAgIGNvbnN0IG9wdGlvblRhZ3MgPSB0aGlzLmNvbmZpZ3VyYXRpb24uc3VwcG9ydGVkT3B0aW9uVGFncy5zbGljZSgpO1xuICAgIGlmIChtZXRob2QgPT09IEMuUkVHSVNURVIpIHtcbiAgICAgIG9wdGlvblRhZ3MucHVzaChcInBhdGhcIiwgXCJncnV1XCIpO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09PSBDLklOVklURSAmJiAodGhpcy5jb25maWd1cmF0aW9uLmNvbnRhY3QucHViR3J1dSB8fCB0aGlzLmNvbmZpZ3VyYXRpb24uY29udGFjdC50ZW1wR3J1dSkpIHtcbiAgICAgIG9wdGlvblRhZ3MucHVzaChcImdydXVcIik7XG4gICAgfVxuICAgIGNvbnN0IHJvdXRlU2V0ID0gdGhpcy5jb25maWd1cmF0aW9uLnJvdXRlU2V0O1xuICAgIGNvbnN0IHVzZXJBZ2VudFN0cmluZyA9IHRoaXMuY29uZmlndXJhdGlvbi51c2VyQWdlbnRIZWFkZXJGaWVsZFZhbHVlO1xuICAgIGNvbnN0IHZpYUhvc3QgPSB0aGlzLmNvbmZpZ3VyYXRpb24udmlhSG9zdDtcblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlT3B0aW9ucyA9IHtcbiAgICAgIGNhbGxJZFByZWZpeCxcbiAgICAgIGZvcmNlUnBvcnQsXG4gICAgICBmcm9tRGlzcGxheU5hbWUsXG4gICAgICBoYWNrVmlhVGNwLFxuICAgICAgb3B0aW9uVGFncyxcbiAgICAgIHJvdXRlU2V0LFxuICAgICAgdXNlckFnZW50U3RyaW5nLFxuICAgICAgdmlhSG9zdCxcbiAgICB9O1xuXG4gICAgLy8gbWVyZ2UgcHJvdmlkZWQgb3B0aW9ucyB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlT3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoXG4gICAgICBtZXRob2QsXG4gICAgICByZXF1ZXN0VVJJLFxuICAgICAgZnJvbVVSSSxcbiAgICAgIHRvVVJJLFxuICAgICAgcmVxdWVzdE9wdGlvbnMsXG4gICAgICBleHRyYUhlYWRlcnMsXG4gICAgICBib2R5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gaW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlIGZyb20gdGhlIHRyYW5zcG9ydC5cbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UgZnJvbSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAqL1xuICBwdWJsaWMgcmVjZWl2ZUluY29taW5nUmVxdWVzdEZyb21UcmFuc3BvcnQobWVzc2FnZTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSk6IHZvaWQge1xuICAgIHRoaXMucmVjZWl2ZVJlcXVlc3RGcm9tVHJhbnNwb3J0KG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbiBpbmNvbWluZyByZXNwb25zZSBtZXNzYWdlIGZyb20gdGhlIHRyYW5zcG9ydC5cbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXNwb25zZSBtZXNzYWdlIGZyb20gdHJhbnNwb3J0IGxheWVyLlxuICAgKi9cbiAgcHVibGljIHJlY2VpdmVJbmNvbWluZ1Jlc3BvbnNlRnJvbVRyYW5zcG9ydChtZXNzYWdlOiBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSk6IHZvaWQge1xuICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlRnJvbVRyYW5zcG9ydChtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0YXRlbGVzcyBVQVMgaXMgYSBVQVMgdGhhdCBkb2VzIG5vdCBtYWludGFpbiB0cmFuc2FjdGlvbiBzdGF0ZS5cbiAgICogSXQgcmVwbGllcyB0byByZXF1ZXN0cyBub3JtYWxseSwgYnV0IGRpc2NhcmRzIGFueSBzdGF0ZSB0aGF0IHdvdWxkXG4gICAqIG9yZGluYXJpbHkgYmUgcmV0YWluZWQgYnkgYSBVQVMgYWZ0ZXIgYSByZXNwb25zZSBoYXMgYmVlbiBzZW50LiAgSWYgYVxuICAgKiBzdGF0ZWxlc3MgVUFTIHJlY2VpdmVzIGEgcmV0cmFuc21pc3Npb24gb2YgYSByZXF1ZXN0LCBpdCByZWdlbmVyYXRlc1xuICAgKiB0aGUgcmVzcG9uc2UgYW5kIHJlLXNlbmRzIGl0LCBqdXN0IGFzIGlmIGl0IHdlcmUgcmVwbHlpbmcgdG8gdGhlIGZpcnN0XG4gICAqIGluc3RhbmNlIG9mIHRoZSByZXF1ZXN0LiBBIFVBUyBjYW5ub3QgYmUgc3RhdGVsZXNzIHVubGVzcyB0aGUgcmVxdWVzdFxuICAgKiBwcm9jZXNzaW5nIGZvciB0aGF0IG1ldGhvZCB3b3VsZCBhbHdheXMgcmVzdWx0IGluIHRoZSBzYW1lIHJlc3BvbnNlXG4gICAqIGlmIHRoZSByZXF1ZXN0cyBhcmUgaWRlbnRpY2FsLiBUaGlzIHJ1bGVzIG91dCBzdGF0ZWxlc3MgcmVnaXN0cmFycyxcbiAgICogZm9yIGV4YW1wbGUuICBTdGF0ZWxlc3MgVUFTcyBkbyBub3QgdXNlIGEgdHJhbnNhY3Rpb24gbGF5ZXI7IHRoZXlcbiAgICogcmVjZWl2ZSByZXF1ZXN0cyBkaXJlY3RseSBmcm9tIHRoZSB0cmFuc3BvcnQgbGF5ZXIgYW5kIHNlbmQgcmVzcG9uc2VzXG4gICAqIGRpcmVjdGx5IHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjdcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UgdG8gcmVwbHkgdG8uXG4gICAqIEBwYXJhbSBzdGF0dXNDb2RlIC0gU3RhdHVzIGNvZGUgdG8gcmVwbHkgd2l0aC5cbiAgICovXG4gIHB1YmxpYyByZXBseVN0YXRlbGVzcyhcbiAgICBtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICAgIG9wdGlvbnM6IFJlc3BvbnNlT3B0aW9uc1xuICApOiBPdXRnb2luZ1Jlc3BvbnNlIHtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSB0aGlzLmNvbmZpZ3VyYXRpb24udXNlckFnZW50SGVhZGVyRmllbGRWYWx1ZTtcbiAgICBjb25zdCBzdXBwb3J0ZWQgPSB0aGlzLmNvbmZpZ3VyYXRpb24uc3VwcG9ydGVkT3B0aW9uVGFnc1Jlc3BvbnNlO1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHVzZXJBZ2VudCwgc3VwcG9ydGVkIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBjb25zdHJ1Y3RPdXRnb2luZ1Jlc3BvbnNlKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UubWVzc2FnZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAvLyBJZiB0aGUgdHJhbnNwb3J0IHJlamVjdHMsIGl0IFNIT1VMRCByZWplY3Qgd2l0aCBhIFRyYW5zcG9ydEVycm9yLlxuICAgICAgLy8gQnV0IHRoZSB0cmFuc3BvcnQgbWF5IGJlIGV4dGVybmFsIGNvZGUsIHNvIHdlIGFyZSBjYXJlZnVsLi4uXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBUcmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQgc2VuZGluZyBzdGF0ZWxlc3MgcmVwbHkgdG8gJHttZXNzYWdlLm1ldGhvZH0gcmVxdWVzdC5gKTtcbiAgICAgIC8vIFRPRE86IEN1cnJlbnRseSB0aGVyZSBpcyBubyBob29rIHRvIHByb3ZpZGUgbm90aWZpY2F0aW9uIHRoYXQgYSB0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWRcbiAgICAgIC8vIGFuZCB0aHJvd2luZyB3b3VsZCByZXN1bHQgaW4gYW4gdW5jYXVnaHQgZXJyb3IgKGluIHByb21pc2UpLCBzbyB3ZSBzaWxpZW50bHkgZWF0IHRoZSBlcnJvci5cbiAgICAgIC8vIEZ1cnRoZXJtb3JlLCBzaWxpZW50eSBlYXRpbmcgc3RhdGVsZXNzIHJlcGx5IHRyYW5zcG9ydCBlcnJvcnMgaXMgYXJndWFibHkgd2hhdCB3ZSB3YW50IHRvIGRvIGhlcmUuXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluIFNlY3Rpb24gMTguMi4xLCByZXBsYWNlIHRoZSBsYXN0IHBhcmFncmFwaCB3aXRoOlxuICAgKlxuICAgKiBOZXh0LCB0aGUgc2VydmVyIHRyYW5zcG9ydCBhdHRlbXB0cyB0byBtYXRjaCB0aGUgcmVxdWVzdCB0byBhXG4gICAqIHNlcnZlciB0cmFuc2FjdGlvbi4gIEl0IGRvZXMgc28gdXNpbmcgdGhlIG1hdGNoaW5nIHJ1bGVzIGRlc2NyaWJlZFxuICAgKiBpbiBTZWN0aW9uIDE3LjIuMy4gIElmIGEgbWF0Y2hpbmcgc2VydmVyIHRyYW5zYWN0aW9uIGlzIGZvdW5kLCB0aGVcbiAgICogcmVxdWVzdCBpcyBwYXNzZWQgdG8gdGhhdCB0cmFuc2FjdGlvbiBmb3IgcHJvY2Vzc2luZy4gIElmIG5vIG1hdGNoXG4gICAqIGlzIGZvdW5kLCB0aGUgcmVxdWVzdCBpcyBwYXNzZWQgdG8gdGhlIGNvcmUsIHdoaWNoIG1heSBkZWNpZGUgdG9cbiAgICogY29uc3RydWN0IGEgbmV3IHNlcnZlciB0cmFuc2FjdGlvbiBmb3IgdGhhdCByZXF1ZXN0LlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguMTBcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UgZnJvbSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAqL1xuICBwcml2YXRlIHJlY2VpdmVSZXF1ZXN0RnJvbVRyYW5zcG9ydChtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlKTogdm9pZCB7XG4gICAgLy8gV2hlbiBhIHJlcXVlc3QgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgbmV0d29yayBieSB0aGUgc2VydmVyLCBpdCBoYXMgdG9cbiAgICAvLyBiZSBtYXRjaGVkIHRvIGFuIGV4aXN0aW5nIHRyYW5zYWN0aW9uLiAgVGhpcyBpcyBhY2NvbXBsaXNoZWQgaW4gdGhlXG4gICAgLy8gZm9sbG93aW5nIG1hbm5lci5cbiAgICAvL1xuICAgIC8vIFRoZSBicmFuY2ggcGFyYW1ldGVyIGluIHRoZSB0b3Btb3N0IFZpYSBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3RcbiAgICAvLyBpcyBleGFtaW5lZC4gIElmIGl0IGlzIHByZXNlbnQgYW5kIGJlZ2lucyB3aXRoIHRoZSBtYWdpYyBjb29raWVcbiAgICAvLyBcIno5aEc0YktcIiwgdGhlIHJlcXVlc3Qgd2FzIGdlbmVyYXRlZCBieSBhIGNsaWVudCB0cmFuc2FjdGlvblxuICAgIC8vIGNvbXBsaWFudCB0byB0aGlzIHNwZWNpZmljYXRpb24uICBUaGVyZWZvcmUsIHRoZSBicmFuY2ggcGFyYW1ldGVyXG4gICAgLy8gd2lsbCBiZSB1bmlxdWUgYWNyb3NzIGFsbCB0cmFuc2FjdGlvbnMgc2VudCBieSB0aGF0IGNsaWVudC4gIFRoZVxuICAgIC8vIHJlcXVlc3QgbWF0Y2hlcyBhIHRyYW5zYWN0aW9uIGlmOlxuICAgIC8vXG4gICAgLy8gICAgMS4gdGhlIGJyYW5jaCBwYXJhbWV0ZXIgaW4gdGhlIHJlcXVlc3QgaXMgZXF1YWwgdG8gdGhlIG9uZSBpbiB0aGVcbiAgICAvLyAgICAgICB0b3AgVmlhIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdCB0aGF0IGNyZWF0ZWQgdGhlXG4gICAgLy8gICAgICAgdHJhbnNhY3Rpb24sIGFuZFxuICAgIC8vXG4gICAgLy8gICAgMi4gdGhlIHNlbnQtYnkgdmFsdWUgaW4gdGhlIHRvcCBWaWEgb2YgdGhlIHJlcXVlc3QgaXMgZXF1YWwgdG8gdGhlXG4gICAgLy8gICAgICAgb25lIGluIHRoZSByZXF1ZXN0IHRoYXQgY3JlYXRlZCB0aGUgdHJhbnNhY3Rpb24sIGFuZFxuICAgIC8vXG4gICAgLy8gICAgMy4gdGhlIG1ldGhvZCBvZiB0aGUgcmVxdWVzdCBtYXRjaGVzIHRoZSBvbmUgdGhhdCBjcmVhdGVkIHRoZVxuICAgIC8vICAgICAgIHRyYW5zYWN0aW9uLCBleGNlcHQgZm9yIEFDSywgd2hlcmUgdGhlIG1ldGhvZCBvZiB0aGUgcmVxdWVzdFxuICAgIC8vICAgICAgIHRoYXQgY3JlYXRlZCB0aGUgdHJhbnNhY3Rpb24gaXMgSU5WSVRFLlxuICAgIC8vXG4gICAgLy8gVGhpcyBtYXRjaGluZyBydWxlIGFwcGxpZXMgdG8gYm90aCBJTlZJVEUgYW5kIG5vbi1JTlZJVEUgdHJhbnNhY3Rpb25zXG4gICAgLy8gYWxpa2UuXG4gICAgLy9cbiAgICAvLyAgICBUaGUgc2VudC1ieSB2YWx1ZSBpcyB1c2VkIGFzIHBhcnQgb2YgdGhlIG1hdGNoaW5nIHByb2Nlc3MgYmVjYXVzZVxuICAgIC8vICAgIHRoZXJlIGNvdWxkIGJlIGFjY2lkZW50YWwgb3IgbWFsaWNpb3VzIGR1cGxpY2F0aW9uIG9mIGJyYW5jaFxuICAgIC8vICAgIHBhcmFtZXRlcnMgZnJvbSBkaWZmZXJlbnQgY2xpZW50cy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuM1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBtZXNzYWdlLnZpYUJyYW5jaDsgLy8gRklYTUU6IEN1cnJlbnRseSBvbmx5IHVzaW5nIHJ1bGUgMS4uLlxuICAgIGNvbnN0IHVhcyA9IHRoaXMudXNlckFnZW50U2VydmVycy5nZXQodHJhbnNhY3Rpb25JZCk7XG5cbiAgICAvLyBXaGVuIHJlY2VpdmluZyBhbiBBQ0sgdGhhdCBtYXRjaGVzIGFuIGV4aXN0aW5nIElOVklURSBzZXJ2ZXJcbiAgICAvLyB0cmFuc2FjdGlvbiBhbmQgdGhhdCBkb2VzIG5vdCBjb250YWluIGEgYnJhbmNoIHBhcmFtZXRlciBjb250YWluaW5nXG4gICAgLy8gdGhlIG1hZ2ljIGNvb2tpZSBkZWZpbmVkIGluIFJGQyAzMjYxLCB0aGUgbWF0Y2hpbmcgdHJhbnNhY3Rpb24gTVVTVFxuICAgIC8vIGJlIGNoZWNrZWQgdG8gc2VlIGlmIGl0IGlzIGluIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUuICBJZiBpdCBpcywgdGhlblxuICAgIC8vIHRoZSBBQ0sgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIHRyYW5zYWN0aW9uIHVzZXIgaW5zdGVhZCBvZlxuICAgIC8vIGJlaW5nIGFic29yYmVkIGJ5IHRoZSB0cmFuc2FjdGlvbiBzdGF0ZSBtYWNoaW5lLiAgVGhpcyBpcyBuZWNlc3NhcnlcbiAgICAvLyBhcyByZXF1ZXN0cyBmcm9tIFJGQyAyNTQzIGNsaWVudHMgd2lsbCBub3QgaW5jbHVkZSBhIHVuaXF1ZSBicmFuY2hcbiAgICAvLyBwYXJhbWV0ZXIsIGFuZCB0aGUgbWVjaGFuaXNtcyBmb3IgY2FsY3VsYXRpbmcgdGhlIHRyYW5zYWN0aW9uIElEIGZyb21cbiAgICAvLyBzdWNoIGEgcmVxdWVzdCB3aWxsIGJlIHRoZSBzYW1lIGZvciBib3RoIElOVklURSBhbmQgQUNLcy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTZcblxuICAgIC8vIEFueSBBQ0tzIHJlY2VpdmVkIGZyb20gdGhlIG5ldHdvcmsgd2hpbGUgaW4gdGhlIFwiQWNjZXB0ZWRcIiBzdGF0ZSBNVVNUIGJlXG4gICAgLy8gcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBUVSBhbmQgbm90IGFic29yYmVkLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tNy4xXG4gICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBDLkFDSykge1xuICAgICAgaWYgKHVhcyAmJiB1YXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpIHtcbiAgICAgICAgaWYgKHVhcyBpbnN0YW5jZW9mIEludml0ZVVzZXJBZ2VudFNlcnZlcikge1xuICAgICAgICAgIC8vIFRoZXNlIGFyZSBBQ0tzIG1hdGNoaW5nIGFuIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIG5ldmVyIGhhcHBlbiB3aXRoIFJGQyAzMjYxIGNvbXBsaWFudCB1c2VyIGFnZW50c1xuICAgICAgICAgIC8vICh3b3VsZCBiZSBhIGJyb2tlbiBBQ0sgdG8gbmVnYXRpdmUgZmluYWwgcmVzcG9uc2Ugb3Igc29tZXRoaW5nKVxuICAgICAgICAgIC8vIGJ1dCBpcyBhcHBhcmVudGx5IGhvdyBSRkMgMjU0MyB1c2VyIGFnZW50cyBkbyB0aGluZ3MuXG4gICAgICAgICAgLy8gV2UgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGluZyB0aGlzIGNhc2UuXG4gICAgICAgICAgLy8gTk9URTogTm90IGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGggUkZDIDI1NDMgKG5vIHN1cHBvcnQgZm9yIHN0cmljdC1yb3V0aW5nKS5cbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYERpc2NhcmRpbmcgb3V0IG9mIGRpYWxvZyBBQ0sgYWZ0ZXIgMnh4IHJlc3BvbnNlIHNlbnQgb24gdHJhbnNhY3Rpb24gJHt0cmFuc2FjdGlvbklkfS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgQ0FOQ0VMIG1ldGhvZCByZXF1ZXN0cyB0aGF0IHRoZSBUVSBhdCB0aGUgc2VydmVyIHNpZGUgY2FuY2VsIGFcbiAgICAvLyBwZW5kaW5nIHRyYW5zYWN0aW9uLiAgVGhlIFRVIGRldGVybWluZXMgdGhlIHRyYW5zYWN0aW9uIHRvIGJlXG4gICAgLy8gY2FuY2VsbGVkIGJ5IHRha2luZyB0aGUgQ0FOQ0VMIHJlcXVlc3QsIGFuZCB0aGVuIGFzc3VtaW5nIHRoYXQgdGhlXG4gICAgLy8gcmVxdWVzdCBtZXRob2QgaXMgYW55dGhpbmcgYnV0IENBTkNFTCBvciBBQ0sgYW5kIGFwcGx5aW5nIHRoZVxuICAgIC8vIHRyYW5zYWN0aW9uIG1hdGNoaW5nIHByb2NlZHVyZXMgb2YgU2VjdGlvbiAxNy4yLjMuICBUaGUgbWF0Y2hpbmdcbiAgICAvLyB0cmFuc2FjdGlvbiBpcyB0aGUgb25lIHRvIGJlIGNhbmNlbGxlZC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMlxuICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gQy5DQU5DRUwpIHtcbiAgICAgIGlmICh1YXMpIHtcbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgbWV0aG9kIG9mIHRoZSBvcmlnaW5hbCByZXF1ZXN0LCBhcyBsb25nIGFzIHRoZVxuICAgICAgICAvLyBDQU5DRUwgbWF0Y2hlZCBhbiBleGlzdGluZyB0cmFuc2FjdGlvbiwgdGhlIFVBUyBhbnN3ZXJzIHRoZSBDQU5DRUxcbiAgICAgICAgLy8gcmVxdWVzdCBpdHNlbGYgd2l0aCBhIDIwMCAoT0spIHJlc3BvbnNlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMlxuICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogMjAwIH0pO1xuXG4gICAgICAgIC8vIElmIHRoZSB0cmFuc2FjdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHJlcXVlc3Qgc3RpbGwgZXhpc3RzLCB0aGUgYmVoYXZpb3JcbiAgICAgICAgLy8gb2YgdGhlIFVBUyBvbiByZWNlaXZpbmcgYSBDQU5DRUwgcmVxdWVzdCBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaGFzIGFscmVhZHlcbiAgICAgICAgLy8gc2VudCBhIGZpbmFsIHJlc3BvbnNlIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdC4gSWYgaXQgaGFzLCB0aGUgQ0FOQ0VMXG4gICAgICAgIC8vIHJlcXVlc3QgaGFzIG5vIGVmZmVjdCBvbiB0aGUgcHJvY2Vzc2luZyBvZiB0aGUgb3JpZ2luYWwgcmVxdWVzdCwgbm9cbiAgICAgICAgLy8gZWZmZWN0IG9uIGFueSBzZXNzaW9uIHN0YXRlLCBhbmQgbm8gZWZmZWN0IG9uIHRoZSByZXNwb25zZXMgZ2VuZXJhdGVkXG4gICAgICAgIC8vIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdC4gSWYgdGhlIFVBUyBoYXMgbm90IGlzc3VlZCBhIGZpbmFsIHJlc3BvbnNlXG4gICAgICAgIC8vIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdCwgaXRzIGJlaGF2aW9yIGRlcGVuZHMgb24gdGhlIG1ldGhvZCBvZiB0aGVcbiAgICAgICAgLy8gb3JpZ2luYWwgcmVxdWVzdC4gSWYgdGhlIG9yaWdpbmFsIHJlcXVlc3Qgd2FzIGFuIElOVklURSwgdGhlIFVBU1xuICAgICAgICAvLyBTSE9VTEQgaW1tZWRpYXRlbHkgcmVzcG9uZCB0byB0aGUgSU5WSVRFIHdpdGggYSA0ODcgKFJlcXVlc3RcbiAgICAgICAgLy8gVGVybWluYXRlZCkuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOS4yXG4gICAgICAgIGlmIChcbiAgICAgICAgICB1YXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiAmJlxuICAgICAgICAgIHVhcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh1YXMgaW5zdGFuY2VvZiBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHVhcy5yZWNlaXZlQ2FuY2VsKG1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBIENBTkNFTCByZXF1ZXN0IGhhcyBubyBpbXBhY3Qgb24gdGhlIHByb2Nlc3Npbmcgb2ZcbiAgICAgICAgICAvLyB0cmFuc2FjdGlvbnMgd2l0aCBhbnkgb3RoZXIgbWV0aG9kIGRlZmluZWQgaW4gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOS4yXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBVQVMgZGlkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgdHJhbnNhY3Rpb24gZm9yIHRoZSBDQU5DRUxcbiAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBwcm9jZWR1cmUgYWJvdmUsIGl0IFNIT1VMRCByZXNwb25kIHRvIHRoZSBDQU5DRUxcbiAgICAgICAgLy8gd2l0aCBhIDQ4MSAoQ2FsbCBMZWcvVHJhbnNhY3Rpb24gRG9lcyBOb3QgRXhpc3QpLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMlxuICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDgxIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgbWF0Y2hpbmcgc2VydmVyIHRyYW5zYWN0aW9uIGlzIGZvdW5kLCB0aGUgcmVxdWVzdCBpcyBwYXNzZWQgdG8gdGhhdFxuICAgIC8vIHRyYW5zYWN0aW9uIGZvciBwcm9jZXNzaW5nLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC4xMFxuICAgIGlmICh1YXMpIHtcbiAgICAgIHVhcy50cmFuc2FjdGlvbi5yZWNlaXZlUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBubyBtYXRjaCBpcyBmb3VuZCwgdGhlIHJlcXVlc3QgaXMgcGFzc2VkIHRvIHRoZSBjb3JlLCB3aGljaCBtYXkgZGVjaWRlIHRvXG4gICAgLy8gY29uc3RydWN0IGEgbmV3IHNlcnZlciB0cmFuc2FjdGlvbiBmb3IgdGhhdCByZXF1ZXN0LlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC4xMFxuICAgIHRoaXMucmVjZWl2ZVJlcXVlc3QobWVzc2FnZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFVBQyBhbmQgVUFTIHByb2NlZHVyZXMgZGVwZW5kIHN0cm9uZ2x5IG9uIHR3byBmYWN0b3JzLiAgRmlyc3QsIGJhc2VkXG4gICAqIG9uIHdoZXRoZXIgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2UgaXMgaW5zaWRlIG9yIG91dHNpZGUgb2YgYSBkaWFsb2csXG4gICAqIGFuZCBzZWNvbmQsIGJhc2VkIG9uIHRoZSBtZXRob2Qgb2YgYSByZXF1ZXN0LiAgRGlhbG9ncyBhcmUgZGlzY3Vzc2VkXG4gICAqIHRob3JvdWdobHkgaW4gU2VjdGlvbiAxMjsgdGhleSByZXByZXNlbnQgYSBwZWVyLXRvLXBlZXIgcmVsYXRpb25zaGlwXG4gICAqIGJldHdlZW4gdXNlciBhZ2VudHMgYW5kIGFyZSBlc3RhYmxpc2hlZCBieSBzcGVjaWZpYyBTSVAgbWV0aG9kcywgc3VjaFxuICAgKiBhcyBJTlZJVEUuXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSByZWNlaXZlUmVxdWVzdChtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlKTogdm9pZCB7XG5cbiAgICAvLyA4LjIgVUFTIEJlaGF2aW9yXG4gICAgLy8gVUFTcyBTSE9VTEQgcHJvY2VzcyB0aGUgcmVxdWVzdHMgaW4gdGhlIG9yZGVyIG9mIHRoZSBzdGVwcyB0aGF0XG4gICAgLy8gZm9sbG93IGluIHRoaXMgc2VjdGlvbiAodGhhdCBpcywgc3RhcnRpbmcgd2l0aCBhdXRoZW50aWNhdGlvbiwgdGhlblxuICAgIC8vIGluc3BlY3RpbmcgdGhlIG1ldGhvZCwgdGhlIGhlYWRlciBmaWVsZHMsIGFuZCBzbyBvbiB0aHJvdWdob3V0IHRoZVxuICAgIC8vIHJlbWFpbmRlciBvZiB0aGlzIHNlY3Rpb24pLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yXG5cbiAgICAvLyA4LjIuMSBNZXRob2QgSW5zcGVjdGlvblxuICAgIC8vIE9uY2UgYSByZXF1ZXN0IGlzIGF1dGhlbnRpY2F0ZWQgKG9yIGF1dGhlbnRpY2F0aW9uIGlzIHNraXBwZWQpLCB0aGVcbiAgICAvLyBVQVMgTVVTVCBpbnNwZWN0IHRoZSBtZXRob2Qgb2YgdGhlIHJlcXVlc3QuICBJZiB0aGUgVUFTIHJlY29nbml6ZXNcbiAgICAvLyBidXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbWV0aG9kIG9mIGEgcmVxdWVzdCwgaXQgTVVTVCBnZW5lcmF0ZSBhIDQwNVxuICAgIC8vIChNZXRob2QgTm90IEFsbG93ZWQpIHJlc3BvbnNlLiAgUHJvY2VkdXJlcyBmb3IgZ2VuZXJhdGluZyByZXNwb25zZXNcbiAgICAvLyBhcmUgZGVzY3JpYmVkIGluIFNlY3Rpb24gOC4yLjYuICBUaGUgVUFTIE1VU1QgYWxzbyBhZGQgYW4gQWxsb3dcbiAgICAvLyBoZWFkZXIgZmllbGQgdG8gdGhlIDQwNSAoTWV0aG9kIE5vdCBBbGxvd2VkKSByZXNwb25zZS4gIFRoZSBBbGxvd1xuICAgIC8vIGhlYWRlciBmaWVsZCBNVVNUIGxpc3QgdGhlIHNldCBvZiBtZXRob2RzIHN1cHBvcnRlZCBieSB0aGUgVUFTXG4gICAgLy8gZ2VuZXJhdGluZyB0aGUgbWVzc2FnZS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi4xXG4gICAgaWYgKEFsbG93ZWRNZXRob2RzLmluZGV4T2YobWVzc2FnZS5tZXRob2QpID09PSAtMSkge1xuICAgICAgY29uc3QgYWxsb3dIZWFkZXIgPSBcIkFsbG93OiBcIiArIEFsbG93ZWRNZXRob2RzLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHtcbiAgICAgICAgc3RhdHVzQ29kZTogNDA1LFxuICAgICAgICBleHRyYUhlYWRlcnM6IFthbGxvd0hlYWRlcl1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIDguMi4yIEhlYWRlciBJbnNwZWN0aW9uXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuMlxuICAgIGlmICghbWVzc2FnZS5ydXJpKSB7IC8vIEZJWE1FOiBBIHJlcXVlc3QgbWVzc2FnZSBzaG91bGQgYWx3YXlzIGhhdmUgYW4gcnVyaVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdC1VUkkgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG5cbiAgICAvLyA4LjIuMi4xIFRvIGFuZCBSZXF1ZXN0LVVSSVxuICAgIC8vIElmIHRoZSBSZXF1ZXN0LVVSSSB1c2VzIGEgc2NoZW1lIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIFVBUywgaXQgU0hPVUxEXG4gICAgLy8gcmVqZWN0IHRoZSByZXF1ZXN0IHdpdGggYSA0MTYgKFVuc3VwcG9ydGVkIFVSSSBTY2hlbWUpIHJlc3BvbnNlLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjIuMVxuICAgIGlmIChtZXNzYWdlLnJ1cmkuc2NoZW1lICE9PSBcInNpcFwiKSB7XG4gICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDE2IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIDguMi4yLjEgVG8gYW5kIFJlcXVlc3QtVVJJXG4gICAgLy8gSWYgdGhlIFJlcXVlc3QtVVJJIGRvZXMgbm90IGlkZW50aWZ5IGFuIGFkZHJlc3MgdGhhdCB0aGVcbiAgICAvLyBVQVMgaXMgd2lsbGluZyB0byBhY2NlcHQgcmVxdWVzdHMgZm9yLCBpdCBTSE9VTEQgcmVqZWN0XG4gICAgLy8gdGhlIHJlcXVlc3Qgd2l0aCBhIDQwNCAoTm90IEZvdW5kKSByZXNwb25zZS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi4yLjFcbiAgICBjb25zdCBydXJpID0gbWVzc2FnZS5ydXJpO1xuICAgIGNvbnN0IHJ1cmlNYXRjaGVzID0gKHVyaTogVVJJIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICByZXR1cm4gISF1cmkgJiYgdXJpLnVzZXIgPT09IHJ1cmkudXNlcjtcbiAgICB9O1xuICAgIGlmIChcbiAgICAgICFydXJpTWF0Y2hlcyh0aGlzLmNvbmZpZ3VyYXRpb24uYW9yKSAmJlxuICAgICAgIShcbiAgICAgICAgcnVyaU1hdGNoZXModGhpcy5jb25maWd1cmF0aW9uLmNvbnRhY3QudXJpKSB8fFxuICAgICAgICBydXJpTWF0Y2hlcyh0aGlzLmNvbmZpZ3VyYXRpb24uY29udGFjdC5wdWJHcnV1KSB8fFxuICAgICAgICBydXJpTWF0Y2hlcyh0aGlzLmNvbmZpZ3VyYXRpb24uY29udGFjdC50ZW1wR3J1dSlcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJSZXF1ZXN0LVVSSSBkb2VzIG5vdCBwb2ludCB0byB1cy5cIik7XG4gICAgICBpZiAobWVzc2FnZS5tZXRob2QgIT09IEMuQUNLKSB7XG4gICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDQgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gOC4yLjIuMSBUbyBhbmQgUmVxdWVzdC1VUklcbiAgICAvLyBPdGhlciBwb3RlbnRpYWwgc291cmNlcyBvZiByZWNlaXZlZCBSZXF1ZXN0LVVSSXMgaW5jbHVkZVxuICAgIC8vIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZHMgb2YgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcyBzZW50IGJ5IHRoZSBVQVxuICAgIC8vIHRoYXQgZXN0YWJsaXNoIG9yIHJlZnJlc2ggZGlhbG9ncy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi4yLjFcbiAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IEMuSU5WSVRFKSB7XG4gICAgICBpZiAoIW1lc3NhZ2UuaGFzSGVhZGVyKFwiQ29udGFjdFwiKSkge1xuICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHtcbiAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgcmVhc29uUGhyYXNlOiBcIk1pc3NpbmcgQ29udGFjdCBIZWFkZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDguMi4yLjIgTWVyZ2VkIFJlcXVlc3RzXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgaGFzIG5vIHRhZyBpbiB0aGUgVG8gaGVhZGVyIGZpZWxkLCB0aGUgVUFTIGNvcmUgTVVTVFxuICAgIC8vIGNoZWNrIHRoZSByZXF1ZXN0IGFnYWluc3Qgb25nb2luZyB0cmFuc2FjdGlvbnMuICBJZiB0aGUgRnJvbSB0YWcsXG4gICAgLy8gQ2FsbC1JRCwgYW5kIENTZXEgZXhhY3RseSBtYXRjaCB0aG9zZSBhc3NvY2lhdGVkIHdpdGggYW4gb25nb2luZ1xuICAgIC8vIHRyYW5zYWN0aW9uLCBidXQgdGhlIHJlcXVlc3QgZG9lcyBub3QgbWF0Y2ggdGhhdCB0cmFuc2FjdGlvbiAoYmFzZWRcbiAgICAvLyBvbiB0aGUgbWF0Y2hpbmcgcnVsZXMgaW4gU2VjdGlvbiAxNy4yLjMpLCB0aGUgVUFTIGNvcmUgU0hPVUxEXG4gICAgLy8gZ2VuZXJhdGUgYSA0ODIgKExvb3AgRGV0ZWN0ZWQpIHJlc3BvbnNlIGFuZCBwYXNzIGl0IHRvIHRoZSBzZXJ2ZXJcbiAgICAvLyB0cmFuc2FjdGlvbi5cbiAgICAvL1xuICAgIC8vICAgIFRoZSBzYW1lIHJlcXVlc3QgaGFzIGFycml2ZWQgYXQgdGhlIFVBUyBtb3JlIHRoYW4gb25jZSwgZm9sbG93aW5nXG4gICAgLy8gICAgZGlmZmVyZW50IHBhdGhzLCBtb3N0IGxpa2VseSBkdWUgdG8gZm9ya2luZy4gIFRoZSBVQVMgcHJvY2Vzc2VzXG4gICAgLy8gICAgdGhlIGZpcnN0IHN1Y2ggcmVxdWVzdCByZWNlaXZlZCBhbmQgcmVzcG9uZHMgd2l0aCBhIDQ4MiAoTG9vcFxuICAgIC8vICAgIERldGVjdGVkKSB0byB0aGUgcmVzdCBvZiB0aGVtLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjIuMlxuICAgIGlmICghbWVzc2FnZS50b1RhZykge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IG1lc3NhZ2UudmlhQnJhbmNoO1xuICAgICAgaWYgKCF0aGlzLnVzZXJBZ2VudFNlcnZlcnMuaGFzKHRyYW5zYWN0aW9uSWQpKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZFJlcXVlc3QgPVxuICAgICAgICAgIEFycmF5LmZyb20odGhpcy51c2VyQWdlbnRTZXJ2ZXJzLnZhbHVlcygpKVxuICAgICAgICAgICAgLnNvbWUoKHVhcykgPT5cbiAgICAgICAgICAgICAgdWFzLnRyYW5zYWN0aW9uLnJlcXVlc3QuZnJvbVRhZyA9PT0gbWVzc2FnZS5mcm9tVGFnICYmXG4gICAgICAgICAgICAgIHVhcy50cmFuc2FjdGlvbi5yZXF1ZXN0LmNhbGxJZCA9PT0gbWVzc2FnZS5jYWxsSWQgJiZcbiAgICAgICAgICAgICAgdWFzLnRyYW5zYWN0aW9uLnJlcXVlc3QuY3NlcSA9PT0gbWVzc2FnZS5jc2VxKTtcbiAgICAgICAgaWYgKG1lcmdlZFJlcXVlc3QpIHtcbiAgICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDgyIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDguMi4yLjMgUmVxdWlyZVxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjIuM1xuICAgIC8vIFRPRE9cblxuICAgIC8vIDguMi4zIENvbnRlbnQgUHJvY2Vzc2luZ1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjNcbiAgICAvLyBUT0RPXG5cbiAgICAvLyA4LjIuNCBBcHBseWluZyBFeHRlbnNpb25zXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNFxuICAgIC8vIFRPRE9cblxuICAgIC8vIDguMi41IFByb2Nlc3NpbmcgdGhlIFJlcXVlc3RcbiAgICAvLyBBc3N1bWluZyBhbGwgb2YgdGhlIGNoZWNrcyBpbiB0aGUgcHJldmlvdXMgc3Vic2VjdGlvbnMgYXJlIHBhc3NlZCxcbiAgICAvLyB0aGUgVUFTIHByb2Nlc3NpbmcgYmVjb21lcyBtZXRob2Qtc3BlY2lmaWMuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNVxuXG4gICAgLy8gVGhlIFVBUyB3aWxsIHJlY2VpdmUgdGhlIHJlcXVlc3QgZnJvbSB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIuICBJZiB0aGVcbiAgICAvLyByZXF1ZXN0IGhhcyBhIHRhZyBpbiB0aGUgVG8gaGVhZGVyIGZpZWxkLCB0aGUgVUFTIGNvcmUgY29tcHV0ZXMgdGhlXG4gICAgLy8gZGlhbG9nIGlkZW50aWZpZXIgY29ycmVzcG9uZGluZyB0byB0aGUgcmVxdWVzdCBhbmQgY29tcGFyZXMgaXQgd2l0aFxuICAgIC8vIGV4aXN0aW5nIGRpYWxvZ3MuICBJZiB0aGVyZSBpcyBhIG1hdGNoLCB0aGlzIGlzIGEgbWlkLWRpYWxvZyByZXF1ZXN0LlxuICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlIFVBUyBmaXJzdCBhcHBsaWVzIHRoZSBzYW1lIHByb2Nlc3NpbmcgcnVsZXMgZm9yXG4gICAgLy8gcmVxdWVzdHMgb3V0c2lkZSBvZiBhIGRpYWxvZywgZGlzY3Vzc2VkIGluIFNlY3Rpb24gOC4yLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgaWYgKG1lc3NhZ2UudG9UYWcpIHtcbiAgICAgIHRoaXMucmVjZWl2ZUluc2lkZURpYWxvZ1JlcXVlc3QobWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVjZWl2ZU91dHNpZGVEaWFsb2dSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogT25jZSBhIGRpYWxvZyBoYXMgYmVlbiBlc3RhYmxpc2hlZCBiZXR3ZWVuIHR3byBVQXMsIGVpdGhlciBvZiB0aGVtXG4gICAqIE1BWSBpbml0aWF0ZSBuZXcgdHJhbnNhY3Rpb25zIGFzIG5lZWRlZCB3aXRoaW4gdGhlIGRpYWxvZy4gIFRoZSBVQVxuICAgKiBzZW5kaW5nIHRoZSByZXF1ZXN0IHdpbGwgdGFrZSB0aGUgVUFDIHJvbGUgZm9yIHRoZSB0cmFuc2FjdGlvbi4gIFRoZVxuICAgKiBVQSByZWNlaXZpbmcgdGhlIHJlcXVlc3Qgd2lsbCB0YWtlIHRoZSBVQVMgcm9sZS4gIE5vdGUgdGhhdCB0aGVzZSBtYXlcbiAgICogYmUgZGlmZmVyZW50IHJvbGVzIHRoYW4gdGhlIFVBcyBoZWxkIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24gdGhhdFxuICAgKiBlc3RhYmxpc2hlZCB0aGUgZGlhbG9nLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjJcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UuXG4gICAqL1xuICBwcml2YXRlIHJlY2VpdmVJbnNpZGVEaWFsb2dSZXF1ZXN0KG1lc3NhZ2U6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UpOiB2b2lkIHtcblxuICAgIC8vIE5PVElGWSByZXF1ZXN0cyBhcmUgbWF0Y2hlZCB0byBzdWNoIFNVQlNDUklCRSByZXF1ZXN0cyBpZiB0aGV5XG4gICAgLy8gY29udGFpbiB0aGUgc2FtZSBcIkNhbGwtSURcIiwgYSBcIlRvXCIgaGVhZGVyIGZpZWxkIFwidGFnXCIgcGFyYW1ldGVyIHRoYXRcbiAgICAvLyBtYXRjaGVzIHRoZSBcIkZyb21cIiBoZWFkZXIgZmllbGQgXCJ0YWdcIiBwYXJhbWV0ZXIgb2YgdGhlIFNVQlNDUklCRVxuICAgIC8vIHJlcXVlc3QsIGFuZCB0aGUgc2FtZSBcIkV2ZW50XCIgaGVhZGVyIGZpZWxkLiAgUnVsZXMgZm9yIGNvbXBhcmlzb25zIG9mXG4gICAgLy8gdGhlIFwiRXZlbnRcIiBoZWFkZXIgZmllbGRzIGFyZSBkZXNjcmliZWQgaW4gU2VjdGlvbiA4LjIuMS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuNC4xXG4gICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBDLk5PVElGWSkge1xuICAgICAgY29uc3QgZXZlbnQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiRXZlbnRcIik7XG4gICAgICBpZiAoIWV2ZW50IHx8ICFldmVudC5ldmVudCkge1xuICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDg5IH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEZJWE1FOiBTdWJzY3JpYmVyIGlkIHNob3VsZCBhbHNvIG1hdGNoaW5nIG9uIGV2ZW50IGlkLlxuICAgICAgY29uc3Qgc3Vic2NyaWJlcklkID0gbWVzc2FnZS5jYWxsSWQgKyBtZXNzYWdlLnRvVGFnICsgZXZlbnQuZXZlbnQ7XG4gICAgICBjb25zdCBzdWJzY3JpYmVyID0gdGhpcy5zdWJzY3JpYmVycy5nZXQoc3Vic2NyaWJlcklkKTtcbiAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGNvbnN0IHVhcyA9IG5ldyBOb3RpZnlVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIHN1YnNjcmliZXIub25Ob3RpZnkodWFzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlcXVlc3RzIHNlbnQgd2l0aGluIGEgZGlhbG9nLCBhcyBhbnkgb3RoZXIgcmVxdWVzdHMsIGFyZSBhdG9taWMuICBJZlxuICAgIC8vIGEgcGFydGljdWxhciByZXF1ZXN0IGlzIGFjY2VwdGVkIGJ5IHRoZSBVQVMsIGFsbCB0aGUgc3RhdGUgY2hhbmdlc1xuICAgIC8vIGFzc29jaWF0ZWQgd2l0aCBpdCBhcmUgcGVyZm9ybWVkLiAgSWYgdGhlIHJlcXVlc3QgaXMgcmVqZWN0ZWQsIG5vbmVcbiAgICAvLyBvZiB0aGUgc3RhdGUgY2hhbmdlcyBhcmUgcGVyZm9ybWVkLlxuICAgIC8vXG4gICAgLy8gICAgTm90ZSB0aGF0IHNvbWUgcmVxdWVzdHMsIHN1Y2ggYXMgSU5WSVRFcywgYWZmZWN0IHNldmVyYWwgcGllY2VzIG9mXG4gICAgLy8gICAgc3RhdGUuXG4gICAgLy9cbiAgICAvLyBUaGUgVUFTIHdpbGwgcmVjZWl2ZSB0aGUgcmVxdWVzdCBmcm9tIHRoZSB0cmFuc2FjdGlvbiBsYXllci4gIElmIHRoZVxuICAgIC8vIHJlcXVlc3QgaGFzIGEgdGFnIGluIHRoZSBUbyBoZWFkZXIgZmllbGQsIHRoZSBVQVMgY29yZSBjb21wdXRlcyB0aGVcbiAgICAvLyBkaWFsb2cgaWRlbnRpZmllciBjb3JyZXNwb25kaW5nIHRvIHRoZSByZXF1ZXN0IGFuZCBjb21wYXJlcyBpdCB3aXRoXG4gICAgLy8gZXhpc3RpbmcgZGlhbG9ncy4gIElmIHRoZXJlIGlzIGEgbWF0Y2gsIHRoaXMgaXMgYSBtaWQtZGlhbG9nIHJlcXVlc3QuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICBjb25zdCBkaWFsb2dJZCA9IG1lc3NhZ2UuY2FsbElkICsgbWVzc2FnZS50b1RhZyArIG1lc3NhZ2UuZnJvbVRhZztcbiAgICBjb25zdCBkaWFsb2cgPSB0aGlzLmRpYWxvZ3MuZ2V0KGRpYWxvZ0lkKTtcbiAgICBpZiAoZGlhbG9nKSB7XG4gICAgICAvLyBbU2lwLWltcGxlbWVudG9yc10gUmVnLiBTSVAgcmVpbnZpdGUsIFVQREFURSBhbmQgT1BUSU9OU1xuICAgICAgLy8gWW91IGdvdCB0aGUgcXVlc3Rpb24gcmlnaHQuXG4gICAgICAvL1xuICAgICAgLy8gQW5kIHlvdSBnb3QgdGhlIHJpZ2h0IGFuc3dlciB0b28uIDotKVxuICAgICAgLy9cbiAgICAgIC8vICAgVGhhbmtzLFxuICAgICAgLy8gICBQYXVsXG4gICAgICAvL1xuICAgICAgLy8gUm9iZXJ0IFNwYXJrcyB3cm90ZTpcbiAgICAgIC8vID4gU28gSSd2ZSBsb3N0IHRyYWNrIG9mIHRoZSBxdWVzdGlvbiBkdXJpbmcgdGhlIG11c2luZy5cbiAgICAgIC8vID5cbiAgICAgIC8vID4gSSBfdGhpbmtfIHRoZSBmdW5kYW1lbnRhbCBxdWVzdGlvbiBiZWluZyBhc2tlZCBpcyB0aGlzOlxuICAgICAgLy8gPlxuICAgICAgLy8gPiBJcyBhbiBlbmRwb2ludCByZXF1aXJlZCB0byByZWplY3QgKHdpdGggYSA0ODEpIGFuIE9QVElPTlMgcmVxdWVzdCB0aGF0XG4gICAgICAvLyA+IGFycml2ZXMgd2l0aCBhdCB0by10YWcgYnV0IGRvZXMgbm90IG1hdGNoIGFueSBleGlzdGluZyBkaWFsb2cgc3RhdGUuXG4gICAgICAvLyA+IChBc3N1bWluZyBzb21lIGVhcmxpZXIgcmVxdWlyZW1lbnQgaGFzbid0IGZvcmNlZCBhbm90aGVyIGVycm9yIGNvZGUpLiBPclxuICAgICAgLy8gPiBpcyBpdCBPSyBpZiBpdCBqdXN0IHNlbmRzXG4gICAgICAvLyA+IGEgMjAwIE9LIGFueWhvdy5cbiAgICAgIC8vID5cbiAgICAgIC8vID4gTXkgdGFrZSBvbiB0aGUgY29sbGVjdGlvbiBvZiBzcGVjcyBpcyB0aGF0IGl0cyBfbm90XyBvayBmb3IgaXQgdG8gc2VuZFxuICAgICAgLy8gPiB0aGUgMjAwIE9LIGFueWhvdyBhbmQgdGhhdCBpdCBpcyByZXF1aXJlZCB0byBzZW5kXG4gICAgICAvLyA+IHRoZSA0ODEuIEkgYmFzZSB0aGlzIHByaW1hcmlseSBvbiB0aGVzZSBzZW50ZW5jZXMgZnJvbSAxMS4yIGluIDMyNjE6XG4gICAgICAvLyA+XG4gICAgICAvLyA+ICAgIFRoZSByZXNwb25zZSB0byBhbiBPUFRJT05TIGlzIGNvbnN0cnVjdGVkIHVzaW5nIHRoZSBzdGFuZGFyZCBydWxlc1xuICAgICAgLy8gPiAgICBmb3IgYSBTSVAgcmVzcG9uc2UgYXMgZGlzY3Vzc2VkIGluIFNlY3Rpb24gOC4yLjYuICBUaGUgcmVzcG9uc2UgY29kZVxuICAgICAgLy8gPiAgICBjaG9zZW4gTVVTVCBiZSB0aGUgc2FtZSB0aGF0IHdvdWxkIGhhdmUgYmVlbiBjaG9zZW4gaGFkIHRoZSByZXF1ZXN0XG4gICAgICAvLyA+ICAgIGJlZW4gYW4gSU5WSVRFLlxuICAgICAgLy8gPlxuICAgICAgLy8gPiBEaWQgSSBtaXNzIHRoZSBwb2ludCBvZiB0aGUgcXVlc3Rpb24/XG4gICAgICAvLyA+XG4gICAgICAvLyA+IE9uIE1heSAxNSwgMjAwOCwgYXQgMTI6NDggUE0sIFBhdWwgS3l6aXZhdCB3cm90ZTpcbiAgICAgIC8vID5cbiAgICAgIC8vID4+IFtJbmNsdWRpbmcgUm9iZXJ0IGluIGhvcGVzIG9mIGdldHRpbmcgaGlzIGluc2lnaHQgb24gdGhpcy5dXG4gICAgICAvLyBodHRwczovL2xpc3RzLmNzLmNvbHVtYmlhLmVkdS9waXBlcm1haWwvc2lwLWltcGxlbWVudG9ycy8yMDA4LU1heS8wMTkxNzguaHRtbFxuICAgICAgLy9cbiAgICAgIC8vIFJlcXVlc3RzIHRoYXQgZG8gbm90IGNoYW5nZSBpbiBhbnkgd2F5IHRoZSBzdGF0ZSBvZiBhIGRpYWxvZyBtYXkgYmVcbiAgICAgIC8vIHJlY2VpdmVkIHdpdGhpbiBhIGRpYWxvZyAoZm9yIGV4YW1wbGUsIGFuIE9QVElPTlMgcmVxdWVzdCkuICBUaGV5IGFyZVxuICAgICAgLy8gcHJvY2Vzc2VkIGFzIGlmIHRoZXkgaGFkIGJlZW4gcmVjZWl2ZWQgb3V0c2lkZSB0aGUgZGlhbG9nLlxuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gQy5PUFRJT05TKSB7XG4gICAgICAgIGNvbnN0IGFsbG93SGVhZGVyID0gXCJBbGxvdzogXCIgKyBBbGxvd2VkTWV0aG9kcy50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBhY2NlcHRIZWFkZXIgPSBcIkFjY2VwdDogXCIgKyBhY2NlcHRlZEJvZHlUeXBlcy50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHtcbiAgICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgICAgZXh0cmFIZWFkZXJzOiBbYWxsb3dIZWFkZXIsIGFjY2VwdEhlYWRlcl1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUGFzcyB0aGUgaW5jb21pbmcgcmVxdWVzdCB0byB0aGUgZGlhbG9nIGZvciBmdXJ0aGVyIGhhbmRsaW5nLlxuICAgICAgZGlhbG9nLnJlY2VpdmVSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBiZWhhdmlvcnMgb2YgYSBzdGF0ZWxlc3MgVUFTIGFyZSB0aGUgZm9sbG93aW5nOlxuICAgIC8vIC4uLlxuICAgIC8vIG8gIEEgc3RhdGVsZXNzIFVBUyBNVVNUIGlnbm9yZSBBQ0sgcmVxdWVzdHMuXG4gICAgLy8gLi4uXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuN1xuICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gQy5BQ0spIHtcbiAgICAgIC8vIElmIGEgZmluYWwgcmVzcG9uc2UgdG8gYW4gSU5WSVRFIHdhcyBzZW50IHN0YXRlbGVzc2x5LFxuICAgICAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgQUNLOlxuICAgICAgLy8gLSB3aWxsIG5vdCBtYXRjaCBhbiBleGlzdGluZyB0cmFuc2FjdGlvblxuICAgICAgLy8gLSBtYXkgaGF2ZSB0YWcgaW4gdGhlIFRvIGhlYWRlciBmaWVsZFxuICAgICAgLy8gLSBub3Qgbm90IG1hdGNoIGFueSBleGlzdGluZyBkaWFsb2dzXG4gICAgICAvLyBBYnNvcmIgdW5tYXRjaGVkIEFDS3MuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgaGFzIGEgdGFnIGluIHRoZSBUbyBoZWFkZXIgZmllbGQsIGJ1dCB0aGUgZGlhbG9nXG4gICAgLy8gaWRlbnRpZmllciBkb2VzIG5vdCBtYXRjaCBhbnkgZXhpc3RpbmcgZGlhbG9ncywgdGhlIFVBUyBtYXkgaGF2ZVxuICAgIC8vIGNyYXNoZWQgYW5kIHJlc3RhcnRlZCwgb3IgaXQgbWF5IGhhdmUgcmVjZWl2ZWQgYSByZXF1ZXN0IGZvciBhXG4gICAgLy8gZGlmZmVyZW50IChwb3NzaWJseSBmYWlsZWQpIFVBUyAodGhlIFVBU3MgY2FuIGNvbnN0cnVjdCB0aGUgVG8gdGFnc1xuICAgIC8vIHNvIHRoYXQgYSBVQVMgY2FuIGlkZW50aWZ5IHRoYXQgdGhlIHRhZyB3YXMgZm9yIGEgVUFTIGZvciB3aGljaCBpdCBpc1xuICAgIC8vIHByb3ZpZGluZyByZWNvdmVyeSkuICBBbm90aGVyIHBvc3NpYmlsaXR5IGlzIHRoYXQgdGhlIGluY29taW5nXG4gICAgLy8gcmVxdWVzdCBoYXMgYmVlbiBzaW1wbHkgbWlzLXJvdXRlZC4gIEJhc2VkIG9uIHRoZSBUbyB0YWcsIHRoZSBVQVMgTUFZXG4gICAgLy8gZWl0aGVyIGFjY2VwdCBvciByZWplY3QgdGhlIHJlcXVlc3QuICBBY2NlcHRpbmcgdGhlIHJlcXVlc3QgZm9yXG4gICAgLy8gYWNjZXB0YWJsZSBUbyB0YWdzIHByb3ZpZGVzIHJvYnVzdG5lc3MsIHNvIHRoYXQgZGlhbG9ncyBjYW4gcGVyc2lzdFxuICAgIC8vIGV2ZW4gdGhyb3VnaCBjcmFzaGVzLiAgVUFzIHdpc2hpbmcgdG8gc3VwcG9ydCB0aGlzIGNhcGFiaWxpdHkgbXVzdFxuICAgIC8vIHRha2UgaW50byBjb25zaWRlcmF0aW9uIHNvbWUgaXNzdWVzIHN1Y2ggYXMgY2hvb3NpbmcgbW9ub3RvbmljYWxseVxuICAgIC8vIGluY3JlYXNpbmcgQ1NlcSBzZXF1ZW5jZSBudW1iZXJzIGV2ZW4gYWNyb3NzIHJlYm9vdHMsIHJlY29uc3RydWN0aW5nXG4gICAgLy8gdGhlIHJvdXRlIHNldCwgYW5kIGFjY2VwdGluZyBvdXQtb2YtcmFuZ2UgUlRQIHRpbWVzdGFtcHMgYW5kIHNlcXVlbmNlXG4gICAgLy8gbnVtYmVycy5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBVQVMgd2lzaGVzIHRvIHJlamVjdCB0aGUgcmVxdWVzdCBiZWNhdXNlIGl0IGRvZXMgbm90IHdpc2ggdG9cbiAgICAvLyByZWNyZWF0ZSB0aGUgZGlhbG9nLCBpdCBNVVNUIHJlc3BvbmQgdG8gdGhlIHJlcXVlc3Qgd2l0aCBhIDQ4MVxuICAgIC8vIChDYWxsL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0KSBzdGF0dXMgY29kZSBhbmQgcGFzcyB0aGF0IHRvIHRoZVxuICAgIC8vIHNlcnZlciB0cmFuc2FjdGlvbi5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0ODEgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc3VtaW5nIGFsbCBvZiB0aGUgY2hlY2tzIGluIHRoZSBwcmV2aW91cyBzdWJzZWN0aW9ucyBhcmUgcGFzc2VkLFxuICAgKiB0aGUgVUFTIHByb2Nlc3NpbmcgYmVjb21lcyBtZXRob2Qtc3BlY2lmaWMuXG4gICAqICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi41XG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSByZWNlaXZlT3V0c2lkZURpYWxvZ1JlcXVlc3QobWVzc2FnZTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSk6IHZvaWQge1xuXG4gICAgc3dpdGNoIChtZXNzYWdlLm1ldGhvZCkge1xuICAgICAgY2FzZSBDLkFDSzpcbiAgICAgICAgLy8gQWJzb3JiIHN0cmF5IG91dCBvZiBkaWFsb2cgQUNLc1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5CWUU6XG4gICAgICAgIC8vIElmIHRoZSBCWUUgZG9lcyBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgZGlhbG9nLCB0aGUgVUFTIGNvcmUgU0hPVUxEXG4gICAgICAgIC8vIGdlbmVyYXRlIGEgNDgxIChDYWxsL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0KSByZXNwb25zZSBhbmQgcGFzc1xuICAgICAgICAvLyB0aGF0IHRvIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24uIFRoaXMgcnVsZSBtZWFucyB0aGF0IGEgQllFIHNlbnRcbiAgICAgICAgLy8gd2l0aG91dCB0YWdzIGJ5IGEgVUFDIHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTUuMS4yXG4gICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0ODEgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLkNBTkNFTDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG91dCBvZiBkaWFsb2cgcmVxdWVzdCBtZXRob2QgJHttZXNzYWdlLm1ldGhvZH0uYCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLklORk86XG4gICAgICAgIC8vIFVzZSBvZiB0aGUgSU5GTyBtZXRob2QgZG9lcyBub3QgY29uc3RpdHV0ZSBhIHNlcGFyYXRlIGRpYWxvZyB1c2FnZS5cbiAgICAgICAgLy8gSU5GTyBtZXNzYWdlcyBhcmUgYWx3YXlzIHBhcnQgb2YsIGFuZCBzaGFyZSB0aGUgZmF0ZSBvZiwgYW4gaW52aXRlXG4gICAgICAgIC8vIGRpYWxvZyB1c2FnZSBbUkZDNTA1N10uICBJTkZPIG1lc3NhZ2VzIGNhbm5vdCBiZSBzZW50IGFzIHBhcnQgb2ZcbiAgICAgICAgLy8gb3RoZXIgZGlhbG9nIHVzYWdlcywgb3Igb3V0c2lkZSBhbiBleGlzdGluZyBkaWFsb2cuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDg2I3NlY3Rpb24tMVxuICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDA1IH0pOyAvLyBTaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLklOVklURTpcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4zLjFcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHVhcyA9IG5ldyBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSA/XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uSW52aXRlKHVhcykgOlxuICAgICAgICAgICAgdWFzLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLk1FU1NBR0U6XG4gICAgICAgIC8vIE1FU1NBR0UgcmVxdWVzdHMgYXJlIGRpc2NvdXJhZ2VkIGluc2lkZSBhIGRpYWxvZy4gIEltcGxlbWVudGF0aW9uc1xuICAgICAgICAvLyBhcmUgcmVzdHJpY3RlZCBmcm9tIGNyZWF0aW5nIGEgdXNhZ2UgZm9yIHRoZSBwdXJwb3NlIG9mIGNhcnJ5aW5nIGFcbiAgICAgICAgLy8gc2VxdWVuY2Ugb2YgTUVTU0FHRSByZXF1ZXN0cyAodGhvdWdoIHNvbWUgaW1wbGVtZW50YXRpb25zIHVzZSBpdCB0aGF0XG4gICAgICAgIC8vIHdheSwgYWdhaW5zdCB0aGUgc3RhbmRhcmQgcmVjb21tZW5kYXRpb24pLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTA1NyNzZWN0aW9uLTUuM1xuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgdWFzID0gbmV3IE1lc3NhZ2VVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbk1lc3NhZ2UgP1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbk1lc3NhZ2UodWFzKSA6XG4gICAgICAgICAgICB1YXMuYWNjZXB0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuTk9USUZZOlxuICAgICAgICAvLyBPYnNvbGV0ZWQgYnk6IFJGQyA2NjY1XG4gICAgICAgIC8vIElmIGFueSBub24tU1VCU0NSSUJFIG1lY2hhbmlzbXMgYXJlIGRlZmluZWQgdG8gY3JlYXRlIHN1YnNjcmlwdGlvbnMsXG4gICAgICAgIC8vIGl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgcGFydGllcyBkZWZpbmluZyB0aG9zZSBtZWNoYW5pc21zIHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IGNvcnJlbGF0aW9uIG9mIGEgTk9USUZZIG1lc3NhZ2UgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9uIGlzIHBvc3NpYmxlLiAgRGVzaWduZXJzIG9mIHN1Y2ggbWVjaGFuaXNtcyBhcmUgYWxzb1xuICAgICAgICAvLyB3YXJuZWQgdG8gbWFrZSBhIGRpc3RpbmN0aW9uIGJldHdlZW4gc2VuZGluZyBhIE5PVElGWSBtZXNzYWdlIHRvIGFcbiAgICAgICAgLy8gc3Vic2NyaWJlciB3aG8gaXMgYXdhcmUgb2YgdGhlIHN1YnNjcmlwdGlvbiwgYW5kIHNlbmRpbmcgYSBOT1RJRllcbiAgICAgICAgLy8gbWVzc2FnZSB0byBhbiB1bnN1c3BlY3Rpbmcgbm9kZS4gIFRoZSBsYXR0ZXIgYmVoYXZpb3IgaXMgaW52YWxpZCwgYW5kXG4gICAgICAgIC8vIE1VU1QgcmVjZWl2ZSBhIFwiNDgxIFN1YnNjcmlwdGlvbiBkb2VzIG5vdCBleGlzdFwiIHJlc3BvbnNlICh1bmxlc3NcbiAgICAgICAgLy8gc29tZSBvdGhlciA0MDAtIG9yIDUwMC1jbGFzcyBlcnJvciBjb2RlIGlzIG1vcmUgYXBwbGljYWJsZSksIGFzXG4gICAgICAgIC8vIGRlc2NyaWJlZCBpbiBzZWN0aW9uIDMuMi40LiAgSW4gb3RoZXIgd29yZHMsIGtub3dsZWRnZSBvZiBhXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbiBtdXN0IGV4aXN0IGluIGJvdGggdGhlIHN1YnNjcmliZXIgYW5kIHRoZSBub3RpZmllciB0byBiZVxuICAgICAgICAvLyB2YWxpZCwgZXZlbiBpZiBpbnN0YWxsZWQgdmlhIGEgbm9uLVNVQlNDUklCRSBtZWNoYW5pc20uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjY1I3NlY3Rpb24tMy4yXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5PVElGWSByZXF1ZXN0cyBhcmUgc2VudCB0byBpbmZvcm0gc3Vic2NyaWJlcnMgb2YgY2hhbmdlcyBpbiBzdGF0ZSB0b1xuICAgICAgICAvLyB3aGljaCB0aGUgc3Vic2NyaWJlciBoYXMgYSBzdWJzY3JpcHRpb24uICBTdWJzY3JpcHRpb25zIGFyZSBjcmVhdGVkXG4gICAgICAgIC8vIHVzaW5nIHRoZSBTVUJTQ1JJQkUgbWV0aG9kLiAgSW4gbGVnYWN5IGltcGxlbWVudGF0aW9ucywgaXQgaXNcbiAgICAgICAgLy8gcG9zc2libGUgdGhhdCBvdGhlciBtZWFucyBvZiBzdWJzY3JpcHRpb24gY3JlYXRpb24gaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBhbGxvdyB0aGUgY3JlYXRpb24gb2ZcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9ucyBleGNlcHQgdGhyb3VnaCBTVUJTQ1JJQkUgcmVxdWVzdHMgYW5kIChmb3IgYmFja3dhcmRzLVxuICAgICAgICAvLyBjb21wYXRpYmlsaXR5KSBSRUZFUiByZXF1ZXN0cyBbUkZDMzUxNV0uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tMy4yXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB1YXMgPSBuZXcgTm90aWZ5VXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkgP1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSh1YXMpIDpcbiAgICAgICAgICAgIHVhcy5yZWplY3QoeyBzdGF0dXNDb2RlOiA0MDUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuT1BUSU9OUzpcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMS4yXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBhbGxvd0hlYWRlciA9IFwiQWxsb3c6IFwiICsgQWxsb3dlZE1ldGhvZHMudG9TdHJpbmcoKTtcbiAgICAgICAgICBjb25zdCBhY2NlcHRIZWFkZXIgPSBcIkFjY2VwdDogXCIgKyBhY2NlcHRlZEJvZHlUeXBlcy50b1N0cmluZygpO1xuICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwge1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBbIGFsbG93SGVhZGVyLCBhY2NlcHRIZWFkZXIgXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlJFRkVSOlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzUxNSNzZWN0aW9uLTIuNC4yXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB1YXMgPSBuZXcgUmVmZXJVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZmVyID9cbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWZlcih1YXMpIDpcbiAgICAgICAgICAgIHVhcy5yZWplY3QoeyBzdGF0dXNDb2RlOiA0MDUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuUkVHSVNURVI6XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTAuM1xuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgdWFzID0gbmV3IFJlZ2lzdGVyVXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWdpc3RlciA/XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVnaXN0ZXIodWFzKSA6XG4gICAgICAgICAgICB1YXMucmVqZWN0KHsgc3RhdHVzQ29kZTogNDA1IH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDLlNVQlNDUklCRTpcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjJcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHVhcyA9IG5ldyBTdWJzY3JpYmVVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblN1YnNjcmliZSA/XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uU3Vic2NyaWJlKHVhcykgOlxuICAgICAgICAgICAgdWFzLnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4MCB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBvdXQgb2YgZGlhbG9nIHJlcXVlc3QgbWV0aG9kICR7bWVzc2FnZS5tZXRob2R9LmApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUmVzcG9uc2VzIGFyZSBmaXJzdCBwcm9jZXNzZWQgYnkgdGhlIHRyYW5zcG9ydCBsYXllciBhbmQgdGhlbiBwYXNzZWRcbiAgICogdXAgdG8gdGhlIHRyYW5zYWN0aW9uIGxheWVyLiAgVGhlIHRyYW5zYWN0aW9uIGxheWVyIHBlcmZvcm1zIGl0c1xuICAgKiBwcm9jZXNzaW5nIGFuZCB0aGVuIHBhc3NlcyB0aGUgcmVzcG9uc2UgdXAgdG8gdGhlIFRVLiAgVGhlIG1ham9yaXR5XG4gICAqIG9mIHJlc3BvbnNlIHByb2Nlc3NpbmcgaW4gdGhlIFRVIGlzIG1ldGhvZCBzcGVjaWZpYy4gIEhvd2V2ZXIsIHRoZXJlXG4gICAqIGFyZSBzb21lIGdlbmVyYWwgYmVoYXZpb3JzIGluZGVwZW5kZW50IG9mIHRoZSBtZXRob2QuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjNcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXNwb25zZSBtZXNzYWdlIGZyb20gdHJhbnNwb3J0IGxheWVyLlxuICAgKi9cbiAgcHJpdmF0ZSByZWNlaXZlUmVzcG9uc2VGcm9tVHJhbnNwb3J0KG1lc3NhZ2U6IEluY29taW5nUmVzcG9uc2VNZXNzYWdlKTogdm9pZCB7XG5cbiAgICAvLyA4LjEuMy4xIFRyYW5zYWN0aW9uIExheWVyIEVycm9yc1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjMuMVxuICAgIC8vIEhhbmRsZWQgYnkgdHJhbnNhY3Rpb24gbGF5ZXIgY2FsbGJhY2tzLlxuXG4gICAgLy8gOC4xLjMuMiBVbnJlY29nbml6ZWQgUmVzcG9uc2VzXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy4xXG4gICAgLy8gVE9ET1xuXG4gICAgLy8gOC4xLjMuMyBWaWFzXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy4zXG4gICAgaWYgKG1lc3NhZ2UuZ2V0SGVhZGVycyhcInZpYVwiKS5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTW9yZSB0aGFuIG9uZSBWaWEgaGVhZGVyIGZpZWxkIHByZXNlbnQgaW4gdGhlIHJlc3BvbnNlLCBkcm9wcGluZ1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyA4LjEuMy40IFByb2Nlc3NpbmcgM3h4IFJlc3BvbnNlc1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjMuNFxuICAgIC8vIFRPRE9cblxuICAgIC8vIDguMS4zLjUgUHJvY2Vzc2luZyA0eHggUmVzcG9uc2VzXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy41XG4gICAgLy8gVE9ET1xuXG4gICAgLy8gV2hlbiB0aGUgdHJhbnNwb3J0IGxheWVyIGluIHRoZSBjbGllbnQgcmVjZWl2ZXMgYSByZXNwb25zZSwgaXQgaGFzIHRvXG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIGNsaWVudCB0cmFuc2FjdGlvbiB3aWxsIGhhbmRsZSB0aGUgcmVzcG9uc2UsIHNvIHRoYXRcbiAgICAvLyB0aGUgcHJvY2Vzc2luZyBvZiBTZWN0aW9ucyAxNy4xLjEgYW5kIDE3LjEuMiBjYW4gdGFrZSBwbGFjZS4gIFRoZVxuICAgIC8vIGJyYW5jaCBwYXJhbWV0ZXIgaW4gdGhlIHRvcCBWaWEgaGVhZGVyIGZpZWxkIGlzIHVzZWQgZm9yIHRoaXNcbiAgICAvLyBwdXJwb3NlLiAgQSByZXNwb25zZSBtYXRjaGVzIGEgY2xpZW50IHRyYW5zYWN0aW9uIHVuZGVyIHR3b1xuICAgIC8vIGNvbmRpdGlvbnM6XG4gICAgLy9cbiAgICAvLyAgICAxLiAgSWYgdGhlIHJlc3BvbnNlIGhhcyB0aGUgc2FtZSB2YWx1ZSBvZiB0aGUgYnJhbmNoIHBhcmFtZXRlciBpblxuICAgIC8vICAgICAgICB0aGUgdG9wIFZpYSBoZWFkZXIgZmllbGQgYXMgdGhlIGJyYW5jaCBwYXJhbWV0ZXIgaW4gdGhlIHRvcFxuICAgIC8vICAgICAgICBWaWEgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXF1ZXN0IHRoYXQgY3JlYXRlZCB0aGUgdHJhbnNhY3Rpb24uXG4gICAgLy9cbiAgICAvLyAgICAyLiAgSWYgdGhlIG1ldGhvZCBwYXJhbWV0ZXIgaW4gdGhlIENTZXEgaGVhZGVyIGZpZWxkIG1hdGNoZXMgdGhlXG4gICAgLy8gICAgICAgIG1ldGhvZCBvZiB0aGUgcmVxdWVzdCB0aGF0IGNyZWF0ZWQgdGhlIHRyYW5zYWN0aW9uLiAgVGhlXG4gICAgLy8gICAgICAgIG1ldGhvZCBpcyBuZWVkZWQgc2luY2UgYSBDQU5DRUwgcmVxdWVzdCBjb25zdGl0dXRlcyBhXG4gICAgLy8gICAgICAgIGRpZmZlcmVudCB0cmFuc2FjdGlvbiwgYnV0IHNoYXJlcyB0aGUgc2FtZSB2YWx1ZSBvZiB0aGUgYnJhbmNoXG4gICAgLy8gICAgICAgIHBhcmFtZXRlci5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuM1xuICAgIGNvbnN0IHVzZXJBZ2VudENsaWVudElkID0gbWVzc2FnZS52aWFCcmFuY2ggKyBtZXNzYWdlLm1ldGhvZDtcbiAgICBjb25zdCB1c2VyQWdlbnRDbGllbnQgPSB0aGlzLnVzZXJBZ2VudENsaWVudHMuZ2V0KHVzZXJBZ2VudENsaWVudElkKTtcblxuICAgIC8vIFRoZSBjbGllbnQgdHJhbnNwb3J0IHVzZXMgdGhlIG1hdGNoaW5nIHByb2NlZHVyZXMgb2YgU2VjdGlvblxuICAgIC8vIDE3LjEuMyB0byBhdHRlbXB0IHRvIG1hdGNoIHRoZSByZXNwb25zZSB0byBhbiBleGlzdGluZ1xuICAgIC8vIHRyYW5zYWN0aW9uLiAgSWYgdGhlcmUgaXMgYSBtYXRjaCwgdGhlIHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHRvXG4gICAgLy8gdGhhdCB0cmFuc2FjdGlvbi4gIE90aGVyd2lzZSwgYW55IGVsZW1lbnQgb3RoZXIgdGhhbiBhIHN0YXRlbGVzc1xuICAgIC8vIHByb3h5IE1VU1Qgc2lsZW50bHkgZGlzY2FyZCB0aGUgcmVzcG9uc2UuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjlcbiAgICBpZiAodXNlckFnZW50Q2xpZW50KSB7XG4gICAgICB1c2VyQWdlbnRDbGllbnQudHJhbnNhY3Rpb24ucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICBgRGlzY2FyZGluZyB1bm1hdGNoZWQgJHttZXNzYWdlLnN0YXR1c0NvZGV9IHJlc3BvbnNlIHRvICR7bWVzc2FnZS5tZXRob2R9ICR7dXNlckFnZW50Q2xpZW50SWR9LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBTZXNzaW9uRGlhbG9nIH0gZnJvbSBcIi4uL2RpYWxvZ3NcIjtcbmltcG9ydCB7IEMsIE91dGdvaW5nQnllUmVxdWVzdCwgT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGUsIFJlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENsaWVudCB9IGZyb20gXCIuL3VzZXItYWdlbnQtY2xpZW50XCI7XG5cbi8qKlxuICogQllFIFVBQy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEJ5ZVVzZXJBZ2VudENsaWVudCBleHRlbmRzIFVzZXJBZ2VudENsaWVudCBpbXBsZW1lbnRzIE91dGdvaW5nQnllUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGRpYWxvZzogU2Vzc2lvbkRpYWxvZyxcbiAgICBkZWxlZ2F0ZT86IE91dGdvaW5nUmVxdWVzdERlbGVnYXRlLFxuICAgIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9uc1xuICApIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZGlhbG9nLmNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoQy5CWUUsIG9wdGlvbnMpO1xuICAgIHN1cGVyKE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICAgIGRpYWxvZy5kaXNwb3NlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IFNlc3Npb25EaWFsb2cgfSBmcm9tIFwiLi4vZGlhbG9nc1wiO1xuaW1wb3J0IHsgSW5jb21pbmdCeWVSZXF1ZXN0LCBJbmNvbWluZ1JlcXVlc3REZWxlZ2F0ZSwgSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRTZXJ2ZXIgfSBmcm9tIFwiLi91c2VyLWFnZW50LXNlcnZlclwiO1xuXG4vKipcbiAqIEJZRSBVQVMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBCeWVVc2VyQWdlbnRTZXJ2ZXIgZXh0ZW5kcyBVc2VyQWdlbnRTZXJ2ZXIgaW1wbGVtZW50cyBJbmNvbWluZ0J5ZVJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihcbiAgICBkaWFsb2c6IFNlc3Npb25EaWFsb2csXG4gICAgbWVzc2FnZTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICBkZWxlZ2F0ZT86IEluY29taW5nUmVxdWVzdERlbGVnYXRlXG4gICkge1xuICAgIHN1cGVyKE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBPdXRnb2luZ0NhbmNlbFJlcXVlc3QsIE91dGdvaW5nUmVxdWVzdERlbGVnYXRlLCBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENvcmUgfSBmcm9tIFwiLi4vdXNlci1hZ2VudC1jb3JlXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRDbGllbnQgfSBmcm9tIFwiLi91c2VyLWFnZW50LWNsaWVudFwiO1xuXG4vKipcbiAqIENBTkNFTCBVQUMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBDYW5jZWxVc2VyQWdlbnRDbGllbnQgZXh0ZW5kcyBVc2VyQWdlbnRDbGllbnQgaW1wbGVtZW50cyBPdXRnb2luZ0NhbmNlbFJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihcbiAgICBjb3JlOiBVc2VyQWdlbnRDb3JlLFxuICAgIG1lc3NhZ2U6IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UsXG4gICAgZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZVxuICApIHtcbiAgICBzdXBlcihOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICB9XG59XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9ieWUtdXNlci1hZ2VudC1jbGllbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2J5ZS11c2VyLWFnZW50LXNlcnZlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vY2FuY2VsLXVzZXItYWdlbnQtY2xpZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbmZvLXVzZXItYWdlbnQtY2xpZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbmZvLXVzZXItYWdlbnQtc2VydmVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbnZpdGUtdXNlci1hZ2VudC1jbGllbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2ludml0ZS11c2VyLWFnZW50LXNlcnZlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWVzc2FnZS11c2VyLWFnZW50LWNsaWVudFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWVzc2FnZS11c2VyLWFnZW50LXNlcnZlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbm90aWZ5LXVzZXItYWdlbnQtY2xpZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ub3RpZnktdXNlci1hZ2VudC1zZXJ2ZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3B1Ymxpc2gtdXNlci1hZ2VudC1jbGllbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3ByYWNrLXVzZXItYWdlbnQtY2xpZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wcmFjay11c2VyLWFnZW50LXNlcnZlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmUtaW52aXRlLXVzZXItYWdlbnQtY2xpZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZS1pbnZpdGUtdXNlci1hZ2VudC1zZXJ2ZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3JlLXN1YnNjcmliZS11c2VyLWFnZW50LWNsaWVudFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmUtc3Vic2NyaWJlLXVzZXItYWdlbnQtc2VydmVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZWZlci11c2VyLWFnZW50LWNsaWVudFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmVmZXItdXNlci1hZ2VudC1zZXJ2ZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3JlZ2lzdGVyLXVzZXItYWdlbnQtY2xpZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZWdpc3Rlci11c2VyLWFnZW50LXNlcnZlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3Vic2NyaWJlLXVzZXItYWdlbnQtY2xpZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zdWJzY3JpYmUtdXNlci1hZ2VudC1zZXJ2ZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3VzZXItYWdlbnQtY2xpZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi91c2VyLWFnZW50LXNlcnZlclwiO1xuIiwiaW1wb3J0IHsgU2Vzc2lvbkRpYWxvZyB9IGZyb20gXCIuLi9kaWFsb2dzXCI7XG5pbXBvcnQgeyBDLCBPdXRnb2luZ0luZm9SZXF1ZXN0LCBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50Q2xpZW50IH0gZnJvbSBcIi4vdXNlci1hZ2VudC1jbGllbnRcIjtcblxuLyoqXG4gKiBJTkZPIFVBQy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEluZm9Vc2VyQWdlbnRDbGllbnQgZXh0ZW5kcyBVc2VyQWdlbnRDbGllbnQgaW1wbGVtZW50cyBPdXRnb2luZ0luZm9SZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgZGlhbG9nOiBTZXNzaW9uRGlhbG9nLFxuICAgIGRlbGVnYXRlPzogT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGUsXG4gICAgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zXG4gICkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkaWFsb2cuY3JlYXRlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShDLklORk8sIG9wdGlvbnMpO1xuICAgIHN1cGVyKE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBTZXNzaW9uRGlhbG9nIH0gZnJvbSBcIi4uL2RpYWxvZ3NcIjtcbmltcG9ydCB7IEluY29taW5nSW5mb1JlcXVlc3QsIEluY29taW5nUmVxdWVzdERlbGVnYXRlLCBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50U2VydmVyIH0gZnJvbSBcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIjtcblxuLyoqXG4gKiBJTkZPIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEluZm9Vc2VyQWdlbnRTZXJ2ZXIgZXh0ZW5kcyBVc2VyQWdlbnRTZXJ2ZXIgaW1wbGVtZW50cyBJbmNvbWluZ0luZm9SZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgZGlhbG9nOiBTZXNzaW9uRGlhbG9nLFxuICAgIG1lc3NhZ2U6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UsXG4gICAgZGVsZWdhdGU/OiBJbmNvbWluZ1JlcXVlc3REZWxlZ2F0ZVxuICApIHtcbiAgICBzdXBlcihOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlhbG9nLCBTZXNzaW9uRGlhbG9nIH0gZnJvbSBcIi4uL2RpYWxvZ3NcIjtcbmltcG9ydCB7IFRyYW5zcG9ydEVycm9yIH0gZnJvbSBcIi4uL2V4Y2VwdGlvbnNcIjtcbmltcG9ydCB7XG4gIEluY29taW5nUmVzcG9uc2VNZXNzYWdlLFxuICBPdXRnb2luZ0Fja1JlcXVlc3QsXG4gIE91dGdvaW5nSW52aXRlUmVxdWVzdCxcbiAgT3V0Z29pbmdJbnZpdGVSZXF1ZXN0RGVsZWdhdGUsXG4gIE91dGdvaW5nUHJhY2tSZXF1ZXN0LFxuICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICBSZXF1ZXN0T3B0aW9uc1xufSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IFNpZ25hbGluZ1N0YXRlIH0gZnJvbSBcIi4uL3Nlc3Npb25cIjtcbmltcG9ydCB7IEludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvblN0YXRlIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50Q29yZSB9IGZyb20gXCIuLi91c2VyLWFnZW50LWNvcmVcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENsaWVudCB9IGZyb20gXCIuL3VzZXItYWdlbnQtY2xpZW50XCI7XG5cbi8qKlxuICogSU5WSVRFIFVBQy5cbiAqIEByZW1hcmtzXG4gKiAxMyBJbml0aWF0aW5nIGEgU2Vzc2lvblxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xM1xuICogMTMuMSBPdmVydmlld1xuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4xXG4gKiAxMy4yIFVBQyBQcm9jZXNzaW5nXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjJcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEludml0ZVVzZXJBZ2VudENsaWVudCBleHRlbmRzIFVzZXJBZ2VudENsaWVudCBpbXBsZW1lbnRzIE91dGdvaW5nSW52aXRlUmVxdWVzdCB7XG4gIHB1YmxpYyBkZWxlZ2F0ZTogT3V0Z29pbmdJbnZpdGVSZXF1ZXN0RGVsZWdhdGUgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBjb25maXJtZWREaWFsb2dBY2tzID0gbmV3IE1hcDxzdHJpbmcsIE91dGdvaW5nQWNrUmVxdWVzdD4oKTtcbiAgcHJpdmF0ZSBjb25maXJtZWREaWFsb2dzID0gbmV3IE1hcDxzdHJpbmcsIFNlc3Npb25EaWFsb2c+KCk7XG4gIHByaXZhdGUgZWFybHlEaWFsb2dzID0gbmV3IE1hcDxzdHJpbmcsIFNlc3Npb25EaWFsb2c+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY29yZTogVXNlckFnZW50Q29yZSxcbiAgICBtZXNzYWdlOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGRlbGVnYXRlPzogT3V0Z29pbmdJbnZpdGVSZXF1ZXN0RGVsZWdhdGVcbiAgKSB7XG4gICAgc3VwZXIoSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyBUaGUgVUFDIGNvcmUgY29uc2lkZXJzIHRoZSBJTlZJVEUgdHJhbnNhY3Rpb24gY29tcGxldGVkIDY0KlQxIHNlY29uZHNcbiAgICAvLyBhZnRlciB0aGUgcmVjZXB0aW9uIG9mIHRoZSBmaXJzdCAyeHggcmVzcG9uc2UuICBBdCB0aGlzIHBvaW50IGFsbCB0aGVcbiAgICAvLyBlYXJseSBkaWFsb2dzIHRoYXQgaGF2ZSBub3QgdHJhbnNpdGlvbmVkIHRvIGVzdGFibGlzaGVkIGRpYWxvZ3MgYXJlXG4gICAgLy8gdGVybWluYXRlZC4gIE9uY2UgdGhlIElOVklURSB0cmFuc2FjdGlvbiBpcyBjb25zaWRlcmVkIGNvbXBsZXRlZCBieVxuICAgIC8vIHRoZSBVQUMgY29yZSwgbm8gbW9yZSBuZXcgMnh4IHJlc3BvbnNlcyBhcmUgZXhwZWN0ZWQgdG8gYXJyaXZlLlxuICAgIC8vXG4gICAgLy8gSWYsIGFmdGVyIGFja25vd2xlZGdpbmcgYW55IDJ4eCByZXNwb25zZSB0byBhbiBJTlZJVEUsIHRoZSBVQUMgZG9lc1xuICAgIC8vIG5vdCB3YW50IHRvIGNvbnRpbnVlIHdpdGggdGhhdCBkaWFsb2csIHRoZW4gdGhlIFVBQyBNVVNUIHRlcm1pbmF0ZVxuICAgIC8vIHRoZSBkaWFsb2cgYnkgc2VuZGluZyBhIEJZRSByZXF1ZXN0IGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDE1LlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjRcbiAgICB0aGlzLmVhcmx5RGlhbG9ncy5mb3JFYWNoKChlYXJseURpYWxvZykgPT4gZWFybHlEaWFsb2cuZGlzcG9zZSgpKTtcbiAgICB0aGlzLmVhcmx5RGlhbG9ncy5jbGVhcigpO1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWFsIGNhc2UgZm9yIHRyYW5zcG9ydCBlcnJvciB3aGlsZSBzZW5kaW5nIEFDSy5cbiAgICogQHBhcmFtIGVycm9yIC0gVHJhbnNwb3J0IGVycm9yXG4gICAqL1xuICBwcm90ZWN0ZWQgb25UcmFuc3BvcnRFcnJvcihlcnJvcjogVHJhbnNwb3J0RXJyb3IpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gVHJhbnNhY3Rpb25TdGF0ZS5DYWxsaW5nKSB7XG4gICAgICByZXR1cm4gc3VwZXIub25UcmFuc3BvcnRFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIC8vIElmIG5vdCBpbiAnY2FsbGluZycgc3RhdGUsIHRoZSB0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgc2VuZGluZyBhbiBBQ0suXG4gICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJVc2VyIGFnZW50IGNsaWVudCByZXF1ZXN0IHRyYW5zcG9ydCBlcnJvciB3aGlsZSBzZW5kaW5nIEFDSy5cIik7XG4gIH1cblxuICAvKipcbiAgICogT25jZSB0aGUgSU5WSVRFIGhhcyBiZWVuIHBhc3NlZCB0byB0aGUgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiwgdGhlXG4gICAqIFVBQyB3YWl0cyBmb3IgcmVzcG9uc2VzIGZvciB0aGUgSU5WSVRFLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMlxuICAgKiBAcGFyYW0gaW5jb21pbmdSZXNwb25zZSAtIEluY29taW5nIHJlc3BvbnNlIHRvIElOVklURSByZXF1ZXN0LlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlY2VpdmVSZXNwb25zZShtZXNzYWdlOiBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5hdXRoZW50aWNhdGlvbkd1YXJkKG1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IG1lc3NhZ2Uuc3RhdHVzQ29kZSA/IG1lc3NhZ2Uuc3RhdHVzQ29kZS50b1N0cmluZygpIDogXCJcIjtcbiAgICBpZiAoIXN0YXR1c0NvZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHN0YXR1cyBjb2RlIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIC9eMTAwJC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblRyeWluZykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25UcnlpbmcoeyBtZXNzYWdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAvLyBaZXJvLCBvbmUgb3IgbXVsdGlwbGUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIG1heSBhcnJpdmUgYmVmb3JlIG9uZSBvclxuICAgICAgICAvLyBtb3JlIGZpbmFsIHJlc3BvbnNlcyBhcmUgcmVjZWl2ZWQuICBQcm92aXNpb25hbCByZXNwb25zZXMgZm9yIGFuXG4gICAgICAgIC8vIElOVklURSByZXF1ZXN0IGNhbiBjcmVhdGUgXCJlYXJseSBkaWFsb2dzXCIuICBJZiBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlXG4gICAgICAgIC8vIGhhcyBhIHRhZyBpbiB0aGUgVG8gZmllbGQsIGFuZCBpZiB0aGUgZGlhbG9nIElEIG9mIHRoZSByZXNwb25zZSBkb2VzXG4gICAgICAgIC8vIG5vdCBtYXRjaCBhbiBleGlzdGluZyBkaWFsb2csIG9uZSBpcyBjb25zdHJ1Y3RlZCB1c2luZyB0aGUgcHJvY2VkdXJlc1xuICAgICAgICAvLyBkZWZpbmVkIGluIFNlY3Rpb24gMTIuMS4yLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZWFybHkgZGlhbG9nIHdpbGwgb25seSBiZSBuZWVkZWQgaWYgdGhlIFVBQyBuZWVkcyB0byBzZW5kIGFcbiAgICAgICAgLy8gcmVxdWVzdCB0byBpdHMgcGVlciB3aXRoaW4gdGhlIGRpYWxvZyBiZWZvcmUgdGhlIGluaXRpYWwgSU5WSVRFXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIGNvbXBsZXRlcy4gIEhlYWRlciBmaWVsZHMgcHJlc2VudCBpbiBhIHByb3Zpc2lvbmFsXG4gICAgICAgIC8vIHJlc3BvbnNlIGFyZSBhcHBsaWNhYmxlIGFzIGxvbmcgYXMgdGhlIGRpYWxvZyBpcyBpbiB0aGUgZWFybHkgc3RhdGVcbiAgICAgICAgLy8gKGZvciBleGFtcGxlLCBhbiBBbGxvdyBoZWFkZXIgZmllbGQgaW4gYSBwcm92aXNpb25hbCByZXNwb25zZVxuICAgICAgICAvLyBjb250YWlucyB0aGUgbWV0aG9kcyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBkaWFsb2cgd2hpbGUgdGhpcyBpcyBpblxuICAgICAgICAvLyB0aGUgZWFybHkgc3RhdGUpLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi4xXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBQcm92aXNpb25hbCB3aXRob3V0IHRvIHRhZywgbm8gZGlhbG9nIHRvIGNyZWF0ZS5cbiAgICAgICAgICBpZiAoIW1lc3NhZ2UudG9UYWcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJOb24tMTAwIDF4eCBJTlZJVEUgcmVzcG9uc2UgcmVjZWl2ZWQgd2l0aG91dCBhIHRvIHRhZywgZHJvcHBpbmcuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbXB1dGUgZGlhbG9nIHN0YXRlLlxuICAgICAgICAgIGNvbnN0IGRpYWxvZ1N0YXRlID0gRGlhbG9nLmluaXRpYWxEaWFsb2dTdGF0ZUZvclVzZXJBZ2VudENsaWVudCh0aGlzLm1lc3NhZ2UsIG1lc3NhZ2UpO1xuXG4gICAgICAgICAgLy8gSGF2ZSBleGlzdGluZyBlYXJseSBkaWFsb2cgb3IgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgICBsZXQgZWFybHlEaWFsb2cgPSB0aGlzLmVhcmx5RGlhbG9ncy5nZXQoZGlhbG9nU3RhdGUuaWQpO1xuICAgICAgICAgIGlmICghZWFybHlEaWFsb2cpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYXJseURpYWxvZyA9IG5ldyBTZXNzaW9uRGlhbG9nKHRyYW5zYWN0aW9uLCB0aGlzLmNvcmUsIGRpYWxvZ1N0YXRlKTtcbiAgICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2dzLnNldChlYXJseURpYWxvZy5pZCwgZWFybHlEaWFsb2cpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3Qgb3V0IG9mIG9yZGVyIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcy5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyB3aGVyZSB0aGUgcnNlcSB0cmFja2luZyBpcyBkb25lLlxuICAgICAgICAgIGlmICghZWFybHlEaWFsb2cucmVsaWFibGVTZXF1ZW5jZUd1YXJkKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiMXh4IElOVklURSByZWxpYWJsZSByZXNwb25zZSByZWNlaXZlZCBvdXQgb2Ygb3JkZXIsIGRyb3BwaW5nLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCBvZmZlciBpcyBpbiBhbiBJTlZJVEUsIHRoZSBhbnN3ZXIgTVVTVCBiZSBpbiBhXG4gICAgICAgICAgLy8gcmVsaWFibGUgbm9uLWZhaWx1cmUgbWVzc2FnZSBmcm9tIFVBUyBiYWNrIHRvIFVBQyB3aGljaCBpc1xuICAgICAgICAgIC8vIGNvcnJlbGF0ZWQgdG8gdGhhdCBJTlZJVEUuICBGb3IgdGhpcyBzcGVjaWZpY2F0aW9uLCB0aGF0IGlzXG4gICAgICAgICAgLy8gb25seSB0aGUgZmluYWwgMnh4IHJlc3BvbnNlIHRvIHRoYXQgSU5WSVRFLiAgVGhhdCBzYW1lIGV4YWN0XG4gICAgICAgICAgLy8gYW5zd2VyIE1BWSBhbHNvIGJlIHBsYWNlZCBpbiBhbnkgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIHNlbnRcbiAgICAgICAgICAvLyBwcmlvciB0byB0aGUgYW5zd2VyLiAgVGhlIFVBQyBNVVNUIHRyZWF0IHRoZSBmaXJzdCBzZXNzaW9uXG4gICAgICAgICAgLy8gZGVzY3JpcHRpb24gaXQgcmVjZWl2ZXMgYXMgdGhlIGFuc3dlciwgYW5kIE1VU1QgaWdub3JlIGFueVxuICAgICAgICAgIC8vIHNlc3Npb24gZGVzY3JpcHRpb25zIGluIHN1YnNlcXVlbnQgcmVzcG9uc2VzIHRvIHRoZSBpbml0aWFsXG4gICAgICAgICAgLy8gSU5WSVRFLlxuICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZWFybHlEaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IFNpZ25hbGluZ1N0YXRlLkluaXRpYWwgfHxcbiAgICAgICAgICAgIGVhcmx5RGlhbG9nLnNpZ25hbGluZ1N0YXRlID09PSBTaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZWFybHlEaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFBhc3MgcmVzcG9uc2UgdG8gZGVsZWdhdGUuXG4gICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGVhcmx5RGlhbG9nO1xuICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Qcm9ncmVzcykge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgc2Vzc2lvbixcbiAgICAgICAgICAgICAgcHJhY2s6IChvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpOiBPdXRnb2luZ1ByYWNrUmVxdWVzdCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Z29pbmdQcmFja1JlcXVlc3QgPSBzZXNzaW9uLnByYWNrKHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dGdvaW5nUHJhY2tSZXF1ZXN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgIC8vIE11bHRpcGxlIDJ4eCByZXNwb25zZXMgbWF5IGFycml2ZSBhdCB0aGUgVUFDIGZvciBhIHNpbmdsZSBJTlZJVEVcbiAgICAgICAgLy8gcmVxdWVzdCBkdWUgdG8gYSBmb3JraW5nIHByb3h5LiAgRWFjaCByZXNwb25zZSBpcyBkaXN0aW5ndWlzaGVkIGJ5XG4gICAgICAgIC8vIHRoZSB0YWcgcGFyYW1ldGVyIGluIHRoZSBUbyBoZWFkZXIgZmllbGQsIGFuZCBlYWNoIHJlcHJlc2VudHMgYVxuICAgICAgICAvLyBkaXN0aW5jdCBkaWFsb2csIHdpdGggYSBkaXN0aW5jdCBkaWFsb2cgaWRlbnRpZmllci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIGRpYWxvZyBpZGVudGlmaWVyIGluIHRoZSAyeHggcmVzcG9uc2UgbWF0Y2hlcyB0aGUgZGlhbG9nXG4gICAgICAgIC8vIGlkZW50aWZpZXIgb2YgYW4gZXhpc3RpbmcgZGlhbG9nLCB0aGUgZGlhbG9nIE1VU1QgYmUgdHJhbnNpdGlvbmVkIHRvXG4gICAgICAgIC8vIHRoZSBcImNvbmZpcm1lZFwiIHN0YXRlLCBhbmQgdGhlIHJvdXRlIHNldCBmb3IgdGhlIGRpYWxvZyBNVVNUIGJlXG4gICAgICAgIC8vIHJlY29tcHV0ZWQgYmFzZWQgb24gdGhlIDJ4eCByZXNwb25zZSB1c2luZyB0aGUgcHJvY2VkdXJlcyBvZiBTZWN0aW9uXG4gICAgICAgIC8vIDEyLjIuMS4yLiAgT3RoZXJ3aXNlLCBhIG5ldyBkaWFsb2cgaW4gdGhlIFwiY29uZmlybWVkXCIgc3RhdGUgTVVTVCBiZVxuICAgICAgICAvLyBjb25zdHJ1Y3RlZCB1c2luZyB0aGUgcHJvY2VkdXJlcyBvZiBTZWN0aW9uIDEyLjEuMi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjIuNFxuICAgICAgICB7XG4gICAgICAgICAgLy8gQ29tcHV0ZSBkaWFsb2cgc3RhdGUuXG4gICAgICAgICAgY29uc3QgZGlhbG9nU3RhdGUgPSBEaWFsb2cuaW5pdGlhbERpYWxvZ1N0YXRlRm9yVXNlckFnZW50Q2xpZW50KHRoaXMubWVzc2FnZSwgbWVzc2FnZSk7XG5cbiAgICAgICAgICAvLyBOT1RFOiBDdXJyZW50bHkgb3VyIHRyYW5zYWN0aW9uIGxheWVyIGlzIGNhY2hpbmcgdGhlIDJ4eCBBQ0tzIGFuZFxuICAgICAgICAgIC8vIGhhbmRsaW5nIHJldHJhbnNtaXNzaW9ucyBvZiB0aGUgQUNLIHdoaWNoIGlzIGFuIGFwcHJvYWNoIHdoaWNoIGlzXG4gICAgICAgICAgLy8gbm90IHRvIHNwZWMuIEluIGFueSBldmVudCwgdGhpcyBibG9jayBpcyBpbnRlbmRlZCB0byBwcm92aWRlIGEgdG9cbiAgICAgICAgICAvLyBzcGVjIGltcGxlbWVudGF0aW9uIG9mIEFDSyByZXRyYW5zbWlzc2lvbnMsIGJ1dCBpdCBzaG91bGQgbm90IGJlXG4gICAgICAgICAgLy8gaGl0IGN1cnJlbnRseS5cbiAgICAgICAgICBsZXQgZGlhbG9nID0gdGhpcy5jb25maXJtZWREaWFsb2dzLmdldChkaWFsb2dTdGF0ZS5pZCk7XG4gICAgICAgICAgaWYgKGRpYWxvZykge1xuICAgICAgICAgICAgLy8gT25jZSB0aGUgQUNLIGhhcyBiZWVuIGNvbnN0cnVjdGVkLCB0aGUgcHJvY2VkdXJlcyBvZiBbNF0gYXJlIHVzZWQgdG9cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZGVzdGluYXRpb24gYWRkcmVzcywgcG9ydCBhbmQgdHJhbnNwb3J0LiAgSG93ZXZlciwgdGhlXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGlzIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGRpcmVjdGx5IGZvciB0cmFuc21pc3Npb24sXG4gICAgICAgICAgICAvLyByYXRoZXIgdGhhbiBhIGNsaWVudCB0cmFuc2FjdGlvbi4gIFRoaXMgaXMgYmVjYXVzZSB0aGUgVUFDIGNvcmVcbiAgICAgICAgICAgIC8vIGhhbmRsZXMgcmV0cmFuc21pc3Npb25zIG9mIHRoZSBBQ0ssIG5vdCB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIuICBUaGVcbiAgICAgICAgICAgIC8vIEFDSyBNVVNUIGJlIHBhc3NlZCB0byB0aGUgY2xpZW50IHRyYW5zcG9ydCBldmVyeSB0aW1lIGFcbiAgICAgICAgICAgIC8vIHJldHJhbnNtaXNzaW9uIG9mIHRoZSAyeHggZmluYWwgcmVzcG9uc2UgdGhhdCB0cmlnZ2VyZWQgdGhlIEFDS1xuICAgICAgICAgICAgLy8gYXJyaXZlcy5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjRcbiAgICAgICAgICAgIGNvbnN0IG91dGdvaW5nQWNrUmVxdWVzdCA9IHRoaXMuY29uZmlybWVkRGlhbG9nQWNrcy5nZXQoZGlhbG9nU3RhdGUuaWQpO1xuICAgICAgICAgICAgaWYgKG91dGdvaW5nQWNrUmVxdWVzdCkge1xuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xpZW50IHRyYW5zYWN0aW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWNrUmVzcG9uc2Uob3V0Z29pbmdBY2tSZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gSWYgc3RpbGwgd2FpdGluZyBmb3IgYW4gQUNLLCBkcm9wIHRoZSByZXRyYW5zbWlzc2lvbiBvZiB0aGUgMnh4IGZpbmFsIHJlc3BvbnNlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBkaWFsb2cgaWRlbnRpZmllciBpbiB0aGUgMnh4IHJlc3BvbnNlIG1hdGNoZXMgdGhlIGRpYWxvZ1xuICAgICAgICAgIC8vIGlkZW50aWZpZXIgb2YgYW4gZXhpc3RpbmcgZGlhbG9nLCB0aGUgZGlhbG9nIE1VU1QgYmUgdHJhbnNpdGlvbmVkIHRvXG4gICAgICAgICAgLy8gdGhlIFwiY29uZmlybWVkXCIgc3RhdGUsIGFuZCB0aGUgcm91dGUgc2V0IGZvciB0aGUgZGlhbG9nIE1VU1QgYmVcbiAgICAgICAgICAvLyByZWNvbXB1dGVkIGJhc2VkIG9uIHRoZSAyeHggcmVzcG9uc2UgdXNpbmcgdGhlIHByb2NlZHVyZXMgb2YgU2VjdGlvblxuICAgICAgICAgIC8vIDEyLjIuMS4yLiBPdGhlcndpc2UsIGEgbmV3IGRpYWxvZyBpbiB0aGUgXCJjb25maXJtZWRcIiBzdGF0ZSBNVVNUIGJlXG4gICAgICAgICAgLy8gY29uc3RydWN0ZWQgdXNpbmcgdGhlIHByb2NlZHVyZXMgb2YgU2VjdGlvbiAxMi4xLjIuXG4gICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjIuNFxuICAgICAgICAgIGRpYWxvZyA9IHRoaXMuZWFybHlEaWFsb2dzLmdldChkaWFsb2dTdGF0ZS5pZCk7XG4gICAgICAgICAgaWYgKGRpYWxvZykge1xuICAgICAgICAgICAgZGlhbG9nLmNvbmZpcm0oKTtcbiAgICAgICAgICAgIGRpYWxvZy5yZWNvbXB1dGVSb3V0ZVNldChtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2dzLmRlbGV0ZShkaWFsb2cuaWQpO1xuICAgICAgICAgICAgdGhpcy5jb25maXJtZWREaWFsb2dzLnNldChkaWFsb2cuaWQsIGRpYWxvZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaWFsb2cgPSBuZXcgU2Vzc2lvbkRpYWxvZyh0cmFuc2FjdGlvbiwgdGhpcy5jb3JlLCBkaWFsb2dTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpcm1lZERpYWxvZ3Muc2V0KGRpYWxvZy5pZCwgZGlhbG9nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCBvZmZlciBpcyBpbiBhbiBJTlZJVEUsIHRoZSBhbnN3ZXIgTVVTVCBiZSBpbiBhXG4gICAgICAgICAgLy8gcmVsaWFibGUgbm9uLWZhaWx1cmUgbWVzc2FnZSBmcm9tIFVBUyBiYWNrIHRvIFVBQyB3aGljaCBpc1xuICAgICAgICAgIC8vIGNvcnJlbGF0ZWQgdG8gdGhhdCBJTlZJVEUuICBGb3IgdGhpcyBzcGVjaWZpY2F0aW9uLCB0aGF0IGlzXG4gICAgICAgICAgLy8gb25seSB0aGUgZmluYWwgMnh4IHJlc3BvbnNlIHRvIHRoYXQgSU5WSVRFLiAgVGhhdCBzYW1lIGV4YWN0XG4gICAgICAgICAgLy8gYW5zd2VyIE1BWSBhbHNvIGJlIHBsYWNlZCBpbiBhbnkgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIHNlbnRcbiAgICAgICAgICAvLyBwcmlvciB0byB0aGUgYW5zd2VyLiAgVGhlIFVBQyBNVVNUIHRyZWF0IHRoZSBmaXJzdCBzZXNzaW9uXG4gICAgICAgICAgLy8gZGVzY3JpcHRpb24gaXQgcmVjZWl2ZXMgYXMgdGhlIGFuc3dlciwgYW5kIE1VU1QgaWdub3JlIGFueVxuICAgICAgICAgIC8vIHNlc3Npb24gZGVzY3JpcHRpb25zIGluIHN1YnNlcXVlbnQgcmVzcG9uc2VzIHRvIHRoZSBpbml0aWFsXG4gICAgICAgICAgLy8gSU5WSVRFLlxuICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZGlhbG9nLnNpZ25hbGluZ1N0YXRlID09PSBTaWduYWxpbmdTdGF0ZS5Jbml0aWFsIHx8XG4gICAgICAgICAgICBkaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IFNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlc3Npb24gSW5pdGlhdGVkISA6KVxuICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkaWFsb2c7XG5cbiAgICAgICAgICAvLyBUaGUgVUFDIGNvcmUgTVVTVCBnZW5lcmF0ZSBhbiBBQ0sgcmVxdWVzdCBmb3IgZWFjaCAyeHggcmVjZWl2ZWQgZnJvbVxuICAgICAgICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBsYXllci4gIFRoZSBoZWFkZXIgZmllbGRzIG9mIHRoZSBBQ0sgYXJlIGNvbnN0cnVjdGVkXG4gICAgICAgICAgLy8gaW4gdGhlIHNhbWUgd2F5IGFzIGZvciBhbnkgcmVxdWVzdCBzZW50IHdpdGhpbiBhIGRpYWxvZyAoc2VlIFNlY3Rpb25cbiAgICAgICAgICAvLyAxMikgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSBDU2VxIGFuZCB0aGUgaGVhZGVyIGZpZWxkcyByZWxhdGVkIHRvXG4gICAgICAgICAgLy8gYXV0aGVudGljYXRpb24uICBUaGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBDU2VxIGhlYWRlciBmaWVsZCBNVVNUIGJlXG4gICAgICAgICAgLy8gdGhlIHNhbWUgYXMgdGhlIElOVklURSBiZWluZyBhY2tub3dsZWRnZWQsIGJ1dCB0aGUgQ1NlcSBtZXRob2QgTVVTVFxuICAgICAgICAgIC8vIGJlIEFDSy4gIFRoZSBBQ0sgTVVTVCBjb250YWluIHRoZSBzYW1lIGNyZWRlbnRpYWxzIGFzIHRoZSBJTlZJVEUuICBJZlxuICAgICAgICAgIC8vIHRoZSAyeHggY29udGFpbnMgYW4gb2ZmZXIgKGJhc2VkIG9uIHRoZSBydWxlcyBhYm92ZSksIHRoZSBBQ0sgTVVTVFxuICAgICAgICAgIC8vIGNhcnJ5IGFuIGFuc3dlciBpbiBpdHMgYm9keS4gIElmIHRoZSBvZmZlciBpbiB0aGUgMnh4IHJlc3BvbnNlIGlzIG5vdFxuICAgICAgICAgIC8vIGFjY2VwdGFibGUsIHRoZSBVQUMgY29yZSBNVVNUIGdlbmVyYXRlIGEgdmFsaWQgYW5zd2VyIGluIHRoZSBBQ0sgYW5kXG4gICAgICAgICAgLy8gdGhlbiBzZW5kIGEgQllFIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjRcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uQWNjZXB0KSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uQWNjZXB0KHtcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgc2Vzc2lvbixcbiAgICAgICAgICAgICAgYWNrOiAob3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogT3V0Z29pbmdBY2tSZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRnb2luZ0Fja1JlcXVlc3QgPSBzZXNzaW9uLmFjayhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1lZERpYWxvZ0Fja3Muc2V0KHNlc3Npb24uaWQsIG91dGdvaW5nQWNrUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dGdvaW5nQWNrUmVxdWVzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG91dGdvaW5nQWNrUmVxdWVzdCA9IHNlc3Npb24uYWNrKCk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpcm1lZERpYWxvZ0Fja3Muc2V0KHNlc3Npb24uaWQsIG91dGdvaW5nQWNrUmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgL14zWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAvLyAxMi4zIFRlcm1pbmF0aW9uIG9mIGEgRGlhbG9nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluZGVwZW5kZW50IG9mIHRoZSBtZXRob2QsIGlmIGEgcmVxdWVzdCBvdXRzaWRlIG9mIGEgZGlhbG9nIGdlbmVyYXRlc1xuICAgICAgICAvLyBhIG5vbi0yeHggZmluYWwgcmVzcG9uc2UsIGFueSBlYXJseSBkaWFsb2dzIGNyZWF0ZWQgdGhyb3VnaFxuICAgICAgICAvLyBwcm92aXNpb25hbCByZXNwb25zZXMgdG8gdGhhdCByZXF1ZXN0IGFyZSB0ZXJtaW5hdGVkLiAgVGhlIG1lY2hhbmlzbVxuICAgICAgICAvLyBmb3IgdGVybWluYXRpbmcgY29uZmlybWVkIGRpYWxvZ3MgaXMgbWV0aG9kIHNwZWNpZmljLiAgSW4gdGhpc1xuICAgICAgICAvLyBzcGVjaWZpY2F0aW9uLCB0aGUgQllFIG1ldGhvZCB0ZXJtaW5hdGVzIGEgc2Vzc2lvbiBhbmQgdGhlIGRpYWxvZ1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggaXQuICBTZWUgU2VjdGlvbiAxNSBmb3IgZGV0YWlscy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4zXG5cbiAgICAgICAgLy8gQWxsIGVhcmx5IGRpYWxvZ3MgYXJlIGNvbnNpZGVyZWQgdGVybWluYXRlZCB1cG9uIHJlY2VwdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gbm9uLTJ4eCBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWZ0ZXIgaGF2aW5nIHJlY2VpdmVkIHRoZSBub24tMnh4IGZpbmFsIHJlc3BvbnNlIHRoZSBVQUMgY29yZVxuICAgICAgICAvLyBjb25zaWRlcnMgdGhlIElOVklURSB0cmFuc2FjdGlvbiBjb21wbGV0ZWQuICBUaGUgSU5WSVRFIGNsaWVudFxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBoYW5kbGVzIHRoZSBnZW5lcmF0aW9uIG9mIEFDS3MgZm9yIHRoZSByZXNwb25zZSAoc2VlXG4gICAgICAgIC8vIFNlY3Rpb24gMTcpLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi4zXG4gICAgICAgIHRoaXMuZWFybHlEaWFsb2dzLmZvckVhY2goKGVhcmx5RGlhbG9nKSA9PiBlYXJseURpYWxvZy5kaXNwb3NlKCkpO1xuICAgICAgICB0aGlzLmVhcmx5RGlhbG9ncy5jbGVhcigpO1xuXG4gICAgICAgIC8vIEEgM3h4IHJlc3BvbnNlIG1heSBjb250YWluIG9uZSBvciBtb3JlIENvbnRhY3QgaGVhZGVyIGZpZWxkIHZhbHVlc1xuICAgICAgICAvLyBwcm92aWRpbmcgbmV3IGFkZHJlc3NlcyB3aGVyZSB0aGUgY2FsbGVlIG1pZ2h0IGJlIHJlYWNoYWJsZS5cbiAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBzdGF0dXMgY29kZSBvZiB0aGUgM3h4IHJlc3BvbnNlIChzZWUgU2VjdGlvbiAyMS4zKSxcbiAgICAgICAgLy8gdGhlIFVBQyBNQVkgY2hvb3NlIHRvIHRyeSB0aG9zZSBuZXcgYWRkcmVzc2VzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi4yXG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWRpcmVjdCkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWRpcmVjdCh7IG1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAvXls0LTZdWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAvLyAxMi4zIFRlcm1pbmF0aW9uIG9mIGEgRGlhbG9nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluZGVwZW5kZW50IG9mIHRoZSBtZXRob2QsIGlmIGEgcmVxdWVzdCBvdXRzaWRlIG9mIGEgZGlhbG9nIGdlbmVyYXRlc1xuICAgICAgICAvLyBhIG5vbi0yeHggZmluYWwgcmVzcG9uc2UsIGFueSBlYXJseSBkaWFsb2dzIGNyZWF0ZWQgdGhyb3VnaFxuICAgICAgICAvLyBwcm92aXNpb25hbCByZXNwb25zZXMgdG8gdGhhdCByZXF1ZXN0IGFyZSB0ZXJtaW5hdGVkLiAgVGhlIG1lY2hhbmlzbVxuICAgICAgICAvLyBmb3IgdGVybWluYXRpbmcgY29uZmlybWVkIGRpYWxvZ3MgaXMgbWV0aG9kIHNwZWNpZmljLiAgSW4gdGhpc1xuICAgICAgICAvLyBzcGVjaWZpY2F0aW9uLCB0aGUgQllFIG1ldGhvZCB0ZXJtaW5hdGVzIGEgc2Vzc2lvbiBhbmQgdGhlIGRpYWxvZ1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggaXQuICBTZWUgU2VjdGlvbiAxNSBmb3IgZGV0YWlscy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4zXG5cbiAgICAgICAgLy8gQWxsIGVhcmx5IGRpYWxvZ3MgYXJlIGNvbnNpZGVyZWQgdGVybWluYXRlZCB1cG9uIHJlY2VwdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gbm9uLTJ4eCBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWZ0ZXIgaGF2aW5nIHJlY2VpdmVkIHRoZSBub24tMnh4IGZpbmFsIHJlc3BvbnNlIHRoZSBVQUMgY29yZVxuICAgICAgICAvLyBjb25zaWRlcnMgdGhlIElOVklURSB0cmFuc2FjdGlvbiBjb21wbGV0ZWQuICBUaGUgSU5WSVRFIGNsaWVudFxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBoYW5kbGVzIHRoZSBnZW5lcmF0aW9uIG9mIEFDS3MgZm9yIHRoZSByZXNwb25zZSAoc2VlXG4gICAgICAgIC8vIFNlY3Rpb24gMTcpLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi4zXG4gICAgICAgIHRoaXMuZWFybHlEaWFsb2dzLmZvckVhY2goKGVhcmx5RGlhbG9nKSA9PiBlYXJseURpYWxvZy5kaXNwb3NlKCkpO1xuICAgICAgICB0aGlzLmVhcmx5RGlhbG9ncy5jbGVhcigpO1xuXG4gICAgICAgIC8vIEEgc2luZ2xlIG5vbi0yeHggZmluYWwgcmVzcG9uc2UgbWF5IGJlIHJlY2VpdmVkIGZvciB0aGUgSU5WSVRFLiAgNHh4LFxuICAgICAgICAvLyA1eHggYW5kIDZ4eCByZXNwb25zZXMgbWF5IGNvbnRhaW4gYSBDb250YWN0IGhlYWRlciBmaWVsZCB2YWx1ZVxuICAgICAgICAvLyBpbmRpY2F0aW5nIHRoZSBsb2NhdGlvbiB3aGVyZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvclxuICAgICAgICAvLyBjYW4gYmUgZm91bmQuICBTdWJzZXF1ZW50IGZpbmFsIHJlc3BvbnNlcyAod2hpY2ggd291bGQgb25seSBhcnJpdmVcbiAgICAgICAgLy8gdW5kZXIgZXJyb3IgY29uZGl0aW9ucykgTVVTVCBiZSBpZ25vcmVkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi4zXG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWplY3QpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVqZWN0KHsgbWVzc2FnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfWApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgRXhlY3V0aW5nIHdoYXQgc2hvdWxkIGJlIGFuIHVucmVhY2hhYmxlIGNvZGUgcGF0aCByZWNlaXZpbmcgJHtzdGF0dXNDb2RlfSByZXNwb25zZS5gKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlhbG9nLCBTZXNzaW9uRGlhbG9nIH0gZnJvbSBcIi4uL2RpYWxvZ3NcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdGVFcnJvciB9IGZyb20gXCIuLi9leGNlcHRpb25zXCI7XG5pbXBvcnQge1xuICBJbmNvbWluZ0ludml0ZVJlcXVlc3QsXG4gIEluY29taW5nUmVxdWVzdERlbGVnYXRlLFxuICBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICBPdXRnb2luZ1Jlc3BvbnNlLFxuICBPdXRnb2luZ1Jlc3BvbnNlV2l0aFNlc3Npb24sXG4gIFJlc3BvbnNlT3B0aW9ucyxcbiAgVVJJXG59IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgU2lnbmFsaW5nU3RhdGUgfSBmcm9tIFwiLi4vc2Vzc2lvblwiO1xuaW1wb3J0IHsgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRDb3JlIH0gZnJvbSBcIi4uL3VzZXItYWdlbnQtY29yZVwiO1xuaW1wb3J0IHsgQWxsb3dlZE1ldGhvZHMgfSBmcm9tIFwiLi4vdXNlci1hZ2VudC1jb3JlL2FsbG93ZWQtbWV0aG9kc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50U2VydmVyIH0gZnJvbSBcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIjtcblxuLyoqXG4gKiBJTlZJVEUgVUFTLlxuICogQHJlbWFya3NcbiAqIDEzIEluaXRpYXRpbmcgYSBTZXNzaW9uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzXG4gKiAxMy4xIE92ZXJ2aWV3XG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjFcbiAqIDEzLjMgVUFTIFByb2Nlc3NpbmdcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuM1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSW52aXRlVXNlckFnZW50U2VydmVyIGV4dGVuZHMgVXNlckFnZW50U2VydmVyIGltcGxlbWVudHMgSW5jb21pbmdJbnZpdGVSZXF1ZXN0IHtcblxuICAvKiogVGhlIGNvbmZpcm1lZCBkaWFsb2csIGlmIGFueS4gKi9cbiAgcHJpdmF0ZSBjb25maXJtZWREaWFsb2c6IFNlc3Npb25EaWFsb2cgfCB1bmRlZmluZWQ7XG4gIC8qKiBUaGUgZWFybHkgZGlhbG9nLCBpZiBhbnkuICovXG4gIHByaXZhdGUgZWFybHlEaWFsb2c6IFNlc3Npb25EaWFsb2cgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGNvcmU6IFVzZXJBZ2VudENvcmUsXG4gICAgbWVzc2FnZTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICBkZWxlZ2F0ZT86IEluY29taW5nUmVxdWVzdERlbGVnYXRlXG4gICkge1xuICAgIHN1cGVyKEludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSk7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5lYXJseURpYWxvZykge1xuICAgICAgdGhpcy5lYXJseURpYWxvZy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAxMy4zLjEuNCBUaGUgSU5WSVRFIGlzIEFjY2VwdGVkXG4gICAqIFRoZSBVQVMgY29yZSBnZW5lcmF0ZXMgYSAyeHggcmVzcG9uc2UuICBUaGlzIHJlc3BvbnNlIGVzdGFibGlzaGVzIGFcbiAgICogZGlhbG9nLCBhbmQgdGhlcmVmb3JlIGZvbGxvd3MgdGhlIHByb2NlZHVyZXMgb2YgU2VjdGlvbiAxMi4xLjEgaW5cbiAgICogYWRkaXRpb24gdG8gdGhvc2Ugb2YgU2VjdGlvbiA4LjIuNi5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4zLjEuNFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFjY2VwdCBvcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHB1YmxpYyBhY2NlcHQob3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0geyBzdGF0dXNDb2RlOiAyMDAgfSk6IE91dGdvaW5nUmVzcG9uc2VXaXRoU2Vzc2lvbiB7XG4gICAgaWYgKCF0aGlzLmFjY2VwdGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvblN0YXRlRXJyb3IoXG4gICAgICAgIGAke3RoaXMubWVzc2FnZS5tZXRob2R9IG5vdCBhY2NlcHRhYmxlIGluIHN0YXRlICR7dGhpcy50cmFuc2FjdGlvbi5zdGF0ZX0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHJlc3BvbnNlIGVzdGFibGlzaGVzIGEgZGlhbG9nLi4uXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4zLjEuNFxuICAgIGlmICghdGhpcy5jb25maXJtZWREaWFsb2cpIHtcbiAgICAgIGlmICh0aGlzLmVhcmx5RGlhbG9nKSB7XG4gICAgICAgIHRoaXMuZWFybHlEaWFsb2cuY29uZmlybSgpO1xuICAgICAgICB0aGlzLmNvbmZpcm1lZERpYWxvZyA9IHRoaXMuZWFybHlEaWFsb2c7XG4gICAgICAgIHRoaXMuZWFybHlEaWFsb2cgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMudHJhbnNhY3Rpb247XG4gICAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gbm90IGluc3RhbmNlIG9mIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IERpYWxvZy5pbml0aWFsRGlhbG9nU3RhdGVGb3JVc2VyQWdlbnRTZXJ2ZXIodGhpcy5tZXNzYWdlLCB0aGlzLnRvVGFnKTtcbiAgICAgICAgdGhpcy5jb25maXJtZWREaWFsb2cgPSBuZXcgU2Vzc2lvbkRpYWxvZyh0cmFuc2FjdGlvbiwgdGhpcy5jb3JlLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBhIFVBUyByZXNwb25kcyB0byBhIHJlcXVlc3Qgd2l0aCBhIHJlc3BvbnNlIHRoYXQgZXN0YWJsaXNoZXMgYVxuICAgIC8vIGRpYWxvZyAoc3VjaCBhcyBhIDJ4eCB0byBJTlZJVEUpLCB0aGUgVUFTIE1VU1QgY29weSBhbGwgUmVjb3JkLVJvdXRlXG4gICAgLy8gaGVhZGVyIGZpZWxkIHZhbHVlcyBmcm9tIHRoZSByZXF1ZXN0IGludG8gdGhlIHJlc3BvbnNlIChpbmNsdWRpbmcgdGhlXG4gICAgLy8gVVJJcywgVVJJIHBhcmFtZXRlcnMsIGFuZCBhbnkgUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLFxuICAgIC8vIHdoZXRoZXIgdGhleSBhcmUga25vd24gb3IgdW5rbm93biB0byB0aGUgVUFTKSBhbmQgTVVTVCBtYWludGFpbiB0aGVcbiAgICAvLyBvcmRlciBvZiB0aG9zZSB2YWx1ZXMuICBUaGUgVUFTIE1VU1QgYWRkIGEgQ29udGFjdCBoZWFkZXIgZmllbGQgdG9cbiAgICAvLyB0aGUgcmVzcG9uc2UuICBUaGUgQ29udGFjdCBoZWFkZXIgZmllbGQgY29udGFpbnMgYW4gYWRkcmVzcyB3aGVyZSB0aGVcbiAgICAvLyBVQVMgd291bGQgbGlrZSB0byBiZSBjb250YWN0ZWQgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHMgaW4gdGhlIGRpYWxvZ1xuICAgIC8vICh3aGljaCBpbmNsdWRlcyB0aGUgQUNLIGZvciBhIDJ4eCByZXNwb25zZSBpbiB0aGUgY2FzZSBvZiBhbiBJTlZJVEUpLlxuICAgIC8vIEdlbmVyYWxseSwgdGhlIGhvc3QgcG9ydGlvbiBvZiB0aGlzIFVSSSBpcyB0aGUgSVAgYWRkcmVzcyBvciBGUUROIG9mXG4gICAgLy8gdGhlIGhvc3QuICBUaGUgVVJJIHByb3ZpZGVkIGluIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBNVVNUIGJlIGEgU0lQXG4gICAgLy8gb3IgU0lQUyBVUkkuICBJZiB0aGUgcmVxdWVzdCB0aGF0IGluaXRpYXRlZCB0aGUgZGlhbG9nIGNvbnRhaW5lZCBhXG4gICAgLy8gU0lQUyBVUkkgaW4gdGhlIFJlcXVlc3QtVVJJIG9yIGluIHRoZSB0b3AgUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZFxuICAgIC8vIHZhbHVlLCBpZiB0aGVyZSB3YXMgYW55LCBvciB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGQgaWYgdGhlcmUgd2FzIG5vXG4gICAgLy8gUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCwgdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIGluIHRoZSByZXNwb25zZVxuICAgIC8vIE1VU1QgYmUgYSBTSVBTIFVSSS4gIFRoZSBVUkkgU0hPVUxEIGhhdmUgZ2xvYmFsIHNjb3BlICh0aGF0IGlzLCB0aGVcbiAgICAvLyBzYW1lIFVSSSBjYW4gYmUgdXNlZCBpbiBtZXNzYWdlcyBvdXRzaWRlIHRoaXMgZGlhbG9nKS4gIFRoZSBzYW1lIHdheSxcbiAgICAvLyB0aGUgc2NvcGUgb2YgdGhlIFVSSSBpbiB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGQgb2YgdGhlIElOVklURSBpcyBub3RcbiAgICAvLyBsaW1pdGVkIHRvIHRoaXMgZGlhbG9nIGVpdGhlci4gIEl0IGNhbiB0aGVyZWZvcmUgYmUgdXNlZCBpbiBtZXNzYWdlc1xuICAgIC8vIHRvIHRoZSBVQUMgZXZlbiBvdXRzaWRlIHRoaXMgZGlhbG9nLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4xXG4gICAgY29uc3QgcmVjb3JkUm91dGVIZWFkZXIgPSB0aGlzLm1lc3NhZ2VcbiAgICAgIC5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpXG4gICAgICAubWFwKChoZWFkZXIpID0+IGBSZWNvcmQtUm91dGU6ICR7aGVhZGVyfWApO1xuICAgIGNvbnN0IGNvbnRhY3RIZWFkZXIgPSBgQ29udGFjdDogJHt0aGlzLmNvcmUuY29uZmlndXJhdGlvbi5jb250YWN0LnRvU3RyaW5nKCl9YDtcblxuICAgIC8vIEEgMnh4IHJlc3BvbnNlIHRvIGFuIElOVklURSBTSE9VTEQgY29udGFpbiB0aGUgQWxsb3cgaGVhZGVyIGZpZWxkIGFuZFxuICAgIC8vIHRoZSBTdXBwb3J0ZWQgaGVhZGVyIGZpZWxkLCBhbmQgTUFZIGNvbnRhaW4gdGhlIEFjY2VwdCBoZWFkZXIgZmllbGQuXG4gICAgLy8gSW5jbHVkaW5nIHRoZXNlIGhlYWRlciBmaWVsZHMgYWxsb3dzIHRoZSBVQUMgdG8gZGV0ZXJtaW5lIHRoZVxuICAgIC8vIGZlYXR1cmVzIGFuZCBleHRlbnNpb25zIHN1cHBvcnRlZCBieSB0aGUgVUFTIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlXG4gICAgLy8gY2FsbCwgd2l0aG91dCBwcm9iaW5nLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjRcblxuICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCBub3QgYmUgaGFyZCBjb2RlZC5cbiAgICBjb25zdCBhbGxvd0hlYWRlciA9IFwiQWxsb3c6IFwiICsgQWxsb3dlZE1ldGhvZHMudG9TdHJpbmcoKTtcblxuICAgIC8vIEZJWE1FOiBUT0RPOiBTdXBwb3J0ZWQgaGVhZGVyIChzZWUgcmVwbHkoKSlcblxuICAgIC8vIEZJWE1FOiBUT0RPOiBBY2NlcHQgaGVhZGVyXG5cbiAgICAvLyBJZiB0aGUgSU5WSVRFIHJlcXVlc3QgY29udGFpbmVkIGFuIG9mZmVyLCBhbmQgdGhlIFVBUyBoYWQgbm90IHlldFxuICAgIC8vIHNlbnQgYW4gYW5zd2VyLCB0aGUgMnh4IE1VU1QgY29udGFpbiBhbiBhbnN3ZXIuICBJZiB0aGUgSU5WSVRFIGRpZFxuICAgIC8vIG5vdCBjb250YWluIGFuIG9mZmVyLCB0aGUgMnh4IE1VU1QgY29udGFpbiBhbiBvZmZlciBpZiB0aGUgVUFTIGhhZFxuICAgIC8vIG5vdCB5ZXQgc2VudCBhbiBvZmZlci5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS40XG4gICAgaWYgKCFvcHRpb25zLmJvZHkpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpcm1lZERpYWxvZy5zaWduYWxpbmdTdGF0ZSA9PT0gU2lnbmFsaW5nU3RhdGUuU3RhYmxlKSB7XG4gICAgICAgIG9wdGlvbnMuYm9keSA9IHRoaXMuY29uZmlybWVkRGlhbG9nLmFuc3dlcjsgLy8gcmVzZW5kIHRoZSBhbnN3ZXIgc2VudCBpbiBwcm92aXNpb25hbCByZXNwb25zZVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdGhpcy5jb25maXJtZWREaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IFNpZ25hbGluZ1N0YXRlLkluaXRpYWwgfHxcbiAgICAgICAgdGhpcy5jb25maXJtZWREaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IFNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlclxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIG11c3QgaGF2ZSBhIGJvZHkuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMuc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAyMDA7XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXTtcbiAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzLmNvbmNhdChyZWNvcmRSb3V0ZUhlYWRlcik7XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChhbGxvd0hlYWRlcik7XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChjb250YWN0SGVhZGVyKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gc3VwZXIuYWNjZXB0KG9wdGlvbnMpO1xuICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLmNvbmZpcm1lZERpYWxvZztcbiAgICBjb25zdCByZXN1bHQ6IE91dGdvaW5nUmVzcG9uc2VXaXRoU2Vzc2lvbiA9IHsgLi4ucmVzcG9uc2UsIHNlc3Npb24gfTtcblxuICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlXG4gICAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgICAgLy8gT25jZSB0aGUgVUFTIGhhcyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgaW5pdGlhbFxuICAgICAgLy8gb2ZmZXIsIGl0IE1VU1QgTk9UIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIGluIGFueSByZXNwb25zZXNcbiAgICAgIC8vIHRvIHRoZSBpbml0aWFsIElOVklURS4gIFRoaXMgbWVhbnMgdGhhdCBhIFVBUyBiYXNlZCBvbiB0aGlzXG4gICAgICAvLyBzcGVjaWZpY2F0aW9uIGFsb25lIGNhbiBuZXZlciBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyB1bnRpbFxuICAgICAgLy8gY29tcGxldGlvbiBvZiB0aGUgaW5pdGlhbCB0cmFuc2FjdGlvbi5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICBpZiAodGhpcy5jb25maXJtZWREaWFsb2cuc2lnbmFsaW5nU3RhdGUgIT09IFNpZ25hbGluZ1N0YXRlLlN0YWJsZSkge1xuICAgICAgICB0aGlzLmNvbmZpcm1lZERpYWxvZy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24ob3B0aW9ucy5ib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIDEzLjMuMS4xIFByb2dyZXNzXG4gICAqIElmIHRoZSBVQVMgaXMgbm90IGFibGUgdG8gYW5zd2VyIHRoZSBpbnZpdGF0aW9uIGltbWVkaWF0ZWx5LCBpdCBjYW5cbiAgICogY2hvb3NlIHRvIGluZGljYXRlIHNvbWUga2luZCBvZiBwcm9ncmVzcyB0byB0aGUgVUFDIChmb3IgZXhhbXBsZSwgYW5cbiAgICogaW5kaWNhdGlvbiB0aGF0IGEgcGhvbmUgaXMgcmluZ2luZykuICBUaGlzIGlzIGFjY29tcGxpc2hlZCB3aXRoIGFcbiAgICogcHJvdmlzaW9uYWwgcmVzcG9uc2UgYmV0d2VlbiAxMDEgYW5kIDE5OS4gIFRoZXNlIHByb3Zpc2lvbmFsXG4gICAqIHJlc3BvbnNlcyBlc3RhYmxpc2ggZWFybHkgZGlhbG9ncyBhbmQgdGhlcmVmb3JlIGZvbGxvdyB0aGUgcHJvY2VkdXJlc1xuICAgKiBvZiBTZWN0aW9uIDEyLjEuMSBpbiBhZGRpdGlvbiB0byB0aG9zZSBvZiBTZWN0aW9uIDguMi42LiAgQSBVQVMgTUFZXG4gICAqIHNlbmQgYXMgbWFueSBwcm92aXNpb25hbCByZXNwb25zZXMgYXMgaXQgbGlrZXMuICBFYWNoIG9mIHRoZXNlIE1VU1RcbiAgICogaW5kaWNhdGUgdGhlIHNhbWUgZGlhbG9nIElELiAgSG93ZXZlciwgdGhlc2Ugd2lsbCBub3QgYmUgZGVsaXZlcmVkXG4gICAqIHJlbGlhYmx5LlxuICAgKlxuICAgKiBJZiB0aGUgVUFTIGRlc2lyZXMgYW4gZXh0ZW5kZWQgcGVyaW9kIG9mIHRpbWUgdG8gYW5zd2VyIHRoZSBJTlZJVEUsXG4gICAqIGl0IHdpbGwgbmVlZCB0byBhc2sgZm9yIGFuIFwiZXh0ZW5zaW9uXCIgaW4gb3JkZXIgdG8gcHJldmVudCBwcm94aWVzXG4gICAqIGZyb20gY2FuY2VsaW5nIHRoZSB0cmFuc2FjdGlvbi4gIEEgcHJveHkgaGFzIHRoZSBvcHRpb24gb2YgY2FuY2VsaW5nXG4gICAqIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSBpcyBhIGdhcCBvZiAzIG1pbnV0ZXMgYmV0d2VlbiByZXNwb25zZXMgaW4gYVxuICAgKiB0cmFuc2FjdGlvbi4gIFRvIHByZXZlbnQgY2FuY2VsbGF0aW9uLCB0aGUgVUFTIE1VU1Qgc2VuZCBhIG5vbi0xMDBcbiAgICogcHJvdmlzaW9uYWwgcmVzcG9uc2UgYXQgZXZlcnkgbWludXRlLCB0byBoYW5kbGUgdGhlIHBvc3NpYmlsaXR5IG9mXG4gICAqIGxvc3QgcHJvdmlzaW9uYWwgcmVzcG9uc2VzLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS4xXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUHJvZ3Jlc3Mgb3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBwdWJsaWMgcHJvZ3Jlc3Mob3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0geyBzdGF0dXNDb2RlOiAxODAgfSk6IE91dGdvaW5nUmVzcG9uc2VXaXRoU2Vzc2lvbiB7XG4gICAgaWYgKCF0aGlzLnByb2dyZXNzYWJsZSkge1xuICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uU3RhdGVFcnJvcihcbiAgICAgICAgYCR7dGhpcy5tZXNzYWdlLm1ldGhvZH0gbm90IHByb2dyZXNzYWJsZSBpbiBzdGF0ZSAke3RoaXMudHJhbnNhY3Rpb24uc3RhdGV9LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyByZXNwb25zZSBlc3RhYmxpc2hlcyBhIGRpYWxvZy4uLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjRcbiAgICBpZiAoIXRoaXMuZWFybHlEaWFsb2cpIHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy50cmFuc2FjdGlvbjtcbiAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0ZSA9IERpYWxvZy5pbml0aWFsRGlhbG9nU3RhdGVGb3JVc2VyQWdlbnRTZXJ2ZXIodGhpcy5tZXNzYWdlLCB0aGlzLnRvVGFnLCB0cnVlKTtcbiAgICAgIHRoaXMuZWFybHlEaWFsb2cgPSBuZXcgU2Vzc2lvbkRpYWxvZyh0cmFuc2FjdGlvbiwgdGhpcy5jb3JlLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBhIFVBUyByZXNwb25kcyB0byBhIHJlcXVlc3Qgd2l0aCBhIHJlc3BvbnNlIHRoYXQgZXN0YWJsaXNoZXMgYVxuICAgIC8vIGRpYWxvZyAoc3VjaCBhcyBhIDJ4eCB0byBJTlZJVEUpLCB0aGUgVUFTIE1VU1QgY29weSBhbGwgUmVjb3JkLVJvdXRlXG4gICAgLy8gaGVhZGVyIGZpZWxkIHZhbHVlcyBmcm9tIHRoZSByZXF1ZXN0IGludG8gdGhlIHJlc3BvbnNlIChpbmNsdWRpbmcgdGhlXG4gICAgLy8gVVJJcywgVVJJIHBhcmFtZXRlcnMsIGFuZCBhbnkgUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLFxuICAgIC8vIHdoZXRoZXIgdGhleSBhcmUga25vd24gb3IgdW5rbm93biB0byB0aGUgVUFTKSBhbmQgTVVTVCBtYWludGFpbiB0aGVcbiAgICAvLyBvcmRlciBvZiB0aG9zZSB2YWx1ZXMuICBUaGUgVUFTIE1VU1QgYWRkIGEgQ29udGFjdCBoZWFkZXIgZmllbGQgdG9cbiAgICAvLyB0aGUgcmVzcG9uc2UuICBUaGUgQ29udGFjdCBoZWFkZXIgZmllbGQgY29udGFpbnMgYW4gYWRkcmVzcyB3aGVyZSB0aGVcbiAgICAvLyBVQVMgd291bGQgbGlrZSB0byBiZSBjb250YWN0ZWQgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHMgaW4gdGhlIGRpYWxvZ1xuICAgIC8vICh3aGljaCBpbmNsdWRlcyB0aGUgQUNLIGZvciBhIDJ4eCByZXNwb25zZSBpbiB0aGUgY2FzZSBvZiBhbiBJTlZJVEUpLlxuICAgIC8vIEdlbmVyYWxseSwgdGhlIGhvc3QgcG9ydGlvbiBvZiB0aGlzIFVSSSBpcyB0aGUgSVAgYWRkcmVzcyBvciBGUUROIG9mXG4gICAgLy8gdGhlIGhvc3QuICBUaGUgVVJJIHByb3ZpZGVkIGluIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBNVVNUIGJlIGEgU0lQXG4gICAgLy8gb3IgU0lQUyBVUkkuICBJZiB0aGUgcmVxdWVzdCB0aGF0IGluaXRpYXRlZCB0aGUgZGlhbG9nIGNvbnRhaW5lZCBhXG4gICAgLy8gU0lQUyBVUkkgaW4gdGhlIFJlcXVlc3QtVVJJIG9yIGluIHRoZSB0b3AgUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZFxuICAgIC8vIHZhbHVlLCBpZiB0aGVyZSB3YXMgYW55LCBvciB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGQgaWYgdGhlcmUgd2FzIG5vXG4gICAgLy8gUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCwgdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIGluIHRoZSByZXNwb25zZVxuICAgIC8vIE1VU1QgYmUgYSBTSVBTIFVSSS4gIFRoZSBVUkkgU0hPVUxEIGhhdmUgZ2xvYmFsIHNjb3BlICh0aGF0IGlzLCB0aGVcbiAgICAvLyBzYW1lIFVSSSBjYW4gYmUgdXNlZCBpbiBtZXNzYWdlcyBvdXRzaWRlIHRoaXMgZGlhbG9nKS4gIFRoZSBzYW1lIHdheSxcbiAgICAvLyB0aGUgc2NvcGUgb2YgdGhlIFVSSSBpbiB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGQgb2YgdGhlIElOVklURSBpcyBub3RcbiAgICAvLyBsaW1pdGVkIHRvIHRoaXMgZGlhbG9nIGVpdGhlci4gIEl0IGNhbiB0aGVyZWZvcmUgYmUgdXNlZCBpbiBtZXNzYWdlc1xuICAgIC8vIHRvIHRoZSBVQUMgZXZlbiBvdXRzaWRlIHRoaXMgZGlhbG9nLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4xXG4gICAgY29uc3QgcmVjb3JkUm91dGVIZWFkZXIgPSB0aGlzLm1lc3NhZ2VcbiAgICAgIC5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpXG4gICAgICAubWFwKChoZWFkZXIpID0+IGBSZWNvcmQtUm91dGU6ICR7aGVhZGVyfWApO1xuICAgIGNvbnN0IGNvbnRhY3RIZWFkZXIgPSBgQ29udGFjdDogJHt0aGlzLmNvcmUuY29uZmlndXJhdGlvbi5jb250YWN0fWA7XG5cbiAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdO1xuICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMuY29uY2F0KHJlY29yZFJvdXRlSGVhZGVyKTtcbiAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKGNvbnRhY3RIZWFkZXIpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBzdXBlci5wcm9ncmVzcyhvcHRpb25zKTtcbiAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5lYXJseURpYWxvZztcbiAgICBjb25zdCByZXN1bHQ6IE91dGdvaW5nUmVzcG9uc2VXaXRoU2Vzc2lvbiA9IHsgLi4ucmVzcG9uc2UsIHNlc3Npb24gfTtcblxuICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlXG4gICAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgICAgLy8gT25jZSB0aGUgVUFTIGhhcyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgaW5pdGlhbFxuICAgICAgLy8gb2ZmZXIsIGl0IE1VU1QgTk9UIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIGluIGFueSByZXNwb25zZXNcbiAgICAgIC8vIHRvIHRoZSBpbml0aWFsIElOVklURS4gIFRoaXMgbWVhbnMgdGhhdCBhIFVBUyBiYXNlZCBvbiB0aGlzXG4gICAgICAvLyBzcGVjaWZpY2F0aW9uIGFsb25lIGNhbiBuZXZlciBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyB1bnRpbFxuICAgICAgLy8gY29tcGxldGlvbiBvZiB0aGUgaW5pdGlhbCB0cmFuc2FjdGlvbi5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICBpZiAodGhpcy5lYXJseURpYWxvZy5zaWduYWxpbmdTdGF0ZSAhPT0gU2lnbmFsaW5nU3RhdGUuU3RhYmxlKSB7XG4gICAgICAgIHRoaXMuZWFybHlEaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG9wdGlvbnMuYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiAxMy4zLjEuMiBUaGUgSU5WSVRFIGlzIFJlZGlyZWN0ZWRcbiAgICogSWYgdGhlIFVBUyBkZWNpZGVzIHRvIHJlZGlyZWN0IHRoZSBjYWxsLCBhIDN4eCByZXNwb25zZSBpcyBzZW50LiAgQVxuICAgKiAzMDAgKE11bHRpcGxlIENob2ljZXMpLCAzMDEgKE1vdmVkIFBlcm1hbmVudGx5KSBvciAzMDIgKE1vdmVkXG4gICAqIFRlbXBvcmFyaWx5KSByZXNwb25zZSBTSE9VTEQgY29udGFpbiBhIENvbnRhY3QgaGVhZGVyIGZpZWxkXG4gICAqIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgVVJJcyBvZiBuZXcgYWRkcmVzc2VzIHRvIGJlIHRyaWVkLiAgVGhlXG4gICAqIHJlc3BvbnNlIGlzIHBhc3NlZCB0byB0aGUgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiwgd2hpY2ggd2lsbCBkZWFsXG4gICAqIHdpdGggaXRzIHJldHJhbnNtaXNzaW9ucy5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4zLjEuMlxuICAgKiBAcGFyYW0gY29udGFjdHMgLSBDb250YWN0cyB0byByZWRpcmVjdCB0by5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZWRpcmVjdCBvcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHB1YmxpYyByZWRpcmVjdChjb250YWN0czogQXJyYXk8VVJJPiwgb3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0geyBzdGF0dXNDb2RlOiAzMDIgfSk6IE91dGdvaW5nUmVzcG9uc2Uge1xuICAgIHJldHVybiBzdXBlci5yZWRpcmVjdChjb250YWN0cywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogMTMuMy4xLjMgVGhlIElOVklURSBpcyBSZWplY3RlZFxuICAgKiBBIGNvbW1vbiBzY2VuYXJpbyBvY2N1cnMgd2hlbiB0aGUgY2FsbGVlIGlzIGN1cnJlbnRseSBub3Qgd2lsbGluZyBvclxuICAgKiBhYmxlIHRvIHRha2UgYWRkaXRpb25hbCBjYWxscyBhdCB0aGlzIGVuZCBzeXN0ZW0uICBBIDQ4NiAoQnVzeSBIZXJlKVxuICAgKiBTSE9VTEQgYmUgcmV0dXJuZWQgaW4gc3VjaCBhIHNjZW5hcmlvLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS4zXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVqZWN0IG9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgcHVibGljIHJlamVjdChvcHRpb25zOiBSZXNwb25zZU9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDQ4NiB9KTogT3V0Z29pbmdSZXNwb25zZSB7XG4gICAgcmV0dXJuIHN1cGVyLnJlamVjdChvcHRpb25zKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgT3V0Z29pbmdNZXNzYWdlUmVxdWVzdCwgT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGUsIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50Q29yZSB9IGZyb20gXCIuLi91c2VyLWFnZW50LWNvcmVcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENsaWVudCB9IGZyb20gXCIuL3VzZXItYWdlbnQtY2xpZW50XCI7XG5cbi8qKlxuICogTUVTU0FHRSBVQVMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlVXNlckFnZW50Q2xpZW50IGV4dGVuZHMgVXNlckFnZW50Q2xpZW50IGltcGxlbWVudHMgT3V0Z29pbmdNZXNzYWdlUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGNvcmU6IFVzZXJBZ2VudENvcmUsXG4gICAgbWVzc2FnZTogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICBkZWxlZ2F0ZT86IE91dGdvaW5nUmVxdWVzdERlbGVnYXRlXG4gICkge1xuICAgIHN1cGVyKE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluY29taW5nTWVzc2FnZVJlcXVlc3QsIEluY29taW5nUmVxdWVzdERlbGVnYXRlLCBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENvcmUgfSBmcm9tIFwiLi4vdXNlci1hZ2VudC1jb3JlXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRTZXJ2ZXIgfSBmcm9tIFwiLi91c2VyLWFnZW50LXNlcnZlclwiO1xuXG4vKipcbiAqIE1FU1NBR0UgVUFTLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgTWVzc2FnZVVzZXJBZ2VudFNlcnZlciBleHRlbmRzIFVzZXJBZ2VudFNlcnZlciBpbXBsZW1lbnRzIEluY29taW5nTWVzc2FnZVJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgY29yZTogVXNlckFnZW50Q29yZSxcbiAgICBtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGRlbGVnYXRlPzogSW5jb21pbmdSZXF1ZXN0RGVsZWdhdGVcbiAgKSB7XG4gICAgc3VwZXIoTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgU2Vzc2lvbkRpYWxvZyB9IGZyb20gXCIuLi9kaWFsb2dzXCI7XG5pbXBvcnQgeyBDLCBPdXRnb2luZ05vdGlmeVJlcXVlc3QsIE91dGdvaW5nUmVxdWVzdERlbGVnYXRlLCBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRDbGllbnQgfSBmcm9tIFwiLi91c2VyLWFnZW50LWNsaWVudFwiO1xuXG4vKipcbiAqIE5PVElGWSBVQVMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RpZnlVc2VyQWdlbnRDbGllbnQgZXh0ZW5kcyBVc2VyQWdlbnRDbGllbnQgaW1wbGVtZW50cyBPdXRnb2luZ05vdGlmeVJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihcbiAgICBkaWFsb2c6IFNlc3Npb25EaWFsb2csXG4gICAgZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSxcbiAgICBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRpYWxvZy5jcmVhdGVPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKEMuTk9USUZZLCBvcHRpb25zKTtcbiAgICBzdXBlcihOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGlhbG9nIH0gZnJvbSBcIi4uL2RpYWxvZ3NcIjtcbmltcG9ydCB7IEluY29taW5nTm90aWZ5UmVxdWVzdCwgSW5jb21pbmdSZXF1ZXN0RGVsZWdhdGUsIEluY29taW5nUmVxdWVzdE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50Q29yZSB9IGZyb20gXCIuLi91c2VyLWFnZW50LWNvcmVcIjtcbmltcG9ydCB7IFVzZXJBZ2VudFNlcnZlciB9IGZyb20gXCIuL3VzZXItYWdlbnQtc2VydmVyXCI7XG5cbi8qKlxuICogTk9USUZZIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE5vdGlmeVVzZXJBZ2VudFNlcnZlciBleHRlbmRzIFVzZXJBZ2VudFNlcnZlciBpbXBsZW1lbnRzIEluY29taW5nTm90aWZ5UmVxdWVzdCB7XG4gIC8qKlxuICAgKiBOT1RJRlkgVUFTIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gZGlhbG9nT3JDb3JlIC0gRGlhbG9nIGZvciBpbiBkaWFsb2cgTk9USUZZLCBVc2VyQWdlbnRDb3JlIGZvciBvdXQgb2YgZGlhbG9nIE5PVElGWSAoZGVwcmVjYXRlZCkuXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgTk9USUZZIHJlcXVlc3QgbWVzc2FnZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIGRpYWxvZ09yQ29yZTogRGlhbG9nIHwgVXNlckFnZW50Q29yZSxcbiAgICBtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGRlbGVnYXRlPzogSW5jb21pbmdSZXF1ZXN0RGVsZWdhdGVcbiAgKSB7XG4gICAgY29uc3QgdXNlckFnZW50Q29yZSA9XG4gICAgICBpbnN0YW5jZU9mRGlhbG9nKGRpYWxvZ09yQ29yZSkgP1xuICAgICAgICBkaWFsb2dPckNvcmUudXNlckFnZW50Q29yZSA6XG4gICAgICAgIGRpYWxvZ09yQ29yZTtcbiAgICBzdXBlcihOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgdXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlT2ZEaWFsb2cob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgRGlhbG9nIHtcbiAgcmV0dXJuIG9iamVjdC51c2VyQWdlbnRDb3JlICE9PSB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBTZXNzaW9uRGlhbG9nIH0gZnJvbSBcIi4uL2RpYWxvZ3NcIjtcbmltcG9ydCB7IEMsIE91dGdvaW5nUHJhY2tSZXF1ZXN0LCBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50Q2xpZW50IH0gZnJvbSBcIi4vdXNlci1hZ2VudC1jbGllbnRcIjtcblxuLyoqXG4gKiBQUkFDSyBVQUMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmFja1VzZXJBZ2VudENsaWVudCBleHRlbmRzIFVzZXJBZ2VudENsaWVudCBpbXBsZW1lbnRzIE91dGdvaW5nUHJhY2tSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgZGlhbG9nOiBTZXNzaW9uRGlhbG9nLFxuICAgIGRlbGVnYXRlPzogT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGUsXG4gICAgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zXG4gICkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkaWFsb2cuY3JlYXRlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShDLlBSQUNLLCBvcHRpb25zKTtcbiAgICBzdXBlcihOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgICBkaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBTZXNzaW9uRGlhbG9nIH0gZnJvbSBcIi4uL2RpYWxvZ3NcIjtcbmltcG9ydCB7XG4gIEluY29taW5nUHJhY2tSZXF1ZXN0LFxuICBJbmNvbWluZ1JlcXVlc3REZWxlZ2F0ZSxcbiAgSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgT3V0Z29pbmdSZXNwb25zZSxcbiAgUmVzcG9uc2VPcHRpb25zXG59IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRTZXJ2ZXIgfSBmcm9tIFwiLi91c2VyLWFnZW50LXNlcnZlclwiO1xuXG4vKipcbiAqIFBSQUNLIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFByYWNrVXNlckFnZW50U2VydmVyIGV4dGVuZHMgVXNlckFnZW50U2VydmVyIGltcGxlbWVudHMgSW5jb21pbmdQcmFja1JlcXVlc3Qge1xuICBwcml2YXRlIGRpYWxvZzogU2Vzc2lvbkRpYWxvZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBkaWFsb2c6IFNlc3Npb25EaWFsb2csXG4gICAgbWVzc2FnZTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICBkZWxlZ2F0ZT86IEluY29taW5nUmVxdWVzdERlbGVnYXRlXG4gICkge1xuICAgIHN1cGVyKE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlIHdpdGggb2ZmZXIvYW5zd2VyIGluIGJvZHlcbiAgICBkaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgIHRoaXMuZGlhbG9nID0gZGlhbG9nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZGlhbG9nIHNpZ25hbGluZyBzdGF0ZSBvbiBhIDJ4eCByZXNwb25zZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHB1YmxpYyBhY2NlcHQob3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0geyBzdGF0dXNDb2RlOiAyMDAgfSk6IE91dGdvaW5nUmVzcG9uc2Uge1xuICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlIHdpdGggb2ZmZXIvYW5zd2VyIGluIGJvZHlcbiAgICAgIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihvcHRpb25zLmJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuYWNjZXB0KG9wdGlvbnMpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBPdXRnb2luZ1B1Ymxpc2hSZXF1ZXN0LCBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRDb3JlIH0gZnJvbSBcIi4uL3VzZXItYWdlbnQtY29yZVwiO1xuaW1wb3J0IHsgVXNlckFnZW50Q2xpZW50IH0gZnJvbSBcIi4vdXNlci1hZ2VudC1jbGllbnRcIjtcblxuLyoqXG4gKiBQVUJMSVNIIFVBQy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFB1Ymxpc2hVc2VyQWdlbnRDbGllbnQgZXh0ZW5kcyBVc2VyQWdlbnRDbGllbnQgaW1wbGVtZW50cyBPdXRnb2luZ1B1Ymxpc2hSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgY29yZTogVXNlckFnZW50Q29yZSxcbiAgICBtZXNzYWdlOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGRlbGVnYXRlPzogT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGVcbiAgKSB7XG4gICAgc3VwZXIoTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgU2Vzc2lvbkRpYWxvZyB9IGZyb20gXCIuLi9kaWFsb2dzXCI7XG5pbXBvcnQge1xuICBDLFxuICBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSxcbiAgT3V0Z29pbmdBY2tSZXF1ZXN0LFxuICBPdXRnb2luZ0ludml0ZVJlcXVlc3QsXG4gIE91dGdvaW5nSW52aXRlUmVxdWVzdERlbGVnYXRlLFxuICBPdXRnb2luZ1ByYWNrUmVxdWVzdCxcbiAgUmVxdWVzdE9wdGlvbnNcbn0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENsaWVudCB9IGZyb20gXCIuL3VzZXItYWdlbnQtY2xpZW50XCI7XG5cbi8qKlxuICogUmUtSU5WSVRFIFVBQy5cbiAqIEByZW1hcmtzXG4gKiAxNCBNb2RpZnlpbmcgYW4gRXhpc3RpbmcgU2Vzc2lvblxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNFxuICogMTQuMSBVQUMgQmVoYXZpb3JcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTQuMVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVJbnZpdGVVc2VyQWdlbnRDbGllbnQgZXh0ZW5kcyBVc2VyQWdlbnRDbGllbnQgaW1wbGVtZW50cyBPdXRnb2luZ0ludml0ZVJlcXVlc3Qge1xuICBwdWJsaWMgZGVsZWdhdGU6IE91dGdvaW5nSW52aXRlUmVxdWVzdERlbGVnYXRlIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgZGlhbG9nOiBTZXNzaW9uRGlhbG9nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGRpYWxvZzogU2Vzc2lvbkRpYWxvZyxcbiAgICBkZWxlZ2F0ZT86IE91dGdvaW5nSW52aXRlUmVxdWVzdERlbGVnYXRlLFxuICAgIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9uc1xuICApIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZGlhbG9nLmNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoQy5JTlZJVEUsIG9wdGlvbnMpO1xuICAgIHN1cGVyKEludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICBkaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgIC8vIEZJWE1FOiBUT0RPOiBuZXh0IGxpbmUgb2J2aW91c2x5IG5lZWRzIHRvIGJlIGltcHJvdmVkLi4uXG4gICAgZGlhbG9nLnJlaW52aXRlVXNlckFnZW50Q2xpZW50ID0gdGhpczsgLy8gbGV0IHRoZSBkaWFsb2cga25vdyByZS1pbnZpdGUgcmVxdWVzdCBzZW50XG4gICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2U6IEluY29taW5nUmVzcG9uc2VNZXNzYWdlKTogdm9pZCB7XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IG1lc3NhZ2Uuc3RhdHVzQ29kZSA/IG1lc3NhZ2Uuc3RhdHVzQ29kZS50b1N0cmluZygpIDogXCJcIjtcbiAgICBpZiAoIXN0YXR1c0NvZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHN0YXR1cyBjb2RlIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIC9eMTAwJC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblRyeWluZykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25UcnlpbmcoeyBtZXNzYWdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Qcm9ncmVzcykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5kaWFsb2csXG4gICAgICAgICAgICBwcmFjazogKG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyk6IE91dGdvaW5nUHJhY2tSZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgLy8gVXBkYXRlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGUgd2l0aCBvZmZlci9hbnN3ZXIgaW4gYm9keVxuICAgICAgICB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24obWVzc2FnZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkFjY2VwdCkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25BY2NlcHQoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHNlc3Npb246IHRoaXMuZGlhbG9nLFxuICAgICAgICAgICAgYWNrOiAob3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKTogT3V0Z29pbmdBY2tSZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3V0Z29pbmdBY2tSZXF1ZXN0ID0gdGhpcy5kaWFsb2cuYWNrKG9wdGlvbnMpO1xuICAgICAgICAgICAgICByZXR1cm4gb3V0Z29pbmdBY2tSZXF1ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAvXjNbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlUm9sbGJhY2soKTtcbiAgICAgICAgdGhpcy5kaWFsb2cucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQgPSB1bmRlZmluZWQ7IC8vIEFDSyB3YXMgaGFuZGxlZCBieSB0cmFuc2FjdGlvblxuXG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWRpcmVjdCkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWRpcmVjdCh7IG1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC9eWzQtNl1bMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlUm9sbGJhY2soKTtcbiAgICAgICAgdGhpcy5kaWFsb2cucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQgPSB1bmRlZmluZWQ7IC8vIEFDSyB3YXMgaGFuZGxlZCBieSB0cmFuc2FjdGlvblxuXG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWplY3QpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVqZWN0KHsgbWVzc2FnZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBhIFVBIHJlY2VpdmVzIGEgbm9uLTJ4eCBmaW5hbCByZXNwb25zZSB0byBhIHJlLUlOVklURSwgdGhlIHNlc3Npb25cbiAgICAgICAgICAvLyBwYXJhbWV0ZXJzIE1VU1QgcmVtYWluIHVuY2hhbmdlZCwgYXMgaWYgbm8gcmUtSU5WSVRFIGhhZCBiZWVuIGlzc3VlZC5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQsIGFzIHN0YXRlZCBpbiBTZWN0aW9uIDEyLjIuMS4yLCBpZiB0aGUgbm9uLTJ4eCBmaW5hbFxuICAgICAgICAgIC8vIHJlc3BvbnNlIGlzIGEgNDgxIChDYWxsL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0KSwgb3IgYSA0MDhcbiAgICAgICAgICAvLyAoUmVxdWVzdCBUaW1lb3V0KSwgb3Igbm8gcmVzcG9uc2UgYXQgYWxsIGlzIHJlY2VpdmVkIGZvciB0aGUgcmUtXG4gICAgICAgICAgLy8gSU5WSVRFICh0aGF0IGlzLCBhIHRpbWVvdXQgaXMgcmV0dXJuZWQgYnkgdGhlIElOVklURSBjbGllbnRcbiAgICAgICAgICAvLyB0cmFuc2FjdGlvbiksIHRoZSBVQUMgd2lsbCB0ZXJtaW5hdGUgdGhlIGRpYWxvZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgVUFDIHJlY2VpdmVzIGEgNDkxIHJlc3BvbnNlIHRvIGEgcmUtSU5WSVRFLCBpdCBTSE9VTEQgc3RhcnQgYVxuICAgICAgICAgIC8vIHRpbWVyIHdpdGggYSB2YWx1ZSBUIGNob3NlbiBhcyBmb2xsb3dzOlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAgMS4gSWYgdGhlIFVBQyBpcyB0aGUgb3duZXIgb2YgdGhlIENhbGwtSUQgb2YgdGhlIGRpYWxvZyBJRFxuICAgICAgICAgIC8vICAgICAgIChtZWFuaW5nIGl0IGdlbmVyYXRlZCB0aGUgdmFsdWUpLCBUIGhhcyBhIHJhbmRvbWx5IGNob3NlbiB2YWx1ZVxuICAgICAgICAgIC8vICAgICAgIGJldHdlZW4gMi4xIGFuZCA0IHNlY29uZHMgaW4gdW5pdHMgb2YgMTAgbXMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAyLiBJZiB0aGUgVUFDIGlzIG5vdCB0aGUgb3duZXIgb2YgdGhlIENhbGwtSUQgb2YgdGhlIGRpYWxvZyBJRCwgVFxuICAgICAgICAgIC8vICAgICAgIGhhcyBhIHJhbmRvbWx5IGNob3NlbiB2YWx1ZSBvZiBiZXR3ZWVuIDAgYW5kIDIgc2Vjb25kcyBpbiB1bml0c1xuICAgICAgICAgIC8vICAgICAgIG9mIDEwIG1zLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gV2hlbiB0aGUgdGltZXIgZmlyZXMsIHRoZSBVQUMgU0hPVUxEIGF0dGVtcHQgdGhlIHJlLUlOVklURSBvbmNlIG1vcmUsXG4gICAgICAgICAgLy8gaWYgaXQgc3RpbGwgZGVzaXJlcyBmb3IgdGhhdCBzZXNzaW9uIG1vZGlmaWNhdGlvbiB0byB0YWtlIHBsYWNlLiAgRm9yXG4gICAgICAgICAgLy8gZXhhbXBsZSwgaWYgdGhlIGNhbGwgd2FzIGFscmVhZHkgaHVuZyB1cCB3aXRoIGEgQllFLCB0aGUgcmUtSU5WSVRFXG4gICAgICAgICAgLy8gd291bGQgbm90IHRha2UgcGxhY2UuXG4gICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNC4xXG5cbiAgICAgICAgICAvLyBGSVhNRTogVE9ETzogVGhlIGFib3ZlLlxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX1gKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IFNlc3Npb25EaWFsb2cgfSBmcm9tIFwiLi4vZGlhbG9nc1wiO1xuaW1wb3J0IHtcbiAgSW5jb21pbmdJbnZpdGVSZXF1ZXN0LFxuICBJbmNvbWluZ1JlcXVlc3REZWxlZ2F0ZSxcbiAgSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgT3V0Z29pbmdSZXNwb25zZSxcbiAgT3V0Z29pbmdSZXNwb25zZVdpdGhTZXNzaW9uLFxuICBSZXNwb25zZU9wdGlvbnMsXG4gIFVSSVxufSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IEludml0ZVNlcnZlclRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50U2VydmVyIH0gZnJvbSBcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIjtcblxuLyoqXG4gKiBSZS1JTlZJVEUgVUFTLlxuICogQHJlbWFya3NcbiAqIDE0IE1vZGlmeWluZyBhbiBFeGlzdGluZyBTZXNzaW9uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE0XG4gKiAxNC4yIFVBUyBCZWhhdmlvclxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNC4yXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZUludml0ZVVzZXJBZ2VudFNlcnZlciBleHRlbmRzIFVzZXJBZ2VudFNlcnZlciBpbXBsZW1lbnRzIEluY29taW5nSW52aXRlUmVxdWVzdCB7XG4gIHByaXZhdGUgZGlhbG9nOiBTZXNzaW9uRGlhbG9nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGRpYWxvZzogU2Vzc2lvbkRpYWxvZyxcbiAgICBtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGRlbGVnYXRlPzogSW5jb21pbmdSZXF1ZXN0RGVsZWdhdGVcbiAgKSB7XG4gICAgc3VwZXIoSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIGRpYWxvZy51c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSk7XG4gICAgZGlhbG9nLnJlaW52aXRlVXNlckFnZW50U2VydmVyID0gdGhpcztcbiAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGUgb24gYSAyeHggcmVzcG9uc2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBwdWJsaWMgYWNjZXB0KG9wdGlvbnM6IFJlc3BvbnNlT3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogMjAwIH0pOiBPdXRnb2luZ1Jlc3BvbnNlV2l0aFNlc3Npb24ge1xuXG4gICAgLy8gRklYTUU6IFRoZSBuZXh0IHR3byBsaW5lcyBTSE9VTEQgZ28gYXdheSwgYnV0IEkgc3VwcG9zZSBpdCdzIHRlY2huaWNhbGx5IGhhcm1sZXNzLi4uXG4gICAgLy8gVGhlc2UgYXJlIGhlcmUgYmVjYXVzZSBzb21lIHZlcnNpb25zIG9mIFNJUC5qcyBwcmlvciB0byAwLjEzLjggc2V0IHRoZSByb3V0ZSBzZXRcbiAgICAvLyBvZiBhbGwgaW4gZGlhbG9nIEFDS3MgYmFzZWQgb24gdGhlIFJlY29yZC1Sb3V0ZSBoZWFkZXJzIGluIHRoZSBhc3NvY2lhdGVkIDJ4eFxuICAgIC8vIHJlc3BvbnNlLiBXaGlsZSB0aGlzIHdvcmtlZCBmb3IgZGlhbG9nIGZvcm1pbmcgMnh4IHJlc3BvbnNlcywgaXQgd2FzIHRlY2huaWNhbGx5XG4gICAgLy8gYnJva2VuIGZvciByZS1JTlZJVEUgQUNLUyBhcyBpdCBvbmx5IHdvcmtlZCBpZiB0aGUgVUFTIHBvcHVsYXRlZCB0aGUgUmVjb3JkLVJvdXRlXG4gICAgLy8gaGVhZGVycyBpbiB0aGUgcmUtSU5WSVRFIDJ4eCByZXNwb25zZSAod2hpY2ggaXMgbm90IHJlcXVpcmVkIGFuZCBhIHdhc3RlIG9mIGJhbmR3aWR0aFxuICAgIC8vIGFzIHRoZSBzaG91bGQgYmUgaWdub3JlZCBpZiBwcmVzZW50IGluIHJlLUlOVklURSBBQ0tTKSBhbmQgdGhlIFVBUyBwb3B1bGF0ZWRcbiAgICAvLyB0aGUgUmVjb3JkLVJvdXRlIGhlYWRlcnMgd2l0aCB0aGUgY29ycmVjdCB2YWx1ZXMgKHdvdWxkIGJlIHdlaXJkIG5vdCB0b28sIGJ1dC4uLikuXG4gICAgLy8gQW55d2F5LCBmb3Igbm93IHRoZSB0ZWNobmljYWxseSB1c2VsZXNzIFJlY29yZC1Sb3V0ZSBoZWFkZXJzIGFyZSBiZWluZyBhZGRlZFxuICAgIC8vIHRvIG1haW50YWluIFwiYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcIiB3aXRoIHRoZSBvbGRlciBicm9rZW4gdmVyc2lvbnMgb2YgU0lQLmpzLlxuICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycy5jb25jYXQodGhpcy5kaWFsb2cucm91dGVTZXQubWFwKChyb3V0ZSkgPT4gYFJlY29yZC1Sb3V0ZTogJHtyb3V0ZX1gKSk7XG5cbiAgICAvLyBTZW5kIGFuZCByZXR1cm4gdGhlIHJlc3BvbnNlXG4gICAgY29uc3QgcmVzcG9uc2UgPSBzdXBlci5hY2NlcHQob3B0aW9ucyk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuZGlhbG9nO1xuICAgIGNvbnN0IHJlc3VsdDogT3V0Z29pbmdSZXNwb25zZVdpdGhTZXNzaW9uID0geyAuLi5yZXNwb25zZSwgc2Vzc2lvbiB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgICAgLy8gVXBkYXRlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGUgd2l0aCBvZmZlci9hbnN3ZXIgaW4gYm9keVxuICAgICAgdGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG9wdGlvbnMuYm9keSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGRpYWxvZ1xuICAgIHRoaXMuZGlhbG9nLnJlQ29uZmlybSgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGUgb24gYSAxeHggcmVzcG9uc2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUHJvZ3Jlc3Mgb3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBwdWJsaWMgcHJvZ3Jlc3Mob3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0geyBzdGF0dXNDb2RlOiAxODAgfSk6IE91dGdvaW5nUmVzcG9uc2VXaXRoU2Vzc2lvbiB7XG4gICAgLy8gU2VuZCBhbmQgcmV0dXJuIHRoZSByZXNwb25zZVxuICAgIGNvbnN0IHJlc3BvbnNlID0gc3VwZXIucHJvZ3Jlc3Mob3B0aW9ucyk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuZGlhbG9nO1xuICAgIGNvbnN0IHJlc3VsdDogT3V0Z29pbmdSZXNwb25zZVdpdGhTZXNzaW9uID0geyAuLi5yZXNwb25zZSwgc2Vzc2lvbiB9O1xuXG4gICAgLy8gVXBkYXRlIGRpYWxvZyBzaWduYWxpbmcgc3RhdGVcbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24ob3B0aW9ucy5ib2R5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IE5vdCBZZXQgU3VwcG9ydGVkXG4gICAqIEBwYXJhbSBjb250YWN0cyAtIENvbnRhY3RzIHRvIHJlZGlyZWN0IHRvLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlZGlyZWN0IG9wdGlvbnMgYnVja2V0LlxuICAgKi9cbiAgcHVibGljIHJlZGlyZWN0KGNvbnRhY3RzOiBBcnJheTxVUkk+LCBvcHRpb25zOiBSZXNwb25zZU9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDMwMiB9KTogT3V0Z29pbmdSZXNwb25zZSB7XG4gICAgdGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGVSb2xsYmFjaygpO1xuICAgIHRoaXMuZGlhbG9nLnJlaW52aXRlVXNlckFnZW50U2VydmVyID0gdW5kZWZpbmVkOyAvLyBBQ0sgd2lsbCBiZSBoYW5kbGVkIGJ5IHRyYW5zYWN0aW9uXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZC5cIik7XG4gIH1cblxuICAvKipcbiAgICogMy4xIEJhY2tncm91bmQgb24gUmUtSU5WSVRFIEhhbmRsaW5nIGJ5IFVBU3NcbiAgICogQW4gZXJyb3IgcmVzcG9uc2UgdG8gYSByZS1JTlZJVEUgaGFzIHRoZSBmb2xsb3dpbmcgc2VtYW50aWNzLiAgQXNcbiAgICogc3BlY2lmaWVkIGluIFNlY3Rpb24gMTIuMi4yIG9mIFJGQyAzMjYxIFtSRkMzMjYxXSwgaWYgYSByZS1JTlZJVEUgaXNcbiAgICogcmVqZWN0ZWQsIG5vIHN0YXRlIGNoYW5nZXMgYXJlIHBlcmZvcm1lZC5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYxNDEjc2VjdGlvbi0zLjFcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZWplY3Qgb3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBwdWJsaWMgcmVqZWN0KG9wdGlvbnM6IFJlc3BvbnNlT3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogNDg4IH0pOiBPdXRnb2luZ1Jlc3BvbnNlIHtcbiAgICB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZVJvbGxiYWNrKCk7XG4gICAgdGhpcy5kaWFsb2cucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIgPSB1bmRlZmluZWQ7IC8vIEFDSyB3aWxsIGJlIGhhbmRsZWQgYnkgdHJhbnNhY3Rpb25cbiAgICByZXR1cm4gc3VwZXIucmVqZWN0KG9wdGlvbnMpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBTdWJzY3JpcHRpb25EaWFsb2cgfSBmcm9tIFwiLi4vZGlhbG9nc1wiO1xuaW1wb3J0IHtcbiAgQyxcbiAgSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UsXG4gIE91dGdvaW5nUmVxdWVzdERlbGVnYXRlLFxuICBPdXRnb2luZ1N1YnNjcmliZVJlcXVlc3QsXG4gIFJlcXVlc3RPcHRpb25zXG59IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRDbGllbnQgfSBmcm9tIFwiLi91c2VyLWFnZW50LWNsaWVudFwiO1xuXG4vKipcbiAqIFJlLVNVQlNDUklCRSBVQUMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZVN1YnNjcmliZVVzZXJBZ2VudENsaWVudCBleHRlbmRzIFVzZXJBZ2VudENsaWVudCBpbXBsZW1lbnRzIE91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdCB7XG4gIHByaXZhdGUgZGlhbG9nOiBTdWJzY3JpcHRpb25EaWFsb2c7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgZGlhbG9nOiBTdWJzY3JpcHRpb25EaWFsb2csXG4gICAgZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSxcbiAgICBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRpYWxvZy5jcmVhdGVPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKEMuU1VCU0NSSUJFLCBvcHRpb25zKTtcbiAgICBzdXBlcihOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcbiAgfVxuXG4gIHB1YmxpYyB3YWl0Tm90aWZ5U3RvcCgpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBQbGFjZWhvbGRlci4gTm90IHV0aWxpemVkIGN1cnJlbnRseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUmVjZWl2ZSBhIHJlc3BvbnNlIGZyb20gdGhlIHRyYW5zYWN0aW9uIGxheWVyLlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlc3BvbnNlIG1lc3NhZ2UuXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2U6IEluY29taW5nUmVzcG9uc2VNZXNzYWdlKTogdm9pZCB7XG4gICAgaWYgKG1lc3NhZ2Uuc3RhdHVzQ29kZSAmJiBtZXNzYWdlLnN0YXR1c0NvZGUgPj0gMjAwICYmIG1lc3NhZ2Uuc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgICAgLy8gIFRoZSBcIkV4cGlyZXNcIiBoZWFkZXIgZmllbGQgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gU1VCU0NSSUJFXG4gICAgICAvLyAgcmVxdWVzdCBpbmRpY2F0ZXMgdGhlIGFjdHVhbCBkdXJhdGlvbiBmb3Igd2hpY2ggdGhlIHN1YnNjcmlwdGlvbiB3aWxsXG4gICAgICAvLyAgcmVtYWluIGFjdGl2ZSAodW5sZXNzIHJlZnJlc2hlZCkuICBUaGUgcmVjZWl2ZWQgdmFsdWUgbWlnaHQgYmVcbiAgICAgIC8vICBzbWFsbGVyIHRoYW4gdGhlIHZhbHVlIGluZGljYXRlZCBpbiB0aGUgU1VCU0NSSUJFIHJlcXVlc3QgYnV0IGNhbm5vdFxuICAgICAgLy8gIGJlIGxhcmdlcjsgc2VlIFNlY3Rpb24gNC4yLjEgZm9yIGRldGFpbHMuXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjFcbiAgICAgIGNvbnN0IGV4cGlyZXMgPSBtZXNzYWdlLmdldEhlYWRlcihcIkV4cGlyZXNcIik7XG4gICAgICBpZiAoIWV4cGlyZXMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkV4cGlyZXMgaGVhZGVyIG1pc3NpbmcgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gU1VCU0NSSUJFXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uRXhwaXJlc1JlY2VpdmVkID0gTnVtYmVyKGV4cGlyZXMpO1xuICAgICAgICBpZiAodGhpcy5kaWFsb2cuc3Vic2NyaXB0aW9uRXhwaXJlcyA+IHN1YnNjcmlwdGlvbkV4cGlyZXNSZWNlaXZlZCkge1xuICAgICAgICAgIHRoaXMuZGlhbG9nLnN1YnNjcmlwdGlvbkV4cGlyZXMgPSBzdWJzY3JpcHRpb25FeHBpcmVzUmVjZWl2ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS5zdGF0dXNDb2RlICYmIG1lc3NhZ2Uuc3RhdHVzQ29kZSA+PSA0MDAgJiYgbWVzc2FnZS5zdGF0dXNDb2RlIDwgNzAwKSB7XG4gICAgICAvLyBJZiBhIFNVQlNDUklCRSByZXF1ZXN0IHRvIHJlZnJlc2ggYSBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgYSA0MDQsIDQwNSxcbiAgICAgIC8vIDQxMCwgNDE2LCA0ODAtNDg1LCA0ODksIDUwMSwgb3IgNjA0IHJlc3BvbnNlLCB0aGUgc3Vic2NyaWJlciBNVVNUXG4gICAgICAvLyBjb25zaWRlciB0aGUgc3Vic2NyaXB0aW9uIHRlcm1pbmF0ZWQuICAoU2VlIFtSRkM1MDU3XSBmb3IgZnVydGhlclxuICAgICAgLy8gZGV0YWlscyBhbmQgbm90ZXMgYWJvdXQgdGhlIGVmZmVjdCBvZiBlcnJvciBjb2RlcyBvbiBkaWFsb2dzIGFuZFxuICAgICAgLy8gdXNhZ2VzIHdpdGhpbiBkaWFsb2csIHN1Y2ggYXMgc3Vic2NyaXB0aW9ucykuICBJZiB0aGUgc3Vic2NyaWJlclxuICAgICAgLy8gd2lzaGVzIHRvIHJlLXN1YnNjcmliZSB0byB0aGUgc3RhdGUsIGhlIGRvZXMgc28gYnkgY29tcG9zaW5nIGFuXG4gICAgICAvLyB1bnJlbGF0ZWQgaW5pdGlhbCBTVUJTQ1JJQkUgcmVxdWVzdCB3aXRoIGEgZnJlc2hseSBnZW5lcmF0ZWQgQ2FsbC1JRFxuICAgICAgLy8gYW5kIGEgbmV3LCB1bmlxdWUgXCJGcm9tXCIgdGFnIChzZWUgU2VjdGlvbiA0LjEuMi4xKS5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMlxuICAgICAgY29uc3QgZXJyb3JDb2RlcyA9IFs0MDQsIDQwNSwgNDEwLCA0MTYsIDQ4MCwgNDgxLCA0ODIsIDQ4MywgNDg0LCA0ODUsIDQ4OSwgNTAxLCA2MDRdO1xuICAgICAgaWYgKGVycm9yQ29kZXMuaW5kZXhPZihtZXNzYWdlLnN0YXR1c0NvZGUpICE9PSAtMSkge1xuICAgICAgICB0aGlzLmRpYWxvZy50ZXJtaW5hdGUoKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIGEgU1VCU0NSSUJFIHJlcXVlc3QgdG8gcmVmcmVzaCBhIHN1YnNjcmlwdGlvbiBmYWlscyB3aXRoIGFueSBlcnJvclxuICAgICAgLy8gY29kZSBvdGhlciB0aGFuIHRob3NlIGxpc3RlZCBhYm92ZSwgdGhlIG9yaWdpbmFsIHN1YnNjcmlwdGlvbiBpc1xuICAgICAgLy8gc3RpbGwgY29uc2lkZXJlZCB2YWxpZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBtb3N0IHJlY2VudGx5IGtub3duXG4gICAgICAvLyBcIkV4cGlyZXNcIiB2YWx1ZSBhcyBuZWdvdGlhdGVkIGJ5IHRoZSBtb3N0IHJlY2VudCBzdWNjZXNzZnVsIFNVQlNDUklCRVxuICAgICAgLy8gdHJhbnNhY3Rpb24sIG9yIGFzIGNvbW11bmljYXRlZCBieSBhIE5PVElGWSByZXF1ZXN0IGluIGl0c1xuICAgICAgLy8gXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBoZWFkZXIgZmllbGQgXCJleHBpcmVzXCIgcGFyYW1ldGVyLlxuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4yXG4gICAgfVxuXG4gICAgc3VwZXIucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaWFsb2cgfSBmcm9tIFwiLi4vZGlhbG9nc1wiO1xuaW1wb3J0IHsgSW5jb21pbmdSZXF1ZXN0RGVsZWdhdGUsIEluY29taW5nUmVxdWVzdE1lc3NhZ2UsIEluY29taW5nU3Vic2NyaWJlUmVxdWVzdCB9IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRTZXJ2ZXIgfSBmcm9tIFwiLi91c2VyLWFnZW50LXNlcnZlclwiO1xuXG4vKipcbiAqIFJlLVNVQlNDUklCRSBVQVMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZVN1YnNjcmliZVVzZXJBZ2VudFNlcnZlciBleHRlbmRzIFVzZXJBZ2VudFNlcnZlciBpbXBsZW1lbnRzIEluY29taW5nU3Vic2NyaWJlUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgZGlhbG9nOiBEaWFsb2csXG4gICAgbWVzc2FnZTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICBkZWxlZ2F0ZT86IEluY29taW5nUmVxdWVzdERlbGVnYXRlXG4gICkge1xuICAgIHN1cGVyKE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBTZXNzaW9uRGlhbG9nIH0gZnJvbSBcIi4uL2RpYWxvZ3NcIjtcbmltcG9ydCB7IEMsIE91dGdvaW5nUmVmZXJSZXF1ZXN0LCBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50Q2xpZW50IH0gZnJvbSBcIi4vdXNlci1hZ2VudC1jbGllbnRcIjtcblxuLyoqXG4gKiBSRUZFUiBVQUMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWZlclVzZXJBZ2VudENsaWVudCBleHRlbmRzIFVzZXJBZ2VudENsaWVudCBpbXBsZW1lbnRzIE91dGdvaW5nUmVmZXJSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgZGlhbG9nOiBTZXNzaW9uRGlhbG9nLFxuICAgIGRlbGVnYXRlPzogT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGUsXG4gICAgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zXG4gICkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkaWFsb2cuY3JlYXRlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShDLlJFRkVSLCBvcHRpb25zKTtcbiAgICBzdXBlcihOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgU2Vzc2lvbkRpYWxvZyB9IGZyb20gXCIuLi9kaWFsb2dzXCI7XG5pbXBvcnQgeyBJbmNvbWluZ1JlZmVyUmVxdWVzdCwgSW5jb21pbmdSZXF1ZXN0RGVsZWdhdGUsIEluY29taW5nUmVxdWVzdE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50Q29yZSB9IGZyb20gXCIuLi91c2VyLWFnZW50LWNvcmVcIjtcbmltcG9ydCB7IFVzZXJBZ2VudFNlcnZlciB9IGZyb20gXCIuL3VzZXItYWdlbnQtc2VydmVyXCI7XG5cbi8qKlxuICogUkVGRVIgVUFTLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVmZXJVc2VyQWdlbnRTZXJ2ZXIgZXh0ZW5kcyBVc2VyQWdlbnRTZXJ2ZXIgaW1wbGVtZW50cyBJbmNvbWluZ1JlZmVyUmVxdWVzdCB7XG4gIC8qKlxuICAgKiBSRUZFUiBVQVMgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSBkaWFsb2dPckNvcmUgLSBEaWFsb2cgZm9yIGluIGRpYWxvZyBSRUZFUiwgVXNlckFnZW50Q29yZSBmb3Igb3V0IG9mIGRpYWxvZyBSRUZFUi5cbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyBSRUZFUiByZXF1ZXN0IG1lc3NhZ2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBkaWFsb2dPckNvcmU6IFNlc3Npb25EaWFsb2cgfCBVc2VyQWdlbnRDb3JlLFxuICAgIG1lc3NhZ2U6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UsXG4gICAgZGVsZWdhdGU/OiBJbmNvbWluZ1JlcXVlc3REZWxlZ2F0ZVxuICApIHtcbiAgICBjb25zdCB1c2VyQWdlbnRDb3JlID1cbiAgICAgIGluc3RhbmNlT2ZTZXNzaW9uRGlhbG9nKGRpYWxvZ09yQ29yZSkgP1xuICAgICAgICBkaWFsb2dPckNvcmUudXNlckFnZW50Q29yZSA6XG4gICAgICAgIGRpYWxvZ09yQ29yZTtcbiAgICBzdXBlcihOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgdXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlT2ZTZXNzaW9uRGlhbG9nKG9iamVjdDogYW55KTogb2JqZWN0IGlzIFNlc3Npb25EaWFsb2cge1xuICByZXR1cm4gb2JqZWN0LnVzZXJBZ2VudENvcmUgIT09IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB7IE91dGdvaW5nUmVnaXN0ZXJSZXF1ZXN0LCBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSwgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRDb3JlIH0gZnJvbSBcIi4uL3VzZXItYWdlbnQtY29yZVwiO1xuaW1wb3J0IHsgVXNlckFnZW50Q2xpZW50IH0gZnJvbSBcIi4vdXNlci1hZ2VudC1jbGllbnRcIjtcblxuLyoqXG4gKiBSRUdJU1RFUiBVQUMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RlclVzZXJBZ2VudENsaWVudCBleHRlbmRzIFVzZXJBZ2VudENsaWVudCBpbXBsZW1lbnRzIE91dGdvaW5nUmVnaXN0ZXJSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgY29yZTogVXNlckFnZW50Q29yZSxcbiAgICBtZXNzYWdlOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGRlbGVnYXRlPzogT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGVcbiAgKSB7XG4gICAgc3VwZXIoTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW5jb21pbmdSZWdpc3RlclJlcXVlc3QsIEluY29taW5nUmVxdWVzdERlbGVnYXRlLCBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENvcmUgfSBmcm9tIFwiLi4vdXNlci1hZ2VudC1jb3JlXCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRTZXJ2ZXIgfSBmcm9tIFwiLi91c2VyLWFnZW50LXNlcnZlclwiO1xuXG4vKipcbiAqIFJFR0lTVEVSIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ2lzdGVyVXNlckFnZW50U2VydmVyIGV4dGVuZHMgVXNlckFnZW50U2VydmVyIGltcGxlbWVudHMgSW5jb21pbmdSZWdpc3RlclJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgY29yZTogVXNlckFnZW50Q29yZSxcbiAgICBtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGRlbGVnYXRlPzogSW5jb21pbmdSZXF1ZXN0RGVsZWdhdGVcbiAgKSB7XG4gICAgc3VwZXIoTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgU3Vic2NyaXB0aW9uRGlhbG9nIH0gZnJvbSBcIi4uL2RpYWxvZ3Mvc3Vic2NyaXB0aW9uLWRpYWxvZ1wiO1xuaW1wb3J0IHtcbiAgSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UsXG4gIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UsXG4gIE91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdCxcbiAgT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0RGVsZWdhdGVcbn0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25TdGF0ZSB9IGZyb20gXCIuLi9zdWJzY3JpcHRpb25cIjtcbmltcG9ydCB7IFRpbWVycyB9IGZyb20gXCIuLi90aW1lcnNcIjtcbmltcG9ydCB7IE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50Q29yZSB9IGZyb20gXCIuLi91c2VyLWFnZW50LWNvcmVcIjtcbmltcG9ydCB7IE5vdGlmeVVzZXJBZ2VudFNlcnZlciB9IGZyb20gXCIuL25vdGlmeS11c2VyLWFnZW50LXNlcnZlclwiO1xuaW1wb3J0IHsgVXNlckFnZW50Q2xpZW50IH0gZnJvbSBcIi4vdXNlci1hZ2VudC1jbGllbnRcIjtcblxuLyoqXG4gKiBTVUJTQ1JJQkUgVUFDLlxuICogQHJlbWFya3NcbiAqIDQuMS4gIFN1YnNjcmliZXIgQmVoYXZpb3JcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xXG4gKlxuICogVXNlciBhZ2VudCBjbGllbnQgZm9yIGluc3RhbGxhdGlvbiBvZiBhIHNpbmdsZSBzdWJzY3JpcHRpb24gcGVyIFNVQlNDUklCRSByZXF1ZXN0LlxuICogVE9ETzogU3VwcG9ydCBmb3IgaW5zdGFsbGF0aW9uIG9mIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgb24gZm9ya2VkIFNVQlNDUklCRSByZXFldWVzdHMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQgZXh0ZW5kcyBVc2VyQWdlbnRDbGllbnQgaW1wbGVtZW50cyBPdXRnb2luZ1N1YnNjcmliZVJlcXVlc3Qge1xuICBwdWJsaWMgZGVsZWdhdGU6IE91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdERlbGVnYXRlIHwgdW5kZWZpbmVkO1xuXG4gIC8qKiBEaWFsb2cgY3JlYXRlZCB1cG9uIHJlY2VpdmluZyB0aGUgZmlyc3QgTk9USUZZLiAqL1xuICBwcml2YXRlIGRpYWxvZzogU3Vic2NyaXB0aW9uRGlhbG9nIHwgdW5kZWZpbmVkO1xuICAvKiogSWRlbnRpZmllciBvZiB0aGlzIHVzZXIgYWdlbnQgY2xpZW50LiAqL1xuICBwcml2YXRlIHN1YnNjcmliZXJJZDogc3RyaW5nO1xuICAvKiogV2hlbiB0aGUgc3Vic2NyaXB0aW9uIGV4cGlyZXMuIFN0YXJ0cyBhcyByZXF1ZXN0ZWQgZXhwaXJlcyBhbmQgdXBkYXRlZCBvbiAyMDAgYW5kIE5PVElGWS4gKi9cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25FeHBpcmVzOiBudW1iZXI7XG4gIC8qKiBUaGUgcmVxdWVzdGVkIGV4cGlyZXMgZm9yIHRoZSBzdWJzY3JpcHRpb24uICovXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uRXhwaXJlc1JlcXVlc3RlZDogbnVtYmVyO1xuICAvKiogU3Vic2NyaXB0aW9uIGV2ZW50IGJlaW5nIHRhcmdldGVkLiAqL1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbkV2ZW50OiBzdHJpbmc7XG4gIC8qKiBTdWJzY3JpcHRpb24gc3RhdGUuICovXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uU3RhdGU6IFN1YnNjcmlwdGlvblN0YXRlO1xuICAvKiogVGltZXIgTiBJZC4gKi9cbiAgcHJpdmF0ZSBOOiBhbnkgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY29yZTogVXNlckFnZW50Q29yZSxcbiAgICBtZXNzYWdlOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICAgIGRlbGVnYXRlPzogT3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0RGVsZWdhdGVcbiAgKSB7XG4gICAgLy8gR2V0IGV2ZW50IGZyb20gcmVxdWVzdCBtZXNzYWdlLlxuICAgIGNvbnN0IGV2ZW50ID0gbWVzc2FnZS5nZXRIZWFkZXIoXCJFdmVudFwiKTtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCB1bmRlZmluZWRcIik7XG4gICAgfVxuICAgIC8vIEdldCBleHBpcmVzIGZyb20gcmVxZXVzdCBtZXNzYWdlLlxuICAgIGNvbnN0IGV4cGlyZXMgPSBtZXNzYWdlLmdldEhlYWRlcihcIkV4cGlyZXNcIik7XG4gICAgaWYgKCFleHBpcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBpcmVzIHVuZGVmaW5lZFwiKTtcbiAgICB9XG4gICAgc3VwZXIoTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKTtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG5cbiAgICAvLyBGSVhNRTogU3Vic2NyaWJlciBpZCBzaG91bGQgYWxzbyBiZSBtYXRjaGluZyBvbiBldmVudCBpZC5cbiAgICB0aGlzLnN1YnNjcmliZXJJZCA9IG1lc3NhZ2UuY2FsbElkICsgbWVzc2FnZS5mcm9tVGFnICsgZXZlbnQ7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzUmVxdWVzdGVkID0gdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzID0gTnVtYmVyKGV4cGlyZXMpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uRXZlbnQgPSBldmVudDtcbiAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlID0gU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdDtcblxuICAgIC8vIFN0YXJ0IHdhaXRpbmcgZm9yIGEgTk9USUZZIHdlIGNhbiB1c2UgdG8gY3JlYXRlIGEgc3Vic2NyaXB0aW9uLlxuICAgIHRoaXMud2FpdE5vdGlmeVN0YXJ0KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJ1Y3Rvci5cbiAgICogTm90ZSB0aGF0IFRpbWVyIE4gbWF5IGxpdmUgb24gd2FpdGluZyBmb3IgYW4gaW5pdGlhbCBOT1RJRlkgYW5kXG4gICAqIHRoZSBkZWxlZ2F0ZSBtYXkgc3RpbGwgcmVjZWl2ZSB0aGF0IE5PVElGWS4gSWYgeW91IGRvbid0IHdhbnRcbiAgICogdGhhdCBiZWhhdmlvciB0aGVuIGVpdGhlciBjbGVhciB0aGUgZGVsZWdhdGUgc28gdGhlIGRlbGVnYXRlXG4gICAqIGRvZXNuJ3QgZ2V0IGNhbGxlZCAoYSAyMDAgd2lsbCBiZSBzZW50IGluIHJlc3BvbnNlIHRvIHRoZSBOT1RJRlkpXG4gICAqIG9yIGNhbGwgYHdhaXROb3RpZnlTdG9wYCB3aGljaCB3aWxsIGNsZWFyIFRpbWVyIE4gYW5kIHJlbW92ZSB0aGlzXG4gICAqIFVBQyBmcm9tIHRoZSBjb3JlIChhIDQ4MSB3aWxsIGJlIHNlbnQgaW4gcmVzcG9uc2UgdG8gdGhlIE5PVElGWSkuXG4gICAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIG91dCBvZiBkaWFsb2cgTk9USUZZIGFzc29pY2F0ZWQgd2l0aCBTVUJTQ1JJQkUgcmVxdWVzdC5cbiAgICogVGhpcyBpcyB0aGUgZmlyc3QgTk9USUZZIHJlY2VpdmVkIGFmdGVyIHRoZSBTVUJTQ1JJQkUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHVhcyAtIFVzZXIgYWdlbnQgc2VydmVyIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb24gY3JlYXRpbmcgTk9USUZZLlxuICAgKi9cbiAgcHVibGljIG9uTm90aWZ5KHVhczogTm90aWZ5VXNlckFnZW50U2VydmVyKTogdm9pZCB7XG4gICAgLy8gTk9USUZZIHJlcXVlc3RzIGFyZSBtYXRjaGVkIHRvIHN1Y2ggU1VCU0NSSUJFIHJlcXVlc3RzIGlmIHRoZXlcbiAgICAvLyBjb250YWluIHRoZSBzYW1lIFwiQ2FsbC1JRFwiLCBhIFwiVG9cIiBoZWFkZXIgZmllbGQgXCJ0YWdcIiBwYXJhbWV0ZXIgdGhhdFxuICAgIC8vIG1hdGNoZXMgdGhlIFwiRnJvbVwiIGhlYWRlciBmaWVsZCBcInRhZ1wiIHBhcmFtZXRlciBvZiB0aGUgU1VCU0NSSUJFXG4gICAgLy8gcmVxdWVzdCwgYW5kIHRoZSBzYW1lIFwiRXZlbnRcIiBoZWFkZXIgZmllbGQuICBSdWxlcyBmb3IgY29tcGFyaXNvbnMgb2ZcbiAgICAvLyB0aGUgXCJFdmVudFwiIGhlYWRlciBmaWVsZHMgYXJlIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDguMi4xLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC40LjFcbiAgICBjb25zdCBldmVudDogc3RyaW5nID0gdWFzLm1lc3NhZ2UucGFyc2VIZWFkZXIoXCJFdmVudFwiKS5ldmVudDtcbiAgICBpZiAoIWV2ZW50IHx8IGV2ZW50ICE9PSB0aGlzLnN1YnNjcmlwdGlvbkV2ZW50KSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBGYWlsZWQgdG8gcGFyc2UgZXZlbnQuYCk7XG4gICAgICB1YXMucmVqZWN0KHsgc3RhdHVzQ29kZTogNDg5IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5PVElGWSByZXF1ZXN0cyBNVVNUIGNvbnRhaW4gXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBoZWFkZXIgZmllbGRzIHRoYXRcbiAgICAvLyBpbmRpY2F0ZSB0aGUgc3RhdHVzIG9mIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuM1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvblN0YXRlID0gdWFzLm1lc3NhZ2UucGFyc2VIZWFkZXIoXCJTdWJzY3JpcHRpb24tU3RhdGVcIik7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25TdGF0ZSB8fCAhc3Vic2NyaXB0aW9uU3RhdGUuc3RhdGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJGYWlsZWQgdG8gcGFyc2Ugc3Vic2NyaXB0aW9uIHN0YXRlLlwiKTtcbiAgICAgIHVhcy5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODkgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHN1YnNjcmlwdGlvbiBzdGF0ZS5cbiAgICBjb25zdCBzdGF0ZTogc3RyaW5nID0gc3Vic2NyaXB0aW9uU3RhdGUuc3RhdGU7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWN0aXZlXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRlcm1pbmF0ZWRcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBJbnZhbGlkIHN1YnNjcmlwdGlvbiBzdGF0ZSAke3N0YXRlfWApO1xuICAgICAgICB1YXMucmVqZWN0KHsgc3RhdHVzQ29kZTogNDg5IH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGlhbG9ncyB1c2FnZXMgYXJlIGNyZWF0ZWQgdXBvbiBjb21wbGV0aW9uIG9mIGEgTk9USUZZIHRyYW5zYWN0aW9uXG4gICAgLy8gZm9yIGEgbmV3IHN1YnNjcmlwdGlvbiwgdW5sZXNzIHRoZSBOT1RJRlkgcmVxdWVzdCBjb250YWlucyBhXG4gICAgLy8gXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBvZiBcInRlcm1pbmF0ZWQuXCJcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuNC4xXG4gICAgaWYgKHN0YXRlICE9PSBcInRlcm1pbmF0ZWRcIikge1xuICAgICAgLy8gVGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIE1VU1QgYmUgcHJlc2VudCBhbmQgY29udGFpbiBleGFjdGx5IG9uZSBTSVBcbiAgICAgIC8vIG9yIFNJUFMgVVJJIGluIGFueSByZXF1ZXN0IHRoYXQgY2FuIHJlc3VsdCBpbiB0aGUgZXN0YWJsaXNobWVudCBvZiBhXG4gICAgICAvLyBkaWFsb2cuXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4xLjhcbiAgICAgIGNvbnN0IGNvbnRhY3QgPSB1YXMubWVzc2FnZS5wYXJzZUhlYWRlcihcImNvbnRhY3RcIik7XG4gICAgICBpZiAoIWNvbnRhY3QpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkZhaWxlZCB0byBwYXJzZSBjb250YWN0LlwiKTtcbiAgICAgICAgdWFzLnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4OSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluIGFjY29yZGFuY2Ugd2l0aCB0aGUgcnVsZXMgZm9yIHByb3h5aW5nIG5vbi1JTlZJVEUgcmVxdWVzdHMgYXNcbiAgICAvLyBkZWZpbmVkIGluIFtSRkMzMjYxXSwgc3VjY2Vzc2Z1bCBTVUJTQ1JJQkUgcmVxdWVzdHMgd2lsbCByZWNlaXZlIG9ubHlcbiAgICAvLyBvbmUgMjAwLWNsYXNzIHJlc3BvbnNlOyBob3dldmVyLCBkdWUgdG8gZm9ya2luZywgdGhlIHN1YnNjcmlwdGlvbiBtYXlcbiAgICAvLyBoYXZlIGJlZW4gYWNjZXB0ZWQgYnkgbXVsdGlwbGUgbm9kZXMuICBUaGUgc3Vic2NyaWJlciBNVVNUIHRoZXJlZm9yZVxuICAgIC8vIGJlIHByZXBhcmVkIHRvIHJlY2VpdmUgTk9USUZZIHJlcXVlc3RzIHdpdGggXCJGcm9tOlwiIHRhZ3MgdGhhdCBkaWZmZXJcbiAgICAvLyBmcm9tIHRoZSBcIlRvOlwiIHRhZyByZWNlaXZlZCBpbiB0aGUgU1VCU0NSSUJFIDIwMC1jbGFzcyByZXNwb25zZS5cbiAgICAvL1xuICAgIC8vIElmIG11bHRpcGxlIE5PVElGWSByZXF1ZXN0cyBhcmUgcmVjZWl2ZWQgaW4gZGlmZmVyZW50IGRpYWxvZ3MgaW5cbiAgICAvLyByZXNwb25zZSB0byBhIHNpbmdsZSBTVUJTQ1JJQkUgcmVxdWVzdCwgZWFjaCBkaWFsb2cgcmVwcmVzZW50cyBhXG4gICAgLy8gZGlmZmVyZW50IGRlc3RpbmF0aW9uIHRvIHdoaWNoIHRoZSBTVUJTQ1JJQkUgcmVxdWVzdCB3YXMgZm9ya2VkLlxuICAgIC8vIFN1YnNjcmliZXIgaGFuZGxpbmcgaW4gc3VjaCBzaXR1YXRpb25zIHZhcmllcyBieSBldmVudCBwYWNrYWdlOyBzZWVcbiAgICAvLyBTZWN0aW9uIDUuNC45IGZvciBkZXRhaWxzLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjRcblxuICAgIC8vIEVhY2ggZXZlbnQgcGFja2FnZSBNVVNUIHNwZWNpZnkgd2hldGhlciBmb3JrZWQgU1VCU0NSSUJFIHJlcXVlc3RzIGFyZVxuICAgIC8vIGFsbG93ZWQgdG8gaW5zdGFsbCBtdWx0aXBsZSBzdWJzY3JpcHRpb25zLlxuICAgIC8vXG4gICAgLy8gSWYgc3VjaCBiZWhhdmlvciBpcyBub3QgYWxsb3dlZCwgdGhlIGZpcnN0IHBvdGVudGlhbCBkaWFsb2ctXG4gICAgLy8gZXN0YWJsaXNoaW5nIG1lc3NhZ2Ugd2lsbCBjcmVhdGUgYSBkaWFsb2cuICBBbGwgc3Vic2VxdWVudCBOT1RJRllcbiAgICAvLyByZXF1ZXN0cyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIFNVQlNDUklCRSByZXF1ZXN0IChpLmUuLCBoYXZlXG4gICAgLy8gbWF0Y2hpbmcgXCJUb1wiLCBcIkZyb21cIiwgXCJDYWxsLUlEXCIsIGFuZCBcIkV2ZW50XCIgaGVhZGVyIGZpZWxkcywgYXMgd2VsbFxuICAgIC8vIGFzIFwiRnJvbVwiIGhlYWRlciBmaWVsZCBcInRhZ1wiIHBhcmFtZXRlciBhbmQgXCJFdmVudFwiIGhlYWRlciBmaWVsZCBcImlkXCJcbiAgICAvLyBwYXJhbWV0ZXIpIGJ1dCB0aGF0IGRvIG5vdCBtYXRjaCB0aGUgZGlhbG9nIHdvdWxkIGJlIHJlamVjdGVkIHdpdGggYVxuICAgIC8vIDQ4MSByZXNwb25zZS4gIE5vdGUgdGhhdCB0aGUgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIHRoZSBTVUJTQ1JJQkVcbiAgICAvLyByZXF1ZXN0IGNhbiBhcnJpdmUgYWZ0ZXIgYSBtYXRjaGluZyBOT1RJRlkgcmVxdWVzdCBoYXMgYmVlbiByZWNlaXZlZDtcbiAgICAvLyBzdWNoIHJlc3BvbnNlcyBtaWdodCBub3QgY29ycmVsYXRlIHRvIHRoZSBzYW1lIGRpYWxvZyBlc3RhYmxpc2hlZCBieVxuICAgIC8vIHRoZSBOT1RJRlkgcmVxdWVzdC4gIEV4Y2VwdCBhcyByZXF1aXJlZCB0byBjb21wbGV0ZSB0aGUgU1VCU0NSSUJFXG4gICAgLy8gdHJhbnNhY3Rpb24sIHN1Y2ggbm9uLW1hdGNoaW5nIDIwMC1jbGFzcyByZXNwb25zZXMgYXJlIGlnbm9yZWQuXG4gICAgLy9cbiAgICAvLyBJZiBpbnN0YWxsaW5nIG9mIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgYnkgd2F5IG9mIGEgc2luZ2xlIGZvcmtlZFxuICAgIC8vIFNVQlNDUklCRSByZXF1ZXN0IGlzIGFsbG93ZWQsIHRoZSBzdWJzY3JpYmVyIGVzdGFibGlzaGVzIGEgbmV3IGRpYWxvZ1xuICAgIC8vIHRvd2FyZHMgZWFjaCBub3RpZmllciBieSByZXR1cm5pbmcgYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gZWFjaFxuICAgIC8vIE5PVElGWSByZXF1ZXN0LiAgRWFjaCBkaWFsb2cgaXMgdGhlbiBoYW5kbGVkIGFzIGl0cyBvd24gZW50aXR5IGFuZCBpc1xuICAgIC8vIHJlZnJlc2hlZCBpbmRlcGVuZGVudGx5IG9mIHRoZSBvdGhlciBkaWFsb2dzLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGNhc2UgdGhhdCBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIGFyZSBhbGxvd2VkLCB0aGUgZXZlbnRcbiAgICAvLyBwYWNrYWdlIE1VU1Qgc3BlY2lmeSB3aGV0aGVyIG1lcmdpbmcgb2YgdGhlIG5vdGlmaWNhdGlvbnMgdG8gZm9ybSBhXG4gICAgLy8gc2luZ2xlIHN0YXRlIGlzIHJlcXVpcmVkLCBhbmQgaG93IHN1Y2ggbWVyZ2luZyBpcyB0byBiZSBwZXJmb3JtZWQuXG4gICAgLy8gTm90ZSB0aGF0IGl0IGlzIHBvc3NpYmxlIHRoYXQgc29tZSBldmVudCBwYWNrYWdlcyBtYXkgYmUgZGVmaW5lZCBpblxuICAgIC8vIHN1Y2ggYSB3YXkgdGhhdCBlYWNoIGRpYWxvZyBpcyB0aWVkIHRvIGEgbXV0dWFsbHkgZXhjbHVzaXZlIHN0YXRlXG4gICAgLy8gdGhhdCBpcyB1bmFmZmVjdGVkIGJ5IHRoZSBvdGhlciBkaWFsb2dzOyB0aGlzIE1VU1QgYmUgY2xlYXJseSBzdGF0ZWRcbiAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTUuNC45XG5cbiAgICAvLyAqKiogTk9URTogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBvbmx5IGZvciBldmVudCBwYWNrYWdlcyB3aGljaFxuICAgIC8vIGRvIG5vdCBhbGxvdyBmb3JrZWQgcmVxdWVzdHMgdG8gaW5zdGFsbCBtdWxpcGxlIHN1YnNjcmlwdGlvbnMuXG4gICAgLy8gQXMgc3VjaCBhbmQgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBzcGVjaWZpY2FpdG9uLCB3ZSBzdG9wIHdhaXRpbmdcbiAgICAvLyBhbmQgYW55IGZ1dHVyZSBOT1RJRlkgcmVxdWVzdHMgd2lsbCBiZSByZWplY3RlZCB3aXRoIGEgNDgxLlxuICAgIGlmICh0aGlzLmRpYWxvZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIGFscmVhZHkgY3JlYXRlZC4gVGhpcyBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIGluc3RhbGwgb2Ygc2luZ2xlIHN1YnNjcmlwdGlvbnMuXCIpO1xuICAgIH1cbiAgICB0aGlzLndhaXROb3RpZnlTdG9wKCk7XG5cbiAgICAvLyBVcGRhdGUgZXhwaXJlcy5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXMgPVxuICAgICAgc3Vic2NyaXB0aW9uU3RhdGUuZXhwaXJlcyA/XG4gICAgICAgIE1hdGgubWluKHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcywgTWF0aC5tYXgoc3Vic2NyaXB0aW9uU3RhdGUuZXhwaXJlcywgMCkpIDpcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzO1xuXG4gICAgLy8gVXBkYXRlIHN1YnNjcmlwdG9pbiBzdGF0ZS5cbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlID0gU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWN0aXZlXCI6XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgPSBTdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRlcm1pbmF0ZWRcIjpcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSA9IFN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgc3RhdGUgJHtzdGF0ZX0uYCk7XG4gICAgfVxuXG4gICAgLy8gRGlhbG9ncyB1c2FnZXMgYXJlIGNyZWF0ZWQgdXBvbiBjb21wbGV0aW9uIG9mIGEgTk9USUZZIHRyYW5zYWN0aW9uXG4gICAgLy8gZm9yIGEgbmV3IHN1YnNjcmlwdGlvbiwgdW5sZXNzIHRoZSBOT1RJRlkgcmVxdWVzdCBjb250YWlucyBhXG4gICAgLy8gXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBvZiBcInRlcm1pbmF0ZWQuXCJcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuNC4xXG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IFN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgIC8vIEJlY2F1c2UgdGhlIGRpYWxvZyB1c2FnZSBpcyBlc3RhYmxpc2hlZCBieSB0aGUgTk9USUZZIHJlcXVlc3QsIHRoZVxuICAgICAgLy8gcm91dGUgc2V0IGF0IHRoZSBzdWJzY3JpYmVyIGlzIHRha2VuIGZyb20gdGhlIE5PVElGWSByZXF1ZXN0IGl0c2VsZixcbiAgICAgIC8vIGFzIG9wcG9zZWQgdG8gdGhlIHJvdXRlIHNldCBwcmVzZW50IGluIHRoZSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gdGhlXG4gICAgICAvLyBTVUJTQ1JJQkUgcmVxdWVzdC5cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC40LjFcbiAgICAgIGNvbnN0IGRpYWxvZ1N0YXRlID0gU3Vic2NyaXB0aW9uRGlhbG9nLmluaXRpYWxEaWFsb2dTdGF0ZUZvclN1YnNjcmlwdGlvbih0aGlzLm1lc3NhZ2UsIHVhcy5tZXNzYWdlKTtcblxuICAgICAgLy8gU3Vic2NyaXB0aW9uIEluaXRpYXRlZCEgOilcbiAgICAgIHRoaXMuZGlhbG9nID0gbmV3IFN1YnNjcmlwdGlvbkRpYWxvZyhcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25FdmVudCxcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzLFxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlLFxuICAgICAgICB0aGlzLmNvcmUsXG4gICAgICAgIGRpYWxvZ1N0YXRlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIERlbGVnYXRlLlxuICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB1YXM7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLmRpYWxvZztcbiAgICAgIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkoeyByZXF1ZXN0LCBzdWJzY3JpcHRpb24gfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVhcy5hY2NlcHQoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgd2FpdE5vdGlmeVN0YXJ0KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5OKSB7XG4gICAgICAvLyBBZGQgb3Vyc2VsdmVzIHRvIHRoZSBjb3JlJ3Mgc3Vic2NyaWJlciBtYXAuXG4gICAgICAvLyBUaGlzIGFsbG93cyB0aGUgY29yZSB0byByb3V0ZSBvdXQgb2YgZGlhbG9nIE5PVElGWSBtZXNzYWdlcyB0byB1cy5cbiAgICAgIHRoaXMuY29yZS5zdWJzY3JpYmVycy5zZXQodGhpcy5zdWJzY3JpYmVySWQsIHRoaXMpO1xuICAgICAgdGhpcy5OID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnRpbWVyX04oKSwgVGltZXJzLlRJTUVSX04pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB3YWl0Tm90aWZ5U3RvcCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5OKSB7XG4gICAgICAvLyBSZW1vdmUgb3Vyc2VsdmVzIHRvIHRoZSBjb3JlJ3Mgc3Vic2NyaWJlciBtYXAuXG4gICAgICAvLyBBbnkgZnV0dXJlIG91dCBvZiBkaWFsb2cgTk9USUZZIG1lc3NhZ2VzIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhIDQ4MS5cbiAgICAgIHRoaXMuY29yZS5zdWJzY3JpYmVycy5kZWxldGUodGhpcy5zdWJzY3JpYmVySWQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuTik7XG4gICAgICB0aGlzLk4gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY2VpdmUgYSByZXNwb25zZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBsYXllci5cbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXNwb25zZSBtZXNzYWdlLlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlY2VpdmVSZXNwb25zZShtZXNzYWdlOiBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5hdXRoZW50aWNhdGlvbkd1YXJkKG1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2Uuc3RhdHVzQ29kZSAmJiBtZXNzYWdlLnN0YXR1c0NvZGUgPj0gMjAwICYmIG1lc3NhZ2Uuc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgICAgLy8gIFRoZSBcIkV4cGlyZXNcIiBoZWFkZXIgZmllbGQgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gU1VCU0NSSUJFXG4gICAgICAvLyAgcmVxdWVzdCBpbmRpY2F0ZXMgdGhlIGFjdHVhbCBkdXJhdGlvbiBmb3Igd2hpY2ggdGhlIHN1YnNjcmlwdGlvbiB3aWxsXG4gICAgICAvLyAgcmVtYWluIGFjdGl2ZSAodW5sZXNzIHJlZnJlc2hlZCkuICBUaGUgcmVjZWl2ZWQgdmFsdWUgbWlnaHQgYmVcbiAgICAgIC8vICBzbWFsbGVyIHRoYW4gdGhlIHZhbHVlIGluZGljYXRlZCBpbiB0aGUgU1VCU0NSSUJFIHJlcXVlc3QgYnV0IGNhbm5vdFxuICAgICAgLy8gIGJlIGxhcmdlcjsgc2VlIFNlY3Rpb24gNC4yLjEgZm9yIGRldGFpbHMuXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjFcblxuICAgICAgLy8gVGhlIFwiRXhwaXJlc1wiIHZhbHVlcyBwcmVzZW50IGluIFNVQlNDUklCRSAyMDAtY2xhc3MgcmVzcG9uc2VzIGJlaGF2ZVxuICAgICAgLy8gaW4gdGhlIHNhbWUgd2F5IGFzIHRoZXkgZG8gaW4gUkVHSVNURVIgcmVzcG9uc2VzOiB0aGUgc2VydmVyIE1BWVxuICAgICAgLy8gc2hvcnRlbiB0aGUgaW50ZXJ2YWwgYnV0IE1VU1QgTk9UIGxlbmd0aGVuIGl0LlxuICAgICAgLy9cbiAgICAgIC8vICAgIElmIHRoZSBkdXJhdGlvbiBzcGVjaWZpZWQgaW4gYSBTVUJTQ1JJQkUgcmVxdWVzdCBpcyB1bmFjY2VwdGFibHlcbiAgICAgIC8vICAgIHNob3J0LCB0aGUgbm90aWZpZXIgbWF5IGJlIGFibGUgdG8gc2VuZCBhIDQyMyByZXNwb25zZSwgYXNcbiAgICAgIC8vICAgIGRlc2NyaWJlZCBlYXJsaWVyIGluIHRoaXMgc2VjdGlvbi5cbiAgICAgIC8vXG4gICAgICAvLyAyMDAtY2xhc3MgcmVzcG9uc2VzIHRvIFNVQlNDUklCRSByZXF1ZXN0cyB3aWxsIG5vdCBnZW5lcmFsbHkgY29udGFpblxuICAgICAgLy8gYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBiZXlvbmQgc3Vic2NyaXB0aW9uIGR1cmF0aW9uOyB0aGVpciBwcmltYXJ5XG4gICAgICAvLyBwdXJwb3NlIGlzIHRvIHNlcnZlIGFzIGEgcmVsaWFiaWxpdHkgbWVjaGFuaXNtLiAgU3RhdGUgaW5mb3JtYXRpb25cbiAgICAgIC8vIHdpbGwgYmUgY29tbXVuaWNhdGVkIHZpYSBhIHN1YnNlcXVlbnQgTk9USUZZIHJlcXVlc3QgZnJvbSB0aGVcbiAgICAgIC8vIG5vdGlmaWVyLlxuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjIuMS4xXG4gICAgICBjb25zdCBleHBpcmVzID0gbWVzc2FnZS5nZXRIZWFkZXIoXCJFeHBpcmVzXCIpO1xuICAgICAgaWYgKCFleHBpcmVzKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJFeHBpcmVzIGhlYWRlciBtaXNzaW5nIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFNVQlNDUklCRVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbkV4cGlyZXNSZWNlaXZlZCA9IE51bWJlcihleHBpcmVzKTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkV4cGlyZXNSZWNlaXZlZCA+IHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlc1JlcXVlc3RlZCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBcIkV4cGlyZXMgaGVhZGVyIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFNVQlNDUklCRSB3aXRoIGEgaGlnaGVyIHZhbHVlIHRoYW4gdGhlIG9uZSBpbiB0aGUgcmVxdWVzdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uRXhwaXJlc1JlY2VpdmVkIDwgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzKSB7XG4gICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzID0gc3Vic2NyaXB0aW9uRXhwaXJlc1JlY2VpdmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBJZiBhIE5PVElGWSBhcnJpdmVkIGJlZm9yZSAyMDAtY2xhc3MgcmVzcG9uc2UgYSBkaWFsb2cgbWF5IGhhdmUgYmVlbiBjcmVhdGVkLlxuICAgICAgLy8gVXBkYXRlZCB0aGUgZGlhbG9ncyBleHBpcmF0aW9uIG9ubHkgaWYgdGhpcyBpbmRpY2F0ZXMgZWFybGllciBleHBpcmF0aW9uLlxuICAgICAgaWYgKHRoaXMuZGlhbG9nKSB7XG4gICAgICAgIGlmICh0aGlzLmRpYWxvZy5zdWJzY3JpcHRpb25FeHBpcmVzID4gdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzKSB7XG4gICAgICAgICAgdGhpcy5kaWFsb2cuc3Vic2NyaXB0aW9uRXhwaXJlcyA9IHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnN0YXR1c0NvZGUgJiYgbWVzc2FnZS5zdGF0dXNDb2RlID49IDMwMCAmJiBtZXNzYWdlLnN0YXR1c0NvZGUgPCA3MDApIHtcbiAgICAgIHRoaXMud2FpdE5vdGlmeVN0b3AoKTsgLy8gTm8gTk9USUZZIHdpbGwgYmUgc2VudCBhZnRlciBhIG5lZ2F0aXZlIGZpbmFsIHJlc3BvbnNlLlxuICAgIH1cblxuICAgIHN1cGVyLnJlY2VpdmVSZXNwb25zZShtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUbyBlbnN1cmUgdGhhdCBzdWJzY3JpYmVycyBkbyBub3Qgd2FpdCBpbmRlZmluaXRlbHkgZm9yIGFcbiAgICogc3Vic2NyaXB0aW9uIHRvIGJlIGVzdGFibGlzaGVkLCBhIHN1YnNjcmliZXIgc3RhcnRzIGEgVGltZXIgTiwgc2V0IHRvXG4gICAqIDY0KlQxLCB3aGVuIGl0IHNlbmRzIGEgU1VCU0NSSUJFIHJlcXVlc3QuICBJZiB0aGlzIFRpbWVyIE4gZXhwaXJlc1xuICAgKiBwcmlvciB0byB0aGUgcmVjZWlwdCBvZiBhIE5PVElGWSByZXF1ZXN0LCB0aGUgc3Vic2NyaWJlciBjb25zaWRlcnNcbiAgICogdGhlIHN1YnNjcmlwdGlvbiBmYWlsZWQsIGFuZCBjbGVhbnMgdXAgYW55IHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICogc3Vic2NyaXB0aW9uIGF0dGVtcHQuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuNFxuICAgKi9cbiAgcHJpdmF0ZSB0aW1lcl9OKCk6IHZvaWQge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oYFRpbWVyIE4gZXhwaXJlZCBmb3IgU1VCU0NSSUJFIHVzZXIgYWdlbnQgY2xpZW50LiBUaW1lZCBvdXQgd2FpdGluZyBmb3IgTk9USUZZLmApO1xuICAgIHRoaXMud2FpdE5vdGlmeVN0b3AoKTtcbiAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5VGltZW91dCkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeVRpbWVvdXQoKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IEluY29taW5nUmVxdWVzdERlbGVnYXRlLCBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLCBJbmNvbWluZ1N1YnNjcmliZVJlcXVlc3QgfSBmcm9tIFwiLi4vbWVzc2FnZXNcIjtcbmltcG9ydCB7IE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgVXNlckFnZW50Q29yZSB9IGZyb20gXCIuLi91c2VyLWFnZW50LWNvcmVcIjtcbmltcG9ydCB7IFVzZXJBZ2VudFNlcnZlciB9IGZyb20gXCIuL3VzZXItYWdlbnQtc2VydmVyXCI7XG5cbi8qKlxuICogU1VCU0NSSUJFIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnNjcmliZVVzZXJBZ2VudFNlcnZlciBleHRlbmRzIFVzZXJBZ2VudFNlcnZlciBpbXBsZW1lbnRzIEluY29taW5nU3Vic2NyaWJlUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBjb3JlOiBVc2VyQWdlbnRDb3JlLFxuICAgIG1lc3NhZ2U6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UsXG4gICAgZGVsZWdhdGU/OiBJbmNvbWluZ1JlcXVlc3REZWxlZ2F0ZVxuICApIHtcbiAgICBzdXBlcihOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBUcmFuc3BvcnRFcnJvciB9IGZyb20gXCIuLi9leGNlcHRpb25zXCI7XG5pbXBvcnQgeyBMb2dnZXIsIExvZ2dlckZhY3RvcnkgfSBmcm9tIFwiLi4vbG9nXCI7XG5pbXBvcnQge1xuICBDLFxuICBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSxcbiAgT3V0Z29pbmdSZXF1ZXN0LFxuICBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZSxcbiAgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgUmVxdWVzdE9wdGlvbnNcbn0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQge1xuICBDbGllbnRUcmFuc2FjdGlvbixcbiAgQ2xpZW50VHJhbnNhY3Rpb25Vc2VyLFxuICBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbixcbiAgVHJhbnNhY3Rpb25TdGF0ZVxufSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBUcmFuc3BvcnQgfSBmcm9tIFwiLi4vdHJhbnNwb3J0XCI7XG5pbXBvcnQgeyBVc2VyQWdlbnRDb3JlIH0gZnJvbSBcIi4uL3VzZXItYWdlbnQtY29yZVwiO1xuXG50eXBlIENsaWVudFRyYW5zYWN0aW9uQ29uc3RydWN0b3IgPSBuZXcgKFxuICBtZXNzYWdlOiBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLFxuICB0cmFuc3BvcnQ6IFRyYW5zcG9ydCxcbiAgdXNlcjogQ2xpZW50VHJhbnNhY3Rpb25Vc2VyXG4pID0+IENsaWVudFRyYW5zYWN0aW9uO1xuXG4vKipcbiAqIFVzZXIgQWdlbnQgQ2xpZW50IChVQUMpLlxuICogQHJlbWFya3NcbiAqIEEgdXNlciBhZ2VudCBjbGllbnQgaXMgYSBsb2dpY2FsIGVudGl0eVxuICogdGhhdCBjcmVhdGVzIGEgbmV3IHJlcXVlc3QsIGFuZCB0aGVuIHVzZXMgdGhlIGNsaWVudFxuICogdHJhbnNhY3Rpb24gc3RhdGUgbWFjaGluZXJ5IHRvIHNlbmQgaXQuICBUaGUgcm9sZSBvZiBVQUMgbGFzdHNcbiAqIG9ubHkgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGF0IHRyYW5zYWN0aW9uLiAgSW4gb3RoZXIgd29yZHMsIGlmXG4gKiBhIHBpZWNlIG9mIHNvZnR3YXJlIGluaXRpYXRlcyBhIHJlcXVlc3QsIGl0IGFjdHMgYXMgYSBVQUMgZm9yXG4gKiB0aGUgZHVyYXRpb24gb2YgdGhhdCB0cmFuc2FjdGlvbi4gIElmIGl0IHJlY2VpdmVzIGEgcmVxdWVzdFxuICogbGF0ZXIsIGl0IGFzc3VtZXMgdGhlIHJvbGUgb2YgYSB1c2VyIGFnZW50IHNlcnZlciBmb3IgdGhlXG4gKiBwcm9jZXNzaW5nIG9mIHRoYXQgdHJhbnNhY3Rpb24uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTZcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFVzZXJBZ2VudENsaWVudCBpbXBsZW1lbnRzIE91dGdvaW5nUmVxdWVzdCB7XG4gIHByb3RlY3RlZCBsb2dnZXI6IExvZ2dlcjtcblxuICBwcml2YXRlIF90cmFuc2FjdGlvbjogQ2xpZW50VHJhbnNhY3Rpb24gfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBjcmVkZW50aWFsczogYW55O1xuICBwcml2YXRlIGNoYWxsZW5nZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdGFsZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdHJhbnNhY3Rpb25Db25zdHJ1Y3RvcjogQ2xpZW50VHJhbnNhY3Rpb25Db25zdHJ1Y3RvcixcbiAgICBwcm90ZWN0ZWQgY29yZTogVXNlckFnZW50Q29yZSxcbiAgICBwdWJsaWMgbWVzc2FnZTogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgICBwdWJsaWMgZGVsZWdhdGU/OiBPdXRnb2luZ1JlcXVlc3REZWxlZ2F0ZVxuICApIHtcbiAgICB0aGlzLmxvZ2dlciA9IHRoaXMubG9nZ2VyRmFjdG9yeS5nZXRMb2dnZXIoXCJzaXAudXNlci1hZ2VudC1jbGllbnRcIik7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIGdldCBsb2dnZXJGYWN0b3J5KCk6IExvZ2dlckZhY3Rvcnkge1xuICAgIHJldHVybiB0aGlzLmNvcmUubG9nZ2VyRmFjdG9yeTtcbiAgfVxuXG4gIC8qKiBUaGUgdHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVxdWVzdC4gKi9cbiAgZ2V0IHRyYW5zYWN0aW9uKCk6IENsaWVudFRyYW5zYWN0aW9uIHtcbiAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiB1bmRlZmluZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogU2luY2UgcmVxdWVzdHMgb3RoZXIgdGhhbiBJTlZJVEUgYXJlIHJlc3BvbmRlZCB0byBpbW1lZGlhdGVseSwgc2VuZGluZyBhXG4gICAqIENBTkNFTCBmb3IgYSBub24tSU5WSVRFIHJlcXVlc3Qgd291bGQgYWx3YXlzIGNyZWF0ZSBhIHJhY2UgY29uZGl0aW9uLlxuICAgKiBBIENBTkNFTCByZXF1ZXN0IFNIT1VMRCBOT1QgYmUgc2VudCB0byBjYW5jZWwgYSByZXF1ZXN0IG90aGVyIHRoYW4gSU5WSVRFLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENhbmNlbCBvcHRpb25zIGJ1Y2tldC5cbiAgICovXG4gIHB1YmxpYyBjYW5jZWwocmVhc29uPzogc3RyaW5nLCBvcHRpb25zOiBSZXF1ZXN0T3B0aW9ucyA9IHt9KTogT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZSB7XG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiB1bmRlZmluZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubWVzc2FnZS50bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gdW5kZWZpbmVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm1lc3NhZ2UuZnJvbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB1bmRlZmluZWQuXCIpO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvY2VkdXJlcyBhcmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBDQU5DRUwgcmVxdWVzdC4gIFRoZVxuICAgIC8vIFJlcXVlc3QtVVJJLCBDYWxsLUlELCBUbywgdGhlIG51bWVyaWMgcGFydCBvZiBDU2VxLCBhbmQgRnJvbSBoZWFkZXJcbiAgICAvLyBmaWVsZHMgaW4gdGhlIENBTkNFTCByZXF1ZXN0IE1VU1QgYmUgaWRlbnRpY2FsIHRvIHRob3NlIGluIHRoZVxuICAgIC8vIHJlcXVlc3QgYmVpbmcgY2FuY2VsbGVkLCBpbmNsdWRpbmcgdGFncy4gIEEgQ0FOQ0VMIGNvbnN0cnVjdGVkIGJ5IGFcbiAgICAvLyBjbGllbnQgTVVTVCBoYXZlIG9ubHkgYSBzaW5nbGUgVmlhIGhlYWRlciBmaWVsZCB2YWx1ZSBtYXRjaGluZyB0aGVcbiAgICAvLyB0b3AgVmlhIHZhbHVlIGluIHRoZSByZXF1ZXN0IGJlaW5nIGNhbmNlbGxlZC4gIFVzaW5nIHRoZSBzYW1lIHZhbHVlc1xuICAgIC8vIGZvciB0aGVzZSBoZWFkZXIgZmllbGRzIGFsbG93cyB0aGUgQ0FOQ0VMIHRvIGJlIG1hdGNoZWQgd2l0aCB0aGVcbiAgICAvLyByZXF1ZXN0IGl0IGNhbmNlbHMgKFNlY3Rpb24gOS4yIGluZGljYXRlcyBob3cgc3VjaCBtYXRjaGluZyBvY2N1cnMpLlxuICAgIC8vIEhvd2V2ZXIsIHRoZSBtZXRob2QgcGFydCBvZiB0aGUgQ1NlcSBoZWFkZXIgZmllbGQgTVVTVCBoYXZlIGEgdmFsdWVcbiAgICAvLyBvZiBDQU5DRUwuICBUaGlzIGFsbG93cyBpdCB0byBiZSBpZGVudGlmaWVkIGFuZCBwcm9jZXNzZWQgYXMgYVxuICAgIC8vIHRyYW5zYWN0aW9uIGluIGl0cyBvd24gcmlnaHQgKFNlZSBTZWN0aW9uIDE3KS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNvcmUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoXG4gICAgICBDLkNBTkNFTCxcbiAgICAgIHRoaXMubWVzc2FnZS5ydXJpLFxuICAgICAgdGhpcy5tZXNzYWdlLmZyb20udXJpLFxuICAgICAgdGhpcy5tZXNzYWdlLnRvLnVyaSxcbiAgICAgIHtcbiAgICAgICAgdG9UYWc6IHRoaXMubWVzc2FnZS50b1RhZyxcbiAgICAgICAgZnJvbVRhZzogdGhpcy5tZXNzYWdlLmZyb21UYWcsXG4gICAgICAgIGNhbGxJZDogdGhpcy5tZXNzYWdlLmNhbGxJZCxcbiAgICAgICAgY3NlcTogdGhpcy5tZXNzYWdlLmNzZXFcbiAgICAgIH0sXG4gICAgICBvcHRpb25zLmV4dHJhSGVhZGVyc1xuICAgICk7XG5cbiAgICAvLyBUT0RPOiBSZXZpc2l0IHRoaXMuXG4gICAgLy8gVGhlIENBTkNFTCBuZWVkcyB0byB1c2UgdGhlIHNhbWUgYnJhbmNoIHBhcmFtZXRlciBzbyB0aGF0XG4gICAgLy8gaXQgbWF0Y2hlcyB0aGUgSU5WSVRFIHRyYW5zYWN0aW9uLCBidXQgdGhpcyBpcyBhIGhhY2t5IHdheSB0byBkbyB0aGlzLlxuICAgIC8vIE9yIGF0IHRoZSB2ZXJ5IGxlYXN0IG5vdCB3ZWxsIGRvY3VtZW50ZWQuIElmIHRoZSB0aGUgYnJhbmNoIHBhcmFtZXRlclxuICAgIC8vIGlzIHNldCBvbiB0aGUgb3V0Z29pbmcgcmVxdWVzdCwgdGhlIHRyYW5zYWN0aW9uIHdpbGwgdXNlIGl0LlxuICAgIC8vIE90aGVyd2lzZSB0aGUgdHJhbnNhY3Rpb24gd2lsbCBtYWtlIGEgbmV3IG9uZS5cbiAgICBtZXNzYWdlLmJyYW5jaCA9IHRoaXMubWVzc2FnZS5icmFuY2g7XG5cbiAgICBpZiAodGhpcy5tZXNzYWdlLmhlYWRlcnMuUm91dGUpIHtcbiAgICAgIG1lc3NhZ2UuaGVhZGVycy5Sb3V0ZSA9IHRoaXMubWVzc2FnZS5oZWFkZXJzLlJvdXRlO1xuICAgIH1cblxuICAgIGlmIChyZWFzb24pIHtcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwiUmVhc29uXCIsIHJlYXNvbik7XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gcHJvdmlzaW9uYWwgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQsIHRoZSBDQU5DRUwgcmVxdWVzdCBNVVNUXG4gICAgLy8gTk9UIGJlIHNlbnQ7IHJhdGhlciwgdGhlIGNsaWVudCBNVVNUIHdhaXQgZm9yIHRoZSBhcnJpdmFsIG9mIGFcbiAgICAvLyBwcm92aXNpb25hbCByZXNwb25zZSBiZWZvcmUgc2VuZGluZyB0aGUgcmVxdWVzdC4gSWYgdGhlIG9yaWdpbmFsXG4gICAgLy8gcmVxdWVzdCBoYXMgZ2VuZXJhdGVkIGEgZmluYWwgcmVzcG9uc2UsIHRoZSBDQU5DRUwgU0hPVUxEIE5PVCBiZVxuICAgIC8vIHNlbnQsIGFzIGl0IGlzIGFuIGVmZmVjdGl2ZSBuby1vcCwgc2luY2UgQ0FOQ0VMIGhhcyBubyBlZmZlY3Qgb25cbiAgICAvLyByZXF1ZXN0cyB0aGF0IGhhdmUgYWxyZWFkeSBnZW5lcmF0ZWQgYSBmaW5hbCByZXNwb25zZS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMVxuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpIHtcbiAgICAgIGNvbnN0IHVhYyA9IG5ldyBVc2VyQWdlbnRDbGllbnQoTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIHRoaXMuY29yZSwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25jZShcInN0YXRlQ2hhbmdlZFwiLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uICYmIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgICAgIGNvbnN0IHVhYyA9IG5ldyBVc2VyQWdlbnRDbGllbnQoTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIHRoaXMuY29yZSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGEgNDAxIChVbmF1dGhvcml6ZWQpIG9yIDQwNyAoUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWQpXG4gICAqIHJlc3BvbnNlIGlzIHJlY2VpdmVkLCB0aGUgVUFDIFNIT1VMRCBmb2xsb3cgdGhlIGF1dGhvcml6YXRpb25cbiAgICogcHJvY2VkdXJlcyBvZiBTZWN0aW9uIDIyLjIgYW5kIFNlY3Rpb24gMjIuMyB0byByZXRyeSB0aGUgcmVxdWVzdCB3aXRoXG4gICAqIGNyZWRlbnRpYWxzLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4zLjVcbiAgICogMjIgVXNhZ2Ugb2YgSFRUUCBBdXRoZW50aWNhdGlvblxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTIyXG4gICAqIDIyLjEgRnJhbWV3b3JrXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMjIuMVxuICAgKiAyMi4yIFVzZXItdG8tVXNlciBBdXRoZW50aWNhdGlvblxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTIyLjJcbiAgICogMjIuMyBQcm94eS10by1Vc2VyIEF1dGhlbnRpY2F0aW9uXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMjIuM1xuICAgKlxuICAgKiBGSVhNRTogVGhpcyBcImd1YXJkIGZvciBhbmQgcmV0cnkgdGhlIHJlcXVlc3Qgd2l0aCBjcmVkZW50aWFsc1wiXG4gICAqIGltcGxlbWVudGF0aW9uIGlzIG5vdCBjb21wbGV0ZSBhbmQgYXQgYmVzdCBtaW5pbWFsbHkgcGFzc2FibGUuXG4gICAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBpbmNvbWluZyByZXNwb25zZSB0byBndWFyZC5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcHJvZ3JhbSBleGVjdXRpb24gaXMgdG8gY29udGludWUgaW4gdGhlIGJyYW5jaCBpbiBxdWVzdGlvbi5cbiAgICogICAgICAgICAgT3RoZXJ3aXNlIHRoZSByZXF1ZXN0IGlzIHJldHJpZWQgd2l0aCBjcmVkZW50aWFscyBhbmQgY3VycmVudCByZXF1ZXN0IHByb2Nlc3NpbmcgbXVzdCBzdG9wLlxuICAgKi9cbiAgcHJvdGVjdGVkIGF1dGhlbnRpY2F0aW9uR3VhcmQobWVzc2FnZTogSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UpOiBib29sZWFuIHtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gbWVzc2FnZS5zdGF0dXNDb2RlO1xuICAgIGlmICghc3RhdHVzQ29kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2Ugc3RhdHVzIGNvZGUgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIDQwMSAoVW5hdXRob3JpemVkKSBvciA0MDcgKFByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkKVxuICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkLCB0aGUgVUFDIFNIT1VMRCBmb2xsb3cgdGhlIGF1dGhvcml6YXRpb25cbiAgICAvLyBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gMjIuMiBhbmQgU2VjdGlvbiAyMi4zIHRvIHJldHJ5IHRoZSByZXF1ZXN0IHdpdGhcbiAgICAvLyBjcmVkZW50aWFscy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4zLjVcbiAgICBpZiAoc3RhdHVzQ29kZSAhPT0gNDAxICYmIHN0YXR1c0NvZGUgIT09IDQwNykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gR2V0IGFuZCBwYXJzZSB0aGUgYXBwcm9wcmlhdGUgV1dXLUF1dGhlbnRpY2F0ZSBvciBQcm94eS1BdXRoZW50aWNhdGUgaGVhZGVyLlxuICAgIGxldCBjaGFsbGVuZ2U6IGFueTtcbiAgICBsZXQgYXV0aG9yaXphdGlvbkhlYWRlck5hbWU6IHN0cmluZztcbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gNDAxKSB7XG4gICAgICBjaGFsbGVuZ2UgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwid3d3LWF1dGhlbnRpY2F0ZVwiKTtcbiAgICAgIGF1dGhvcml6YXRpb25IZWFkZXJOYW1lID0gXCJhdXRob3JpemF0aW9uXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYWxsZW5nZSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJwcm94eS1hdXRoZW50aWNhdGVcIik7XG4gICAgICBhdXRob3JpemF0aW9uSGVhZGVyTmFtZSA9IFwicHJveHktYXV0aG9yaXphdGlvblwiO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBpdCBzZWVtcyBhIHZhbGlkIGNoYWxsZW5nZS5cbiAgICBpZiAoIWNoYWxsZW5nZSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihzdGF0dXNDb2RlICsgXCIgd2l0aCB3cm9uZyBvciBtaXNzaW5nIGNoYWxsZW5nZSwgY2Fubm90IGF1dGhlbnRpY2F0ZVwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIGluZmluaXRlIGF1dGhlbnRpY2F0aW9ucy5cbiAgICBpZiAodGhpcy5jaGFsbGVuZ2VkICYmICh0aGlzLnN0YWxlIHx8IGNoYWxsZW5nZS5zdGFsZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oc3RhdHVzQ29kZSArIFwiIGFwcGFyZW50bHkgaW4gYXV0aGVudGljYXRpb24gbG9vcCwgY2Fubm90IGF1dGhlbnRpY2F0ZVwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEdldCBjcmVkZW50aWFscy5cbiAgICBpZiAoIXRoaXMuY3JlZGVudGlhbHMpIHtcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB0aGlzLmNvcmUuY29uZmlndXJhdGlvbi5hdXRoZW50aWNhdGlvbkZhY3RvcnkoKTtcbiAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVW5hYmxlIHRvIG9idGFpbiBjcmVkZW50aWFscywgY2Fubm90IGF1dGhlbnRpY2F0ZVwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNoYWxsZW5nZSBpcyByZWFsbHkgdmFsaWQuXG4gICAgaWYgKCF0aGlzLmNyZWRlbnRpYWxzLmF1dGhlbnRpY2F0ZSh0aGlzLm1lc3NhZ2UsIGNoYWxsZW5nZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuY2hhbGxlbmdlZCA9IHRydWU7XG4gICAgaWYgKGNoYWxsZW5nZS5zdGFsZSkge1xuICAgICAgdGhpcy5zdGFsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgY3NlcSA9IHRoaXMubWVzc2FnZS5jc2VxICs9IDE7XG4gICAgdGhpcy5tZXNzYWdlLnNldEhlYWRlcihcImNzZXFcIiwgY3NlcSArIFwiIFwiICsgdGhpcy5tZXNzYWdlLm1ldGhvZCk7XG4gICAgdGhpcy5tZXNzYWdlLnNldEhlYWRlcihhdXRob3JpemF0aW9uSGVhZGVyTmFtZSwgdGhpcy5jcmVkZW50aWFscy50b1N0cmluZygpKTtcblxuICAgIC8vIENhbGxpbmcgaW5pdCAoYWdhaW4pIHdpbGwgc3dhcCBvdXQgb3VyIGV4aXN0aW5nIGNsaWVudCB0cmFuc2FjdGlvbiB3aXRoIGEgbmV3IG9uZS5cbiAgICAvLyBGSVhNRTogSEFDSzogQW4gYXNzdW1wdGlvbiBpcyBiZWluZyBtYWRlIGhlcmUgdGhhdCB0aGVyZSBpcyBub3RoaW5nIHRoYXQgbmVlZHMgdG9cbiAgICAvLyBiZSBjbGVhbmVkIHVwIGJleW9uZCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIHdoaWNoIGlzIGJlaW5nIHJlcGxhY2VkLiBGb3IgZXhhbXBsZSxcbiAgICAvLyBpdCBpcyBhc3N1bWVkIHRoYXQgbm8gZWFybHkgZGlhbG9ncyBoYXZlIGJlZW4gY3JlYXRlZC5cbiAgICB0aGlzLmluaXQoKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiA4LjEuMy4xIFRyYW5zYWN0aW9uIExheWVyIEVycm9yc1xuICAgKiBJbiBzb21lIGNhc2VzLCB0aGUgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIHRyYW5zYWN0aW9uIGxheWVyIHdpbGxcbiAgICogbm90IGJlIGEgU0lQIG1lc3NhZ2UsIGJ1dCByYXRoZXIgYSB0cmFuc2FjdGlvbiBsYXllciBlcnJvci4gIFdoZW4gYVxuICAgKiB0aW1lb3V0IGVycm9yIGlzIHJlY2VpdmVkIGZyb20gdGhlIHRyYW5zYWN0aW9uIGxheWVyLCBpdCBNVVNUIGJlXG4gICAqIHRyZWF0ZWQgYXMgaWYgYSA0MDggKFJlcXVlc3QgVGltZW91dCkgc3RhdHVzIGNvZGUgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICAqIElmIGEgZmF0YWwgdHJhbnNwb3J0IGVycm9yIGlzIHJlcG9ydGVkIGJ5IHRoZSB0cmFuc3BvcnQgbGF5ZXJcbiAgICogKGdlbmVyYWxseSwgZHVlIHRvIGZhdGFsIElDTVAgZXJyb3JzIGluIFVEUCBvciBjb25uZWN0aW9uIGZhaWx1cmVzIGluXG4gICAqIFRDUCksIHRoZSBjb25kaXRpb24gTVVTVCBiZSB0cmVhdGVkIGFzIGEgNTAzIChTZXJ2aWNlIFVuYXZhaWxhYmxlKVxuICAgKiBzdGF0dXMgY29kZS5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy4xXG4gICAqL1xuICBwcm90ZWN0ZWQgb25SZXF1ZXN0VGltZW91dCgpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKFwiVXNlciBhZ2VudCBjbGllbnQgcmVxdWVzdCB0aW1lZCBvdXQuIEdlbmVyYXRpbmcgaW50ZXJuYWwgNDA4IFJlcXVlc3QgVGltZW91dC5cIik7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSgpO1xuICAgIG1lc3NhZ2Uuc3RhdHVzQ29kZSA9IDQwODtcbiAgICBtZXNzYWdlLnJlYXNvblBocmFzZSA9IFwiUmVxdWVzdCBUaW1lb3V0XCI7XG4gICAgdGhpcy5yZWNlaXZlUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIDguMS4zLjEgVHJhbnNhY3Rpb24gTGF5ZXIgRXJyb3JzXG4gICAqIEluIHNvbWUgY2FzZXMsIHRoZSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIgd2lsbFxuICAgKiBub3QgYmUgYSBTSVAgbWVzc2FnZSwgYnV0IHJhdGhlciBhIHRyYW5zYWN0aW9uIGxheWVyIGVycm9yLiAgV2hlbiBhXG4gICAqIHRpbWVvdXQgZXJyb3IgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIsIGl0IE1VU1QgYmVcbiAgICogdHJlYXRlZCBhcyBpZiBhIDQwOCAoUmVxdWVzdCBUaW1lb3V0KSBzdGF0dXMgY29kZSBoYXMgYmVlbiByZWNlaXZlZC5cbiAgICogSWYgYSBmYXRhbCB0cmFuc3BvcnQgZXJyb3IgaXMgcmVwb3J0ZWQgYnkgdGhlIHRyYW5zcG9ydCBsYXllclxuICAgKiAoZ2VuZXJhbGx5LCBkdWUgdG8gZmF0YWwgSUNNUCBlcnJvcnMgaW4gVURQIG9yIGNvbm5lY3Rpb24gZmFpbHVyZXMgaW5cbiAgICogVENQKSwgdGhlIGNvbmRpdGlvbiBNVVNUIGJlIHRyZWF0ZWQgYXMgYSA1MDMgKFNlcnZpY2UgVW5hdmFpbGFibGUpXG4gICAqIHN0YXR1cyBjb2RlLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4zLjFcbiAgICogQHBhcmFtIGVycm9yIC0gVHJhbnNwb3J0IGVycm9yXG4gICAqL1xuICAgcHJvdGVjdGVkIG9uVHJhbnNwb3J0RXJyb3IoZXJyb3I6IFRyYW5zcG9ydEVycm9yKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJVc2VyIGFnZW50IGNsaWVudCByZXF1ZXN0IHRyYW5zcG9ydCBlcnJvci4gR2VuZXJhdGluZyBpbnRlcm5hbCA1MDMgU2VydmljZSBVbmF2YWlsYWJsZS5cIik7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSgpO1xuICAgIG1lc3NhZ2Uuc3RhdHVzQ29kZSA9IDUwMztcbiAgICBtZXNzYWdlLnJlYXNvblBocmFzZSA9IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiO1xuICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY2VpdmUgYSByZXNwb25zZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBsYXllci5cbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXNwb25zZSBtZXNzYWdlLlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlY2VpdmVSZXNwb25zZShtZXNzYWdlOiBJbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5hdXRoZW50aWNhdGlvbkd1YXJkKG1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IG1lc3NhZ2Uuc3RhdHVzQ29kZSA/IG1lc3NhZ2Uuc3RhdHVzQ29kZS50b1N0cmluZygpIDogXCJcIjtcbiAgICBpZiAoIXN0YXR1c0NvZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHN0YXR1cyBjb2RlIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIC9eMTAwJC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblRyeWluZykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25UcnlpbmcoeyBtZXNzYWdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Qcm9ncmVzcykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Qcm9ncmVzcyh7IG1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkFjY2VwdCkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25BY2NlcHQoeyBtZXNzYWdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAvXjNbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWRpcmVjdCkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWRpcmVjdCh7IG1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC9eWzQtNl1bMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWplY3QpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVqZWN0KHsgbWVzc2FnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpbml0KCk6IHZvaWQge1xuICAgIC8vIFdlIGFyZSB0aGUgdHJhbnNhY3Rpb24gdXNlci5cbiAgICBjb25zdCB1c2VyOiBDbGllbnRUcmFuc2FjdGlvblVzZXIgPSB7XG4gICAgICBsb2dnZXJGYWN0b3J5OiB0aGlzLmxvZ2dlckZhY3RvcnksXG4gICAgICBvblJlcXVlc3RUaW1lb3V0OiAoKSA9PiB0aGlzLm9uUmVxdWVzdFRpbWVvdXQoKSxcbiAgICAgIG9uU3RhdGVDaGFuZ2U6IChuZXdTdGF0ZSkgPT4ge1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdGVybWluYXRlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjb3JlLlxuICAgICAgICAgIHRoaXMuY29yZS51c2VyQWdlbnRDbGllbnRzLmRlbGV0ZSh1c2VyQWdlbnRDbGllbnRJZCk7XG4gICAgICAgICAgLy8gRklYTUU6IEhBQ0s6IE91ciB0cmFuc2FjdGlvbiBtYXkgaGF2ZSBiZWVuIHN3YXBwZWQgb3V0IHdpdGggYSBuZXcgb25lXG4gICAgICAgICAgLy8gcG9zdCBhdXRoZW50aWNhdGlvbiAoc2VlIGFib3ZlKSwgc28gbWFrZSBzdXJlIHRvIG9ubHkgdG8gZGlzcG9zZSBvZlxuICAgICAgICAgIC8vIG91cnNlbHZlcyBpZiB0aGlzIHRlcm1pbmF0aW5nIHRyYW5zYWN0aW9uIGlzIG91ciBjdXJyZW50IHRyYW5zYWN0aW9uLlxuICAgICAgICAgIGlmICh0cmFuc2FjdGlvbiA9PT0gdGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVHJhbnNwb3J0RXJyb3I6IChlcnJvcikgPT4gdGhpcy5vblRyYW5zcG9ydEVycm9yKGVycm9yKSxcbiAgICAgIHJlY2VpdmVSZXNwb25zZTogKG1lc3NhZ2UpID0+IHRoaXMucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpXG4gICAgfTtcbiAgICAvLyBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gd2l0aCB1cyBhcyB0aGUgdXNlci5cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyB0aGlzLnRyYW5zYWN0aW9uQ29uc3RydWN0b3IodGhpcy5tZXNzYWdlLCB0aGlzLmNvcmUudHJhbnNwb3J0LCB1c2VyKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgIC8vIEFkZCB0aGUgbmV3IHRyYW5zYWN0aW9uIHRvIHRoZSBjb3JlLlxuICAgIGNvbnN0IHVzZXJBZ2VudENsaWVudElkID0gdHJhbnNhY3Rpb24uaWQgKyB0cmFuc2FjdGlvbi5yZXF1ZXN0Lm1ldGhvZDtcbiAgICB0aGlzLmNvcmUudXNlckFnZW50Q2xpZW50cy5zZXQodXNlckFnZW50Q2xpZW50SWQsIHRoaXMpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBUcmFuc2FjdGlvblN0YXRlRXJyb3IgfSBmcm9tIFwiLi4vZXhjZXB0aW9uc1wiO1xuaW1wb3J0IHsgTG9nZ2VyLCBMb2dnZXJGYWN0b3J5IH0gZnJvbSBcIi4uL2xvZ1wiO1xuaW1wb3J0IHtcbiAgY29uc3RydWN0T3V0Z29pbmdSZXNwb25zZSxcbiAgSW5jb21pbmdSZXF1ZXN0LFxuICBJbmNvbWluZ1JlcXVlc3REZWxlZ2F0ZSxcbiAgSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSxcbiAgT3V0Z29pbmdSZXNwb25zZSxcbiAgUmVzcG9uc2VPcHRpb25zLFxuICBVUklcbn0gZnJvbSBcIi4uL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyBuZXdUYWcgfSBmcm9tIFwiLi4vbWVzc2FnZXMvdXRpbHNcIjtcblxuaW1wb3J0IHtcbiAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sXG4gIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLFxuICBTZXJ2ZXJUcmFuc2FjdGlvbixcbiAgU2VydmVyVHJhbnNhY3Rpb25Vc2VyLFxuICBUcmFuc2FjdGlvblN0YXRlXG59IGZyb20gXCIuLi90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IFRyYW5zcG9ydCB9IGZyb20gXCIuLi90cmFuc3BvcnRcIjtcbmltcG9ydCB7IFVzZXJBZ2VudENvcmUgfSBmcm9tIFwiLi4vdXNlci1hZ2VudC1jb3JlXCI7XG5cbnR5cGUgU2VydmVyVHJhbnNhY3Rpb25Db25zdHJ1Y3RvciA9IG5ldyAoXG4gIG1lc3NhZ2U6IEluY29taW5nUmVxdWVzdE1lc3NhZ2UsXG4gIHRyYW5zcG9ydDogVHJhbnNwb3J0LFxuICB1c2VyOiBTZXJ2ZXJUcmFuc2FjdGlvblVzZXJcbikgPT4gU2VydmVyVHJhbnNhY3Rpb247XG5cbi8qKlxuICogVXNlciBBZ2VudCBTZXJ2ZXIgKFVBUykuXG4gKiBAcmVtYXJrc1xuICogQSB1c2VyIGFnZW50IHNlcnZlciBpcyBhIGxvZ2ljYWwgZW50aXR5XG4gKiB0aGF0IGdlbmVyYXRlcyBhIHJlc3BvbnNlIHRvIGEgU0lQIHJlcXVlc3QuICBUaGUgcmVzcG9uc2VcbiAqIGFjY2VwdHMsIHJlamVjdHMsIG9yIHJlZGlyZWN0cyB0aGUgcmVxdWVzdC4gIFRoaXMgcm9sZSBsYXN0c1xuICogb25seSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoYXQgdHJhbnNhY3Rpb24uICBJbiBvdGhlciB3b3JkcywgaWZcbiAqIGEgcGllY2Ugb2Ygc29mdHdhcmUgcmVzcG9uZHMgdG8gYSByZXF1ZXN0LCBpdCBhY3RzIGFzIGEgVUFTIGZvclxuICogdGhlIGR1cmF0aW9uIG9mIHRoYXQgdHJhbnNhY3Rpb24uICBJZiBpdCBnZW5lcmF0ZXMgYSByZXF1ZXN0XG4gKiBsYXRlciwgaXQgYXNzdW1lcyB0aGUgcm9sZSBvZiBhIHVzZXIgYWdlbnQgY2xpZW50IGZvciB0aGVcbiAqIHByb2Nlc3Npbmcgb2YgdGhhdCB0cmFuc2FjdGlvbi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tNlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVXNlckFnZW50U2VydmVyIGltcGxlbWVudHMgSW5jb21pbmdSZXF1ZXN0IHtcbiAgcHJvdGVjdGVkIGxvZ2dlcjogTG9nZ2VyO1xuICBwcm90ZWN0ZWQgdG9UYWc6IHN0cmluZztcblxuICBwcml2YXRlIF90cmFuc2FjdGlvbjogU2VydmVyVHJhbnNhY3Rpb24gfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB0cmFuc2FjdGlvbkNvbnN0cnVjdG9yOiBTZXJ2ZXJUcmFuc2FjdGlvbkNvbnN0cnVjdG9yLFxuICAgIHByb3RlY3RlZCBjb3JlOiBVc2VyQWdlbnRDb3JlLFxuICAgIHB1YmxpYyBtZXNzYWdlOiBJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLFxuICAgIHB1YmxpYyBkZWxlZ2F0ZT86IEluY29taW5nUmVxdWVzdERlbGVnYXRlXG4gICkge1xuICAgIHRoaXMubG9nZ2VyID0gdGhpcy5sb2dnZXJGYWN0b3J5LmdldExvZ2dlcihcInNpcC51c2VyLWFnZW50LXNlcnZlclwiKTtcbiAgICB0aGlzLnRvVGFnID0gbWVzc2FnZS50b1RhZyA/IG1lc3NhZ2UudG9UYWcgOiBuZXdUYWcoKTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMudHJhbnNhY3Rpb24uZGlzcG9zZSgpO1xuICB9XG5cbiAgZ2V0IGxvZ2dlckZhY3RvcnkoKTogTG9nZ2VyRmFjdG9yeSB7XG4gICAgcmV0dXJuIHRoaXMuY29yZS5sb2dnZXJGYWN0b3J5O1xuICB9XG5cbiAgLyoqIFRoZSB0cmFuc2FjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXF1ZXN0LiAqL1xuICBnZXQgdHJhbnNhY3Rpb24oKTogU2VydmVyVHJhbnNhY3Rpb24ge1xuICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBhY2NlcHQob3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0geyBzdGF0dXNDb2RlOiAyMDAgfSk6IE91dGdvaW5nUmVzcG9uc2Uge1xuICAgIGlmICghdGhpcy5hY2NlcHRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25TdGF0ZUVycm9yKFxuICAgICAgICBgJHt0aGlzLm1lc3NhZ2UubWV0aG9kfSBub3QgYWNjZXB0YWJsZSBpbiBzdGF0ZSAke3RoaXMudHJhbnNhY3Rpb24uc3RhdGV9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGU7XG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDAgfHwgc3RhdHVzQ29kZSA+IDI5OSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzdGF0dXNDb2RlOiAke3N0YXR1c0NvZGV9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5yZXBseShvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBwdWJsaWMgcHJvZ3Jlc3Mob3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0geyBzdGF0dXNDb2RlOiAxODAgfSk6IE91dGdvaW5nUmVzcG9uc2Uge1xuICAgIGlmICghdGhpcy5wcm9ncmVzc2FibGUpIHtcbiAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvblN0YXRlRXJyb3IoXG4gICAgICAgIGAke3RoaXMubWVzc2FnZS5tZXRob2R9IG5vdCBwcm9ncmVzc2FibGUgaW4gc3RhdGUgJHt0aGlzLnRyYW5zYWN0aW9uLnN0YXRlfS5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlO1xuICAgIGlmIChzdGF0dXNDb2RlIDwgMTAxIHx8IHN0YXR1c0NvZGUgPiAxOTkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc3RhdHVzQ29kZTogJHtzdGF0dXNDb2RlfWApO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucmVwbHkob3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgcHVibGljIHJlZGlyZWN0KGNvbnRhY3RzOiBBcnJheTxVUkk+LCBvcHRpb25zOiBSZXNwb25zZU9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDMwMiB9KTogT3V0Z29pbmdSZXNwb25zZSB7XG4gICAgaWYgKCF0aGlzLnJlZGlyZWN0YWJsZSkge1xuICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uU3RhdGVFcnJvcihcbiAgICAgICAgYCR7dGhpcy5tZXNzYWdlLm1ldGhvZH0gbm90IHJlZGlyZWN0YWJsZSBpbiBzdGF0ZSAke3RoaXMudHJhbnNhY3Rpb24uc3RhdGV9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGU7XG4gICAgaWYgKHN0YXR1c0NvZGUgPCAzMDAgfHwgc3RhdHVzQ29kZSA+IDM5OSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzdGF0dXNDb2RlOiAke3N0YXR1c0NvZGV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhY3RIZWFkZXJzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICBjb250YWN0cy5mb3JFYWNoKChjb250YWN0KSA9PiBjb250YWN0SGVhZGVycy5wdXNoKGBDb250YWN0OiAke2NvbnRhY3QudG9TdHJpbmcoKX1gKSk7XG4gICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLmNvbmNhdChjb250YWN0SGVhZGVycyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJlcGx5KG9wdGlvbnMpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIHB1YmxpYyByZWplY3Qob3B0aW9uczogUmVzcG9uc2VPcHRpb25zID0geyBzdGF0dXNDb2RlOiA0ODAgfSk6IE91dGdvaW5nUmVzcG9uc2Uge1xuICAgIGlmICghdGhpcy5yZWplY3RhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25TdGF0ZUVycm9yKFxuICAgICAgICBgJHt0aGlzLm1lc3NhZ2UubWV0aG9kfSBub3QgcmVqZWN0YWJsZSBpbiBzdGF0ZSAke3RoaXMudHJhbnNhY3Rpb24uc3RhdGV9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGU7XG4gICAgaWYgKHN0YXR1c0NvZGUgPCA0MDAgfHwgc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzdGF0dXNDb2RlOiAke3N0YXR1c0NvZGV9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5yZXBseShvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBwdWJsaWMgdHJ5aW5nKG9wdGlvbnM/OiBSZXNwb25zZU9wdGlvbnMpOiBPdXRnb2luZ1Jlc3BvbnNlIHtcbiAgICBpZiAoIXRoaXMudHJ5aW5nYWJsZSkge1xuICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uU3RhdGVFcnJvcihcbiAgICAgICAgYCR7dGhpcy5tZXNzYWdlLm1ldGhvZH0gbm90IHRyeWluZ2FibGUgaW4gc3RhdGUgJHt0aGlzLnRyYW5zYWN0aW9uLnN0YXRlfS5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucmVwbHkoeyBzdGF0dXNDb2RlOiAxMDAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBVQVMgZGlkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgdHJhbnNhY3Rpb24gZm9yIHRoZSBDQU5DRUxcbiAgICogYWNjb3JkaW5nIHRvIHRoZSBwcm9jZWR1cmUgYWJvdmUsIGl0IFNIT1VMRCByZXNwb25kIHRvIHRoZSBDQU5DRUxcbiAgICogd2l0aCBhIDQ4MSAoQ2FsbCBMZWcvVHJhbnNhY3Rpb24gRG9lcyBOb3QgRXhpc3QpLiAgSWYgdGhlIHRyYW5zYWN0aW9uXG4gICAqIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdCBzdGlsbCBleGlzdHMsIHRoZSBiZWhhdmlvciBvZiB0aGUgVUFTIG9uXG4gICAqIHJlY2VpdmluZyBhIENBTkNFTCByZXF1ZXN0IGRlcGVuZHMgb24gd2hldGhlciBpdCBoYXMgYWxyZWFkeSBzZW50IGFcbiAgICogZmluYWwgcmVzcG9uc2UgZm9yIHRoZSBvcmlnaW5hbCByZXF1ZXN0LiAgSWYgaXQgaGFzLCB0aGUgQ0FOQ0VMXG4gICAqIHJlcXVlc3QgaGFzIG5vIGVmZmVjdCBvbiB0aGUgcHJvY2Vzc2luZyBvZiB0aGUgb3JpZ2luYWwgcmVxdWVzdCwgbm9cbiAgICogZWZmZWN0IG9uIGFueSBzZXNzaW9uIHN0YXRlLCBhbmQgbm8gZWZmZWN0IG9uIHRoZSByZXNwb25zZXMgZ2VuZXJhdGVkXG4gICAqIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdC4gIElmIHRoZSBVQVMgaGFzIG5vdCBpc3N1ZWQgYSBmaW5hbCByZXNwb25zZVxuICAgKiBmb3IgdGhlIG9yaWdpbmFsIHJlcXVlc3QsIGl0cyBiZWhhdmlvciBkZXBlbmRzIG9uIHRoZSBtZXRob2Qgb2YgdGhlXG4gICAqIG9yaWdpbmFsIHJlcXVlc3QuICBJZiB0aGUgb3JpZ2luYWwgcmVxdWVzdCB3YXMgYW4gSU5WSVRFLCB0aGUgVUFTXG4gICAqIFNIT1VMRCBpbW1lZGlhdGVseSByZXNwb25kIHRvIHRoZSBJTlZJVEUgd2l0aCBhIDQ4NyAoUmVxdWVzdFxuICAgKiBUZXJtaW5hdGVkKS4gIEEgQ0FOQ0VMIHJlcXVlc3QgaGFzIG5vIGltcGFjdCBvbiB0aGUgcHJvY2Vzc2luZyBvZlxuICAgKiB0cmFuc2FjdGlvbnMgd2l0aCBhbnkgb3RoZXIgbWV0aG9kIGRlZmluZWQgaW4gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMlxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIEluY29taW5nIENBTkNFTCByZXF1ZXN0LlxuICAgKi9cbiAgcHVibGljIHJlY2VpdmVDYW5jZWwobWVzc2FnZTogSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSk6IHZvaWQge1xuICAgIC8vIE5vdGU6IEN1cnJlbnRseSBDQU5DRUwgaXMgYmVpbmcgaGFuZGxlZCBhcyBhIHNwZWNpYWwgY2FzZS5cbiAgICAvLyBObyBVQVMgaXMgY3JlYXRlZCB0byBoYW5kbGUgdGhlIENBTkNFTCBhbmQgdGhlIHJlc3BvbnNlIHRvXG4gICAgLy8gaXQgQ0FOQ0VMIGlzIGJlaW5nIGhhbmRsZWQgc3RhdGVsZXNzbHkgYnkgdGhlIHVzZXIgYWdlbnQgY29yZS5cbiAgICAvLyBBcyBzdWNoLCB0aGVyZSBpcyBjdXJyZW50bHkgbm8gd2F5IHRvIGV4dGVybmFsbHkgaW1wYWN0IHRoZVxuICAgIC8vIHJlc3BvbnNlIHRvIHRoZSBhIENBTkNFTCByZXF1ZXN0LlxuICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25DYW5jZWwpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUub25DYW5jZWwobWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGdldCBhY2NlcHRhYmxlKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZyB8fFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlRyeWluZyB8fFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmdcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHJhbnNhY3Rpb24gdHlwZS5cIik7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IHByb2dyZXNzYWJsZSgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIEludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MzIwI3NlY3Rpb24tNC4xXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHJhbnNhY3Rpb24gdHlwZS5cIik7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IHJlZGlyZWN0YWJsZSgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIEludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlRyeWluZyB8fFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmdcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHJhbnNhY3Rpb24gdHlwZS5cIik7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IHJlamVjdGFibGUoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IFRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZztcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gVHJhbnNhY3Rpb25TdGF0ZS5UcnlpbmcgfHxcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRyYW5zYWN0aW9uIHR5cGUuXCIpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCB0cnlpbmdhYmxlKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc7XG4gICAgfVxuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSBUcmFuc2FjdGlvblN0YXRlLlRyeWluZztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0cmFuc2FjdGlvbiB0eXBlLlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgVUFTIHdpc2hlcyB0byBjb25zdHJ1Y3QgYSByZXNwb25zZSB0byBhIHJlcXVlc3QsIGl0IGZvbGxvd3NcbiAgICogdGhlIGdlbmVyYWwgcHJvY2VkdXJlcyBkZXRhaWxlZCBpbiB0aGUgZm9sbG93aW5nIHN1YnNlY3Rpb25zLlxuICAgKiBBZGRpdGlvbmFsIGJlaGF2aW9ycyBzcGVjaWZpYyB0byB0aGUgcmVzcG9uc2UgY29kZSBpbiBxdWVzdGlvbiwgd2hpY2hcbiAgICogYXJlIG5vdCBkZXRhaWxlZCBpbiB0aGlzIHNlY3Rpb24sIG1heSBhbHNvIGJlIHJlcXVpcmVkLlxuICAgKlxuICAgKiBPbmNlIGFsbCBwcm9jZWR1cmVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3JlYXRpb24gb2YgYSByZXNwb25zZSBoYXZlXG4gICAqIGJlZW4gY29tcGxldGVkLCB0aGUgVUFTIGhhbmRzIHRoZSByZXNwb25zZSBiYWNrIHRvIHRoZSBzZXJ2ZXJcbiAgICogdHJhbnNhY3Rpb24gZnJvbSB3aGljaCBpdCByZWNlaXZlZCB0aGUgcmVxdWVzdC5cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNlxuICAgKiBAcGFyYW0gc3RhdHVzQ29kZSAtIFN0YXR1cyBjb2RlIHRvIHJlcGx5IHdpdGguXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVwbHkgb3B0aW9ucyBidWNrZXQuXG4gICAqL1xuICBwcml2YXRlIHJlcGx5KG9wdGlvbnM6IFJlc3BvbnNlT3B0aW9ucyk6IE91dGdvaW5nUmVzcG9uc2Uge1xuICAgIGlmICghb3B0aW9ucy50b1RhZyAmJiBvcHRpb25zLnN0YXR1c0NvZGUgIT09IDEwMCkge1xuICAgICAgb3B0aW9ucy50b1RhZyA9IHRoaXMudG9UYWc7XG4gICAgfVxuICAgIG9wdGlvbnMudXNlckFnZW50ID0gb3B0aW9ucy51c2VyQWdlbnQgfHwgdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24udXNlckFnZW50SGVhZGVyRmllbGRWYWx1ZTtcbiAgICBvcHRpb25zLnN1cHBvcnRlZCA9IG9wdGlvbnMuc3VwcG9ydGVkIHx8IHRoaXMuY29yZS5jb25maWd1cmF0aW9uLnN1cHBvcnRlZE9wdGlvblRhZ3NSZXNwb25zZTtcbiAgICBjb25zdCByZXNwb25zZSA9IGNvbnN0cnVjdE91dGdvaW5nUmVzcG9uc2UodGhpcy5tZXNzYWdlLCBvcHRpb25zKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLnJlY2VpdmVSZXNwb25zZShvcHRpb25zLnN0YXR1c0NvZGUsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdCgpOiB2b2lkIHtcbiAgICAvLyBXZSBhcmUgdGhlIHRyYW5zYWN0aW9uIHVzZXIuXG4gICAgY29uc3QgdXNlcjogU2VydmVyVHJhbnNhY3Rpb25Vc2VyID0ge1xuICAgICAgbG9nZ2VyRmFjdG9yeTogdGhpcy5sb2dnZXJGYWN0b3J5LFxuICAgICAgb25TdGF0ZUNoYW5nZTogKG5ld1N0YXRlKSA9PiB7XG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0ZXJtaW5hdGVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNvcmUuXG4gICAgICAgICAgdGhpcy5jb3JlLnVzZXJBZ2VudFNlcnZlcnMuZGVsZXRlKHVzZXJBZ2VudFNlcnZlcklkKTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVHJhbnNwb3J0RXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblRyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblRyYW5zcG9ydEVycm9yKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlVzZXIgYWdlbnQgc2VydmVyIHJlc3BvbnNlIHRyYW5zcG9ydCBlcnJvci5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIENyZWF0ZSBhIG5ldyB0cmFuc2FjdGlvbiB3aXRoIHVzIGFzIHRoZSB1c2VyLlxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IHRoaXMudHJhbnNhY3Rpb25Db25zdHJ1Y3Rvcih0aGlzLm1lc3NhZ2UsIHRoaXMuY29yZS50cmFuc3BvcnQsIHVzZXIpO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgLy8gQWRkIHRoZSBuZXcgdHJhbnNhY3Rpb24gdG8gdGhlIGNvcmUuXG4gICAgY29uc3QgdXNlckFnZW50U2VydmVySWQgPSB0cmFuc2FjdGlvbi5pZDtcbiAgICB0aGlzLmNvcmUudXNlckFnZW50U2VydmVycy5zZXQodHJhbnNhY3Rpb24uaWQsIHRoaXMpO1xuICB9XG59XG4iLCIvLyB0c2xpbnQ6ZGlzYWJsZTppbnRlcmZhY2UtbmFtZVxuLy8gdHNsaW50OmRpc2FibGU6IHRyYWlsaW5nLWNvbW1hXG4vLyB0c2xpbnQ6ZGlzYWJsZTogb2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzXG4vLyB0c2xpbnQ6ZGlzYWJsZTogbWF4LWxpbmUtbGVuZ3RoXG4vLyB0c2xpbnQ6ZGlzYWJsZTogb25seS1hcnJvdy1mdW5jdGlvbnNcbi8vIHRzbGludDpkaXNhYmxlOiBvbmUtdmFyaWFibGUtcGVyLWRlY2xhcmF0aW9uXG4vLyB0c2xpbnQ6ZGlzYWJsZTogbm8tY29uc2VjdXRpdmUtYmxhbmstbGluZXNcbi8vIHRzbGludDpkaXNhYmxlOiBhbGlnblxuLy8gdHNsaW50OmRpc2FibGU6IHJhZGl4XG4vLyB0c2xpbnQ6ZGlzYWJsZTogcXVvdGVtYXJrXG4vLyB0c2xpbnQ6ZGlzYWJsZTogc2VtaWNvbG9uXG4vLyB0c2xpbnQ6ZGlzYWJsZTogb2JqZWN0LWxpdGVyYWwtc2hvcnRoYW5kXG4vLyB0c2xpbnQ6ZGlzYWJsZTogdmFyaWFibGUtbmFtZVxuLy8gdHNsaW50OmRpc2FibGU6IG5vLXZhci1rZXl3b3JkXG4vLyB0c2xpbnQ6ZGlzYWJsZTogd2hpdGVzcGFjZVxuLy8gdHNsaW50OmRpc2FibGU6IGN1cmx5XG4vLyB0c2xpbnQ6ZGlzYWJsZTogcHJlZmVyLWNvbnN0XG4vLyB0c2xpbnQ6ZGlzYWJsZTogb2JqZWN0LWxpdGVyYWwta2V5LXF1b3Rlc1xuLy8gdHNsaW50OmRpc2FibGU6IG5vLXN0cmluZy1saXRlcmFsXG4vLyB0c2xpbnQ6ZGlzYWJsZTogb25lLWxpbmVcbi8vIHRzbGludDpkaXNhYmxlOiBuby11bnVzZWQtZXhwcmVzc2lvblxuLy8gdHNsaW50OmRpc2FibGU6IHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlblxuLy8gdHNsaW50OmRpc2FibGU6IGFycm93LXJldHVybi1zaG9ydGhhbmRcblxuLy8gR2VuZXJhdGVkIGJ5IFBFRy5qcyB2LiAwLjEwLjAgKHRzLXBlZ2pzIHBsdWdpbiB2LiAwLjIuNiApXG4vL1xuLy8gaHR0cHM6Ly9wZWdqcy5vcmcvICAgaHR0cHM6Ly9naXRodWIuY29tL21ldGFkZXZwcm8vdHMtcGVnanNcblxuaW1wb3J0IHsgTmFtZUFkZHJIZWFkZXIgfSBmcm9tIFwiLi4vLi4vY29yZS9tZXNzYWdlcy9uYW1lLWFkZHItaGVhZGVyXCI7XG5pbXBvcnQgeyBVUkkgfSBmcm9tIFwiLi4vLi4vY29yZS9tZXNzYWdlcy91cmlcIjtcbmV4cG9ydCBpbnRlcmZhY2UgSUZpbGVQb3NpdGlvbiB7XG4gIG9mZnNldDogbnVtYmVyO1xuICBsaW5lOiBudW1iZXI7XG4gIGNvbHVtbjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGaWxlUmFuZ2Uge1xuICBzdGFydDogSUZpbGVQb3NpdGlvbjtcbiAgZW5kOiBJRmlsZVBvc2l0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElMaXRlcmFsRXhwZWN0YXRpb24ge1xuICB0eXBlOiBcImxpdGVyYWxcIjtcbiAgdGV4dDogc3RyaW5nO1xuICBpZ25vcmVDYXNlOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDbGFzc1BhcnRzIGV4dGVuZHMgQXJyYXk8c3RyaW5nIHwgSUNsYXNzUGFydHM+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNsYXNzRXhwZWN0YXRpb24ge1xuICB0eXBlOiBcImNsYXNzXCI7XG4gIHBhcnRzOiBJQ2xhc3NQYXJ0cztcbiAgaW52ZXJ0ZWQ6IGJvb2xlYW47XG4gIGlnbm9yZUNhc2U6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUFueUV4cGVjdGF0aW9uIHtcbiAgdHlwZTogXCJhbnlcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRW5kRXhwZWN0YXRpb24ge1xuICB0eXBlOiBcImVuZFwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElPdGhlckV4cGVjdGF0aW9uIHtcbiAgdHlwZTogXCJvdGhlclwiO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBFeHBlY3RhdGlvbiA9IElMaXRlcmFsRXhwZWN0YXRpb24gfCBJQ2xhc3NFeHBlY3RhdGlvbiB8IElBbnlFeHBlY3RhdGlvbiB8IElFbmRFeHBlY3RhdGlvbiB8IElPdGhlckV4cGVjdGF0aW9uO1xuXG5leHBvcnQgY2xhc3MgU3ludGF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyBzdGF0aWMgYnVpbGRNZXNzYWdlKGV4cGVjdGVkOiBFeHBlY3RhdGlvbltdLCBmb3VuZDogc3RyaW5nIHwgbnVsbCkge1xuICAgIGZ1bmN0aW9uIGhleChjaDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpdGVyYWxFc2NhcGUoczogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiBzXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIilcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICBcIlxcXFxcXFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKVxuICAgICAgICAucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIilcbiAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKVxuICAgICAgICAucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCAgICAgICAgICAgIChjaCkgPT4gXCJcXFxceDBcIiArIGhleChjaCkgKVxuICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4N0YtXFx4OUZdL2csIChjaCkgPT4gXCJcXFxceFwiICArIGhleChjaCkgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFzc0VzY2FwZShzOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHNcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKVxuICAgICAgICAucmVwbGFjZSgvXFxdL2csIFwiXFxcXF1cIilcbiAgICAgICAgLnJlcGxhY2UoL1xcXi9nLCBcIlxcXFxeXCIpXG4gICAgICAgIC5yZXBsYWNlKC8tL2csICBcIlxcXFwtXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKVxuICAgICAgICAucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIilcbiAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKVxuICAgICAgICAucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCAgICAgICAgICAgIChjaCkgPT4gXCJcXFxceDBcIiArIGhleChjaCkgKVxuICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4N0YtXFx4OUZdL2csIChjaCkgPT4gXCJcXFxceFwiICArIGhleChjaCkgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uOiBFeHBlY3RhdGlvbikge1xuICAgICAgc3dpdGNoIChleHBlY3RhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJsaXRlcmFsXCI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcIlwiICsgbGl0ZXJhbEVzY2FwZShleHBlY3RhdGlvbi50ZXh0KSArIFwiXFxcIlwiO1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICBjb25zdCBlc2NhcGVkUGFydHMgPSBleHBlY3RhdGlvbi5wYXJ0cy5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBhcnQpXG4gICAgICAgICAgICAgID8gY2xhc3NFc2NhcGUocGFydFswXSBhcyBzdHJpbmcpICsgXCItXCIgKyBjbGFzc0VzY2FwZShwYXJ0WzFdIGFzIHN0cmluZylcbiAgICAgICAgICAgICAgOiBjbGFzc0VzY2FwZShwYXJ0KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBcIltcIiArIChleHBlY3RhdGlvbi5pbnZlcnRlZCA/IFwiXlwiIDogXCJcIikgKyBlc2NhcGVkUGFydHMgKyBcIl1cIjtcbiAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgIHJldHVybiBcImFueSBjaGFyYWN0ZXJcIjtcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBcImVuZCBvZiBpbnB1dFwiO1xuICAgICAgICBjYXNlIFwib3RoZXJcIjpcbiAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24uZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZDE6IEV4cGVjdGF0aW9uW10pIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9ucyA9IGV4cGVjdGVkMS5tYXAoZGVzY3JpYmVFeHBlY3RhdGlvbik7XG4gICAgICBsZXQgaTogbnVtYmVyO1xuICAgICAgbGV0IGo6IG51bWJlcjtcblxuICAgICAgZGVzY3JpcHRpb25zLnNvcnQoKTtcblxuICAgICAgaWYgKGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoaSA9IDEsIGogPSAxOyBpIDwgZGVzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGRlc2NyaXB0aW9uc1tpIC0gMV0gIT09IGRlc2NyaXB0aW9uc1tpXSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25zW2pdID0gZGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdGlvbnMubGVuZ3RoID0gajtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChkZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zWzBdO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zWzBdICsgXCIgb3IgXCIgKyBkZXNjcmlwdGlvbnNbMV07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICsgXCIsIG9yIFwiXG4gICAgICAgICAgICArIGRlc2NyaXB0aW9uc1tkZXNjcmlwdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVzY3JpYmVGb3VuZChmb3VuZDE6IHN0cmluZyB8IG51bGwpIHtcbiAgICAgIHJldHVybiBmb3VuZDEgPyBcIlxcXCJcIiArIGxpdGVyYWxFc2NhcGUoZm91bmQxKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQpICsgXCIgYnV0IFwiICsgZGVzY3JpYmVGb3VuZChmb3VuZCkgKyBcIiBmb3VuZC5cIjtcbiAgfVxuXG4gIHB1YmxpYyBtZXNzYWdlOiBzdHJpbmc7XG4gIHB1YmxpYyBleHBlY3RlZDogRXhwZWN0YXRpb25bXTtcbiAgcHVibGljIGZvdW5kOiBzdHJpbmcgfCBudWxsO1xuICBwdWJsaWMgbG9jYXRpb246IElGaWxlUmFuZ2U7XG4gIHB1YmxpYyBuYW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBleHBlY3RlZDogRXhwZWN0YXRpb25bXSwgZm91bmQ6IHN0cmluZyB8IG51bGwsIGxvY2F0aW9uOiBJRmlsZVJhbmdlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICB0aGlzLmZvdW5kID0gZm91bmQ7XG4gICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIHRoaXMubmFtZSA9IFwiU3ludGF4RXJyb3JcIjtcblxuICAgIGlmICh0eXBlb2YgKEVycm9yIGFzIGFueSkuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgKEVycm9yIGFzIGFueSkuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgU3ludGF4RXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwZWckcGFyc2UoaW5wdXQ6IHN0cmluZywgb3B0aW9ucz86IElQYXJzZU9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fTtcblxuICBjb25zdCBwZWckRkFJTEVEOiBSZWFkb25seTx7fT4gPSB7fTtcblxuICBjb25zdCBwZWckc3RhcnRSdWxlSW5kaWNlczoge1tpZDogc3RyaW5nXTogbnVtYmVyfSAgPSB7IENvbnRhY3Q6IDExOSwgTmFtZV9BZGRyX0hlYWRlcjogMTU2LCBSZWNvcmRfUm91dGU6IDE3NiwgUmVxdWVzdF9SZXNwb25zZTogODEsIFNJUF9VUkk6IDQ1LCBTdWJzY3JpcHRpb25fU3RhdGU6IDE4NiwgU3VwcG9ydGVkOiAxOTEsIFJlcXVpcmU6IDE4MiwgVmlhOiAxOTQsIGFic29sdXRlVVJJOiA4NCwgQ2FsbF9JRDogMTE4LCBDb250ZW50X0Rpc3Bvc2l0aW9uOiAxMzAsIENvbnRlbnRfTGVuZ3RoOiAxMzUsIENvbnRlbnRfVHlwZTogMTM2LCBDU2VxOiAxNDYsIGRpc3BsYXlOYW1lOiAxMjIsIEV2ZW50OiAxNDksIEZyb206IDE1MSwgaG9zdDogNTIsIE1heF9Gb3J3YXJkczogMTU0LCBNaW5fU0U6IDIxMywgUHJveHlfQXV0aGVudGljYXRlOiAxNTcsIHF1b3RlZF9zdHJpbmc6IDQwLCBSZWZlcl9UbzogMTc4LCBSZXBsYWNlczogMTc5LCBTZXNzaW9uX0V4cGlyZXM6IDIxMCwgc3R1bl9VUkk6IDIxNywgVG86IDE5MiwgdHVybl9VUkk6IDIyMywgdXVpZDogMjI2LCBXV1dfQXV0aGVudGljYXRlOiAyMDksIGNoYWxsZW5nZTogMTU4LCBzaXBmcmFnOiAyMzAsIFJlZmVycmVkX0J5OiAyMzEgfTtcbiAgbGV0IHBlZyRzdGFydFJ1bGVJbmRleCA9IDExOTtcblxuICBjb25zdCBwZWckY29uc3RzID0gW1xuICAgIFwiXFxyXFxuXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlxcclxcblwiLCBmYWxzZSksXG4gICAgL15bMC05XS8sXG4gICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjBcIiwgXCI5XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAvXlthLXpBLVpdLyxcbiAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAvXlswLTlhLWZBLUZdLyxcbiAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiMFwiLCBcIjlcIl0sIFtcImFcIiwgXCJmXCJdLCBbXCJBXCIsIFwiRlwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgL15bXFwwLVxceEZGXS8sXG4gICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIlxcMFwiLCBcIlxceEZGXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAvXltcIl0vLFxuICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIlxcXCJcIl0sIGZhbHNlLCBmYWxzZSksXG4gICAgXCIgXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiBcIiwgZmFsc2UpLFxuICAgIFwiXFx0XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlxcdFwiLCBmYWxzZSksXG4gICAgL15bYS16QS1aMC05XS8sXG4gICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIFwiO1wiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI7XCIsIGZhbHNlKSxcbiAgICBcIi9cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiL1wiLCBmYWxzZSksXG4gICAgXCI/XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIj9cIiwgZmFsc2UpLFxuICAgIFwiOlwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI6XCIsIGZhbHNlKSxcbiAgICBcIkBcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiQFwiLCBmYWxzZSksXG4gICAgXCImXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiZcIiwgZmFsc2UpLFxuICAgIFwiPVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI9XCIsIGZhbHNlKSxcbiAgICBcIitcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiK1wiLCBmYWxzZSksXG4gICAgXCIkXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiRcIiwgZmFsc2UpLFxuICAgIFwiLFwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIsXCIsIGZhbHNlKSxcbiAgICBcIi1cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLVwiLCBmYWxzZSksXG4gICAgXCJfXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIl9cIiwgZmFsc2UpLFxuICAgIFwiLlwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIuXCIsIGZhbHNlKSxcbiAgICBcIiFcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiIVwiLCBmYWxzZSksXG4gICAgXCJ+XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIn5cIiwgZmFsc2UpLFxuICAgIFwiKlwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIqXCIsIGZhbHNlKSxcbiAgICBcIidcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiJ1wiLCBmYWxzZSksXG4gICAgXCIoXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIihcIiwgZmFsc2UpLFxuICAgIFwiKVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIpXCIsIGZhbHNlKSxcbiAgICBcIiVcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiJVwiLCBmYWxzZSksXG4gICAgZnVuY3Rpb24oKTogYW55IHtyZXR1cm4gXCIgXCI7IH0sXG4gICAgZnVuY3Rpb24oKTogYW55IHtyZXR1cm4gJzonOyB9LFxuICAgIC9eWyEtfl0vLFxuICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIhXCIsIFwiflwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgL15bXFx4ODAtXFx1RkZGRl0vLFxuICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJcXHg4MFwiLCBcIlxcdUZGRkZcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIC9eW1xceDgwLVxceEJGXS8sXG4gICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIlxceDgwXCIsIFwiXFx4QkZcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIC9eW2EtZl0vLFxuICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJhXCIsIFwiZlwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgXCJgXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImBcIiwgZmFsc2UpLFxuICAgIFwiPFwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI8XCIsIGZhbHNlKSxcbiAgICBcIj5cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiPlwiLCBmYWxzZSksXG4gICAgXCJcXFxcXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlxcXFxcIiwgZmFsc2UpLFxuICAgIFwiW1wiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJbXCIsIGZhbHNlKSxcbiAgICBcIl1cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiXVwiLCBmYWxzZSksXG4gICAgXCJ7XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIntcIiwgZmFsc2UpLFxuICAgIFwifVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ9XCIsIGZhbHNlKSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIipcIjsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIi9cIjsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIj1cIjsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIihcIjsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIilcIjsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIj5cIjsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIjxcIjsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIixcIjsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIjtcIjsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIjpcIjsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge3JldHVybiBcIlxcXCJcIjsgfSxcbiAgICAvXlshLSddLyxcbiAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiIVwiLCBcIidcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIC9eWyotW10vLFxuICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIqXCIsIFwiW1wiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgL15bXFxdLX5dLyxcbiAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiXVwiLCBcIn5cIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIGZ1bmN0aW9uKGNvbnRlbnRzOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50czsgfSxcbiAgICAvXlsjLVtdLyxcbiAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiI1wiLCBcIltcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIC9eW1xcMC1cXHRdLyxcbiAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiXFwwXCIsIFwiXFx0XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAvXltcXHgwQi1cXGZdLyxcbiAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiXFx4MEJcIiwgXCJcXGZcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIC9eW1xceDBFLVxceDdGXS8sXG4gICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIlxceDBFXCIsIFwiXFx4N0ZcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaSA9IG5ldyBVUkkob3B0aW9ucy5kYXRhLnNjaGVtZSwgb3B0aW9ucy5kYXRhLnVzZXIsIG9wdGlvbnMuZGF0YS5ob3N0LCBvcHRpb25zLmRhdGEucG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5zY2hlbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpID0gbmV3IFVSSShvcHRpb25zLmRhdGEuc2NoZW1lLCBvcHRpb25zLmRhdGEudXNlciwgb3B0aW9ucy5kYXRhLmhvc3QsIG9wdGlvbnMuZGF0YS5wb3J0LCBvcHRpb25zLmRhdGEudXJpX3BhcmFtcywgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnNjaGVtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdF90eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdTSVBfVVJJJykgeyBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEudXJpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICBcInNpcHNcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwic2lwc1wiLCB0cnVlKSxcbiAgICBcInNpcFwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJzaXBcIiwgdHJ1ZSksXG4gICAgZnVuY3Rpb24odXJpX3NjaGVtZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNjaGVtZSA9IHVyaV9zY2hlbWU7IH0sXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVzZXIgPSBkZWNvZGVVUklDb21wb25lbnQodGV4dCgpLnNsaWNlKDAsIC0xKSk7fSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFzc3dvcmQgPSB0ZXh0KCk7IH0sXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3QgPSB0ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXRhLmhvc3Q7IH0sXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdF90eXBlID0gJ2RvbWFpbic7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoKTsgfSxcbiAgICAvXlthLXpBLVowLTlfXFwtXS8sXG4gICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl0sIFwiX1wiLCBcIi1cIl0sIGZhbHNlLCBmYWxzZSksXG4gICAgL15bYS16QS1aMC05XFwtXS8sXG4gICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl0sIFwiLVwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdF90eXBlID0gJ0lQdjYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoKTsgfSxcbiAgICBcIjo6XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjo6XCIsIGZhbHNlKSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnSVB2Nic7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoKTsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdF90eXBlID0gJ0lQdjQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoKTsgfSxcbiAgICBcIjI1XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjI1XCIsIGZhbHNlKSxcbiAgICAvXlswLTVdLyxcbiAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiMFwiLCBcIjVcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIFwiMlwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIyXCIsIGZhbHNlKSxcbiAgICAvXlswLTRdLyxcbiAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiMFwiLCBcIjRcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIFwiMVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIxXCIsIGZhbHNlKSxcbiAgICAvXlsxLTldLyxcbiAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiMVwiLCBcIjlcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgIGZ1bmN0aW9uKHBvcnQ6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChwb3J0LmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wb3J0ID0gcG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3J0OyB9LFxuICAgIFwidHJhbnNwb3J0PVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0cmFuc3BvcnQ9XCIsIHRydWUpLFxuICAgIFwidWRwXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInVkcFwiLCB0cnVlKSxcbiAgICBcInRjcFwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0Y3BcIiwgdHJ1ZSksXG4gICAgXCJzY3RwXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInNjdHBcIiwgdHJ1ZSksXG4gICAgXCJ0bHNcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidGxzXCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKHRyYW5zcG9ydDogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWyd0cmFuc3BvcnQnXSA9IHRyYW5zcG9ydC50b0xvd2VyQ2FzZSgpOyB9LFxuICAgIFwidXNlcj1cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidXNlcj1cIiwgdHJ1ZSksXG4gICAgXCJwaG9uZVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJwaG9uZVwiLCB0cnVlKSxcbiAgICBcImlwXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImlwXCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKHVzZXI6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1sndXNlciddID0gdXNlci50b0xvd2VyQ2FzZSgpOyB9LFxuICAgIFwibWV0aG9kPVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJtZXRob2Q9XCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKG1ldGhvZDogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWydtZXRob2QnXSA9IG1ldGhvZDsgfSxcbiAgICBcInR0bD1cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidHRsPVwiLCB0cnVlKSxcbiAgICBmdW5jdGlvbih0dGw6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnBhcmFtcykgb3B0aW9ucy5kYXRhLnBhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtc1sndHRsJ10gPSB0dGw7IH0sXG4gICAgXCJtYWRkcj1cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwibWFkZHI9XCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKG1hZGRyOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ21hZGRyJ10gPSBtYWRkcjsgfSxcbiAgICBcImxyXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImxyXCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1snbHInXSA9IHVuZGVmaW5lZDsgfSxcbiAgICBmdW5jdGlvbihwYXJhbTogYW55LCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zW3BhcmFtLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7fSxcbiAgICBmdW5jdGlvbihobmFtZTogYW55LCBodmFsdWU6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhuYW1lID0gaG5hbWUuam9pbignJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaHZhbHVlID0gaHZhbHVlLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfaGVhZGVycykgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzW2huYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVyc1tobmFtZV0gPSBbaHZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnNbaG5hbWVdLnB1c2goaHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfX0sXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvdHMgb2YgdGVzdHMgZmFpbCBpZiB0aGlzIGlzbid0IGd1YXJkZWQuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnUmVmZXJfVG8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaSA9IG5ldyBVUkkob3B0aW9ucy5kYXRhLnNjaGVtZSwgb3B0aW9ucy5kYXRhLnVzZXIsIG9wdGlvbnMuZGF0YS5ob3N0LCBvcHRpb25zLmRhdGEucG9ydCwgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMsIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5zY2hlbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgIFwiLy9cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLy9cIiwgZmFsc2UpLFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zY2hlbWU9IHRleHQoKTsgfSxcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiU0lQXCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zaXBfdmVyc2lvbiA9IHRleHQoKTsgfSxcbiAgICBcIklOVklURVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJJTlZJVEVcIiwgZmFsc2UpLFxuICAgIFwiQUNLXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIkFDS1wiLCBmYWxzZSksXG4gICAgXCJWWEFDSFwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJWWEFDSFwiLCBmYWxzZSksXG4gICAgXCJPUFRJT05TXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIk9QVElPTlNcIiwgZmFsc2UpLFxuICAgIFwiQllFXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIkJZRVwiLCBmYWxzZSksXG4gICAgXCJDQU5DRUxcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiQ0FOQ0VMXCIsIGZhbHNlKSxcbiAgICBcIlJFR0lTVEVSXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlJFR0lTVEVSXCIsIGZhbHNlKSxcbiAgICBcIlNVQlNDUklCRVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJTVUJTQ1JJQkVcIiwgZmFsc2UpLFxuICAgIFwiTk9USUZZXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIk5PVElGWVwiLCBmYWxzZSksXG4gICAgXCJSRUZFUlwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJSRUZFUlwiLCBmYWxzZSksXG4gICAgXCJQVUJMSVNIXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlBVQkxJU0hcIiwgZmFsc2UpLFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm1ldGhvZCA9IHRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRhdGEubWV0aG9kOyB9LFxuICAgIGZ1bmN0aW9uKHN0YXR1c19jb2RlOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zdGF0dXNfY29kZSA9IHBhcnNlSW50KHN0YXR1c19jb2RlLmpvaW4oJycpKTsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZWFzb25fcGhyYXNlID0gdGV4dCgpOyB9LFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG4gICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHRleHQoKTsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHgsIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyW2lkeF0ucGFyc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIpIG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbmV3IE5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIucHVzaCggeyAncG9zaXRpb24nOiBwZWckY3VyclBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvZmZzZXQnOiBsb2NhdGlvbigpLnN0YXJ0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwYXJzZWQnOiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTt9LFxuICAgIGZ1bmN0aW9uKGRpc3BsYXlOYW1lOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gdGV4dCgpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcGxheU5hbWVbMF0gPT09ICdcXFwiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZS5zdWJzdHJpbmcoMSwgZGlzcGxheU5hbWUubGVuZ3RoLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTsgfSxcbiAgICBcInFcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicVwiLCB0cnVlKSxcbiAgICBmdW5jdGlvbihxOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEucGFyYW1zKSBvcHRpb25zLmRhdGEucGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtc1sncSddID0gcTsgfSxcbiAgICBcImV4cGlyZXNcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiZXhwaXJlc1wiLCB0cnVlKSxcbiAgICBmdW5jdGlvbihleHBpcmVzOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEucGFyYW1zKSBvcHRpb25zLmRhdGEucGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtc1snZXhwaXJlcyddID0gZXhwaXJlczsgfSxcbiAgICBmdW5jdGlvbihkZWx0YV9zZWNvbmRzOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChkZWx0YV9zZWNvbmRzLmpvaW4oJycpKTsgfSxcbiAgICBcIjBcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMFwiLCBmYWxzZSksXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0ZXh0KCkpOyB9LFxuICAgIGZ1bmN0aW9uKHBhcmFtOiBhbnksIHZhbHVlOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEucGFyYW1zKSBvcHRpb25zLmRhdGEucGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbcGFyYW0udG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTt9LFxuICAgIFwicmVuZGVyXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInJlbmRlclwiLCB0cnVlKSxcbiAgICBcInNlc3Npb25cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwic2Vzc2lvblwiLCB0cnVlKSxcbiAgICBcImljb25cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiaWNvblwiLCB0cnVlKSxcbiAgICBcImFsZXJ0XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImFsZXJ0XCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdDb250ZW50X0Rpc3Bvc2l0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS50eXBlID0gdGV4dCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgXCJoYW5kbGluZ1wiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJoYW5kbGluZ1wiLCB0cnVlKSxcbiAgICBcIm9wdGlvbmFsXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIm9wdGlvbmFsXCIsIHRydWUpLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicmVxdWlyZWRcIiwgdHJ1ZSksXG4gICAgZnVuY3Rpb24obGVuZ3RoOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHBhcnNlSW50KGxlbmd0aC5qb2luKCcnKSk7IH0sXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB0ZXh0KCk7IH0sXG4gICAgXCJ0ZXh0XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRleHRcIiwgdHJ1ZSksXG4gICAgXCJpbWFnZVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJpbWFnZVwiLCB0cnVlKSxcbiAgICBcImF1ZGlvXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImF1ZGlvXCIsIHRydWUpLFxuICAgIFwidmlkZW9cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidmlkZW9cIiwgdHJ1ZSksXG4gICAgXCJhcHBsaWNhdGlvblwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJhcHBsaWNhdGlvblwiLCB0cnVlKSxcbiAgICBcIm1lc3NhZ2VcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwibWVzc2FnZVwiLCB0cnVlKSxcbiAgICBcIm11bHRpcGFydFwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJtdWx0aXBhcnRcIiwgdHJ1ZSksXG4gICAgXCJ4LVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ4LVwiLCB0cnVlKSxcbiAgICBmdW5jdGlvbihjc2VxX3ZhbHVlOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS52YWx1ZT1wYXJzZUludChjc2VxX3ZhbHVlLmpvaW4oJycpKTsgfSxcbiAgICBmdW5jdGlvbihleHBpcmVzOiBhbnkpOiBhbnkge29wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319OyBvcHRpb25zLmRhdGEgPSBleHBpcmVzOyB9LFxuICAgIGZ1bmN0aW9uKGV2ZW50X3R5cGU6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ldmVudCA9IGV2ZW50X3R5cGUudG9Mb3dlckNhc2UoKTsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IG9wdGlvbnMuZGF0YS50YWc7XG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IE5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZykge29wdGlvbnMuZGF0YS5zZXRQYXJhbSgndGFnJyx0YWcpfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgIFwidGFnXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRhZ1wiLCB0cnVlKSxcbiAgICBmdW5jdGlvbih0YWc6IGFueSk6IGFueSB7b3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07b3B0aW9ucy5kYXRhLnRhZyA9IHRhZzsgfSxcbiAgICBmdW5jdGlvbihmb3J3YXJkczogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBwYXJzZUludChmb3J3YXJkcy5qb2luKCcnKSk7IH0sXG4gICAgZnVuY3Rpb24obWluX2V4cGlyZXM6IGFueSk6IGFueSB7b3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07IG9wdGlvbnMuZGF0YSA9IG1pbl9leHBpcmVzOyB9LFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IE5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgXCJkaWdlc3RcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiRGlnZXN0XCIsIHRydWUpLFxuICAgIFwicmVhbG1cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicmVhbG1cIiwgdHJ1ZSksXG4gICAgZnVuY3Rpb24ocmVhbG06IGFueSk6IGFueSB7IG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319OyBvcHRpb25zLmRhdGEucmVhbG0gPSByZWFsbTsgfSxcbiAgICBcImRvbWFpblwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJkb21haW5cIiwgdHJ1ZSksXG4gICAgXCJub25jZVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJub25jZVwiLCB0cnVlKSxcbiAgICBmdW5jdGlvbihub25jZTogYW55KTogYW55IHsgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07IG9wdGlvbnMuZGF0YS5ub25jZT1ub25jZTsgfSxcbiAgICBcIm9wYXF1ZVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJvcGFxdWVcIiwgdHJ1ZSksXG4gICAgZnVuY3Rpb24ob3BhcXVlOiBhbnkpOiBhbnkgeyBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTsgb3B0aW9ucy5kYXRhLm9wYXF1ZT1vcGFxdWU7IH0sXG4gICAgXCJzdGFsZVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJzdGFsZVwiLCB0cnVlKSxcbiAgICBcInRydWVcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidHJ1ZVwiLCB0cnVlKSxcbiAgICBmdW5jdGlvbigpOiBhbnkgeyBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTsgb3B0aW9ucy5kYXRhLnN0YWxlPXRydWU7IH0sXG4gICAgXCJmYWxzZVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJmYWxzZVwiLCB0cnVlKSxcbiAgICBmdW5jdGlvbigpOiBhbnkgeyBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTsgb3B0aW9ucy5kYXRhLnN0YWxlPWZhbHNlOyB9LFxuICAgIFwiYWxnb3JpdGhtXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImFsZ29yaXRobVwiLCB0cnVlKSxcbiAgICBcIm1kNVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJNRDVcIiwgdHJ1ZSksXG4gICAgXCJtZDUtc2Vzc1wiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJNRDUtc2Vzc1wiLCB0cnVlKSxcbiAgICBmdW5jdGlvbihhbGdvcml0aG06IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuYWxnb3JpdGhtPWFsZ29yaXRobS50b1VwcGVyQ2FzZSgpOyB9LFxuICAgIFwicW9wXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInFvcFwiLCB0cnVlKSxcbiAgICBcImF1dGgtaW50XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImF1dGgtaW50XCIsIHRydWUpLFxuICAgIFwiYXV0aFwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJhdXRoXCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKHFvcF92YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucW9wIHx8IChvcHRpb25zLmRhdGEucW9wPVtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucW9wLnB1c2gocW9wX3ZhbHVlLnRvTG93ZXJDYXNlKCkpOyB9LFxuICAgIGZ1bmN0aW9uKHJhY2tfdmFsdWU6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnZhbHVlPXBhcnNlSW50KHJhY2tfdmFsdWUuam9pbignJykpOyB9LFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCwgbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXJbaWR4XS5wYXJzZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgIH19LFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcikgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5wdXNoKCB7ICdwb3NpdGlvbic6IHBlZyRjdXJyUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29mZnNldCc6IGxvY2F0aW9uKCkuc3RhcnQub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhcnNlZCc6IGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO30sXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IE5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEob3B0aW9ucy5kYXRhLnJlcGxhY2VzX2Zyb21fdGFnICYmIG9wdGlvbnMuZGF0YS5yZXBsYWNlc190b190YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsX2lkOiBvcHRpb25zLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgXCJmcm9tLXRhZ1wiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJmcm9tLXRhZ1wiLCB0cnVlKSxcbiAgICBmdW5jdGlvbihmcm9tX3RhZzogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZXBsYWNlc19mcm9tX3RhZyA9IGZyb21fdGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICBcInRvLXRhZ1wiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0by10YWdcIiwgdHJ1ZSksXG4gICAgZnVuY3Rpb24odG9fdGFnOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlcGxhY2VzX3RvX3RhZyA9IHRvX3RhZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgXCJlYXJseS1vbmx5XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImVhcmx5LW9ubHlcIiwgdHJ1ZSksXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5lYXJseV9vbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgZnVuY3Rpb24oaGVhZDogYW55LCByOiBhbnkpOiBhbnkge3JldHVybiByO30sXG4gICAgZnVuY3Rpb24oaGVhZDogYW55LCB0YWlsOiBhbnkpOiBhbnkgeyByZXR1cm4gbGlzdChoZWFkLCB0YWlsKTsgfSxcbiAgICBmdW5jdGlvbih2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1JlcXVpcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdmFsdWUgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgZnVuY3Rpb24ocnNlcV92YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudmFsdWU9cGFyc2VJbnQocnNlcV92YWx1ZS5qb2luKCcnKSk7IH0sXG4gICAgXCJhY3RpdmVcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiYWN0aXZlXCIsIHRydWUpLFxuICAgIFwicGVuZGluZ1wiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJwZW5kaW5nXCIsIHRydWUpLFxuICAgIFwidGVybWluYXRlZFwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0ZXJtaW5hdGVkXCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKCk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnN0YXRlID0gdGV4dCgpOyB9LFxuICAgIFwicmVhc29uXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInJlYXNvblwiLCB0cnVlKSxcbiAgICBmdW5jdGlvbihyZWFzb246IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFzb24gIT09ICd1bmRlZmluZWQnKSBvcHRpb25zLmRhdGEucmVhc29uID0gcmVhc29uOyB9LFxuICAgIGZ1bmN0aW9uKGV4cGlyZXM6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBpcmVzICE9PSAndW5kZWZpbmVkJykgb3B0aW9ucy5kYXRhLmV4cGlyZXMgPSBleHBpcmVzOyB9LFxuICAgIFwicmV0cnlfYWZ0ZXJcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicmV0cnlfYWZ0ZXJcIiwgdHJ1ZSksXG4gICAgZnVuY3Rpb24ocmV0cnlfYWZ0ZXI6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXRyeV9hZnRlciAhPT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMuZGF0YS5yZXRyeV9hZnRlciA9IHJldHJ5X2FmdGVyOyB9LFxuICAgIFwiZGVhY3RpdmF0ZWRcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiZGVhY3RpdmF0ZWRcIiwgdHJ1ZSksXG4gICAgXCJwcm9iYXRpb25cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicHJvYmF0aW9uXCIsIHRydWUpLFxuICAgIFwicmVqZWN0ZWRcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicmVqZWN0ZWRcIiwgdHJ1ZSksXG4gICAgXCJ0aW1lb3V0XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRpbWVvdXRcIiwgdHJ1ZSksXG4gICAgXCJnaXZldXBcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiZ2l2ZXVwXCIsIHRydWUpLFxuICAgIFwibm9yZXNvdXJjZVwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJub3Jlc291cmNlXCIsIHRydWUpLFxuICAgIFwiaW52YXJpYW50XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImludmFyaWFudFwiLCB0cnVlKSxcbiAgICBmdW5jdGlvbih2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1N1cHBvcnRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB2YWx1ZSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICB2YXIgdGFnID0gb3B0aW9ucy5kYXRhLnRhZztcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IE5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcpIHtvcHRpb25zLmRhdGEuc2V0UGFyYW0oJ3RhZycsdGFnKX1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgXCJ0dGxcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidHRsXCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKHZpYV90dGxfdmFsdWU6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudHRsID0gdmlhX3R0bF92YWx1ZTsgfSxcbiAgICBcIm1hZGRyXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIm1hZGRyXCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKHZpYV9tYWRkcjogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tYWRkciA9IHZpYV9tYWRkcjsgfSxcbiAgICBcInJlY2VpdmVkXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInJlY2VpdmVkXCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKHZpYV9yZWNlaXZlZDogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZWNlaXZlZCA9IHZpYV9yZWNlaXZlZDsgfSxcbiAgICBcImJyYW5jaFwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJicmFuY2hcIiwgdHJ1ZSksXG4gICAgZnVuY3Rpb24odmlhX2JyYW5jaDogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5icmFuY2ggPSB2aWFfYnJhbmNoOyB9LFxuICAgIFwicnBvcnRcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicnBvcnRcIiwgdHJ1ZSksXG4gICAgZnVuY3Rpb24ocmVzcG9uc2VfcG9ydDogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiByZXNwb25zZV9wb3J0ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucnBvcnQgPSByZXNwb25zZV9wb3J0LmpvaW4oJycpOyB9LFxuICAgIGZ1bmN0aW9uKHZpYV9wcm90b2NvbDogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wcm90b2NvbCA9IHZpYV9wcm90b2NvbDsgfSxcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiVURQXCIsIHRydWUpLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJUQ1BcIiwgdHJ1ZSksXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlRMU1wiLCB0cnVlKSxcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiU0NUUFwiLCB0cnVlKSxcbiAgICBmdW5jdGlvbih2aWFfdHJhbnNwb3J0OiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnRyYW5zcG9ydCA9IHZpYV90cmFuc3BvcnQ7IH0sXG4gICAgZnVuY3Rpb24oKTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gdGV4dCgpOyB9LFxuICAgIGZ1bmN0aW9uKHZpYV9zZW50X2J5X3BvcnQ6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucG9ydCA9IHBhcnNlSW50KHZpYV9zZW50X2J5X3BvcnQuam9pbignJykpOyB9LFxuICAgIGZ1bmN0aW9uKHR0bDogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHR0bC5qb2luKCcnKSk7IH0sXG4gICAgZnVuY3Rpb24oZGVsdGFTZWNvbmRzOiBhbnkpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnU2Vzc2lvbl9FeHBpcmVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5kZWx0YVNlY29uZHMgPSBkZWx0YVNlY29uZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgXCJyZWZyZXNoZXJcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicmVmcmVzaGVyXCIsIGZhbHNlKSxcbiAgICBcInVhc1wiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ1YXNcIiwgZmFsc2UpLFxuICAgIFwidWFjXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInVhY1wiLCBmYWxzZSksXG4gICAgZnVuY3Rpb24oZW5kcG9pbnQ6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdTZXNzaW9uX0V4cGlyZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlZnJlc2hlciA9IGVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgIGZ1bmN0aW9uKGRlbHRhU2Vjb25kczogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ01pbl9TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBkZWx0YVNlY29uZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgXCJzdHVuc1wiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJzdHVuc1wiLCB0cnVlKSxcbiAgICBcInN0dW5cIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwic3R1blwiLCB0cnVlKSxcbiAgICBmdW5jdGlvbihzY2hlbWU6IGFueSk6IGFueSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O29wdGlvbnMuZGF0YS5zY2hlbWUgPSBzY2hlbWU7IH0sXG4gICAgZnVuY3Rpb24oaG9zdDogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gaG9zdDsgfSxcbiAgICBcIj90cmFuc3BvcnQ9XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIj90cmFuc3BvcnQ9XCIsIGZhbHNlKSxcbiAgICBcInR1cm5zXCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInR1cm5zXCIsIHRydWUpLFxuICAgIFwidHVyblwiLFxuICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0dXJuXCIsIHRydWUpLFxuICAgIGZ1bmN0aW9uKHRyYW5zcG9ydDogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fX07b3B0aW9ucy5kYXRhLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDsgfSxcbiAgICBmdW5jdGlvbigpOiBhbnkge1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge319O29wdGlvbnMuZGF0YSA9IHRleHQoKTsgfSxcbiAgICBcIlJlZmVycmVkLUJ5XCIsXG4gICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlJlZmVycmVkLUJ5XCIsIGZhbHNlKSxcbiAgICBcImJcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiYlwiLCBmYWxzZSksXG4gICAgXCJjaWRcIixcbiAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiY2lkXCIsIGZhbHNlKVxuICBdO1xuXG4gIGNvbnN0IHBlZyRieXRlY29kZSA9IFtcbiAgICBwZWckZGVjb2RlKFwiMiBcXFwiXFxcIjYgNyFcIiksXG4gICAgcGVnJGRlY29kZShcIjRcXFwiXFxcIlxcXCI1ITcjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI0JFxcXCJcXFwiNSE3JVwiKSxcbiAgICBwZWckZGVjb2RlKFwiNCZcXFwiXFxcIjUhNydcIiksXG4gICAgcGVnJGRlY29kZShcIjsnLiMgJjsoXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI0KFxcXCJcXFwiNSE3KVwiKSxcbiAgICBwZWckZGVjb2RlKFwiNCpcXFwiXFxcIjUhNytcIiksXG4gICAgcGVnJGRlY29kZShcIjIsXFxcIlxcXCI2LDctXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIyLlxcXCJcXFwiNi43L1wiKSxcbiAgICBwZWckZGVjb2RlKFwiNDBcXFwiXFxcIjUhNzFcIiksXG4gICAgcGVnJGRlY29kZShcIjIyXFxcIlxcXCI2MjczLlxceDg5ICYyNFxcXCJcXFwiNjQ3NS59ICYyNlxcXCJcXFwiNjY3Ny5xICYyOFxcXCJcXFwiNjg3OS5lICYyOlxcXCJcXFwiNjo3Oy5ZICYyPFxcXCJcXFwiNjw3PS5NICYyPlxcXCJcXFwiNj43Py5BICYyQFxcXCJcXFwiNkA3QS41ICYyQlxcXCJcXFwiNkI3Qy4pICYyRFxcXCJcXFwiNkQ3RVwiKSxcbiAgICBwZWckZGVjb2RlKFwiOykuIyAmOyxcIiksXG4gICAgcGVnJGRlY29kZShcIjJGXFxcIlxcXCI2RjdHLn0gJjJIXFxcIlxcXCI2SDdJLnEgJjJKXFxcIlxcXCI2SjdLLmUgJjJMXFxcIlxcXCI2TDdNLlkgJjJOXFxcIlxcXCI2TjdPLk0gJjJQXFxcIlxcXCI2UDdRLkEgJjJSXFxcIlxcXCI2UjdTLjUgJjJUXFxcIlxcXCI2VDdVLikgJjJWXFxcIlxcXCI2VjdXXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJTJYXFxcIlxcXCI2WDdZLzUjOyMvLCQ7Iy8jJCsjKSgjJyMoXFxcIicjJicjL1xcXCIhJiwpXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJSQ7JDAjKjskJi8sIzsgLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLz0jJDskLyYjMCMqOyQmJiYjLyckOFxcXCI6WlxcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIjsuLlxcXCIgJlxcXCJcIiksXG4gICAgcGVnJGRlY29kZShcIiUkOycuIyAmOygwKSo7Jy4jICY7KCYvPyMyOFxcXCJcXFwiNjg3OS8wJDsvLyckOCM6WyMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJSQ7Mi8mIzAjKjsyJiYmIy9nIyQlJDsuMCMqOy4mLywjOzIvIyQrXFxcIikoXFxcIicjJicjMD0qJSQ7LjAjKjsuJi8sIzsyLyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjL1xcXCIhJiwpXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI0XFxcXFxcXCJcXFwiNSE3XS4jICY7M1wiKSxcbiAgICBwZWckZGVjb2RlKFwiNF5cXFwiXFxcIjUhN19cIiksXG4gICAgcGVnJGRlY29kZShcIjRgXFxcIlxcXCI1ITdhXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI7IS4pICY0YlxcXCJcXFwiNSE3Y1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJSQ7KS5cXHg5NSAmMkZcXFwiXFxcIjZGN0cuXFx4ODkgJjJKXFxcIlxcXCI2SjdLLn0gJjJMXFxcIlxcXCI2TDdNLnEgJjJYXFxcIlxcXCI2WDdZLmUgJjJQXFxcIlxcXCI2UDdRLlkgJjJIXFxcIlxcXCI2SDdJLk0gJjJAXFxcIlxcXCI2QDdBLkEgJjJkXFxcIlxcXCI2ZDdlLjUgJjJSXFxcIlxcXCI2UjdTLikgJjJOXFxcIlxcXCI2TjdPL1xceDlFIzBcXHg5Qio7KS5cXHg5NSAmMkZcXFwiXFxcIjZGN0cuXFx4ODkgJjJKXFxcIlxcXCI2SjdLLn0gJjJMXFxcIlxcXCI2TDdNLnEgJjJYXFxcIlxcXCI2WDdZLmUgJjJQXFxcIlxcXCI2UDdRLlkgJjJIXFxcIlxcXCI2SDdJLk0gJjJAXFxcIlxcXCI2QDdBLkEgJjJkXFxcIlxcXCI2ZDdlLjUgJjJSXFxcIlxcXCI2UjdTLikgJjJOXFxcIlxcXCI2TjdPJiYmIy9cXFwiISYsKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJSQ7KS5cXHg4OSAmMkZcXFwiXFxcIjZGN0cufSAmMkxcXFwiXFxcIjZMN00ucSAmMlhcXFwiXFxcIjZYN1kuZSAmMlBcXFwiXFxcIjZQN1EuWSAmMkhcXFwiXFxcIjZIN0kuTSAmMkBcXFwiXFxcIjZAN0EuQSAmMmRcXFwiXFxcIjZkN2UuNSAmMlJcXFwiXFxcIjZSN1MuKSAmMk5cXFwiXFxcIjZON08vXFx4OTIjMFxceDhGKjspLlxceDg5ICYyRlxcXCJcXFwiNkY3Ry59ICYyTFxcXCJcXFwiNkw3TS5xICYyWFxcXCJcXFwiNlg3WS5lICYyUFxcXCJcXFwiNlA3US5ZICYySFxcXCJcXFwiNkg3SS5NICYyQFxcXCJcXFwiNkA3QS5BICYyZFxcXCJcXFwiNmQ3ZS41ICYyUlxcXCJcXFwiNlI3Uy4pICYyTlxcXCJcXFwiNk43TyYmJiMvXFxcIiEmLClcIiksXG4gICAgcGVnJGRlY29kZShcIjJUXFxcIlxcXCI2VDdVLlxceEUzICYyVlxcXCJcXFwiNlY3Vy5cXHhENyAmMmZcXFwiXFxcIjZmN2cuXFx4Q0IgJjJoXFxcIlxcXCI2aDdpLlxceEJGICYyOlxcXCJcXFwiNjo3Oy5cXHhCMyAmMkRcXFwiXFxcIjZEN0UuXFx4QTcgJjIyXFxcIlxcXCI2MjczLlxceDlCICYyOFxcXCJcXFwiNjg3OS5cXHg4RiAmMmpcXFwiXFxcIjZqN2suXFx4ODMgJjsmLn0gJjI0XFxcIlxcXCI2NDc1LnEgJjJsXFxcIlxcXCI2bDdtLmUgJjJuXFxcIlxcXCI2bjdvLlkgJjI2XFxcIlxcXCI2Njc3Lk0gJjI+XFxcIlxcXCI2Pjc/LkEgJjJwXFxcIlxcXCI2cDdxLjUgJjJyXFxcIlxcXCI2cjdzLikgJjsnLiMgJjsoXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJDspLlxcdTAxMkIgJjJGXFxcIlxcXCI2RjdHLlxcdTAxMUYgJjJKXFxcIlxcXCI2SjdLLlxcdTAxMTMgJjJMXFxcIlxcXCI2TDdNLlxcdTAxMDcgJjJYXFxcIlxcXCI2WDdZLlxceEZCICYyUFxcXCJcXFwiNlA3US5cXHhFRiAmMkhcXFwiXFxcIjZIN0kuXFx4RTMgJjJAXFxcIlxcXCI2QDdBLlxceEQ3ICYyZFxcXCJcXFwiNmQ3ZS5cXHhDQiAmMlJcXFwiXFxcIjZSN1MuXFx4QkYgJjJOXFxcIlxcXCI2TjdPLlxceEIzICYyVFxcXCJcXFwiNlQ3VS5cXHhBNyAmMlZcXFwiXFxcIjZWN1cuXFx4OUIgJjJmXFxcIlxcXCI2ZjdnLlxceDhGICYyaFxcXCJcXFwiNmg3aS5cXHg4MyAmMjhcXFwiXFxcIjY4NzkudyAmMmpcXFwiXFxcIjZqN2suayAmOyYuZSAmMjRcXFwiXFxcIjY0NzUuWSAmMmxcXFwiXFxcIjZsN20uTSAmMm5cXFwiXFxcIjZuN28uQSAmMjZcXFwiXFxcIjY2NzcuNSAmMnBcXFwiXFxcIjZwN3EuKSAmMnJcXFwiXFxcIjZyN3MvXFx1MDEzNCMwXFx1MDEzMSo7KS5cXHUwMTJCICYyRlxcXCJcXFwiNkY3Ry5cXHUwMTFGICYySlxcXCJcXFwiNko3Sy5cXHUwMTEzICYyTFxcXCJcXFwiNkw3TS5cXHUwMTA3ICYyWFxcXCJcXFwiNlg3WS5cXHhGQiAmMlBcXFwiXFxcIjZQN1EuXFx4RUYgJjJIXFxcIlxcXCI2SDdJLlxceEUzICYyQFxcXCJcXFwiNkA3QS5cXHhENyAmMmRcXFwiXFxcIjZkN2UuXFx4Q0IgJjJSXFxcIlxcXCI2UjdTLlxceEJGICYyTlxcXCJcXFwiNk43Ty5cXHhCMyAmMlRcXFwiXFxcIjZUN1UuXFx4QTcgJjJWXFxcIlxcXCI2VjdXLlxceDlCICYyZlxcXCJcXFwiNmY3Zy5cXHg4RiAmMmhcXFwiXFxcIjZoN2kuXFx4ODMgJjI4XFxcIlxcXCI2ODc5LncgJjJqXFxcIlxcXCI2ajdrLmsgJjsmLmUgJjI0XFxcIlxcXCI2NDc1LlkgJjJsXFxcIlxcXCI2bDdtLk0gJjJuXFxcIlxcXCI2bjdvLkEgJjI2XFxcIlxcXCI2Njc3LjUgJjJwXFxcIlxcXCI2cDdxLikgJjJyXFxcIlxcXCI2cjdzJiYmIy9cXFwiISYsKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsvLz8jMlBcXFwiXFxcIjZQN1EvMCQ7Ly8nJDgjOnQjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsvLz8jMjRcXFwiXFxcIjY0NzUvMCQ7Ly8nJDgjOnUjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsvLz8jMj5cXFwiXFxcIjY+Nz8vMCQ7Ly8nJDgjOnYjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsvLz8jMlRcXFwiXFxcIjZUN1UvMCQ7Ly8nJDgjOncjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsvLz8jMlZcXFwiXFxcIjZWN1cvMCQ7Ly8nJDgjOngjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTJoXFxcIlxcXCI2aDdpLzAjOy8vJyQ4XFxcIjp5XFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsvLzYjMmZcXFwiXFxcIjZmN2cvJyQ4XFxcIjp6XFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsvLz8jMkRcXFwiXFxcIjZEN0UvMCQ7Ly8nJDgjOnsjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsvLz8jMjJcXFwiXFxcIjYyNzMvMCQ7Ly8nJDgjOnwjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsvLz8jMjhcXFwiXFxcIjY4NzkvMCQ7Ly8nJDgjOn0jICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsvLzAjOyYvJyQ4XFxcIjp+XFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTsmLzAjOy8vJyQ4XFxcIjp+XFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTs9L1QjJDtHLikgJjtLLiMgJjtGMC8qO0cuKSAmO0suIyAmO0YmLywkOz4vIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiNFxceDdGXFxcIlxcXCI1ITdcXHg4MC5BICY0XFx4ODFcXFwiXFxcIjUhN1xceDgyLjUgJjRcXHg4M1xcXCJcXFwiNSE3XFx4ODQuKSAmOzMuIyAmOy5cIiksXG4gICAgcGVnJGRlY29kZShcIiUlOy8vUSM7Ji9IJCQ7Si4jICY7SzApKjtKLiMgJjtLJi8sJDsmLyMkKyQpKCQnIygjJyMoXFxcIicjJicjL1xcXCIhJiwpXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlOy8vXSM7Ji9UJCUkO0ouIyAmO0swKSo7Si4jICY7SyYvXFxcIiEmLCkvMSQ7Ji8oJDgkOlxceDg1JCEhKSgkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiOy4uRyAmMkxcXFwiXFxcIjZMN00uOyAmNFxceDg2XFxcIlxcXCI1ITdcXHg4Ny4vICY0XFx4ODNcXFwiXFxcIjUhN1xceDg0LiMgJjszXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlMmpcXFwiXFxcIjZqN2svSiM0XFx4ODhcXFwiXFxcIjUhN1xceDg5LjUgJjRcXHg4QVxcXCJcXFwiNSE3XFx4OEIuKSAmNFxceDhDXFxcIlxcXCI1ITdcXHg4RC8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7Ti9NIzI4XFxcIlxcXCI2ODc5Lz4kO08uXFxcIiAmXFxcIi8wJDtTLyckOCQ6XFx4OEUkICkoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7Ti9kIzI4XFxcIlxcXCI2ODc5L1UkO08uXFxcIiAmXFxcIi9HJDtTLz4kO18vNSQ7bC5cXFwiICZcXFwiLyckOCY6XFx4OEYmICkoJicjKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHg5MFxcXCJcXFwiNSQ3XFx4OTEuKSAmM1xceDkyXFxcIlxcXCI1IzdcXHg5My8nIDghOlxceDk0ISEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtQL10jJTI4XFxcIlxcXCI2ODc5LywjO1IvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvNiQyOlxcXCJcXFwiNjo3Oy8nJDgjOlxceDk1IyApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiQ7Ky4pICY7LS4jICY7US8yIzAvKjsrLikgJjstLiMgJjtRJiYmI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiMjxcXFwiXFxcIjY8Nz0ucSAmMj5cXFwiXFxcIjY+Nz8uZSAmMkBcXFwiXFxcIjZAN0EuWSAmMkJcXFwiXFxcIjZCN0MuTSAmMkRcXFwiXFxcIjZEN0UuQSAmMjJcXFwiXFxcIjYyNzMuNSAmMjZcXFwiXFxcIjY2NzcuKSAmMjRcXFwiXFxcIjY0NzVcIiksXG4gICAgcGVnJGRlY29kZShcIiUkOysuXyAmOy0uWSAmMjxcXFwiXFxcIjY8Nz0uTSAmMj5cXFwiXFxcIjY+Nz8uQSAmMkBcXFwiXFxcIjZAN0EuNSAmMkJcXFwiXFxcIjZCN0MuKSAmMkRcXFwiXFxcIjZEN0UwZSo7Ky5fICY7LS5ZICYyPFxcXCJcXFwiNjw3PS5NICYyPlxcXCJcXFwiNj43Py5BICYyQFxcXCJcXFwiNkA3QS41ICYyQlxcXCJcXFwiNkI3Qy4pICYyRFxcXCJcXFwiNkQ3RSYvJiA4ITpcXHg5NiEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtUL0ojJTI4XFxcIlxcXCI2ODc5LywjO14vIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO1UuKSAmO1xcXFwuIyAmO1gvJiA4ITpcXHg5NyEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJSQlO1YvMiMySlxcXCJcXFwiNko3Sy8jJCtcXFwiKShcXFwiJyMmJyMwPColO1YvMiMySlxcXCJcXFwiNko3Sy8jJCtcXFwiKShcXFwiJyMmJyMmL0QjO1cvOyQySlxcXCJcXFwiNko3Sy5cXFwiICZcXFwiLyckOCM6XFx4OTgjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJDRcXHg5OVxcXCJcXFwiNSE3XFx4OUEvLCMwKSo0XFx4OTlcXFwiXFxcIjUhN1xceDlBJiYmI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTQkXFxcIlxcXCI1ITclLz8jJDRcXHg5QlxcXCJcXFwiNSE3XFx4OUMwKSo0XFx4OUJcXFwiXFxcIjUhN1xceDlDJi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUybFxcXCJcXFwiNmw3bS8/IztZLzYkMm5cXFwiXFxcIjZuN28vJyQ4IzpcXHg5RCMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJTtaL1xceEIzIzI4XFxcIlxcXCI2ODc5L1xceEE0JDtaL1xceDlCJDI4XFxcIlxcXCI2ODc5L1xceDhDJDtaL1xceDgzJDI4XFxcIlxcXCI2ODc5L3QkO1ovayQyOFxcXCJcXFwiNjg3OS9cXFxcJDtaL1MkMjhcXFwiXFxcIjY4NzkvRCQ7Wi87JDI4XFxcIlxcXCI2ODc5LywkO1svIyQrLSkoLScjKCwnIygrJyMoKicjKCknIygoJyMoJycjKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyMuXFx1MDc5MCAmJTJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGL1xceEE0IztaL1xceDlCJDI4XFxcIlxcXCI2ODc5L1xceDhDJDtaL1xceDgzJDI4XFxcIlxcXCI2ODc5L3QkO1ovayQyOFxcXCJcXFwiNjg3OS9cXFxcJDtaL1MkMjhcXFwiXFxcIjY4NzkvRCQ7Wi87JDI4XFxcIlxcXCI2ODc5LywkO1svIyQrLCkoLCcjKCsnIygqJyMoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwNkY5ICYlMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvXFx4OEMjO1ovXFx4ODMkMjhcXFwiXFxcIjY4NzkvdCQ7Wi9rJDI4XFxcIlxcXCI2ODc5L1xcXFwkO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCsqKSgqJyMoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwNjdBICYlMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvdCM7Wi9rJDI4XFxcIlxcXCI2ODc5L1xcXFwkO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCsoKSgoJyMoJycjKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyMuXFx1MDYxMyAmJTJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGL1xcXFwjO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCsmKSgmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLlxcdTA1QzQgJiUyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri9EIztaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCskKSgkJyMoIycjKFxcXCInIyYnIy5cXHUwNThEICYlMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvLCM7Wy8jJCtcXFwiKShcXFwiJyMmJyMuXFx1MDU2RSAmJTJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGLywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcdTA1NEYgJiU7Wi9cXHg5QiMyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri9cXHg4QyQ7Wi9cXHg4MyQyOFxcXCJcXFwiNjg3OS90JDtaL2skMjhcXFwiXFxcIjY4NzkvXFxcXCQ7Wi9TJDI4XFxcIlxcXCI2ODc5L0QkO1ovOyQyOFxcXCJcXFwiNjg3OS8sJDtbLyMkKyspKCsnIygqJyMoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwNEM3ICYlO1ovXFx4QUEjJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4ODMkMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvdCQ7Wi9rJDI4XFxcIlxcXCI2ODc5L1xcXFwkO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCsqKSgqJyMoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwNDMwICYlO1ovXFx4QjkjJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4OTIkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvayQyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri9cXFxcJDtaL1MkMjhcXFwiXFxcIjY4NzkvRCQ7Wi87JDI4XFxcIlxcXCI2ODc5LywkO1svIyQrKSkoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwMzhBICYlO1ovXFx4QzgjJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4QTEkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIveiQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9TJDJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGL0QkO1ovOyQyOFxcXCJcXFwiNjg3OS8sJDtbLyMkKygpKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwMkQ1ICYlO1ovXFx4RDcjJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4QjAkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4ODkkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvYiQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi87JDJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGLywkO1svIyQrJykoJycjKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyMuXFx1MDIxMSAmJTtaL1xceEZFIyUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1xceEQ3JCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1xceEIwJCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1xceDg5JCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL2IkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvOyQyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri8sJDtaLyMkKygpKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwMTI2ICYlO1ovXFx1MDExQyMlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHhGNSQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHhDRSQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHhBNyQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHg4MCQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9ZJCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLzIkMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvIyQrKCkoKCcjKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLyYgOCE6XFx4QTAhIClcIiksXG4gICAgcGVnJGRlY29kZShcIiU7Iy9NIzsjLlxcXCIgJlxcXCIvPyQ7Iy5cXFwiICZcXFwiLzEkOyMuXFxcIiAmXFxcIi8jJCskKSgkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtaLzsjMjhcXFwiXFxcIjY4NzkvLCQ7Wi8jJCsjKSgjJyMoXFxcIicjJicjLiMgJjtcXFxcXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO10vbyMySlxcXCJcXFwiNko3Sy9gJDtdL1ckMkpcXFwiXFxcIjZKN0svSCQ7XS8/JDJKXFxcIlxcXCI2SjdLLzAkO10vJyQ4JzpcXHhBMScgKSgnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTJcXHhBMlxcXCJcXFwiNlxceEEyN1xceEEzLzIjNFxceEE0XFxcIlxcXCI1ITdcXHhBNS8jJCtcXFwiKShcXFwiJyMmJyMuXFx4OTggJiUyXFx4QTZcXFwiXFxcIjZcXHhBNjdcXHhBNy87IzRcXHhBOFxcXCJcXFwiNSE3XFx4QTkvLCQ7IS8jJCsjKSgjJyMoXFxcIicjJicjLmogJiUyXFx4QUFcXFwiXFxcIjZcXHhBQTdcXHhBQi81IzshLywkOyEvIyQrIykoIycjKFxcXCInIyYnIy5CICYlNFxceEFDXFxcIlxcXCI1ITdcXHhBRC8sIzshLyMkK1xcXCIpKFxcXCInIyYnIy4jICY7IVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJSU7IS5cXFwiICZcXFwiL1sjOyEuXFxcIiAmXFxcIi9NJDshLlxcXCIgJlxcXCIvPyQ7IS5cXFwiICZcXFwiLzEkOyEuXFxcIiAmXFxcIi8jJCslKSglJyMoJCcjKCMnIyhcXFwiJyMmJyMvJyA4ITpcXHhBRSEhIClcIiksXG4gICAgcGVnJGRlY29kZShcIiQlMjJcXFwiXFxcIjYyNzMvLCM7YC8jJCtcXFwiKShcXFwiJyMmJyMwPColMjJcXFwiXFxcIjYyNzMvLCM7YC8jJCtcXFwiKShcXFwiJyMmJyMmXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI7YS5BICY7Yi47ICY7Yy41ICY7ZC4vICY7ZS4pICY7Zi4jICY7Z1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHhBRlxcXCJcXFwiNSo3XFx4QjAvYSMzXFx4QjFcXFwiXFxcIjUjN1xceEIyLkcgJjNcXHhCM1xcXCJcXFwiNSM3XFx4QjQuOyAmM1xceEI1XFxcIlxcXCI1JDdcXHhCNi4vICYzXFx4QjdcXFwiXFxcIjUjN1xceEI4LiMgJjs2LygkOFxcXCI6XFx4QjlcXFwiISApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHhCQVxcXCJcXFwiNSU3XFx4QkIvSSMzXFx4QkNcXFwiXFxcIjUlN1xceEJELi8gJjNcXHhCRVxcXCJcXFwiNVxcXCI3XFx4QkYuIyAmOzYvKCQ4XFxcIjpcXHhDMFxcXCIhICkoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlM1xceEMxXFxcIlxcXCI1JzdcXHhDMi8xIztcXHg5MC8oJDhcXFwiOlxceEMzXFxcIiEgKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUzXFx4QzRcXFwiXFxcIjUkN1xceEM1LzEjO1xceEYwLygkOFxcXCI6XFx4QzZcXFwiISApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHhDN1xcXCJcXFwiNSY3XFx4QzgvMSM7VC8oJDhcXFwiOlxceEM5XFxcIiEgKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUzXFx4Q0FcXFwiXFxcIjVcXFwiN1xceENCL04jJTI+XFxcIlxcXCI2Pjc/LywjOzYvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvJyQ4XFxcIjpcXHhDQ1xcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7aC9QIyUyPlxcXCJcXFwiNj43Py8sIztpLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLykkOFxcXCI6XFx4Q0RcXFwiXFxcIiEgKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUkO2ovJiMwIyo7aiYmJiMvXFxcIiEmLClcIiksXG4gICAgcGVnJGRlY29kZShcIiUkO2ovJiMwIyo7aiYmJiMvXFxcIiEmLClcIiksXG4gICAgcGVnJGRlY29kZShcIjtrLikgJjsrLiMgJjstXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIybFxcXCJcXFwiNmw3bS5lICYyblxcXCJcXFwiNm43by5ZICYyNFxcXCJcXFwiNjQ3NS5NICYyOFxcXCJcXFwiNjg3OS5BICYyPFxcXCJcXFwiNjw3PS41ICYyQFxcXCJcXFwiNkA3QS4pICYyQlxcXCJcXFwiNkI3Q1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTI2XFxcIlxcXCI2Njc3L24jO20vZSQkJTI8XFxcIlxcXCI2PDc9LywjO20vIyQrXFxcIikoXFxcIicjJicjMDwqJTI8XFxcIlxcXCI2PDc9LywjO20vIyQrXFxcIikoXFxcIicjJicjJi8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO24vQSMyPlxcXCJcXFwiNj43Py8yJDtvLykkOCM6XFx4Q0UjXFxcIlxcXCIgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIkO3AuKSAmOysuIyAmOy0vMiMwLyo7cC4pICY7Ky4jICY7LSYmJiNcIiksXG4gICAgcGVnJGRlY29kZShcIiQ7cC4pICY7Ky4jICY7LTAvKjtwLikgJjsrLiMgJjstJlwiKSxcbiAgICBwZWckZGVjb2RlKFwiMmxcXFwiXFxcIjZsN20uZSAmMm5cXFwiXFxcIjZuN28uWSAmMjRcXFwiXFxcIjY0NzUuTSAmMjZcXFwiXFxcIjY2NzcuQSAmMjhcXFwiXFxcIjY4NzkuNSAmMkBcXFwiXFxcIjZAN0EuKSAmMkJcXFwiXFxcIjZCN0NcIiksXG4gICAgcGVnJGRlY29kZShcIjtcXHg5MS4jICY7clwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHg5MC9HIzsnLz4kO3MvNSQ7Jy8sJDtcXHg4NC8jJCslKSglJyMoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIjtNLiMgJjt0XCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO1xceDdGL0UjMjhcXFwiXFxcIjY4NzkvNiQ7dS4jICY7eC8nJDgjOlxceENGIyApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7di4jICY7dy9KIyUyNlxcXCJcXFwiNjY3Ny8sIztcXHg4My8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUyXFx4RDBcXFwiXFxcIjZcXHhEMDdcXHhEMS86IztcXHg4MC8xJDt3LlxcXCIgJlxcXCIvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTI0XFxcIlxcXCI2NDc1LywjO3svIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO3ovMyMkO3kwIyo7eSYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI7Ki4pICY7Ky4jICY7LVwiKSxcbiAgICBwZWckZGVjb2RlKFwiOysuXFx4OEYgJjstLlxceDg5ICYyMlxcXCJcXFwiNjI3My59ICYyNlxcXCJcXFwiNjY3Ny5xICYyOFxcXCJcXFwiNjg3OS5lICYyOlxcXCJcXFwiNjo3Oy5ZICYyPFxcXCJcXFwiNjw3PS5NICYyPlxcXCJcXFwiNj43Py5BICYyQFxcXCJcXFwiNkA3QS41ICYyQlxcXCJcXFwiNkI3Qy4pICYyRFxcXCJcXFwiNkQ3RVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTt8L2UjJCUyNFxcXCJcXFwiNjQ3NS8sIzt8LyMkK1xcXCIpKFxcXCInIyYnIzA8KiUyNFxcXCJcXFwiNjQ3NS8sIzt8LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJDt+MCMqO34mL2UjJCUyMlxcXCJcXFwiNjI3My8sIzt9LyMkK1xcXCIpKFxcXCInIyYnIzA8KiUyMlxcXCJcXFwiNjI3My8sIzt9LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIkO34wIyo7fiZcIiksXG4gICAgcGVnJGRlY29kZShcIjsrLncgJjstLnEgJjI4XFxcIlxcXCI2ODc5LmUgJjI6XFxcIlxcXCI2Ojc7LlkgJjI8XFxcIlxcXCI2PDc9Lk0gJjI+XFxcIlxcXCI2Pjc/LkEgJjJAXFxcIlxcXCI2QDdBLjUgJjJCXFxcIlxcXCI2QjdDLikgJjJEXFxcIlxcXCI2RDdFXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJTtcXFwiL1xceDg3IyQ7XFxcIi5HICY7IS5BICYyQFxcXCJcXFwiNkA3QS41ICYyRlxcXCJcXFwiNkY3Ry4pICYySlxcXCJcXFwiNko3SzBNKjtcXFwiLkcgJjshLkEgJjJAXFxcIlxcXCI2QDdBLjUgJjJGXFxcIlxcXCI2RjdHLikgJjJKXFxcIlxcXCI2SjdLJi8jJCtcXFwiKShcXFwiJyMmJyMvJiA4ITpcXHhEMiEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiO1xceDgxLiMgJjtcXHg4MlwiKSxcbiAgICBwZWckZGVjb2RlKFwiJSU7Ty8yIzI6XFxcIlxcXCI2Ojc7LyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLywjO1MvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCJcIiksXG4gICAgcGVnJGRlY29kZShcIiQ7Ky5cXHg4MyAmOy0ufSAmMkJcXFwiXFxcIjZCN0MucSAmMkRcXFwiXFxcIjZEN0UuZSAmMjJcXFwiXFxcIjYyNzMuWSAmMjhcXFwiXFxcIjY4NzkuTSAmMjpcXFwiXFxcIjY6NzsuQSAmMjxcXFwiXFxcIjY8Nz0uNSAmMj5cXFwiXFxcIjY+Nz8uKSAmMkBcXFwiXFxcIjZAN0EvXFx4OEMjMFxceDg5KjsrLlxceDgzICY7LS59ICYyQlxcXCJcXFwiNkI3Qy5xICYyRFxcXCJcXFwiNkQ3RS5lICYyMlxcXCJcXFwiNjI3My5ZICYyOFxcXCJcXFwiNjg3OS5NICYyOlxcXCJcXFwiNjo3Oy5BICYyPFxcXCJcXFwiNjw3PS41ICYyPlxcXCJcXFwiNj43Py4pICYyQFxcXCJcXFwiNkA3QSYmJiNcIiksXG4gICAgcGVnJGRlY29kZShcIiQ7eTAjKjt5JlwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHg5MlxcXCJcXFwiNSM3XFx4RDMvcSMyNFxcXCJcXFwiNjQ3NS9iJCQ7IS8mIzAjKjshJiYmIy9MJDJKXFxcIlxcXCI2SjdLLz0kJDshLyYjMCMqOyEmJiYjLyckOCU6XFx4RDQlICkoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIyXFx4RDVcXFwiXFxcIjZcXHhENTdcXHhENlwiKSxcbiAgICBwZWckZGVjb2RlKFwiMlxceEQ3XFxcIlxcXCI2XFx4RDc3XFx4RDhcIiksXG4gICAgcGVnJGRlY29kZShcIjJcXHhEOVxcXCJcXFwiNlxceEQ5N1xceERBXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIyXFx4REJcXFwiXFxcIjZcXHhEQjdcXHhEQ1wiKSxcbiAgICBwZWckZGVjb2RlKFwiMlxceEREXFxcIlxcXCI2XFx4REQ3XFx4REVcIiksXG4gICAgcGVnJGRlY29kZShcIjJcXHhERlxcXCJcXFwiNlxceERGN1xceEUwXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIyXFx4RTFcXFwiXFxcIjZcXHhFMTdcXHhFMlwiKSxcbiAgICBwZWckZGVjb2RlKFwiMlxceEUzXFxcIlxcXCI2XFx4RTM3XFx4RTRcIiksXG4gICAgcGVnJGRlY29kZShcIjJcXHhFNVxcXCJcXFwiNlxceEU1N1xceEU2XCIpLFxuICAgIHBlZyRkZWNvZGUoXCIyXFx4RTdcXFwiXFxcIjZcXHhFNzdcXHhFOFwiKSxcbiAgICBwZWckZGVjb2RlKFwiMlxceEU5XFxcIlxcXCI2XFx4RTk3XFx4RUFcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4ODUuWSAmO1xceDg2LlMgJjtcXHg4OC5NICY7XFx4ODkuRyAmO1xceDhBLkEgJjtcXHg4Qi47ICY7XFx4OEMuNSAmO1xceDhGLi8gJjtcXHg4RC4pICY7XFx4OEUuIyAmOzYvJiA4ITpcXHhFQiEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHg4NC9HIzsnLz4kO1xceDkyLzUkOycvLCQ7XFx4OTQvIyQrJSkoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO1xceDkzLycgOCE6XFx4RUMhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlOyEvNSM7IS8sJDshLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUkOyouQSAmOysuOyAmOy0uNSAmOzMuLyAmOzQuKSAmOycuIyAmOygwRyo7Ki5BICY7Ky47ICY7LS41ICY7My4vICY7NC4pICY7Jy4jICY7KCYvJiA4ITpcXHhFRCEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHhCNi9ZIyQlO0EvLCM7XFx4QjYvIyQrXFxcIikoXFxcIicjJicjMDYqJTtBLywjO1xceEI2LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlOzkvTiMlMjpcXFwiXFxcIjY6NzsvLCM7OS8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8nJDhcXFwiOlxceEVFXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTs6LmMgJiU7XFx4OTgvWSMkJTtBLywjO1xceDk4LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7QS8sIztcXHg5OC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnIy8mIDghOlxceEVGISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO0wuIyAmO1xceDk5L10jJCU7Qi8sIztcXHg5Qi8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4OUIvIyQrXFxcIikoXFxcIicjJicjJi8nJDhcXFwiOlxceEYwXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHg5QS5cXFwiICZcXFwiLz4jO0AvNSQ7TS8sJDs/LyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJTs2L1kjJCU7Li8sIzs2LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Li8sIzs2LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjLiMgJjtILycgOCE6XFx4RjEhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI7XFx4OUMuKSAmO1xceDlELiMgJjtcXHhBMFwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHhGMlxcXCJcXFwiNSE3XFx4RjMvOiM7PC8xJDtcXHg5Ri8oJDgjOlxceEY0IyEgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlM1xceEY1XFxcIlxcXCI1JzdcXHhGNi86Izs8LzEkO1xceDlFLygkOCM6XFx4RjcjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUkOyEvJiMwIyo7ISYmJiMvJyA4ITpcXHhGOCEhIClcIiksXG4gICAgcGVnJGRlY29kZShcIiUyXFx4RjlcXFwiXFxcIjZcXHhGOTdcXHhGQS9vIyUySlxcXCJcXFwiNko3Sy9NIzshLlxcXCIgJlxcXCIvPyQ7IS5cXFwiICZcXFwiLzEkOyEuXFxcIiAmXFxcIi8jJCskKSgkJyMoIycjKFxcXCInIyYnIy5cXFwiICZcXFwiLyckOFxcXCI6XFx4RkJcXFwiICkoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlOzYvSiMlOzwvLCM7XFx4QTEvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvKSQ4XFxcIjpcXHhGQ1xcXCJcXFwiISApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiOzYuKSAmO1QuIyAmO0hcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4QTMvWSMkJTtCLywjO1xceEE0LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhBNC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHhGRFxcXCJcXFwiNSY3XFx4RkUuRyAmM1xceEZGXFxcIlxcXCI1JzdcXHUwMTAwLjsgJjNcXHUwMTAxXFxcIlxcXCI1JDdcXHUwMTAyLi8gJjNcXHUwMTAzXFxcIlxcXCI1JTdcXHUwMTA0LiMgJjs2LyYgOCE6XFx1MDEwNSEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiO1xceEE1LiMgJjtcXHhBMFwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTA2XFxcIlxcXCI1KDdcXHUwMTA3L00jOzwvRCQzXFx1MDEwOFxcXCJcXFwiNSg3XFx1MDEwOS4vICYzXFx1MDEwQVxcXCJcXFwiNSg3XFx1MDEwQi4jICY7Ni8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlOzYvWSMkJTtBLywjOzYvIyQrXFxcIikoXFxcIicjJicjMDYqJTtBLywjOzYvIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUkOyEvJiMwIyo7ISYmJiMvJyA4ITpcXHUwMTBDISEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHhBOS8mIDghOlxcdTAxMEQhIClcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4QUEvayM7Oy9iJDtcXHhBRi9ZJCQlO0IvLCM7XFx4QjAvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEIwLyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrJCkoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIjtcXHhBQi4jICY7XFx4QUNcIiksXG4gICAgcGVnJGRlY29kZShcIjNcXHUwMTBFXFxcIlxcXCI1JDdcXHUwMTBGLlMgJjNcXHUwMTEwXFxcIlxcXCI1JTdcXHUwMTExLkcgJjNcXHUwMTEyXFxcIlxcXCI1JTdcXHUwMTEzLjsgJjNcXHUwMTE0XFxcIlxcXCI1JTdcXHUwMTE1Li8gJjNcXHUwMTE2XFxcIlxcXCI1KzdcXHUwMTE3LiMgJjtcXHhBRFwiKSxcbiAgICBwZWckZGVjb2RlKFwiM1xcdTAxMThcXFwiXFxcIjUnN1xcdTAxMTkuLyAmM1xcdTAxMUFcXFwiXFxcIjUpN1xcdTAxMUIuIyAmO1xceEFEXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI7Ni4jICY7XFx4QUVcIiksXG4gICAgcGVnJGRlY29kZShcIiUzXFx1MDExQ1xcXCJcXFwiNVxcXCI3XFx1MDExRC8sIzs2LyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiO1xceEFELiMgJjs2XCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlOzYvNSM7PC8sJDtcXHhCMS8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI7Ni4jICY7SFwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHhCMy81IzsuLywkO1xceDkwLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUkOyEvJiMwIyo7ISYmJiMvJyA4ITpcXHUwMTFFISEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHg5RS8nIDghOlxcdTAxMUYhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO1xceEI2L14jJCU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjJi8oJDhcXFwiOlxcdTAxMjBcXFwiISEpKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJSU7Ny9lIyQlMkpcXFwiXFxcIjZKN0svLCM7Ny8jJCtcXFwiKShcXFwiJyMmJyMwPColMkpcXFwiXFxcIjZKN0svLCM7Ny8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnIy9cXFwiISYsKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtMLiMgJjtcXHg5OS9dIyQlO0IvLCM7XFx4QjgvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEI4LyMkK1xcXCIpKFxcXCInIyYnIyYvJyQ4XFxcIjpcXHUwMTIxXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiO1xceEI5LiMgJjtcXHhBMFwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTIyXFxcIlxcXCI1IzdcXHUwMTIzLzojOzwvMSQ7Ni8oJDgjOlxcdTAxMjQjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUkOyEvJiMwIyo7ISYmJiMvJyA4ITpcXHUwMTI1ISEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHg5RS8nIDghOlxcdTAxMjYhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJDtcXHg5QTAjKjtcXHg5QSYveCM7QC9vJDtNL2YkOz8vXSQkJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMmLyckOCU6XFx1MDEyNyUgKSglJyMoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIjtcXHhCRVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTI4XFxcIlxcXCI1JjdcXHUwMTI5L2sjOy4vYiQ7XFx4QzEvWSQkJTtBLywjO1xceEMxLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7QS8sIztcXHhDMS8jJCtcXFwiKShcXFwiJyMmJyMmLyMkKyQpKCQnIygjJyMoXFxcIicjJicjLiMgJjtcXHhCRlwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTs2L2sjOy4vYiQ7XFx4QzAvWSQkJTtBLywjO1xceEMwLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7QS8sIztcXHhDMC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlOzYvOyM7PC8yJDs2LiMgJjtILyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIjtcXHhDMi5HICY7XFx4QzQuQSAmO1xceEM2LjsgJjtcXHhDOC41ICY7XFx4QzkuLyAmO1xceENBLikgJjtcXHhDQi4jICY7XFx4QzBcIiksXG4gICAgcGVnJGRlY29kZShcIiUzXFx1MDEyQVxcXCJcXFwiNSU3XFx1MDEyQi81Izs8LywkO1xceEMzLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7SS8nIDghOlxcdTAxMkMhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxMkRcXFwiXFxcIjUmN1xcdTAxMkUvXFx4OTcjOzwvXFx4OEUkO0QvXFx4ODUkO1xceEM1L3wkJCUkOycvJiMwIyo7JyYmJiMvLCM7XFx4QzUvIyQrXFxcIikoXFxcIicjJicjMEMqJSQ7Jy8mIzAjKjsnJiYmIy8sIztcXHhDNS8jJCtcXFwiKShcXFwiJyMmJyMmLywkO0UvIyQrJikoJicjKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiO3QuIyAmO3dcIiksXG4gICAgcGVnJGRlY29kZShcIiUzXFx1MDEyRlxcXCJcXFwiNSU3XFx1MDEzMC81Izs8LywkO1xceEM3LyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7SS8nIDghOlxcdTAxMzEhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxMzJcXFwiXFxcIjUmN1xcdTAxMzMvOiM7PC8xJDtJLygkOCM6XFx1MDEzNCMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTM1XFxcIlxcXCI1JTdcXHUwMTM2L10jOzwvVCQlM1xcdTAxMzdcXFwiXFxcIjUkN1xcdTAxMzgvJiA4ITpcXHUwMTM5ISApLjQgJiUzXFx1MDEzQVxcXCJcXFwiNSU3XFx1MDEzQi8mIDghOlxcdTAxM0MhICkvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTNEXFxcIlxcXCI1KTdcXHUwMTNFL1IjOzwvSSQzXFx1MDEzRlxcXCJcXFwiNSM3XFx1MDE0MC4vICYzXFx1MDE0MVxcXCJcXFwiNSg3XFx1MDE0Mi4jICY7Ni8oJDgjOlxcdTAxNDMjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUzXFx1MDE0NFxcXCJcXFwiNSM3XFx1MDE0NS9cXHg5MyM7PC9cXHg4QSQ7RC9cXHg4MSQlO1xceENDL2UjJCUyRFxcXCJcXFwiNkQ3RS8sIztcXHhDQy8jJCtcXFwiKShcXFwiJyMmJyMwPColMkRcXFwiXFxcIjZEN0UvLCM7XFx4Q0MvIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyMvLCQ7RS8jJCslKSglJyMoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUzXFx1MDE0NlxcXCJcXFwiNSg3XFx1MDE0Ny4vICYzXFx1MDE0OFxcXCJcXFwiNSQ3XFx1MDE0OS4jICY7Ni8nIDghOlxcdTAxNEEhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlOzYvWSMkJTtBLywjOzYvIyQrXFxcIikoXFxcIicjJicjMDYqJTtBLywjOzYvIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4Q0YvRyM7Li8+JDtcXHhDRi81JDsuLywkO1xceDkwLyMkKyUpKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJSQ7IS8mIzAjKjshJiYmIy8nIDghOlxcdTAxNEIhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO1xceEQxL10jJCU7QS8sIztcXHhEMS8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0EvLCM7XFx4RDEvIyQrXFxcIikoXFxcIicjJicjJi8nJDhcXFwiOlxcdTAxNENcXFwiICkoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO1xceDk5L10jJCU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjJi8nJDhcXFwiOlxcdTAxNERcXFwiICkoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO0wuTyAmO1xceDk5LkkgJiU7QC5cXFwiICZcXFwiLzojO3QvMSQ7Py5cXFwiICZcXFwiLyMkKyMpKCMnIyhcXFwiJyMmJyMvXSMkJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMmLyckOFxcXCI6XFx1MDE0RVxcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4RDQvXSMkJTtCLywjO1xceEQ1LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhENS8jJCtcXFwiKShcXFwiJyMmJyMmLyckOFxcXCI6XFx1MDE0RlxcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4OTYvJiA4ITpcXHUwMTUwISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxNTFcXFwiXFxcIjUoN1xcdTAxNTIvOiM7PC8xJDs2LygkOCM6XFx1MDE1MyMhICkoIycjKFxcXCInIyYnIy5nICYlM1xcdTAxNTRcXFwiXFxcIjUmN1xcdTAxNTUvOiM7PC8xJDs2LygkOCM6XFx1MDE1NiMhICkoIycjKFxcXCInIyYnIy46ICYlM1xcdTAxNTdcXFwiXFxcIjUqN1xcdTAxNTgvJiA4ITpcXHUwMTU5ISApLiMgJjtcXHhBMFwiKSxcbiAgICBwZWckZGVjb2RlKFwiJSU7Ni9rIyQlO0EvMiM7Ni8pJDhcXFwiOlxcdTAxNUFcXFwiXFxcIiQgKShcXFwiJyMmJyMwPColO0EvMiM7Ni8pJDhcXFwiOlxcdTAxNUFcXFwiXFxcIiQgKShcXFwiJyMmJyMmLykkOFxcXCI6XFx1MDE1QlxcXCJcXFwiISApKFxcXCInIyYnIy5cXFwiICZcXFwiLycgOCE6XFx1MDE1QyEhIClcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4RDgvWSMkJTtBLywjO1xceEQ4LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7QS8sIztcXHhEOC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHg5OS9ZIyQlO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJDshLyYjMCMqOyEmJiYjLycgOCE6XFx1MDE1RCEhIClcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4REIvWSMkJTtCLywjO1xceERDLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhEQy8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTVFXFxcIlxcXCI1JjdcXHUwMTVGLjsgJjNcXHUwMTYwXFxcIlxcXCI1JzdcXHUwMTYxLi8gJjNcXHUwMTYyXFxcIlxcXCI1KjdcXHUwMTYzLiMgJjs2LyYgOCE6XFx1MDE2NCEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTY1XFxcIlxcXCI1JjdcXHUwMTY2LzojOzwvMSQ7XFx4REQvKCQ4IzpcXHUwMTY3IyEgKSgjJyMoXFxcIicjJicjLn0gJiUzXFx4RjVcXFwiXFxcIjUnN1xceEY2LzojOzwvMSQ7XFx4OUUvKCQ4IzpcXHUwMTY4IyEgKSgjJyMoXFxcIicjJicjLlAgJiUzXFx1MDE2OVxcXCJcXFwiNSs3XFx1MDE2QS86Izs8LzEkO1xceDlFLygkOCM6XFx1MDE2QiMhICkoIycjKFxcXCInIyYnIy4jICY7XFx4QTBcIiksXG4gICAgcGVnJGRlY29kZShcIjNcXHUwMTZDXFxcIlxcXCI1KzdcXHUwMTZELmsgJjNcXHUwMTZFXFxcIlxcXCI1KTdcXHUwMTZGLl8gJjNcXHUwMTcwXFxcIlxcXCI1KDdcXHUwMTcxLlMgJjNcXHUwMTcyXFxcIlxcXCI1JzdcXHUwMTczLkcgJjNcXHUwMTc0XFxcIlxcXCI1JjdcXHUwMTc1LjsgJjNcXHUwMTc2XFxcIlxcXCI1KjdcXHUwMTc3Li8gJjNcXHUwMTc4XFxcIlxcXCI1KTdcXHUwMTc5LiMgJjs2XCIpLFxuICAgIHBlZyRkZWNvZGUoXCI7MS5cXFwiICZcXFwiXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJTs2L2sjJCU7QS8yIzs2LykkOFxcXCI6XFx1MDE1QVxcXCJcXFwiJCApKFxcXCInIyYnIzA8KiU7QS8yIzs2LykkOFxcXCI6XFx1MDE1QVxcXCJcXFwiJCApKFxcXCInIyYnIyYvKSQ4XFxcIjpcXHUwMTVCXFxcIlxcXCIhICkoXFxcIicjJicjLlxcXCIgJlxcXCIvJyA4ITpcXHUwMTdBISEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtMLiMgJjtcXHg5OS9dIyQlO0IvLCM7XFx4RTEvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEUxLyMkK1xcXCIpKFxcXCInIyYnIyYvJyQ4XFxcIjpcXHUwMTdCXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiO1xceEI5LiMgJjtcXHhBMFwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHhFMy9ZIyQlO0EvLCM7XFx4RTMvIyQrXFxcIikoXFxcIicjJicjMDYqJTtBLywjO1xceEUzLyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO1xceEVBL2sjOy4vYiQ7XFx4RUQvWSQkJTtCLywjO1xceEU0LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhFNC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI7XFx4RTUuOyAmO1xceEU2LjUgJjtcXHhFNy4vICY7XFx4RTguKSAmO1xceEU5LiMgJjtcXHhBMFwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTdDXFxcIlxcXCI1IzdcXHUwMTdELzojOzwvMSQ7XFx4RjAvKCQ4IzpcXHUwMTdFIyEgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxN0ZcXFwiXFxcIjUlN1xcdTAxODAvOiM7PC8xJDtULygkOCM6XFx1MDE4MSMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTgyXFxcIlxcXCI1KDdcXHUwMTgzL0YjOzwvPSQ7XFxcXC4pICY7WS4jICY7WC8oJDgjOlxcdTAxODQjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiUzXFx1MDE4NVxcXCJcXFwiNSY3XFx1MDE4Ni86Izs8LzEkOzYvKCQ4IzpcXHUwMTg3IyEgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxODhcXFwiXFxcIjUlN1xcdTAxODkvQSM7PC84JCQ7ITAjKjshJi8oJDgjOlxcdTAxOEEjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4RUIvRyM7Oy8+JDs2LzUkOzsvLCQ7XFx4RUMvIyQrJSkoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlM1xceDkyXFxcIlxcXCI1IzdcXHhEMy4jICY7Ni8nIDghOlxcdTAxOEIhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlM1xceEIxXFxcIlxcXCI1IzdcXHUwMThDLkcgJjNcXHhCM1xcXCJcXFwiNSM3XFx1MDE4RC47ICYzXFx4QjdcXFwiXFxcIjUjN1xcdTAxOEUuLyAmM1xceEI1XFxcIlxcXCI1JDdcXHUwMThGLiMgJjs2LycgOCE6XFx1MDE5MCEhIClcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4RUUvRCMlO0MvLCM7XFx4RUYvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO1UuKSAmO1xcXFwuIyAmO1gvJiA4ITpcXHUwMTkxISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJTshLlxcXCIgJlxcXCIvWyM7IS5cXFwiICZcXFwiL00kOyEuXFxcIiAmXFxcIi8/JDshLlxcXCIgJlxcXCIvMSQ7IS5cXFwiICZcXFwiLyMkKyUpKCUnIygkJyMoIycjKFxcXCInIyYnIy8nIDghOlxcdTAxOTIhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlJTshLz8jOyEuXFxcIiAmXFxcIi8xJDshLlxcXCIgJlxcXCIvIyQrIykoIycjKFxcXCInIyYnIy8nIDghOlxcdTAxOTMhISApXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI7XFx4QkVcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4OUUvXiMkJTtCLywjO1xceEYzLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhGMy8jJCtcXFwiKShcXFwiJyMmJyMmLygkOFxcXCI6XFx1MDE5NFxcXCIhISkoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCI7XFx4RjQuIyAmO1xceEEwXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlMlxcdTAxOTVcXFwiXFxcIjZcXHUwMTk1N1xcdTAxOTYvTCM7PC9DJDJcXHUwMTk3XFxcIlxcXCI2XFx1MDE5NzdcXHUwMTk4LikgJjJcXHUwMTk5XFxcIlxcXCI2XFx1MDE5OTdcXHUwMTlBLygkOCM6XFx1MDE5QiMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHg5RS9eIyQlO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIyYvKCQ4XFxcIjpcXHUwMTlDXFxcIiEhKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7Ni81IzswLywkO1xceEY3LyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiQ7Mi4pICY7NC4jICY7LjAvKjsyLikgJjs0LiMgJjsuJlwiKSxcbiAgICBwZWckZGVjb2RlKFwiJDslMCMqOyUmXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO1xceEZBLzsjMjhcXFwiXFxcIjY4NzkvLCQ7XFx4RkIvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTlEXFxcIlxcXCI1JTdcXHUwMTlFLikgJjNcXHUwMTlGXFxcIlxcXCI1JDdcXHUwMUEwLycgOCE6XFx1MDFBMSEhIClcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx4RkMvSiMlMjhcXFwiXFxcIjY4NzkvLCM7Xi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFxcXC4pICY7WC4jICY7XFx4ODIvJyA4ITpcXHUwMUEyISEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiO1xcXCIuUyAmOyEuTSAmMkZcXFwiXFxcIjZGN0cuQSAmMkpcXFwiXFxcIjZKN0suNSAmMkhcXFwiXFxcIjZIN0kuKSAmMk5cXFwiXFxcIjZON09cIiksXG4gICAgcGVnJGRlY29kZShcIjJMXFxcIlxcXCI2TDdNLlxceDk1ICYyQlxcXCJcXFwiNkI3Qy5cXHg4OSAmMjxcXFwiXFxcIjY8Nz0ufSAmMlJcXFwiXFxcIjZSN1MucSAmMlRcXFwiXFxcIjZUN1UuZSAmMlZcXFwiXFxcIjZWN1cuWSAmMlBcXFwiXFxcIjZQN1EuTSAmMkBcXFwiXFxcIjZAN0EuQSAmMkRcXFwiXFxcIjZEN0UuNSAmMjJcXFwiXFxcIjYyNzMuKSAmMj5cXFwiXFxcIjY+Nz9cIiksXG4gICAgcGVnJGRlY29kZShcIiU7XFx1MDEwMC9iIzI4XFxcIlxcXCI2ODc5L1MkO1xceEZCL0okJTJcXHUwMUEzXFxcIlxcXCI2XFx1MDFBMzdcXHUwMUE0LywjO1xceEVDLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxQTVcXFwiXFxcIjUlN1xcdTAxQTYuKSAmM1xcdTAxQTdcXFwiXFxcIjUkN1xcdTAxQTgvJyA4ITpcXHUwMUExISEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTNcXHhCMVxcXCJcXFwiNSM3XFx4QjIuNiAmM1xceEIzXFxcIlxcXCI1IzdcXHhCNC4qICYkOyswIyo7KyYvJyA4ITpcXHUwMUE5ISEgKVwiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHUwMTA0L1xceDg3IzJGXFxcIlxcXCI2RjdHL3gkO1xcdTAxMDMvbyQyRlxcXCJcXFwiNkY3Ry9gJDtcXHUwMTAzL1ckMkZcXFwiXFxcIjZGN0cvSCQ7XFx1MDEwMy8/JDJGXFxcIlxcXCI2RjdHLzAkO1xcdTAxMDUvJyQ4KTpcXHUwMUFBKSApKCknIygoJyMoJycjKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7Iy8+IzsjLzUkOyMvLCQ7Iy8jJCskKSgkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiJTtcXHUwMTAzLywjO1xcdTAxMDMvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlO1xcdTAxMDMvNSM7XFx1MDEwMy8sJDtcXHUwMTAzLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7cS9UIyQ7bTAjKjttJi9EJCU7IC8sIztcXHhGOC8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlMlxcdTAxQUJcXFwiXFxcIjZcXHUwMUFCN1xcdTAxQUMuKSAmMlxcdTAxQURcXFwiXFxcIjZcXHUwMUFEN1xcdTAxQUUvdyM7MC9uJDtcXHUwMTA4L2UkJCU7Qi8yIztcXHUwMTA5LiMgJjtcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMwPColO0IvMiM7XFx1MDEwOS4jICY7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjJi8jJCskKSgkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICBwZWckZGVjb2RlKFwiO1xceDk5LiMgJjtMXCIpLFxuICAgIHBlZyRkZWNvZGUoXCIlMlxcdTAxQUZcXFwiXFxcIjZcXHUwMUFGN1xcdTAxQjAvNSM7PC8sJDtcXHUwMTBBLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgcGVnJGRlY29kZShcIiU7RC9TIzssL0okMjpcXFwiXFxcIjY6NzsvOyQ7LC4jICY7VC8sJDtFLyMkKyUpKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKVxuICBdO1xuXG4gIGxldCBwZWckY3VyclBvcyA9IDA7XG4gIGxldCBwZWckc2F2ZWRQb3MgPSAwO1xuICBjb25zdCBwZWckcG9zRGV0YWlsc0NhY2hlID0gW3sgbGluZTogMSwgY29sdW1uOiAxIH1dO1xuICBsZXQgcGVnJG1heEZhaWxQb3MgPSAwO1xuICBsZXQgcGVnJG1heEZhaWxFeHBlY3RlZDogRXhwZWN0YXRpb25bXSA9IFtdO1xuICBsZXQgcGVnJHNpbGVudEZhaWxzID0gMDtcblxuICBsZXQgcGVnJHJlc3VsdDtcblxuICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVJbmRpY2VzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cblxuICAgIHBlZyRzdGFydFJ1bGVJbmRleCA9IHBlZyRzdGFydFJ1bGVJbmRpY2VzW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYXRpb24oKTogSUZpbGVSYW5nZSB7XG4gICAgcmV0dXJuIHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbjogc3RyaW5nLCBsb2NhdGlvbjE/OiBJRmlsZVJhbmdlKSB7XG4gICAgbG9jYXRpb24xID0gbG9jYXRpb24xICE9PSB1bmRlZmluZWRcbiAgICAgID8gbG9jYXRpb24xXG4gICAgICA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG5cbiAgICB0aHJvdyBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoXG4gICAgICBbcGVnJG90aGVyRXhwZWN0YXRpb24oZGVzY3JpcHRpb24pXSxcbiAgICAgIGlucHV0LnN1YnN0cmluZyhwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKSxcbiAgICAgIGxvY2F0aW9uMVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlOiBzdHJpbmcsIGxvY2F0aW9uMT86IElGaWxlUmFuZ2UpIHtcbiAgICBsb2NhdGlvbjEgPSBsb2NhdGlvbjEgIT09IHVuZGVmaW5lZFxuICAgICAgPyBsb2NhdGlvbjFcbiAgICAgIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcblxuICAgIHRocm93IHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uMSk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKHRleHQxOiBzdHJpbmcsIGlnbm9yZUNhc2U6IGJvb2xlYW4pOiBJTGl0ZXJhbEV4cGVjdGF0aW9uIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImxpdGVyYWxcIiwgdGV4dDogdGV4dDEsIGlnbm9yZUNhc2U6IGlnbm9yZUNhc2UgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjbGFzc0V4cGVjdGF0aW9uKHBhcnRzOiBJQ2xhc3NQYXJ0cywgaW52ZXJ0ZWQ6IGJvb2xlYW4sIGlnbm9yZUNhc2U6IGJvb2xlYW4pOiBJQ2xhc3NFeHBlY3RhdGlvbiB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJjbGFzc1wiLCBwYXJ0czogcGFydHMsIGludmVydGVkOiBpbnZlcnRlZCwgaWdub3JlQ2FzZTogaWdub3JlQ2FzZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGFueUV4cGVjdGF0aW9uKCk6IElBbnlFeHBlY3RhdGlvbiB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJhbnlcIiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGVuZEV4cGVjdGF0aW9uKCk6IElFbmRFeHBlY3RhdGlvbiB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlbmRcIiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJG90aGVyRXhwZWN0YXRpb24oZGVzY3JpcHRpb246IHN0cmluZyk6IElPdGhlckV4cGVjdGF0aW9uIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvczogbnVtYmVyKSB7XG4gICAgbGV0IGRldGFpbHMgPSBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc107XG4gICAgbGV0IHA7XG5cbiAgICBpZiAoZGV0YWlscykge1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAgPSBwb3MgLSAxO1xuICAgICAgd2hpbGUgKCFwZWckcG9zRGV0YWlsc0NhY2hlW3BdKSB7XG4gICAgICAgIHAtLTtcbiAgICAgIH1cblxuICAgICAgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcF07XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBsaW5lOiBkZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogZGV0YWlscy5jb2x1bW5cbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChwIDwgcG9zKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHApID09PSAxMCkge1xuICAgICAgICAgIGRldGFpbHMubGluZSsrO1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbisrO1xuICAgICAgICB9XG5cbiAgICAgICAgcCsrO1xuICAgICAgfVxuXG4gICAgICBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc10gPSBkZXRhaWxzO1xuXG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY29tcHV0ZUxvY2F0aW9uKHN0YXJ0UG9zOiBudW1iZXIsIGVuZFBvczogbnVtYmVyKTogSUZpbGVSYW5nZSB7XG4gICAgY29uc3Qgc3RhcnRQb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHN0YXJ0UG9zKTtcbiAgICBjb25zdCBlbmRQb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKGVuZFBvcyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgb2Zmc2V0OiBzdGFydFBvcyxcbiAgICAgICAgbGluZTogc3RhcnRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogc3RhcnRQb3NEZXRhaWxzLmNvbHVtblxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBvZmZzZXQ6IGVuZFBvcyxcbiAgICAgICAgbGluZTogZW5kUG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGVuZFBvc0RldGFpbHMuY29sdW1uXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkMTogRXhwZWN0YXRpb24pIHtcbiAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7XG4gICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgIH1cblxuICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZTogc3RyaW5nLCBsb2NhdGlvbjE6IElGaWxlUmFuZ2UpIHtcbiAgICByZXR1cm4gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UsIFtdLCBcIlwiLCBsb2NhdGlvbjEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKGV4cGVjdGVkMTogRXhwZWN0YXRpb25bXSwgZm91bmQ6IHN0cmluZyB8IG51bGwsIGxvY2F0aW9uMTogSUZpbGVSYW5nZSkge1xuICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UoZXhwZWN0ZWQxLCBmb3VuZCksXG4gICAgICBleHBlY3RlZDEsXG4gICAgICBmb3VuZCxcbiAgICAgIGxvY2F0aW9uMVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckZGVjb2RlKHM6IHN0cmluZyk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gcy5zcGxpdChcIlwiKS5tYXAoKGNoKSA9PiAgY2guY2hhckNvZGVBdCgwKSAtIDMyICk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VSdWxlKGluZGV4OiBudW1iZXIpOiBhbnkge1xuICAgIGNvbnN0IGJjID0gcGVnJGJ5dGVjb2RlW2luZGV4XTtcbiAgICBsZXQgaXAgPSAwO1xuICAgIGNvbnN0IGlwczogYW55W10gPSBbXTtcbiAgICBsZXQgZW5kID0gYmMubGVuZ3RoO1xuICAgIGNvbnN0IGVuZHM6IGFueVtdID0gW107XG4gICAgY29uc3Qgc3RhY2s6IGFueVtdID0gW107XG4gICAgbGV0IHBhcmFtcztcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB3aGlsZSAoaXAgPCBlbmQpIHtcbiAgICAgICAgc3dpdGNoIChiY1tpcF0pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pO1xuICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgc3RhY2sucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgc3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJEZBSUxFRCk7XG4gICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBzdGFjay5wdXNoKFtdKTtcbiAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgc3RhY2subGVuZ3RoIC09IGJjW2lwICsgMV07XG4gICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBzdGFjay5zcGxpY2UoLTIsIDEpO1xuICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnB1c2goc3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHN0YWNrLnB1c2goc3RhY2suc3BsaWNlKHN0YWNrLmxlbmd0aCAtIGJjW2lwICsgMV0sIGJjW2lwICsgMV0pKTtcbiAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBzdGFjay5wdXNoKGlucHV0LnN1YnN0cmluZyhzdGFjay5wb3AoKSwgcGVnJGN1cnJQb3MpKTtcbiAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuXG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgaXAgKz0gMztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICBpcCArPSAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwKTtcblxuICAgICAgICAgICAgICBlbmQgPSBpcCArIDIgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXAgKz0gMiArIGJjW2lwICsgMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgaXAgKz0gMztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICBpcCArPSAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG5cbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIChwZWckY29uc3RzW2JjW2lwICsgMV1dIGFzIHN0cmluZykubGVuZ3RoKSA9PT0gcGVnJGNvbnN0c1tiY1tpcCArIDFdXSkge1xuICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM107XG4gICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdKTtcblxuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0gYXMgc3RyaW5nKS5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pIHtcbiAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgaXAgKz0gNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG5cbiAgICAgICAgICAgIGlmICgocGVnJGNvbnN0c1tiY1tpcCArIDFdXSBhcyBSZWdFeHApLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgaXAgKz0gNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgc3RhY2sucHVzaChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIGJjW2lwICsgMV0pKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IGJjW2lwICsgMV07XG4gICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgc3RhY2sucHVzaChwZWckY29uc3RzW2JjW2lwICsgMV1dKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IChwZWckY29uc3RzW2JjW2lwICsgMV1dIGFzIHN0cmluZykubGVuZ3RoO1xuICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJEZBSUxFRCk7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7XG4gICAgICAgICAgICAgIHBlZyRmYWlsKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0gYXMgSUxpdGVyYWxFeHBlY3RhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIGJjW2lwICsgMV1dO1xuICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgIHBhcmFtcyA9IGJjLnNsaWNlKGlwICsgNCwgaXAgKyA0ICsgYmNbaXAgKyAzXSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxIC0gcF07IH0pO1xuXG4gICAgICAgICAgICBzdGFjay5zcGxpY2UoXG4gICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCAtIGJjW2lwICsgMl0sXG4gICAgICAgICAgICAgIGJjW2lwICsgMl0sXG4gICAgICAgICAgICAgIChwZWckY29uc3RzW2JjW2lwICsgMV1dIGFzICgoLi4uYXJnczogYW55W10pID0+IGFueSkpLmFwcGx5KG51bGwsIHBhcmFtcylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgc3RhY2sucHVzaChwZWckcGFyc2VSdWxlKGJjW2lwICsgMV0pKTtcbiAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wY29kZTogXCIgKyBiY1tpcF0gKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBlbmQgPSBlbmRzLnBvcCgpO1xuICAgICAgICBpcCA9IGlwcy5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGFja1swXTtcbiAgfVxuXG5cbiAgICBvcHRpb25zLmRhdGEgPSB7fTsgLy8gT2JqZWN0IHRvIHdoaWNoIGhlYWRlciBhdHRyaWJ1dGVzIHdpbGwgYmUgYXNzaWduZWQgZHVyaW5nIHBhcnNpbmdcblxuICAgIGZ1bmN0aW9uIGxpc3QoaGVhZDogc3RyaW5nLCB0YWlsOiBBcnJheTxzdHJpbmc+KSB7XG4gICAgICByZXR1cm4gW2hlYWRdLmNvbmNhdCh0YWlsKTtcbiAgICB9XG5cblxuICBwZWckcmVzdWx0ID0gcGVnJHBhcnNlUnVsZShwZWckc3RhcnRSdWxlSW5kZXgpO1xuXG4gIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcGVnJHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcGVnJGZhaWwocGVnJGVuZEV4cGVjdGF0aW9uKCkpO1xuICAgIH1cblxuICAgIHRocm93IHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQsXG4gICAgICBwZWckbWF4RmFpbFBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwZWckbWF4RmFpbFBvcykgOiBudWxsLFxuICAgICAgcGVnJG1heEZhaWxQb3MgPCBpbnB1dC5sZW5ndGhcbiAgICAgICAgPyBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRtYXhGYWlsUG9zLCBwZWckbWF4RmFpbFBvcyArIDEpXG4gICAgICAgIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MpXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElQYXJzZU9wdGlvbnMge1xuICBmaWxlbmFtZT86IHN0cmluZztcbiAgc3RhcnRSdWxlPzogc3RyaW5nO1xuICB0cmFjZXI/OiBhbnk7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cbmV4cG9ydCB0eXBlIFBhcnNlRnVuY3Rpb24gPSAoaW5wdXQ6IHN0cmluZywgb3B0aW9ucz86IElQYXJzZU9wdGlvbnMpID0+IGFueTtcbmV4cG9ydCBjb25zdCBwYXJzZTogUGFyc2VGdW5jdGlvbiA9IHBlZyRwYXJzZTtcbiIsImV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVyc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2Vzc2lvbi1kZXNjcmlwdGlvbi1oYW5kbGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zaW1wbGUtdXNlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHJhbnNwb3J0XCI7XG4iLCJpbXBvcnQgeyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXIgfSBmcm9tIFwiLi4vLi4vYXBpXCI7XG5cbmNvbnN0IHN0cmlwUGF5bG9hZCA9IChzZHA6IHN0cmluZywgcGF5bG9hZDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgY29uc3QgbWVkaWFEZXNjczogQXJyYXk8YW55PiA9IFtdO1xuXG4gIGNvbnN0IGxpbmVzOiBBcnJheTxzdHJpbmc+ID0gc2RwLnNwbGl0KC9cXHJcXG4vKTtcblxuICBsZXQgY3VycmVudE1lZGlhRGVzYzogYW55O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDspIHtcbiAgICBjb25zdCBsaW5lOiBzdHJpbmcgPSBsaW5lc1tpXTtcbiAgICBpZiAoL15tPSg/OmF1ZGlvfHZpZGVvKS8udGVzdChsaW5lKSkge1xuICAgICAgY3VycmVudE1lZGlhRGVzYyA9IHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHN0cmlwcGVkOiBbXVxuICAgICAgfTtcbiAgICAgIG1lZGlhRGVzY3MucHVzaChjdXJyZW50TWVkaWFEZXNjKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRNZWRpYURlc2MpIHtcbiAgICAgIGNvbnN0IHJ0cG1hcCA9IC9eYT1ydHBtYXA6KFxcZCspIChbXi9dKylcXC8vLmV4ZWMobGluZSk7XG4gICAgICBpZiAocnRwbWFwICYmIHBheWxvYWQgPT09IHJ0cG1hcFsyXSkge1xuICAgICAgICBsaW5lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGN1cnJlbnRNZWRpYURlc2Muc3RyaXBwZWQucHVzaChydHBtYXBbMV0pO1xuICAgICAgICBjb250aW51ZTsgLy8gRG9uJ3QgaW5jcmVtZW50ICdpJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIGZvciAoY29uc3QgbWVkaWFEZXNjIG9mIG1lZGlhRGVzY3MpIHtcbiAgICBjb25zdCBtbGluZTogQXJyYXk8c3RyaW5nPiA9IGxpbmVzW21lZGlhRGVzYy5pbmRleF0uc3BsaXQoXCIgXCIpO1xuXG4gICAgLy8gSWdub3JlIHRoZSBmaXJzdCAzIHBhcmFtZXRlcnMgb2YgdGhlIG1saW5lLiBUaGUgY29kZWMgaW5mb3JtYXRpb24gaXMgYWZ0ZXIgdGhhdFxuICAgIGZvciAobGV0IGogPSAzOyBqIDwgbWxpbmUubGVuZ3RoOykge1xuICAgICAgaWYgKG1lZGlhRGVzYy5zdHJpcHBlZC5pbmRleE9mKG1saW5lW2pdKSAhPT0gLTEpIHtcbiAgICAgICAgbWxpbmUuc3BsaWNlKGosIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGorKztcbiAgICB9XG5cbiAgICBsaW5lc1ttZWRpYURlc2MuaW5kZXhdID0gbWxpbmUuam9pbihcIiBcIik7XG4gIH1cblxuICByZXR1cm4gbGluZXMuam9pbihcIlxcclxcblwiKTtcbn07XG5cbmNvbnN0IHN0cmlwTWVkaWFEZXNjcmlwdGlvbiA9IChzZHA6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uUmVnRXhwID0gbmV3IFJlZ0V4cChcIm09XCIgKyBkZXNjcmlwdGlvbiArIFwiLiokXCIsIFwiZ21cIik7XG4gIGNvbnN0IGdyb3VwUmVnRXhwID0gbmV3IFJlZ0V4cChcIl5hPWdyb3VwOi4qJFwiLCBcImdtXCIpO1xuXG4gIGlmIChkZXNjcmlwdGlvblJlZ0V4cC50ZXN0KHNkcCkpIHtcbiAgICBsZXQgbWlkTGluZVRvUmVtb3ZlO1xuICAgIHNkcCA9IHNkcC5zcGxpdCgvXm09L2dtKS5maWx0ZXIoKHNlY3Rpb24pID0+IHtcbiAgICAgIGlmIChzZWN0aW9uLnN1YnN0cigwLCBkZXNjcmlwdGlvbi5sZW5ndGgpID09PSBkZXNjcmlwdGlvbikge1xuICAgICAgICBtaWRMaW5lVG9SZW1vdmUgPSBzZWN0aW9uLm1hdGNoKC9eYT1taWQ6LiokL2dtKTtcbiAgICAgICAgaWYgKG1pZExpbmVUb1JlbW92ZSkge1xuICAgICAgICAgIGNvbnN0IHN0ZXAgPSBtaWRMaW5lVG9SZW1vdmVbMF0ubWF0Y2goLzouKyQvZyk7XG4gICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgIG1pZExpbmVUb1JlbW92ZSA9IHN0ZXBbMF0uc3Vic3RyKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KS5qb2luKFwibT1cIik7XG4gICAgY29uc3QgZ3JvdXBMaW5lID0gc2RwLm1hdGNoKGdyb3VwUmVnRXhwKTtcbiAgICBpZiAoZ3JvdXBMaW5lICYmIGdyb3VwTGluZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxldCBncm91cExpbmVQb3J0aW9uID0gZ3JvdXBMaW5lWzBdO1xuICAgICAgY29uc3QgZ3JvdXBSZWdFeHBSZXBsYWNlID0gbmV3IFJlZ0V4cChcIlxcICpcIiArIG1pZExpbmVUb1JlbW92ZSArIFwiW15cXCBdKlwiLCBcImdcIik7XG4gICAgICBncm91cExpbmVQb3J0aW9uID0gZ3JvdXBMaW5lUG9ydGlvbi5yZXBsYWNlKGdyb3VwUmVnRXhwUmVwbGFjZSwgXCJcIik7XG4gICAgICBzZHAgPSBzZHAuc3BsaXQoZ3JvdXBSZWdFeHApLmpvaW4oZ3JvdXBMaW5lUG9ydGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZHA7XG59O1xuXG4vKipcbiAqIE1vZGlmaWVyLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBUY3BDYW5kaWRhdGVzKGRlc2NyaXB0aW9uOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KTogUHJvbWlzZTxSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0PiB7XG4gIGRlc2NyaXB0aW9uLnNkcCA9IChkZXNjcmlwdGlvbi5zZHAgfHwgXCJcIikucmVwbGFjZSgvXmE9Y2FuZGlkYXRlOlxcZCsgXFxkKyB0Y3AgLio/XFxyXFxuL2ltZywgXCJcIik7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBUZWxlcGhvbmVFdmVudChkZXNjcmlwdGlvbjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCk6IFByb21pc2U8UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdD4ge1xuICBkZXNjcmlwdGlvbi5zZHAgPSBzdHJpcFBheWxvYWQoZGVzY3JpcHRpb24uc2RwIHx8IFwiXCIsIFwidGVsZXBob25lLWV2ZW50XCIpO1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlc2NyaXB0aW9uKTtcbn1cblxuLyoqXG4gKiBNb2RpZmllci5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuSml0c2lTZHBJbWFnZWF0dHIoZGVzY3JpcHRpb246IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpOiBQcm9taXNlPFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQ+IHtcbiAgZGVzY3JpcHRpb24uc2RwID0gKGRlc2NyaXB0aW9uLnNkcCB8fCBcIlwiKS5yZXBsYWNlKC9eKGE9aW1hZ2VhdHRyOi4qPykoeHx5KT1cXFswLS9nbSwgXCIkMSQyPVsxOlwiKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjcmlwdGlvbik7XG59XG5cbi8qKlxuICogTW9kaWZpZXIuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEc3MjIoZGVzY3JpcHRpb246IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpOiBQcm9taXNlPFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQ+IHtcbiAgZGVzY3JpcHRpb24uc2RwID0gc3RyaXBQYXlsb2FkKGRlc2NyaXB0aW9uLnNkcCB8fCBcIlwiLCBcIkc3MjJcIik7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBSdHBQYXlsb2FkKHBheWxvYWQ6IHN0cmluZyk6IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllciB7XG4gIHJldHVybiAoZGVzY3JpcHRpb246IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpOiBQcm9taXNlPFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQ+ID0+IHtcbiAgICBkZXNjcmlwdGlvbi5zZHAgPSBzdHJpcFBheWxvYWQoZGVzY3JpcHRpb24uc2RwIHx8IFwiXCIsIHBheWxvYWQpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVyLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBWaWRlbyhkZXNjcmlwdGlvbjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCk6IFByb21pc2U8UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdD4ge1xuICBkZXNjcmlwdGlvbi5zZHAgPSBzdHJpcE1lZGlhRGVzY3JpcHRpb24oZGVzY3JpcHRpb24uc2RwIHx8IFwiXCIsIFwidmlkZW9cIik7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTWlkTGluZXMoZGVzY3JpcHRpb246IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpOiBQcm9taXNlPFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQ+IHtcbiAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcCB8fCBcIlwiO1xuICBpZiAoc2RwLnNlYXJjaCgvXmE9bWlkLiokL2dtKSA9PT0gLTEpIHtcbiAgICBjb25zdCBtbGluZXMgPSBzZHAubWF0Y2goL15tPS4qJC9nbSk7XG4gICAgY29uc3Qgc2RwQXJyYXkgPSBzZHAuc3BsaXQoL15tPS4qJC9nbSk7XG4gICAgaWYgKG1saW5lcykge1xuICAgICAgbWxpbmVzLmZvckVhY2goKGVsZW0sIGlkeCkgPT4ge1xuICAgICAgICBtbGluZXNbaWR4XSA9IGVsZW0gKyBcIlxcbmE9bWlkOlwiICsgaWR4O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNkcEFycmF5LmZvckVhY2goKGVsZW0sIGlkeCkgPT4ge1xuICAgICAgaWYgKG1saW5lcyAmJiBtbGluZXNbaWR4XSkge1xuICAgICAgICBzZHBBcnJheVtpZHhdID0gZWxlbSArIG1saW5lc1tpZHhdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNkcCA9IHNkcEFycmF5LmpvaW4oXCJcIik7XG4gICAgZGVzY3JpcHRpb24uc2RwID0gc2RwO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xufVxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50c1wiO1xuXG5pbXBvcnQge1xuICBCb2R5QW5kQ29udGVudFR5cGUsXG4gIFNlc3Npb24sXG4gIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgYXMgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckRlZmluaXRpb24sXG4gIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcixcbiAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMgYXMgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnNEZWZpbml0aW9uLFxufSBmcm9tIFwiLi4vLi4vYXBpXCI7XG5pbXBvcnQgeyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IgfSBmcm9tIFwiLi4vLi4vYXBpL2V4Y2VwdGlvbnNcIjtcblxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcbmltcG9ydCAqIGFzIE1vZGlmaWVycyBmcm9tIFwiLi9tb2RpZmllcnNcIjtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBQZWVyQ29ubmVjdGlvbi5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQZWVyQ29ubmVjdGlvbk9wdGlvbnMge1xuICBpY2VDaGVja2luZ1RpbWVvdXQ/OiBudW1iZXI7XG4gIHJ0Y0NvbmZpZ3VyYXRpb24/OiBSVENDb25maWd1cmF0aW9uO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHtAbGluayBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyfS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyBleHRlbmRzIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zRGVmaW5pdGlvbiB7XG4gIHBlZXJDb25uZWN0aW9uT3B0aW9ucz86IFBlZXJDb25uZWN0aW9uT3B0aW9ucztcbiAgYWx3YXlzQWNxdWlyZU1lZGlhRmlyc3Q/OiBib29sZWFuO1xuICBkaXNhYmxlQXVkaW9GYWxsYmFjaz86IGJvb2xlYW47XG4gIFJUQ09mZmVyT3B0aW9ucz86IGFueTtcbiAgY29uc3RyYWludHM/OiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzO1xufVxuXG5pbnRlcmZhY2UgRGVmZXJyZWQ8VD4ge1xuICBwcm9taXNlOiBQcm9taXNlPFQ+O1xuICByZXNvbHZlOiAoKSA9PiBUO1xuICByZWplY3Q6ICgpID0+IFQ7XG59XG5cbmZ1bmN0aW9uIGRlZmVyKCk6IERlZmVycmVkPGFueT4ge1xuICBjb25zdCBkZWZlcnJlZDogYW55ID0ge307XG4gIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgcmV0dXJuIGRlZmVycmVkIGFzIERlZmVycmVkPGFueT47XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVByb21pc2VzKGFycjogQXJyYXk8U2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyPiwgdmFsOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gYXJyLnJlZHVjZSgoYWNjLCBmbjogYW55KSA9PiB7XG4gICAgYWNjID0gYWNjLnRoZW4oZm4pO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFByb21pc2UucmVzb2x2ZSh2YWwpKTtcbn1cblxuLyoqXG4gKiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIGZvciB3ZWIgYnJvd3Nlci5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIgaW1wbGVtZW50cyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRGVmaW5pdGlvbiAge1xuXG4gIHB1YmxpYyBzdGF0aWMgZGVmYXVsdEZhY3RvcnkoXG4gICAgc2Vzc2lvbjogU2Vzc2lvbixcbiAgICBvcHRpb25zOiBhbnlcbiAgKTogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciB7XG4gICAgY29uc3QgbG9nZ2VyOiBMb2dnZXIgPSBzZXNzaW9uLnVzZXJBZ2VudC5nZXRMb2dnZXIoXCJzaXAuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclwiLCBzZXNzaW9uLmlkKTtcbiAgICByZXR1cm4gbmV3IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIobG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHB1YmxpYyBwZWVyQ29ubmVjdGlvbiE6IFJUQ1BlZXJDb25uZWN0aW9uO1xuICBwcml2YXRlIG9wdGlvbnM6IGFueTtcbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcbiAgcHJpdmF0ZSBkdG1mU2VuZGVyOiBhbnk7XG4gIHByaXZhdGUgc2hvdWxkQWNxdWlyZU1lZGlhOiBib29sZWFuO1xuICBwcml2YXRlIENPTlRFTlRfVFlQRTogc3RyaW5nO1xuICBwcml2YXRlIGRpcmVjdGlvbjogc3RyaW5nO1xuICBwcml2YXRlIEM6IGFueTtcbiAgcHJpdmF0ZSBtb2RpZmllcnM6IEFycmF5PFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcj47XG4gIHByaXZhdGUgaWNlR2F0aGVyaW5nRGVmZXJyZWQ6IERlZmVycmVkPGFueT4gfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgaWNlR2F0aGVyaW5nVGltZW91dDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBpY2VHYXRoZXJpbmdUaW1lcjogYW55IHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzO1xuXG4gIGNvbnN0cnVjdG9yKGxvZ2dlcjogTG9nZ2VyLCBvcHRpb25zOiBhbnkpIHtcbiAgICBzdXBlcigpO1xuICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoZSBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuZHRtZlNlbmRlciA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuc2hvdWxkQWNxdWlyZU1lZGlhID0gdHJ1ZTtcblxuICAgIHRoaXMuQ09OVEVOVF9UWVBFID0gXCJhcHBsaWNhdGlvbi9zZHBcIjtcblxuICAgIHRoaXMuQyA9IHtcbiAgICAgIERJUkVDVElPTjoge1xuICAgICAgICBOVUxMOiAgICAgbnVsbCxcbiAgICAgICAgU0VORFJFQ1Y6IFwic2VuZHJlY3ZcIixcbiAgICAgICAgU0VORE9OTFk6IFwic2VuZG9ubHlcIixcbiAgICAgICAgUkVDVk9OTFk6IFwicmVjdm9ubHlcIixcbiAgICAgICAgSU5BQ1RJVkU6IFwiaW5hY3RpdmVcIlxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coXCJTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9uczogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMpKTtcblxuICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5DLkRJUkVDVElPTi5OVUxMO1xuXG4gICAgdGhpcy5tb2RpZmllcnMgPSB0aGlzLm9wdGlvbnMubW9kaWZpZXJzIHx8IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLm1vZGlmaWVycykpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzID0gW3RoaXMubW9kaWZpZXJzXTtcbiAgICB9XG5cbiAgICB0aGlzLmljZUdhdGhlcmluZ1RpbWVvdXQgPSBmYWxzZTtcblxuICAgIHRoaXMuaW5pdFBlZXJDb25uZWN0aW9uKHRoaXMub3B0aW9ucy5wZWVyQ29ubmVjdGlvbk9wdGlvbnMpO1xuXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IHRoaXMuY2hlY2tBbmREZWZhdWx0Q29uc3RyYWludHModGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cnVjdG9yXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiY2xvc2luZyBQZWVyQ29ubmVjdGlvblwiKTtcbiAgICAvLyBoYXZlIHRvIGNoZWNrIHNpZ25hbGluZ1N0YXRlIHNpbmNlIHRoaXMuY2xvc2UoKSBnZXRzIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uICYmIHRoaXMucGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09IFwiY2xvc2VkXCIpIHtcbiAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uLmdldFNlbmRlcnMpIHtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCkuZm9yRWFjaCgoc2VuZGVyOiBSVENSdHBTZW5kZXIpID0+IHtcbiAgICAgICAgICBpZiAoc2VuZGVyLnRyYWNrKSB7XG4gICAgICAgICAgICBzZW5kZXIudHJhY2suc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVXNpbmcgZ2V0TG9jYWxTdHJlYW1zIHdoaWNoIGlzIGRlcHJlY2F0ZWRcIik7XG4gICAgICAgICh0aGlzLnBlZXJDb25uZWN0aW9uIGFzIGFueSkuZ2V0TG9jYWxTdHJlYW1zKCkuZm9yRWFjaCgoc3RyZWFtOiBNZWRpYVN0cmVhbSkgPT4ge1xuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uLmdldFJlY2VpdmVycykge1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmdldFJlY2VpdmVycygpLmZvckVhY2goKHJlY2VpdmVyOiBSVENSdHBSZWNlaXZlcikgPT4ge1xuICAgICAgICAgIGlmIChyZWNlaXZlci50cmFjaykge1xuICAgICAgICAgICAgcmVjZWl2ZXIudHJhY2suc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVXNpbmcgZ2V0UmVtb3RlU3RyZWFtcyB3aGljaCBpcyBkZXByZWNhdGVkXCIpO1xuICAgICAgICAodGhpcy5wZWVyQ29ubmVjdGlvbiBhcyBhbnkpLmdldFJlbW90ZVN0cmVhbXMoKS5mb3JFYWNoKChzdHJlYW06IE1lZGlhU3RyZWFtKSA9PiB7XG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldEljZUdhdGhlcmluZ0NvbXBsZXRlKCk7XG4gICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxvY2FsIGRlc2NyaXB0aW9uIGZyb20gdGhlIHVuZGVybHlpbmcgbWVkaWEgaW1wbGVtZW50YXRpb24uXG4gICAqIEByZW1hcmtzXG4gICAqIFJlc29sdmVzIHdpdGggdGhlIGxvY2FsIGRlc2NyaXB0aW9uIHRvIGJlIHVzZWQgZm9yIHRoZSBzZXNzaW9uLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgb2JqZWN0IHRvIGJlIHVzZWQgYnkgZ2V0RGVzY3JpcHRpb25cbiAgICogQHBhcmFtIG1vZGlmaWVycyAtIEFycmF5IHdpdGggb25lIHRpbWUgdXNlIGRlc2NyaXB0aW9uIG1vZGlmaWVyc1xuICAgKi9cbiAgcHVibGljIGdldERlc2NyaXB0aW9uKFxuICAgIG9wdGlvbnM6IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zID0ge30sXG4gICAgbW9kaWZpZXJzOiBBcnJheTxTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXI+ID0gW11cbiAgKTogUHJvbWlzZTxCb2R5QW5kQ29udGVudFR5cGU+IHtcbiAgICBpZiAob3B0aW9ucy5wZWVyQ29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICAgIHRoaXMuaW5pdFBlZXJDb25uZWN0aW9uKG9wdGlvbnMucGVlckNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBNZXJnZSBwYXNzZWQgY29uc3RyYWludHMgd2l0aCBzYXZlZCBjb25zdHJhaW50cyBhbmQgc2F2ZVxuICAgIGxldCBuZXdDb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uc3RyYWludHMsIG9wdGlvbnMuY29uc3RyYWludHMpO1xuICAgIG5ld0NvbnN0cmFpbnRzID0gdGhpcy5jaGVja0FuZERlZmF1bHRDb25zdHJhaW50cyhuZXdDb25zdHJhaW50cyk7XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KG5ld0NvbnN0cmFpbnRzKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5jb25zdHJhaW50cykpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IG5ld0NvbnN0cmFpbnRzO1xuICAgICAgICB0aGlzLnNob3VsZEFjcXVpcmVNZWRpYSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGlmaWVycykpIHtcbiAgICAgIG1vZGlmaWVycyA9IFttb2RpZmllcnNdO1xuICAgIH1cbiAgICBtb2RpZmllcnMgPSBtb2RpZmllcnMuY29uY2F0KHRoaXMubW9kaWZpZXJzKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNob3VsZEFjcXVpcmVNZWRpYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlKHRoaXMuY29uc3RyYWludHMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2hvdWxkQWNxdWlyZU1lZGlhID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLnRoZW4oKCkgPT4gdGhpcy5jcmVhdGVPZmZlck9yQW5zd2VyKG9wdGlvbnMuUlRDT2ZmZXJPcHRpb25zLCBtb2RpZmllcnMpKVxuICAgIC50aGVuKChkZXNjcmlwdGlvbjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkgPT4ge1xuICAgICAgaWYgKGRlc2NyaXB0aW9uLnNkcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IoXCJTRFAgdW5kZWZpbmVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcImdldERlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJvZHk6IGRlc2NyaXB0aW9uLnNkcCxcbiAgICAgICAgY29udGVudFR5cGU6IHRoaXMuQ09OVEVOVF9UWVBFXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBTZXNzaW9uIERlc2NyaXB0aW9uIEhhbmRsZXIgY2FuIGhhbmRsZSB0aGUgQ29udGVudC1UeXBlIGRlc2NyaWJlZCBieSBhIFNJUCBNZXNzYWdlXG4gICAqIEBwYXJhbSBjb250ZW50VHlwZSAtIFRoZSBjb250ZW50IHR5cGUgdGhhdCBpcyBpbiB0aGUgU0lQIE1lc3NhZ2VcbiAgICovXG4gIHB1YmxpYyBoYXNEZXNjcmlwdGlvbihjb250ZW50VHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGNvbnRlbnRUeXBlID09PSB0aGlzLkNPTlRFTlRfVFlQRTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbW9kaWZpZXIgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBzZXNzaW9uIHdvdWxkIGxpa2UgdG8gcGxhY2UgdGhlIGNhbGwgb24gaG9sZC5cbiAgICogQHJlbWFya3NcbiAgICogUmVzb2x2ZXMgd2l0aCBtb2RpZmllZCBTRFAuXG4gICAqIEBwYXJhbSBkZXNjcmlwdGlvbiAtIFRoZSBkZXNjcmlwdGlvbiB0aGF0IHdpbGwgYmUgbW9kaWZpZWRcbiAgICovXG4gIHB1YmxpYyBob2xkTW9kaWZpZXIoZGVzY3JpcHRpb246IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpOiBQcm9taXNlPFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQ+IHtcbiAgICBpZiAoIWRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKCEoL2E9KHNlbmRyZWN2fHNlbmRvbmx5fHJlY3Zvbmx5fGluYWN0aXZlKS8pLnRlc3QoZGVzY3JpcHRpb24uc2RwKSkge1xuICAgICAgZGVzY3JpcHRpb24uc2RwID0gZGVzY3JpcHRpb24uc2RwLnJlcGxhY2UoLyhtPVteXFxyXSpcXHJcXG4pL2csIFwiJDFhPXNlbmRvbmx5XFxyXFxuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXNjcmlwdGlvbi5zZHAgPSBkZXNjcmlwdGlvbi5zZHAucmVwbGFjZSgvYT1zZW5kcmVjdlxcclxcbi9nLCBcImE9c2VuZG9ubHlcXHJcXG5cIik7XG4gICAgICBkZXNjcmlwdGlvbi5zZHAgPSBkZXNjcmlwdGlvbi5zZHAucmVwbGFjZSgvYT1yZWN2b25seVxcclxcbi9nLCBcImE9aW5hY3RpdmVcXHJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmVtb3RlIGRlc2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIG1lZGlhIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcmVtYXJrc1xuICAgKiBSZXNvbHZlcyBvbmNlIHRoZSBkZXNjcmlwdGlvbiBpcyBzZXQuXG4gICAqIEBwYXJhbSBzZXNzaW9uRGVzY3JpcHRpb24gLSBUaGUgZGVzY3JpcHRpb24gcHJvdmlkZWQgYnkgYSBTSVAgbWVzc2FnZSB0byBiZSBzZXQgb24gdGhlIG1lZGlhIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgb2JqZWN0IHRvIGJlIHVzZWQgYnkgZ2V0RGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSBtb2RpZmllcnMgLSBBcnJheSB3aXRoIG9uZSB0aW1lIHVzZSBkZXNjcmlwdGlvbiBtb2RpZmllcnMuXG4gICAqL1xuICBwdWJsaWMgc2V0RGVzY3JpcHRpb24oXG4gICAgc2Vzc2lvbkRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gICAgb3B0aW9uczogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMgPSB7fSxcbiAgICBtb2RpZmllcnM6IEFycmF5PFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcj4gPSBbXVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAob3B0aW9ucy5wZWVyQ29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICAgIHRoaXMuaW5pdFBlZXJDb25uZWN0aW9uKG9wdGlvbnMucGVlckNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kaWZpZXJzKSkge1xuICAgICAgbW9kaWZpZXJzID0gW21vZGlmaWVyc107XG4gICAgfVxuICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycy5jb25jYXQodGhpcy5tb2RpZmllcnMpO1xuXG4gICAgY29uc3QgZGVzY3JpcHRpb246IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXRcbiA9IHtcbiAgICAgIHR5cGU6IHRoaXMuaGFzT2ZmZXIoXCJsb2NhbFwiKSA/IFwiYW5zd2VyXCIgOiBcIm9mZmVyXCIsXG4gICAgICBzZHA6IHNlc3Npb25EZXNjcmlwdGlvblxuICAgIH07XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAvLyBNZWRpYSBzaG91bGQgYmUgYWNxdWlyZWQgaW4gZ2V0RGVzY3JpcHRpb24gdW5sZXNzIHdlIG5lZWQgdG8gZG8gaXQgc29vbmVyIGZvciBzb21lIHJlYXNvbiAoRkY2MSspXG4gICAgICBpZiAodGhpcy5zaG91bGRBY3F1aXJlTWVkaWEgJiYgdGhpcy5vcHRpb25zLmFsd2F5c0FjcXVpcmVNZWRpYUZpcnN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjcXVpcmUodGhpcy5jb25zdHJhaW50cykudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zaG91bGRBY3F1aXJlTWVkaWEgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkudGhlbigoKSA9PiByZWR1Y2VQcm9taXNlcyhtb2RpZmllcnMsIGRlc2NyaXB0aW9uKSlcbiAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBsZXQgbWVzc2FnZSA9IFwiVGhlIG1vZGlmaWVycyBkaWQgbm90IHJlc29sdmUgc3VjY2Vzc2Z1bGx5LlwiO1xuICAgICAgaWYgKGUubmFtZSkge1xuICAgICAgICBtZXNzYWdlICs9IFwiIFwiICsgZS5uYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGUubWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlICs9IFwiIFwiICsgZS5tZXNzYWdlO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLmVtaXQoXCJwZWVyQ29ubmVjdGlvbi1zZXRSZW1vdGVEZXNjcmlwdGlvbkZhaWxlZFwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KS50aGVuKChtb2RpZmllZERlc2NyaXB0aW9uKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoXCJzZXREZXNjcmlwdGlvblwiLCBtb2RpZmllZERlc2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzLnBlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKG1vZGlmaWVkRGVzY3JpcHRpb24pO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAvLyBDaGVjayB0aGUgb3JpZ2luYWwgU0RQIGZvciB2aWRlbywgYW5kIGVuc3VyZSB0aGF0IHdlIGhhdmUgd2FudCB0byBkbyBhdWRpbyBmYWxsYmFja1xuICAgICAgaWYgKCgvXm09dmlkZW8uKyQvZ20pLnRlc3Qoc2Vzc2lvbkRlc2NyaXB0aW9uKSAmJiAhb3B0aW9ucy5kaXNhYmxlQXVkaW9GYWxsYmFjaykge1xuICAgICAgICAvLyBEbyBub3QgdHJ5IHRvIGF1ZGlvIGZhbGxiYWNrIGFnYWluXG4gICAgICAgIG9wdGlvbnMuZGlzYWJsZUF1ZGlvRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAvLyBSZW1vdmUgdmlkZW8gZmlyc3QsIHRoZW4gZG8gdGhlIG90aGVyIG1vZGlmaWVyc1xuICAgICAgICByZXR1cm4gdGhpcy5zZXREZXNjcmlwdGlvbihzZXNzaW9uRGVzY3JpcHRpb24sIG9wdGlvbnMsIFtNb2RpZmllcnMuc3RyaXBWaWRlb10uY29uY2F0KG1vZGlmaWVycykpO1xuICAgICAgfVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGxldCBtZXNzYWdlID0gXCJUaGUgbW9kaWZpZXJzIGRpZCBub3QgcmVzb2x2ZSBzdWNjZXNzZnVsbHkuXCI7XG4gICAgICBpZiAoZS5uYW1lKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgXCIgKyBlLm5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoZS5tZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgXCIgKyBlLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgIHRoaXMuZW1pdChcInBlZXJDb25uZWN0aW9uLXNldFJlbW90ZURlc2NyaXB0aW9uRmFpbGVkXCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgIHRoaXMuZW1pdChcInNldFJlbW90ZURlc2NyaXB0aW9uXCIsIHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0UmVjZWl2ZXJzKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KFwic2V0UmVtb3RlRGVzY3JpcHRpb25cIiwgKHRoaXMucGVlckNvbm5lY3Rpb24gYXMgYW55KS5nZXRSZW1vdGVTdHJlYW1zKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiY29uZmlybWVkXCIsIHRoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgRFRNRiB2aWEgUlRQIChSRkMgNDczMykuXG4gICAqIEByZW1hcmtzXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBEVE1GIHNlbmQgaXMgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcGFyYW0gdG9uZXMgLSBBIHN0cmluZyBjb250YWluaW5nIERUTUYgZGlnaXRzLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgb2JqZWN0IHRvIGJlIHVzZWQgYnkgc2VuZER0bWYuXG4gICAqL1xuICBwdWJsaWMgc2VuZER0bWYodG9uZXM6IHN0cmluZywgb3B0aW9uczogYW55ID0ge30pOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuZHRtZlNlbmRlciAmJiB0aGlzLmhhc0Jyb3dzZXJHZXRTZW5kZXJTdXBwb3J0KCkpIHtcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSB0aGlzLnBlZXJDb25uZWN0aW9uLmdldFNlbmRlcnMoKTtcbiAgICAgIGlmIChzZW5kZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5kdG1mU2VuZGVyID0gc2VuZGVyc1swXS5kdG1mO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZHRtZlNlbmRlciAmJiB0aGlzLmhhc0Jyb3dzZXJUcmFja1N1cHBvcnQoKSkge1xuICAgICAgY29uc3Qgc3RyZWFtcyA9ICh0aGlzLnBlZXJDb25uZWN0aW9uIGFzIGFueSkuZ2V0TG9jYWxTdHJlYW1zKCk7XG4gICAgICBpZiAoc3RyZWFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gc3RyZWFtc1swXS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuZHRtZlNlbmRlciA9ICh0aGlzLnBlZXJDb25uZWN0aW9uIGFzIGFueSkuY3JlYXRlRFRNRlNlbmRlcihhdWRpb1RyYWNrc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmR0bWZTZW5kZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZHRtZlNlbmRlci5pbnNlcnREVE1GKHRvbmVzLCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmludGVyVG9uZUdhcCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUudHlwZSA9PT0gIFwiSW52YWxpZFN0YXRlRXJyb3JcIiB8fCBlLnR5cGUgPT09ICBcIkludmFsaWRDaGFyYWN0ZXJFcnJvclwiKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coXCJEVE1GIHNlbnQgdmlhIFJUUDogXCIgKyB0b25lcy50b1N0cmluZygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvblxuICAgKi9cbiAgcHVibGljIGdldERpcmVjdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBvbihcbiAgICBldmVudDogXCJnZXREZXNjcmlwdGlvblwiIHwgXCJzZXREZXNjcmlwdGlvblwiLFxuICAgIGxpc3RlbmVyOiAoZGVzY3JpcHRpb246IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpID0+IHZvaWRcbiAgKTogdGhpcztcbiAgcHVibGljIG9uKFxuICAgIGV2ZW50OiBcInBlZXJDb25uZWN0aW9uLXNldFJlbW90ZURlc2NyaXB0aW9uRmFpbGVkXCIsXG4gICAgbGlzdGVuZXI6IChlcnJvcjogYW55KSA9PiB2b2lkXG4gICk6IHRoaXM7IC8vIFRPRE86IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFeGNlcHRpb25cbiAgcHVibGljIG9uKGV2ZW50OiBcInNldFJlbW90ZURlc2NyaXB0aW9uXCIsIGxpc3RlbmVyOiAocmVjZWl2ZXJzOiBBcnJheTxSVENSdHBSZWNlaXZlcj4pID0+IHZvaWQpOiB0aGlzO1xuICBwdWJsaWMgb24oZXZlbnQ6IFwiY29uZmlybWVkXCIsIGxpc3RlbmVyOiAoc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcjogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikgPT4gdm9pZCk6IHRoaXM7XG5cbiAgcHVibGljIG9uKFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp1bmlmaWVkLXNpZ25hdHVyZXNcbiAgICBldmVudDogXCJwZWVyQ29ubmVjdGlvbi1jcmVhdGVBbnN3ZXJGYWlsZWRcIiB8IFwicGVlckNvbm5lY3Rpb24tY3JlYXRlT2ZmZXJGYWlsZWRcIixcbiAgICBsaXN0ZW5lcjogKGVycm9yOiBhbnkpID0+IHZvaWRcbiAgKTogdGhpczsgLy8gVE9ETzpcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnVuaWZpZWQtc2lnbmF0dXJlc1xuICBwdWJsaWMgb24oZXZlbnQ6IFwicGVlckNvbm5lY3Rpb24tU2V0TG9jYWxEZXNjcmlwdGlvbkZhaWxlZFwiLCBsaXN0ZW5lcjogKGVycm9yOiBhbnkpID0+IHZvaWQpOiB0aGlzO1xuICBwdWJsaWMgb24oZXZlbnQ6IFwiYWRkVHJhY2tcIiwgbGlzdGVuZXI6ICh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykgPT4gdm9pZCk6IHRoaXM7XG4gIHB1YmxpYyBvbihldmVudDogXCJhZGRTdHJlYW1cIiwgbGlzdGVuZXI6ICh0cmFjazogTWVkaWFTdHJlYW0pID0+IHZvaWQpOiB0aGlzO1xuICBwdWJsaWMgb24oZXZlbnQ6IFwiaWNlQ2FuZGlkYXRlXCIsIGxpc3RlbmVyOiAoY2FuZGlkYXRlOiBSVENJY2VDYW5kaWRhdGUpID0+IHZvaWQpOiB0aGlzO1xuICBwdWJsaWMgb24oXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnVuaWZpZWQtc2lnbmF0dXJlc1xuICAgIGV2ZW50OlxuICAgIFwiaWNlQ29ubmVjdGlvblwiIHxcbiAgICBcImljZUNvbm5lY3Rpb25DaGVja2luZ1wiIHxcbiAgICBcImljZUNvbm5lY3Rpb25Db25uZWN0ZWRcIiB8XG4gICAgXCJpY2VDb25uZWN0aW9uQ29tcGxldGVkXCIgfFxuICAgIFwiaWNlQ29ubmVjdGlvbkZhaWxlZFwiIHxcbiAgICBcImljZUNvbm5lY3Rpb25EaXNjb25uZWN0ZWRcIiB8XG4gICAgXCJpY2VDb25lY3Rpb25DbG9zZWRcIixcbiAgICBsaXN0ZW5lcjogKHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI6IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpID0+IHZvaWRcbiAgKTogdGhpcztcbiAgcHVibGljIG9uKFxuICAgIGV2ZW50OiBcImljZUdhdGhlcmluZ1wiIHwgXCJpY2VHYXRoZXJpbmdDb21wbGV0ZVwiLFxuICAgIGxpc3RlbmVyOiAoc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcjogU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclxuICApID0+IHZvaWQpOiB0aGlzO1xuXG4gIHB1YmxpYyBvbihldmVudDogXCJ1c2VyTWVkaWFSZXF1ZXN0XCIsIGxpc3RlbmVyOiAoY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpID0+IHZvaWQpOiB0aGlzO1xuICBwdWJsaWMgb24oZXZlbnQ6IFwidXNlck1lZGlhXCIsIGxpc3RlbmVyOiAoc3RyZWFtczogTWVkaWFTdHJlYW0pID0+IHZvaWQpOiB0aGlzO1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dW5pZmllZC1zaWduYXR1cmVzXG4gIHB1YmxpYyBvbihldmVudDogXCJ1c2VyTWVkaWFGYWlsZWRcIiwgbGlzdGVuZXI6IChlcnJvcjogYW55KSA9PiB2b2lkKTogdGhpcztcbiAgcHVibGljIG9uKG5hbWU6IHN0cmluZywgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHRoaXMgIHsgcmV0dXJuIHN1cGVyLm9uKG5hbWUsIGNhbGxiYWNrKTsgfVxuXG4gIHByb3RlY3RlZCBnZXRNZWRpYVN0cmVhbShjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8TWVkaWFTdHJlYW0+IHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb25zXG4gIHByaXZhdGUgY3JlYXRlT2ZmZXJPckFuc3dlcihcbiAgICBSVENPZmZlck9wdGlvbnM6IGFueSA9IHt9LFxuICAgIG1vZGlmaWVyczogQXJyYXk8U2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyPiA9IFtdXG4gICk6IFByb21pc2U8UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdD4ge1xuICAgIGNvbnN0IG1ldGhvZE5hbWU6IHN0cmluZyA9IHRoaXMuaGFzT2ZmZXIoXCJyZW1vdGVcIikgPyBcImNyZWF0ZUFuc3dlclwiIDogXCJjcmVhdGVPZmZlclwiO1xuICAgIGNvbnN0IHBjID0gdGhpcy5wZWVyQ29ubmVjdGlvbjtcblxuICAgIHRoaXMubG9nZ2VyLmxvZyhtZXRob2ROYW1lKTtcbiAgICBjb25zdCBtZXRob2QgPSB0aGlzLmhhc09mZmVyKFwicmVtb3RlXCIpID8gcGMuY3JlYXRlQW5zd2VyIDogcGMuY3JlYXRlT2ZmZXI7XG5cbiAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHBjLCBSVENPZmZlck9wdGlvbnMpLmNhdGNoKChlOiBhbnkpID0+IHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBsZXQgbWVzc2FnZSA9IFwicGVlckNvbm5lY3Rpb24tXCIgKyBtZXRob2ROYW1lICsgXCIgZmFpbGVkLlwiO1xuICAgICAgaWYgKGUubmFtZSkge1xuICAgICAgICBtZXNzYWdlICs9IFwiIFwiICsgZS5uYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGUubWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlICs9IFwiIFwiICsgZS5tZXNzYWdlO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLmVtaXQoXCJwZWVyQ29ubmVjdGlvbi1cIiArIG1ldGhvZE5hbWUgKyBcIkZhaWxlZFwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KS50aGVuKChzZHA6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpID0+XG4gICAgICByZWR1Y2VQcm9taXNlcyhtb2RpZmllcnMsIHRoaXMuY3JlYXRlUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdChzZHApKVxuICAgICkudGhlbigoc2RwOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KSA9PiB7XG4gICAgICB0aGlzLnJlc2V0SWNlR2F0aGVyaW5nQ29tcGxldGUoKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNldHRpbmcgbG9jYWwgc2RwLlwiKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInNkcCBpcyBcIiArIHNkcC5zZHAgfHwgXCJ1bmRlZmluZWRcIik7XG4gICAgICByZXR1cm4gcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihzZHApO1xuICAgIH0pLmNhdGNoKChlOiBhbnkpID0+IHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBsZXQgbWVzc2FnZSA9IFwicGVlckNvbm5lY3Rpb24tXCIgKyBtZXRob2ROYW1lICsgXCIgZmFpbGVkLlwiO1xuICAgICAgaWYgKGUubmFtZSkge1xuICAgICAgICBtZXNzYWdlICs9IFwiIFwiICsgZS5uYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGUubWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlICs9IFwiIFwiICsgZS5tZXNzYWdlO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLmVtaXQoXCJwZWVyQ29ubmVjdGlvbi1TZXRMb2NhbERlc2NyaXB0aW9uRmFpbGVkXCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pLnRoZW4oKCkgPT4gdGhpcy53YWl0Rm9ySWNlR2F0aGVyaW5nQ29tcGxldGUoKSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKFwiTWlzc2luZyBsb2NhbCBkZXNjcmlwdGlvbi5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2NhbERlc2NyaXB0aW9uOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0ID1cbiAgICAgICAgdGhpcy5jcmVhdGVSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KHRoaXMucGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbik7XG4gICAgICByZXR1cm4gcmVkdWNlUHJvbWlzZXMobW9kaWZpZXJzLCBsb2NhbERlc2NyaXB0aW9uKTtcbiAgICB9KS50aGVuKChsb2NhbERlc2NyaXB0aW9uOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KSA9PiB7XG4gICAgICB0aGlzLnNldERpcmVjdGlvbihsb2NhbERlc2NyaXB0aW9uLnNkcCB8fCBcIlwiKTtcbiAgICAgIHJldHVybiBsb2NhbERlc2NyaXB0aW9uO1xuICAgIH0pLmNhdGNoKChlOiBhbnkpID0+IHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBsZXQgbWVzc2FnZSA9IFwiRXJyb3IuXCI7XG4gICAgICBpZiAoZS5uYW1lKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgXCIgKyBlLm5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoZS5tZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgXCIgKyBlLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhbiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0IGZyb20gYW4gUlRDU2Vzc2lvbkRlc2NyaXB0aW9uXG4gIHByaXZhdGUgY3JlYXRlUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdChcbiAgICBSVENTZXNzaW9uRGVzY3JpcHRpb246IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXRcbiAgKTogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwOiBSVENTZXNzaW9uRGVzY3JpcHRpb24uc2RwXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkRGVmYXVsdEljZUNoZWNraW5nVGltZW91dChwZWVyQ29ubmVjdGlvbk9wdGlvbnM6IFBlZXJDb25uZWN0aW9uT3B0aW9ucyk6IFBlZXJDb25uZWN0aW9uT3B0aW9ucyB7XG4gICAgaWYgKHBlZXJDb25uZWN0aW9uT3B0aW9ucy5pY2VDaGVja2luZ1RpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGVlckNvbm5lY3Rpb25PcHRpb25zLmljZUNoZWNraW5nVGltZW91dCA9IDUwMDA7XG4gICAgfVxuICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbk9wdGlvbnM7XG4gIH1cblxuICBwcml2YXRlIGFkZERlZmF1bHRJY2VTZXJ2ZXJzKHJ0Y0NvbmZpZ3VyYXRpb246IFJUQ0NvbmZpZ3VyYXRpb24pOiBSVENDb25maWd1cmF0aW9uIHtcbiAgICBpZiAoIXJ0Y0NvbmZpZ3VyYXRpb24uaWNlU2VydmVycykge1xuICAgICAgcnRjQ29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gW3t1cmxzOiBcInN0dW46c3R1bi5sLmdvb2dsZS5jb206MTkzMDJcIn1dO1xuICAgIH1cbiAgICByZXR1cm4gcnRjQ29uZmlndXJhdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tBbmREZWZhdWx0Q29uc3RyYWludHMoY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzIHtcbiAgICBjb25zdCBkZWZhdWx0Q29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7YXVkaW86IHRydWUsIHZpZGVvOiAhdGhpcy5vcHRpb25zLmFsd2F5c0FjcXVpcmVNZWRpYUZpcnN0fTtcblxuICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMgfHwgZGVmYXVsdENvbnN0cmFpbnRzO1xuICAgIC8vIEVtcHR5IG9iamVjdCBjaGVja1xuICAgIGlmIChPYmplY3Qua2V5cyhjb25zdHJhaW50cykubGVuZ3RoID09PSAwICYmIGNvbnN0cmFpbnRzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0Q29uc3RyYWludHM7XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgfVxuXG4gIHByaXZhdGUgaGFzQnJvd3NlclRyYWNrU3VwcG9ydCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnBlZXJDb25uZWN0aW9uLmFkZFRyYWNrKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFzQnJvd3NlckdldFNlbmRlclN1cHBvcnQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdFBlZXJDb25uZWN0aW9uKG9wdGlvbnM6IFBlZXJDb25uZWN0aW9uT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgb3B0aW9ucyA9IHRoaXMuYWRkRGVmYXVsdEljZUNoZWNraW5nVGltZW91dChvcHRpb25zKTtcbiAgICBvcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb24gPSBvcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb24gfHwge307XG4gICAgb3B0aW9ucy5ydGNDb25maWd1cmF0aW9uID0gdGhpcy5hZGREZWZhdWx0SWNlU2VydmVycyhvcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb24pO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKFwiaW5pdFBlZXJDb25uZWN0aW9uXCIpO1xuXG4gICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkFscmVhZHkgaGF2ZSBhIHBlZXIgY29ubmVjdGlvbiBmb3IgdGhpcyBzZXNzaW9uLiBUZWFyaW5nIGRvd24uXCIpO1xuICAgICAgdGhpcy5yZXNldEljZUdhdGhlcmluZ0NvbXBsZXRlKCk7XG4gICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbiA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihvcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb24pO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKFwiTmV3IHBlZXIgY29ubmVjdGlvbiBjcmVhdGVkXCIpO1xuXG4gICAgaWYgKFwib250cmFja1wiIGluIHRoaXMucGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcInRyYWNrXCIsIChlOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwidHJhY2sgYWRkZWRcIik7XG4gICAgICAgIHRoaXMuZW1pdChcImFkZFRyYWNrXCIsIGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVc2luZyBvbmFkZHN0cmVhbSB3aGljaCBpcyBkZXByZWNhdGVkXCIpO1xuICAgICAgKHRoaXMucGVlckNvbm5lY3Rpb24gYXMgYW55KS5vbmFkZHN0cmVhbSA9IChlOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwic3RyZWFtIGFkZGVkXCIpO1xuICAgICAgICB0aGlzLmVtaXQoXCJhZGRTdHJlYW1cIiwgZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoZTogYW55KSA9PiB7XG4gICAgICB0aGlzLmVtaXQoXCJpY2VDYW5kaWRhdGVcIiwgZSk7XG4gICAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSUNFIGNhbmRpZGF0ZSByZWNlaXZlZDogXCIgK1xuICAgICAgICAgIChlLmNhbmRpZGF0ZS5jYW5kaWRhdGUgPT09IG51bGwgPyBudWxsIDogZS5jYW5kaWRhdGUuY2FuZGlkYXRlLnRyaW0oKSkpO1xuICAgICAgfSBlbHNlIGlmIChlLmNhbmRpZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBpbmRpY2F0ZXMgdGhlIGVuZCBvZiBjYW5kaWRhdGUgZ2F0aGVyaW5nXG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklDRSBjYW5kaWRhdGUgZ2F0aGVyaW5nIGNvbXBsZXRlXCIpO1xuICAgICAgICB0aGlzLnRyaWdnZXJJY2VHYXRoZXJpbmdDb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJSVENJY2VHYXRoZXJpbmdTdGF0ZSBjaGFuZ2VkOiBcIiArIHRoaXMucGVlckNvbm5lY3Rpb24uaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgc3dpdGNoICh0aGlzLnBlZXJDb25uZWN0aW9uLmljZUdhdGhlcmluZ1N0YXRlKSB7XG4gICAgICBjYXNlIFwiZ2F0aGVyaW5nXCI6XG4gICAgICAgIHRoaXMuZW1pdChcImljZUdhdGhlcmluZ1wiLCB0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmljZUdhdGhlcmluZ1RpbWVyICYmIG9wdGlvbnMuaWNlQ2hlY2tpbmdUaW1lb3V0KSB7XG4gICAgICAgICAgdGhpcy5pY2VHYXRoZXJpbmdUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5pY2VHYXRoZXJpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiUlRDSWNlQ2hlY2tpbmcgVGltZW91dCBUcmlnZ2VyZWQgYWZ0ZXIgXCIgKyBvcHRpb25zLmljZUNoZWNraW5nVGltZW91dCArIFwiIG1pbGxpc2Vjb25kc1wiKTtcbiAgICAgICAgICAgIHRoaXMuaWNlR2F0aGVyaW5nVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJJY2VHYXRoZXJpbmdDb21wbGV0ZSgpO1xuICAgICAgICAgIH0sIG9wdGlvbnMuaWNlQ2hlY2tpbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb21wbGV0ZVwiOlxuICAgICAgICB0aGlzLnRyaWdnZXJJY2VHYXRoZXJpbmdDb21wbGV0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGxldCBzdGF0ZUV2ZW50OiBzdHJpbmc7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgY2FzZSBcIm5ld1wiOlxuICAgICAgICAgIHN0YXRlRXZlbnQgPSBcImljZUNvbm5lY3Rpb25cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNoZWNraW5nXCI6XG4gICAgICAgICAgc3RhdGVFdmVudCA9IFwiaWNlQ29ubmVjdGlvbkNoZWNraW5nXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb25uZWN0ZWRcIjpcbiAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uQ29ubmVjdGVkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb21wbGV0ZWRcIjpcbiAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uQ29tcGxldGVkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uRmFpbGVkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjbG9zZWRcIjpcbiAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uQ2xvc2VkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlVua25vd24gaWNlQ29ubmVjdGlvbiBzdGF0ZTogXCIgKyB0aGlzLnBlZXJDb25uZWN0aW9uLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSUNFIENvbm5lY3Rpb24gU3RhdGUgY2hhbmdlZCB0byBcIiArIHN0YXRlRXZlbnQpO1xuICAgICAgdGhpcy5lbWl0KHN0YXRlRXZlbnQsIHRoaXMpO1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFjcXVpcmUoY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBEZWZhdWx0IGF1ZGlvICYgdmlkZW8gdG8gdHJ1ZVxuICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jaGVja0FuZERlZmF1bHRDb25zdHJhaW50cyhjb25zdHJhaW50cyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8TWVkaWFTdHJlYW0gfCBBcnJheTxNZWRpYVN0cmVhbT4+ICgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvKlxuICAgICAgICogTWFrZSB0aGUgY2FsbCBhc3luY2hyb25vdXMsIHNvIHRoYXQgSUNDcyBoYXZlIGEgY2hhbmNlXG4gICAgICAgKiB0byBkZWZpbmUgY2FsbGJhY2tzIHRvIGB1c2VyTWVkaWFSZXF1ZXN0YFxuICAgICAgICovXG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJhY3F1aXJpbmcgbG9jYWwgbWVkaWFcIik7XG4gICAgICB0aGlzLmVtaXQoXCJ1c2VyTWVkaWFSZXF1ZXN0XCIsIGNvbnN0cmFpbnRzKTtcblxuICAgICAgaWYgKGNvbnN0cmFpbnRzLmF1ZGlvIHx8IGNvbnN0cmFpbnRzLnZpZGVvKSB7XG4gICAgICAgIHRoaXMuZ2V0TWVkaWFTdHJlYW0oY29uc3RyYWludHMpLnRoZW4oKHN0cmVhbXMpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJhZGRUcmFja1wiKTtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJ1c2VyTWVkaWFcIiwgc3RyZWFtcyk7XG4gICAgICAgICAgcmVzb2x2ZShzdHJlYW1zKTtcbiAgICAgICAgfSkuY2F0Y2goKGU6IGFueSkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdChcInVzZXJNZWRpYUZhaWxlZFwiLCBlKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtcyB3ZXJlIGV4cGxpY2l0bHkgZXhjbHVkZWQuXG4gICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKChlOiBhbnkgLyogRE9NRXhjZXB0aW9uICovKSA9PiB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgbGV0IG1lc3NhZ2UgPSBcIlVuYWJsZSB0byBhY3F1aXJlIHN0cmVhbXMuXCI7XG4gICAgICBpZiAoZS5uYW1lKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgXCIgKyBlLm5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoZS5tZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgXCIgKyBlLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pLnRoZW4oKHN0cmVhbXM6IE1lZGlhU3RyZWFtIHwgQXJyYXk8TWVkaWFTdHJlYW0+KSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJhY3F1aXJlZCBsb2NhbCBtZWRpYSBzdHJlYW1zXCIpO1xuICAgICAgLy8gUmVtb3ZlIG9sZCB0cmFja3NcbiAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uLnJlbW92ZVRyYWNrKSB7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0U2VuZGVycygpLmZvckVhY2goKHNlbmRlcjogUlRDUnRwU2VuZGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJlYW1zO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgbGV0IG1lc3NhZ2UgPSBcIkVycm9yIHJlbW92aW5nIHN0cmVhbXMuXCI7XG4gICAgICBpZiAoZS5uYW1lKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgXCIgKyBlLm5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoZS5tZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgXCIgKyBlLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pLnRoZW4oKHN0cmVhbXM6IE1lZGlhU3RyZWFtIHwgQXJyYXk8TWVkaWFTdHJlYW0+KSA9PiB7XG4gICAgICBjb25zdCBzdHJlYW1zQXJyID0gKFtdIGFzIEFycmF5PE1lZGlhU3RyZWFtPikuY29uY2F0KHN0cmVhbXMpO1xuICAgICAgc3RyZWFtc0Fyci5mb3JFYWNoKChzdHJlYW06IE1lZGlhU3RyZWFtKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uLmFkZFRyYWNrKSB7XG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENocm9tZSA1OSBkb2VzIG5vdCBzdXBwb3J0IGFkZFRyYWNrXG4gICAgICAgICAgKHRoaXMucGVlckNvbm5lY3Rpb24gYXMgYW55KS5hZGRTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBsZXQgbWVzc2FnZSA9IFwiRXJyb3IgYWRkaW5nIHN0cmVhbXMuXCI7XG4gICAgICBpZiAoZS5uYW1lKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgXCIgKyBlLm5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoZS5tZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgXCIgKyBlLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBoYXNPZmZlcih3aGVyZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgb2ZmZXJTdGF0ZTogc3RyaW5nID0gXCJoYXZlLVwiICsgd2hlcmUgKyBcIi1vZmZlclwiO1xuICAgIHJldHVybiB0aGlzLnBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSBvZmZlclN0YXRlO1xuICB9XG5cbiAgLy8gSUNFIGdhdGhlcmluZyBzdGF0ZSBoYW5kbGluZ1xuICBwcml2YXRlIGlzSWNlR2F0aGVyaW5nQ29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucGVlckNvbm5lY3Rpb24uaWNlR2F0aGVyaW5nU3RhdGUgPT09IFwiY29tcGxldGVcIiB8fCB0aGlzLmljZUdhdGhlcmluZ1RpbWVvdXQ7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0SWNlR2F0aGVyaW5nQ29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5pY2VHYXRoZXJpbmdUaW1lb3V0ID0gZmFsc2U7XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coXCJyZXNldEljZUdhdGhlcmluZ0NvbXBsZXRlXCIpO1xuXG4gICAgaWYgKHRoaXMuaWNlR2F0aGVyaW5nVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmljZUdhdGhlcmluZ1RpbWVyKTtcbiAgICAgIHRoaXMuaWNlR2F0aGVyaW5nVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQpIHtcbiAgICAgIHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICB0aGlzLmljZUdhdGhlcmluZ0RlZmVycmVkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0RGlyZWN0aW9uKHNkcDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgbWF0Y2ggPSBzZHAubWF0Y2goL2E9KHNlbmRyZWN2fHNlbmRvbmx5fHJlY3Zvbmx5fGluYWN0aXZlKS8pO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLkMuRElSRUNUSU9OLk5VTEw7XG4gICAgICB0aGlzLmVtaXQoXCJkaXJlY3Rpb25DaGFuZ2VkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBtYXRjaFsxXTtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSB0aGlzLkMuRElSRUNUSU9OLlNFTkRSRUNWOlxuICAgICAgY2FzZSB0aGlzLkMuRElSRUNUSU9OLlNFTkRPTkxZOlxuICAgICAgY2FzZSB0aGlzLkMuRElSRUNUSU9OLlJFQ1ZPTkxZOlxuICAgICAgY2FzZSB0aGlzLkMuRElSRUNUSU9OLklOQUNUSVZFOlxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMuQy5ESVJFQ1RJT04uTlVMTDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImRpcmVjdGlvbkNoYW5nZWRcIik7XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJJY2VHYXRoZXJpbmdDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0ljZUdhdGhlcmluZ0NvbXBsZXRlKCkpIHtcbiAgICAgIHRoaXMuZW1pdChcImljZUdhdGhlcmluZ0NvbXBsZXRlXCIsIHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5pY2VHYXRoZXJpbmdUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pY2VHYXRoZXJpbmdUaW1lcik7XG4gICAgICAgIHRoaXMuaWNlR2F0aGVyaW5nVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmljZUdhdGhlcmluZ0RlZmVycmVkKSB7XG4gICAgICAgIHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmljZUdhdGhlcmluZ0RlZmVycmVkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgd2FpdEZvckljZUdhdGhlcmluZ0NvbXBsZXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIndhaXRGb3JJY2VHYXRoZXJpbmdDb21wbGV0ZVwiKTtcbiAgICBpZiAodGhpcy5pc0ljZUdhdGhlcmluZ0NvbXBsZXRlKCkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklDRSBpcyBhbHJlYWR5IGNvbXBsZXRlLiBSZXR1cm4gcmVzb2x2ZWQuXCIpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQpIHtcbiAgICAgIHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coXCJJQ0UgaXMgbm90IGNvbXBsZXRlLiBSZXR1cm5pbmcgcHJvbWlzZVwiKTtcbiAgICByZXR1cm4gdGhpcy5pY2VHYXRoZXJpbmdEZWZlcnJlZCA/IHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQucHJvbWlzZSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG4iLCIvKipcbiAqIEEgc2ltcGxlIFNJUCB1c2VyIGltcGxlbWVudGF0aW9uIGZvciB3ZWIgYnJvd3NlcnMuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuZXhwb3J0ICogZnJvbSBcIi4vc2ltcGxlLXVzZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NpbXBsZS11c2VyLWRlbGVnYXRlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zaW1wbGUtdXNlci1vcHRpb25zXCI7XG4iLCJpbXBvcnQge1xuICBCeWVyLFxuICBJbmZvZXIsXG4gIEludml0YXRpb24sXG4gIEludml0YXRpb25BY2NlcHRPcHRpb25zLFxuICBJbnZpdGVyLFxuICBJbnZpdGVySW52aXRlT3B0aW9ucyxcbiAgSW52aXRlck9wdGlvbnMsXG4gIE1lc3NhZ2UsXG4gIE1lc3NhZ2VyLFxuICBSZWZlcnJhbCxcbiAgUmVnaXN0ZXJlcixcbiAgUmVnaXN0ZXJlck9wdGlvbnMsXG4gIFJlZ2lzdGVyZXJSZWdpc3Rlck9wdGlvbnMsXG4gIFJlZ2lzdGVyZXJTdGF0ZSxcbiAgUmVnaXN0ZXJlclVucmVnaXN0ZXJPcHRpb25zLFxuICBSZXF1ZXN0UGVuZGluZ0Vycm9yLFxuICBTZXNzaW9uLFxuICBTZXNzaW9uSW52aXRlT3B0aW9ucyxcbiAgU2Vzc2lvblN0YXRlLFxuICBVc2VyQWdlbnQsXG4gIFVzZXJBZ2VudE9wdGlvbnMsXG4gIFVzZXJBZ2VudFN0YXRlXG59IGZyb20gXCIuLi8uLi8uLi9hcGlcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi8uLi8uLi9jb3JlXCI7XG5pbXBvcnQgeyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIH0gZnJvbSBcIi4uL3Nlc3Npb24tZGVzY3JpcHRpb24taGFuZGxlclwiO1xuaW1wb3J0IHsgVHJhbnNwb3J0IH0gZnJvbSBcIi4uL3RyYW5zcG9ydFwiO1xuaW1wb3J0IHsgU2ltcGxlVXNlckRlbGVnYXRlIH0gZnJvbSBcIi4vc2ltcGxlLXVzZXItZGVsZWdhdGVcIjtcbmltcG9ydCB7IFNpbXBsZVVzZXJPcHRpb25zIH0gZnJvbSBcIi4vc2ltcGxlLXVzZXItb3B0aW9uc1wiO1xuXG4vKipcbiAqIEEgc2ltcGxlIFNJUCB1c2VyIGNsYXNzLlxuICogQHJlbWFya3NcbiAqIFdoaWxlIHRoaXMgY2xhc3MgaXMgY29tcGxldGVseSBmdW5jdGlvbmFsIGZvciBzaW1wbGUgdXNlIGNhc2VzLCBpdCBpcyBub3QgaW50ZW5kZWRcbiAqIHRvIHByb3ZpZGUgYW4gaW50ZXJmYWNlIHdoaWNoIGlzIHN1aXRhYmxlIGZvciBtb3N0IChtdXN0IGxlc3MgYWxsKSBhcHBsaWNhdGlvbnMuXG4gKiBXaGlsZSB0aGlzIGNsYXNzIGhhcyBtYW55IGxpbWl0YXRpb25zIChmb3IgZXhhbXBsZSwgaXQgb25seSBoYW5kbGVzIGEgc2luZ2xlIGNvbmN1cnJlbnQgc2Vzc2lvbiksXG4gKiBpdCBpcywgaG93ZXZlciwgaW50ZW5kZWQgdG8gc2VydmUgYXMgYSBzaW1wbGUgZXhhbXBsZSBvZiB1c2luZyB0aGUgU0lQLmpzIEFQSS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXBsZVVzZXIge1xuICAvKiogRGVsZWdhdGUuICovXG4gIHB1YmxpYyBkZWxlZ2F0ZTogU2ltcGxlVXNlckRlbGVnYXRlIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgYXR0ZW1wdGluZ1JlY29ubmVjdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGNvbm5lY3RSZXF1ZXN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcbiAgcHJpdmF0ZSBoZWxkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgb3B0aW9uczogU2ltcGxlVXNlck9wdGlvbnM7XG4gIHByaXZhdGUgcmVnaXN0ZXJlcjogUmVnaXN0ZXJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSByZWdpc3RlclJlcXVlc3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHNlc3Npb246IFNlc3Npb24gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIHByaXZhdGUgdXNlckFnZW50OiBVc2VyQWdlbnQ7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBTaW1wbGVVc2VyYCBjbGFzcy5cbiAgICogQHBhcmFtIHNlcnZlciAtIFNJUCBXZWJTb2NrZXQgU2VydmVyIFVSTC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC4gU2VlIHtAbGluayBTaW1wbGVVc2VyT3B0aW9uc30gZm9yIGRldGFpbHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZXJ2ZXI6IHN0cmluZywgb3B0aW9uczogU2ltcGxlVXNlck9wdGlvbnMgPSB7fSkge1xuICAgIC8vIERlbGVnYXRlXG4gICAgdGhpcy5kZWxlZ2F0ZSA9IG9wdGlvbnMuZGVsZWdhdGU7XG5cbiAgICAvLyBDb3B5IG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIC8vIFVzZXJBZ2VudE9wdGlvbnNcbiAgICBjb25zdCB1c2VyQWdlbnRPcHRpb25zOiBVc2VyQWdlbnRPcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucy51c2VyQWdlbnRPcHRpb25zXG4gICAgfTtcblxuICAgIC8vIFRyYW5zcG9ydFxuICAgIGlmICAoIXVzZXJBZ2VudE9wdGlvbnMudHJhbnNwb3J0Q29uc3RydWN0b3IpIHtcbiAgICAgIHVzZXJBZ2VudE9wdGlvbnMudHJhbnNwb3J0Q29uc3RydWN0b3IgPSBUcmFuc3BvcnQ7XG4gICAgfVxuXG4gICAgLy8gVHJhbnNwb3J0T3B0aW9uc1xuICAgIGlmICghdXNlckFnZW50T3B0aW9ucy50cmFuc3BvcnRPcHRpb25zKSB7XG4gICAgICB1c2VyQWdlbnRPcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgPSB7XG4gICAgICAgIHNlcnZlclxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBVUklcbiAgICBpZiAoIXVzZXJBZ2VudE9wdGlvbnMudXJpKSB7XG4gICAgICAvLyBJZiBhbiBBT1Igd2FzIHByb3ZpZGVkLCBjb252ZXJ0IGl0IHRvIGEgVVJJXG4gICAgICBpZiAob3B0aW9ucy5hb3IpIHtcbiAgICAgICAgY29uc3QgdXJpID0gVXNlckFnZW50Lm1ha2VVUkkob3B0aW9ucy5hb3IpO1xuICAgICAgICBpZiAoIXVyaSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSB2YWxpZCBVUkkgZnJvbSAke29wdGlvbnMuYW9yfWApO1xuICAgICAgICB9XG4gICAgICAgIHVzZXJBZ2VudE9wdGlvbnMudXJpID0gdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVzZXJBZ2VudFxuICAgIHRoaXMudXNlckFnZW50ID0gbmV3IFVzZXJBZ2VudCh1c2VyQWdlbnRPcHRpb25zKTtcblxuICAgIC8vIFVzZXJBZ2VudCdzIGRlbGVnYXRlXG4gICAgdGhpcy51c2VyQWdlbnQuZGVsZWdhdGUgPSB7XG4gICAgICAvLyBIYW5kbGUgY29ubmVjdGlvbiB3aXRoIHNlcnZlciBlc3RhYmxpc2hlZFxuICAgICAgb25Db25uZWN0OiAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIENvbm5lY3RlZGApO1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uU2VydmVyQ29ubmVjdCkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25TZXJ2ZXJDb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlciAmJiB0aGlzLnJlZ2lzdGVyUmVxdWVzdGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gUmVnaXN0ZXJpbmcuLi5gKTtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyZXIucmVnaXN0ZXIoKVxuICAgICAgICAgICAgLmNhdGNoKChlOiBFcnJvcikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgWyR7dGhpcy5pZH1dIEFuIGVycm9yIG9jY3VyZWQgcmVnaXN0ZXJpbmcgYWZ0ZXIgY29ubmVjdGlvbiB3aXRoIHNlcnZlciB3YXMgb2J0YWluZWQuYCk7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEhhbmRsZSBjb25uZWN0aW9uIHdpdGggc2VydmVyIGxvc3RcbiAgICAgIG9uRGlzY29ubmVjdDogKGVycm9yPzogRXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gRGlzY29ubmVjdGVkYCk7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25TZXJ2ZXJEaXNjb25uZWN0KSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblNlcnZlckRpc2Nvbm5lY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBIYW5naW5nIHVwLi4uYCk7XG4gICAgICAgICAgdGhpcy5oYW5ndXAoKSAvLyB3aWxsIGxpa2VseSBmYWlsLCBidXQgbmVlZCB0byBjbGVhbnVwIGh1bmcgY2FsbHNcbiAgICAgICAgICAgIC5jYXRjaCgoZTogRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYFske3RoaXMuaWR9XSBBbiBlcnJvciBvY2N1cmVkIGhhbmdpbmcgdXAgY2FsbCBhZnRlciBjb25uZWN0aW9uIHdpdGggc2VydmVyIHdhcyBsb3N0LmApO1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIFVucmVnaXN0ZXJpbmcuLi5gKTtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyZXIudW5yZWdpc3RlcigpIC8vIHdpbGwgbGlrZWx5IGZhaWwsIGJ1dCBuZWVkIHRvIGNsZWFudXAgaW52YWxpZCByZWdpc3RyYXRpb25zXG4gICAgICAgICAgICAuY2F0Y2goKGU6IEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBbJHt0aGlzLmlkfV0gQW4gZXJyb3Igb2NjdXJlZCB1bnJlZ2lzdGVyaW5nIGFmdGVyIGNvbm5lY3Rpb24gd2l0aCBzZXJ2ZXIgd2FzIGxvc3QuYCk7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGF0dGVtcHQgdG8gcmVjb25uZWN0IGlmIG5ldHdvcmsvc2VydmVyIGRyb3BwZWQgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gSGFuZGxlIGluY29taW5nIGludml0YXRpb25zXG4gICAgICBvbkludml0ZTogKGludml0YXRpb246IEludml0YXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gUmVjZWl2ZWQgSU5WSVRFYCk7XG5cbiAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCBhIHByZS1leGlzdGluZyBzZXNzaW9uLiBUaGlzIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgb25lIHNlc3Npb24gYXQgYSB0aW1lLlxuICAgICAgICAvLyBIb3dldmVyIGFuIGluY29taW5nIElOVklURSByZXF1ZXN0IG1heSBiZSByZWNlaXZlZCBhdCBhbnkgdGltZSBhbmQvb3Igd2hpbGUgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgLy8gb2Ygc2VuZGluZyBhbiBvdXRnb2luZyBJTlZJVEUgcmVxdWVzdC4gU28gd2UgcmVqZWN0IGFueSBpbmNvbWluZyBJTlZJVEUgaW4gdGhvc2UgY2FzZXMuXG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBbJHt0aGlzLmlkfV0gU2Vzc2lvbiBhbHJlYWR5IGluIHByb2dyZXNzLCByZWplY3RpbmcgSU5WSVRFLi4uYCk7XG4gICAgICAgICAgaW52aXRhdGlvbi5yZWplY3QoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBSZWplY3RlZCBJTlZJVEVgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgWyR7dGhpcy5pZH1dIEZhaWxlZCB0byByZWplY3QgSU5WSVRFYCk7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIG91ciBjb25maWd1cmVkIGNvbnN0cmFpbnRzIGFzIG9wdGlvbnMgZm9yIGFueSBJbnZpdGVyIGNyZWF0ZWQgYXMgcmVzdWx0IG9mIGEgUkVGRVJcbiAgICAgICAgY29uc3QgcmVmZXJyYWxJbnZpdGVyT3B0aW9uczogSW52aXRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM6IHsgY29uc3RyYWludHM6IHRoaXMuY29uc3RyYWludHMgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgb3VyIHNlc3Npb25cbiAgICAgICAgdGhpcy5pbml0U2Vzc2lvbihpbnZpdGF0aW9uLCByZWZlcnJhbEludml0ZXJPcHRpb25zKTtcblxuICAgICAgICAvLyBEZWxlZ2F0ZVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uQ2FsbFJlY2VpdmVkKSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkNhbGxSZWNlaXZlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYFske3RoaXMuaWR9XSBObyBoYW5kbGVyIGF2YWlsYWJsZSwgcmVqZWN0aW5nIElOVklURS4uLmApO1xuICAgICAgICAgIGludml0YXRpb24ucmVqZWN0KClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gUmVqZWN0ZWQgSU5WSVRFYCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYFske3RoaXMuaWR9XSBGYWlsZWQgdG8gcmVqZWN0IElOVklURWApO1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gSGFuZGxlIGluY29taW5nIG1lc3NhZ2VzXG4gICAgICBvbk1lc3NhZ2U6IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB7XG4gICAgICAgIG1lc3NhZ2UuYWNjZXB0KClcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uTWVzc2FnZVJlY2VpdmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25NZXNzYWdlUmVjZWl2ZWQobWVzc2FnZS5yZXF1ZXN0LmJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBVc2UgdGhlIFNJUC5qcyBsb2dnZXJcbiAgICB0aGlzLmxvZ2dlciA9IHRoaXMudXNlckFnZW50LmdldExvZ2dlcihcInNpcC5TaW1wbGVVc2VyXCIpO1xuXG4gICAgLy8gTW9uaXRvciBuZXR3b3JrIGNvbm5lY3Rpdml0eSBhbmQgYXR0ZW1wdCByZWNvbm5lY3Rpb24gd2hlbiB3ZSBjb21lIG9ubGluZVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsICgpID0+IHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIE9ubGluZWApO1xuICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0aW9uKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFuY2UgaWRlbnRpZmllci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKHRoaXMub3B0aW9ucy51c2VyQWdlbnRPcHRpb25zICYmIHRoaXMub3B0aW9ucy51c2VyQWdlbnRPcHRpb25zLmRpc3BsYXlOYW1lKSB8fCBcIkFub255bW91c1wiO1xuICB9XG5cbiAgLyoqIFRoZSBsb2NhbCBhdWRpbyB0cmFjaywgaWYgYXZhaWxhYmxlLiAqL1xuICBnZXQgbG9jYWxBdWRpb1RyYWNrKCk6IE1lZGlhU3RyZWFtVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmdldFNlbmRlclRyYWNrKFwiYXVkaW9cIik7XG4gIH1cblxuICAvKiogVGhlIGxvY2FsIHZpZGVvIHRyYWNrLCBpZiBhdmFpbGFibGUuICovXG4gIGdldCBsb2NhbFZpZGVvVHJhY2soKTogTWVkaWFTdHJlYW1UcmFjayB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VuZGVyVHJhY2soXCJ2aWRlb1wiKTtcbiAgfVxuXG4gIC8qKiBUaGUgcmVtb3RlIGF1ZGlvIHRyYWNrLCBpZiBhdmFpbGFibGUuICovXG4gIGdldCByZW1vdGVBdWRpb1RyYWNrKCk6IE1lZGlhU3RyZWFtVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmdldFJlY2VpdmVyVHJhY2soXCJhdWRpb1wiKTtcbiAgfVxuXG4gIC8qKiBUaGUgcmVtb3RlIHZpZGVvIHRyYWNrLCBpZiBhdmFpbGFibGUuICovXG4gIGdldCByZW1vdGVWaWRlb1RyYWNrKCk6IE1lZGlhU3RyZWFtVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmdldFJlY2VpdmVyVHJhY2soXCJ2aWRlb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0LlxuICAgKiBAcmVtYXJrc1xuICAgKiBTdGFydCB0aGUgVXNlckFnZW50J3MgV2ViU29ja2V0IFRyYW5zcG9ydC5cbiAgICovXG4gIHB1YmxpYyBjb25uZWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIENvbm5lY3RpbmcgVXNlckFnZW50Li4uYCk7XG4gICAgdGhpcy5jb25uZWN0UmVxdWVzdGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy51c2VyQWdlbnQuc3RhdGUgIT09IFVzZXJBZ2VudFN0YXRlLlN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnVzZXJBZ2VudC5zdGFydCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51c2VyQWdlbnQucmVjb25uZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdC5cbiAgICogQHJlbWFya3NcbiAgICogU3RvcCB0aGUgVXNlckFnZW50J3MgV2ViU29ja2V0IFRyYW5zcG9ydC5cbiAgICovXG4gIHB1YmxpYyBkaXNjb25uZWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIERpc2Nvbm5lY3RpbmcgVXNlckFnZW50Li4uYCk7XG4gICAgdGhpcy5jb25uZWN0UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMudXNlckFnZW50LnN0b3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBjb25uZWN0ZWQuXG4gICAqL1xuICBwdWJsaWMgaXNDb25uZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudXNlckFnZW50LmlzQ29ubmVjdGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcmVjZWl2aW5nIGluY29taW5nIGNhbGxzLlxuICAgKiBAcmVtYXJrc1xuICAgKiBTZW5kIGEgUkVHSVNURVIgcmVxdWVzdCBmb3IgdGhlIFVzZXJBZ2VudCdzIEFPUi5cbiAgICogUmVzb2x2ZXMgd2hlbiB0aGUgUkVHSVNURVIgcmVxdWVzdCBpcyBzZW50LCBvdGhlcndpc2UgcmVqZWN0cy5cbiAgICovXG4gIHB1YmxpYyByZWdpc3RlcihcbiAgICByZWdpc3RlcmVyT3B0aW9ucz86IFJlZ2lzdGVyZXJPcHRpb25zLFxuICAgIHJlZ2lzdGVyZXJSZWdpc3Rlck9wdGlvbnM/OiBSZWdpc3RlcmVyUmVnaXN0ZXJPcHRpb25zXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIFJlZ2lzdGVyaW5nIFVzZXJBZ2VudC4uLmApO1xuICAgIHRoaXMucmVnaXN0ZXJSZXF1ZXN0ZWQgPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLnJlZ2lzdGVyZXIpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlciA9IG5ldyBSZWdpc3RlcmVyKHRoaXMudXNlckFnZW50LCByZWdpc3RlcmVyT3B0aW9ucyk7XG4gICAgICB0aGlzLnJlZ2lzdGVyZXIuc3RhdGVDaGFuZ2UuYWRkTGlzdGVuZXIoKHN0YXRlOiBSZWdpc3RlcmVyU3RhdGUpID0+IHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgIGNhc2UgUmVnaXN0ZXJlclN0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJlZ2lzdGVyZXJTdGF0ZS5SZWdpc3RlcmVkOlxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZ2lzdGVyZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUmVnaXN0ZXJlclN0YXRlLlVucmVnaXN0ZXJlZDpcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25VbnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblVucmVnaXN0ZXJlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSZWdpc3RlcmVyU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHJlZ2lzdGVyZXIgc3RhdGUuXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVyLnJlZ2lzdGVyKHJlZ2lzdGVyZXJSZWdpc3Rlck9wdGlvbnMpXG4gICAgICAudGhlbigoKSA9PiB7IHJldHVybjsgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCByZWNlaXZpbmcgaW5jb21pbmcgY2FsbHMuXG4gICAqIEByZW1hcmtzXG4gICAqIFNlbmQgYW4gdW4tUkVHSVNURVIgcmVxdWVzdCBmb3IgdGhlIFVzZXJBZ2VudCdzIEFPUi5cbiAgICogUmVzb2x2ZXMgd2hlbiB0aGUgdW4tUkVHSVNURVIgcmVxdWVzdCBpcyBzZW50LCBvdGhlcndpc2UgcmVqZWN0cy5cbiAgICovXG4gIHB1YmxpYyB1bnJlZ2lzdGVyKFxuICAgIHJlZ2lzdGVyZXJVbnJlZ2lzdGVyT3B0aW9ucz86IFJlZ2lzdGVyZXJVbnJlZ2lzdGVyT3B0aW9uc1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBVbnJlZ2lzdGVyaW5nIFVzZXJBZ2VudC4uLmApO1xuICAgIHRoaXMucmVnaXN0ZXJSZXF1ZXN0ZWQgPSBmYWxzZTtcblxuICAgIGlmICghdGhpcy5yZWdpc3RlcmVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlci51bnJlZ2lzdGVyKHJlZ2lzdGVyZXJVbnJlZ2lzdGVyT3B0aW9ucylcbiAgICAgIC50aGVuKCgpID0+IHsgcmV0dXJuOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGFuIG91dG9pbmcgY2FsbC5cbiAgICogQHJlbWFya3NcbiAgICogU2VuZCBhbiBJTlZJVEUgcmVxdWVzdCB0byBjcmVhdGUgYSBuZXcgU2Vzc2lvbi5cbiAgICogUmVzb2x2ZXMgd2hlbiB0aGUgSU5WSVRFIHJlcXVlc3QgaXMgc2VudCwgb3RoZXJ3aXNlIHJlamVjdHMuXG4gICAqIFVzZSBgb25DYWxsQW5zd2VyZWRgIGRlbGVnYXRlIG1ldGhvZCB0byBkZXRlcm1pbmUgaWYgU2Vzc2lvbiBpcyBlc3RhYmxpc2hlZC5cbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uIC0gVGhlIHRhcmdldCBkZXN0aW5hdGlvbiB0byBjYWxsLiBBIFNJUCBhZGRyZXNzIHRvIHNlbmQgdGhlIElOVklURSB0by5cbiAgICovXG4gIHB1YmxpYyBjYWxsKFxuICAgIGRlc3RpbmF0aW9uOiBzdHJpbmcsXG4gICAgaW52aXRlck9wdGlvbnM/OiBJbnZpdGVyT3B0aW9ucyxcbiAgICBpbnZpdGVySW52aXRlT3B0aW9ucz86IEludml0ZXJJbnZpdGVPcHRpb25zXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIEJlZ2lubmluZyBTZXNzaW9uLi4uYCk7XG5cbiAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiU2Vzc2lvbiBhbHJlYWR5IGV4aXN0cy5cIikpO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IFVzZXJBZ2VudC5tYWtlVVJJKGRlc3RpbmF0aW9uKTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBhIHZhbGlkIFVSSSBmcm9tIFwiJHtkZXN0aW5hdGlvbn1cImApKTtcbiAgICB9XG5cbiAgICAvLyBVc2Ugb3VyIGNvbmZpZ3VyZWQgY29uc3RyYWludHMgYXMgSW52aXRlck9wdGlvbnMgaWYgbm9uZSBwcm92aWRlZFxuICAgIGlmICghaW52aXRlck9wdGlvbnMpIHtcbiAgICAgIGludml0ZXJPcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICghaW52aXRlck9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMpIHtcbiAgICAgIGludml0ZXJPcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICghaW52aXRlck9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMuY29uc3RyYWludHMpIHtcbiAgICAgIGludml0ZXJPcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLmNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgSW52aXRlciBmb3IgdGhlIG91dGdvaW5nIFNlc3Npb25cbiAgICBjb25zdCBpbnZpdGVyID0gbmV3IEludml0ZXIodGhpcy51c2VyQWdlbnQsIHRhcmdldCwgaW52aXRlck9wdGlvbnMpO1xuXG4gICAgLy8gU2VuZCBJTlZJVEVcbiAgICByZXR1cm4gdGhpcy5zZW5kSW52aXRlKGludml0ZXIsIGludml0ZXJPcHRpb25zLCBpbnZpdGVySW52aXRlT3B0aW9ucylcbiAgICAgIC50aGVuKCgpID0+IHsgcmV0dXJuOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5ndXAgYSBjYWxsLlxuICAgKiBAcmVtYXJrc1xuICAgKiBTZW5kIGEgQllFIHJlcXVlc3QsIENBTkNFTCByZXF1ZXN0IG9yIHJlamVjdCByZXNwb25zZSB0byBlbmQgdGhlIGN1cnJlbnQgU2Vzc2lvbi5cbiAgICogUmVzb2x2ZXMgd2hlbiB0aGUgcmVxdWVzdC9yZXNwb25zZSBpcyBzZW50LCBvdGhlcndpc2UgcmVqZWN0cy5cbiAgICogVXNlIGBvbkNhbGxUZXJtaW5hdGVkYCBkZWxlZ2F0ZSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIGFuZCB3aGVuIGNhbGwgaXMgZW5kZWQuXG4gICAqL1xuICBwdWJsaWMgaGFuZ3VwKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIEhhbmd1cC4uLmApO1xuICAgIHJldHVybiB0aGlzLnRlcm1pbmF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuc3dlciBhbiBpbmNvbWluZyBjYWxsLlxuICAgKiBAcmVtYXJrc1xuICAgKiBBY2NlcHQgYW4gaW5jb21pbmcgSU5WSVRFIHJlcXVlc3QgY3JlYXRpbmcgYSBuZXcgU2Vzc2lvbi5cbiAgICogUmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UgaXMgc2VudCwgb3RoZXJ3aXNlIHJlamVjdHMuXG4gICAqIFVzZSBgb25DYWxsQW5zd2VyZWRgIGRlbGVnYXRlIG1ldGhvZCB0byBkZXRlcm1pbmUgaWYgYW5kIHdoZW4gY2FsbCBpcyBlc3RhYmxpc2hlZC5cbiAgICovXG4gIHB1YmxpYyBhbnN3ZXIoXG4gICAgaW52aXRhdGlvbkFjY2VwdE9wdGlvbnM/OiBJbnZpdGF0aW9uQWNjZXB0T3B0aW9uc1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBBY2NlcHRpbmcgSW52aXRhdGlvbi4uLmApO1xuXG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTZXNzaW9uIGRvZXMgbm90IGV4aXN0LlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcy5zZXNzaW9uIGluc3RhbmNlb2YgSW52aXRhdGlvbikpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTZXNzaW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGF0aW9uLlwiKSk7XG4gICAgfVxuXG4gICAgLy8gVXNlIG91ciBjb25maWd1cmVkIGNvbnN0cmFpbnRzIGFzIEludml0YXRpb25BY2NlcHRPcHRpb25zIGlmIG5vbmUgcHJvdmlkZWRcbiAgICBpZiAoIWludml0YXRpb25BY2NlcHRPcHRpb25zKSB7XG4gICAgICBpbnZpdGF0aW9uQWNjZXB0T3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIWludml0YXRpb25BY2NlcHRPcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zKSB7XG4gICAgICBpbnZpdGF0aW9uQWNjZXB0T3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIWludml0YXRpb25BY2NlcHRPcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLmNvbnN0cmFpbnRzKSB7XG4gICAgICBpbnZpdGF0aW9uQWNjZXB0T3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucy5jb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5hY2NlcHQoaW52aXRhdGlvbkFjY2VwdE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY2xpbmUgYW4gaW5jb21pbmcgY2FsbC5cbiAgICogQHJlbWFya3NcbiAgICogUmVqZWN0IGFuIGluY29taW5nIElOVklURSByZXF1ZXN0LlxuICAgKiBSZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBpcyBzZW50LCBvdGhlcndpc2UgcmVqZWN0cy5cbiAgICogVXNlIGBvbkNhbGxUZXJtaW5hdGVkYCBkZWxlZ2F0ZSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIGFuZCB3aGVuIGNhbGwgaXMgZW5kZWQuXG4gICAqL1xuICBwdWJsaWMgZGVjbGluZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSByZWplY3RpbmcgSW52aXRhdGlvbi4uLmApO1xuXG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTZXNzaW9uIGRvZXMgbm90IGV4aXN0LlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcy5zZXNzaW9uIGluc3RhbmNlb2YgSW52aXRhdGlvbikpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTZXNzaW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGF0aW9uLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5yZWplY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIb2xkIGNhbGxcbiAgICogQHJlbWFya3NcbiAgICogU2VuZCBhIHJlLUlOVklURSB3aXRoIG5ldyBvZmZlciBpbmRpY2F0aW5nIFwiaG9sZFwiLlxuICAgKiBSZXNvbHZlcyB3aGVuIHRoZSByZS1JTlZJVEUgcmVxdWVzdCBpcyBzZW50LCBvdGhlcndpc2UgcmVqZWN0cy5cbiAgICogVXNlIGBvbkNhbGxIb2xkYCBkZWxlZ2F0ZSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHJlcXVlc3QgaXMgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQuXG4gICAqIFNlZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYzMzdcbiAgICovXG4gIHB1YmxpYyBob2xkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIGhvbGRpbmcgc2Vzc2lvbi4uLmApO1xuICAgIHJldHVybiB0aGlzLnNldEhvbGQodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5ob2xkIGNhbGwuXG4gICAqIEByZW1hcmtzXG4gICAqIFNlbmQgYSByZS1JTlZJVEUgd2l0aCBuZXcgb2ZmZXIgaW5kaWNhdGluZyBcInVuaG9sZFwiLlxuICAgKiBSZXNvbHZlcyB3aGVuIHRoZSByZS1JTlZJVEUgcmVxdWVzdCBpcyBzZW50LCBvdGhlcndpc2UgcmVqZWN0cy5cbiAgICogVXNlIGBvbkNhbGxIb2xkYCBkZWxlZ2F0ZSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHJlcXVlc3QgaXMgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQuXG4gICAqIFNlZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYzMzdcbiAgICovXG4gIHB1YmxpYyB1bmhvbGQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gdW5ob2xkaW5nIHNlc3Npb24uLi5gKTtcbiAgICByZXR1cm4gdGhpcy5zZXRIb2xkKGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIb2xkIHN0YXRlLlxuICAgKiBAcmVtYXJrc1xuICAgKiBUcnVlIGlmIHNlc3Npb24gbWVkaWEgaXMgb24gaG9sZC5cbiAgICovXG4gIHB1YmxpYyBpc0hlbGQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaGVsZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdXRlIGNhbGwuXG4gICAqIEByZW1hcmtzXG4gICAqIERpc2FibGUgc2VuZGVyJ3MgbWVkaWEgdHJhY2tzLlxuICAgKi9cbiAgcHVibGljIG11dGUoKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gZGlzYWJsaW5nIG1lZGlhIHRyYWNrcy4uLmApO1xuICAgIHRoaXMuc2V0TXV0ZSh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbm11dGUgY2FsbC5cbiAgICogQHJlbWFya3NcbiAgICogRW5hYmxlIHNlbmRlcidzIG1lZGlhIHRyYWNrcy5cbiAgICovXG4gIHB1YmxpYyB1bm11dGUoKTogdm9pZCB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gZW5hYmxpbmcgbWVkaWEgdHJhY2tzLi4uYCk7XG4gICAgdGhpcy5zZXRNdXRlKGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdXRlIHN0YXRlLlxuICAgKiBAcmVtYXJrc1xuICAgKiBUcnVlIGlmIHNlbmRlcidzIG1lZGlhIHRyYWNrIGlzIGRpc2FibGVkLlxuICAgKi9cbiAgcHVibGljIGlzTXV0ZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmxvY2FsQXVkaW9UcmFjayB8fCB0aGlzLmxvY2FsVmlkZW9UcmFjaztcbiAgICByZXR1cm4gdHJhY2sgPyAhdHJhY2suZW5hYmxlZCA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgRFRNRi5cbiAgICogQHJlbWFya3NcbiAgICogU2VuZCBhbiBJTkZPIHJlcXVlc3Qgd2l0aCBjb250ZW50IHR5cGUgYXBwbGljYXRpb24vZHRtZi1yZWxheS5cbiAgICogQHBhcmFtIHRvbmUgLSBUb25lIHRvIHNlbmQuXG4gICAqL1xuICBwdWJsaWMgc2VuZERUTUYodG9uZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gc2VuZGluZyBEVE1GLi4uYCk7XG5cbiAgICAvLyBWYWxpZGF0ZSB0b25lXG4gICAgaWYgKCF0b25lLm1hdGNoKC9eWzAtOUEtRCMqLF0kLykpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIERUTUYgdG9uZS5cIikpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiU2Vzc2lvbiBkb2VzIG5vdCBleGlzdC5cIikpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIFNlbmRpbmcgRFRNRiB0b25lOiAke3RvbmV9YCk7XG4gICAgY29uc3QgZHRtZiA9IHRvbmU7XG4gICAgY29uc3QgZHVyYXRpb24gPSAyMDAwO1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICBjb250ZW50RGlzcG9zaXRpb246IFwicmVuZGVyXCIsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9kdG1mLXJlbGF5XCIsXG4gICAgICBjb250ZW50OiBcIlNpZ25hbD1cIiArIGR0bWYgKyBcIlxcclxcbkR1cmF0aW9uPVwiICsgZHVyYXRpb25cbiAgICB9O1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0geyBib2R5IH07XG5cbiAgICByZXR1cm4gbmV3IEluZm9lcih0aGlzLnNlc3Npb24pLmluZm8oeyByZXF1ZXN0T3B0aW9ucyB9KVxuICAgICAgLnRoZW4oKCkgPT4geyByZXR1cm47IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlLlxuICAgKiBAcmVtYXJrc1xuICAgKiBTZW5kIGEgTUVTU0FHRSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gZGVzdGluYXRpb24gLSBUaGUgdGFyZ2V0IGRlc3RpbmF0aW9uIGZvciB0aGUgbWVzc2FnZS4gQSBTSVAgYWRkcmVzcyB0byBzZW5kIHRoZSBNRVNTQUdFIHRvLlxuICAgKi9cbiAgcHVibGljIG1lc3NhZ2UoZGVzdGluYXRpb246IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gc2VuZGluZyBtZXNzYWdlLi4uYCk7XG5cbiAgICBjb25zdCB0YXJnZXQgPSBVc2VyQWdlbnQubWFrZVVSSShkZXN0aW5hdGlvbik7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgYSB2YWxpZCBVUkkgZnJvbSBcIiR7ZGVzdGluYXRpb259XCJgKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWVzc2FnZXIodGhpcy51c2VyQWdlbnQsIHRhcmdldCwgbWVzc2FnZSkubWVzc2FnZSgpO1xuICB9XG5cbiAgLyoqIE1lZGlhIGNvbnN0cmFpbnRzLiAqL1xuICBwcml2YXRlIGdldCBjb25zdHJhaW50cygpOiB7IGF1ZGlvOiBib29sZWFuLCB2aWRlbzogYm9vbGVhbiB9IHtcbiAgICBsZXQgY29uc3RyYWludHMgPSB7IGF1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2UgfTsgLy8gZGVmYXVsdCB0byBhdWRpbyBvbmx5IGNhbGxzXG4gICAgaWYgKHRoaXMub3B0aW9ucy5tZWRpYSAmJiB0aGlzLm9wdGlvbnMubWVkaWEuY29uc3RyYWludHMpIHtcbiAgICAgIGNvbnN0cmFpbnRzID0geyAuLi50aGlzLm9wdGlvbnMubWVkaWEuY29uc3RyYWludHMgfTtcbiAgICAgIGlmICghY29uc3RyYWludHMuYXVkaW8gJiYgIWNvbnN0cmFpbnRzLnZpZGVvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWVkaWEgY29uc3RyYWludHMgLSBhdWRpbyBhbmQvb3IgdmlkZW8gbXVzdCBiZSB0cnVlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgcmVjb25uZWN0aW9uIHVwIHRvIGBtYXhSZWNvbm5lY3Rpb25BdHRlbXB0c2AgdGltZXMuXG4gICAqIEBwYXJhbSByZWNvbm5lY3Rpb25BdHRlbXB0IC0gQ3VycmVudCBhdHRlbXB0IG51bWJlci5cbiAgICovXG4gIHByaXZhdGUgYXR0ZW1wdFJlY29ubmVjdGlvbihyZWNvbm5lY3Rpb25BdHRlbXB0OiBudW1iZXIgPSAxKTogdm9pZCB7XG4gICAgY29uc3QgcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB0aGlzLm9wdGlvbnMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgMztcbiAgICBjb25zdCByZWNvbm5lY3Rpb25EZWxheSA9IHRoaXMub3B0aW9ucy5yZWNvbm5lY3Rpb25EZWxheSB8fCA0O1xuXG4gICAgaWYgKCF0aGlzLmNvbm5lY3RSZXF1ZXN0ZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIFJlY29ubmVjdGlvbiBub3QgY3VycmVudGx5IGRlc2lyZWRgKTtcbiAgICAgIHJldHVybjsgLy8gSWYgaW50ZW50aW9uYWxseSBkaXNjb25uZWN0ZWQsIGRvbid0IHJlY29ubmVjdC5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBSZWNvbm5lY3Rpb24gYXR0ZW1wdCBhbHJlYWR5IGluIHByb2dyZXNzYCk7XG4gICAgfVxuXG4gICAgaWYgKHJlY29ubmVjdGlvbkF0dGVtcHQgPiByZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gUmVjb25uZWN0aW9uIG1heGltdW0gYXR0ZW1wdHMgcmVhY2hlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZWNvbm5lY3Rpb25BdHRlbXB0ID09PSAxKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBSZWNvbm5lY3Rpb24gYXR0ZW1wdCAke3JlY29ubmVjdGlvbkF0dGVtcHR9IG9mICR7cmVjb25uZWN0aW9uQXR0ZW1wdHN9IC0gdHJ5aW5nYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIFJlY29ubmVjdGlvbiBhdHRlbXB0ICR7cmVjb25uZWN0aW9uQXR0ZW1wdH0gb2YgJHtyZWNvbm5lY3Rpb25BdHRlbXB0c30gLSB0cnlpbmcgaW4gJHtyZWNvbm5lY3Rpb25EZWxheX0gc2Vjb25kc2ApO1xuICAgIH1cblxuICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdGlvbiA9IHRydWU7XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5jb25uZWN0UmVxdWVzdGVkKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyXG4gICAgICAgICAgLmxvZyhgWyR7dGhpcy5pZH1dIFJlY29ubmVjdGlvbiBhdHRlbXB0ICR7cmVjb25uZWN0aW9uQXR0ZW1wdH0gb2YgJHtyZWNvbm5lY3Rpb25BdHRlbXB0c30gLSBhYm9ydGVkYCk7XG4gICAgICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdGlvbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm47IC8vIElmIGludGVudGlvbmFsbHkgZGlzY29ubmVjdGVkLCBkb24ndCByZWNvbm5lY3QuXG4gICAgICB9XG4gICAgICB0aGlzLnVzZXJBZ2VudC5yZWNvbm5lY3QoKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2dnZXJcbiAgICAgICAgICAgIC5sb2coYFske3RoaXMuaWR9XSBSZWNvbm5lY3Rpb24gYXR0ZW1wdCAke3JlY29ubmVjdGlvbkF0dGVtcHR9IG9mICR7cmVjb25uZWN0aW9uQXR0ZW1wdHN9IC0gc3VjY2VlZGVkYCk7XG4gICAgICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2dnZXJcbiAgICAgICAgICAgIC5sb2coYFske3RoaXMuaWR9XSBSZWNvbm5lY3Rpb24gYXR0ZW1wdCAke3JlY29ubmVjdGlvbkF0dGVtcHR9IG9mICR7cmVjb25uZWN0aW9uQXR0ZW1wdHN9IC0gZmFpbGVkYCk7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0aW9uKCsrcmVjb25uZWN0aW9uQXR0ZW1wdCk7XG4gICAgICAgIH0pO1xuICAgIH0sIHJlY29ubmVjdGlvbkF0dGVtcHQgPT09IDEgPyAwIDogcmVjb25uZWN0aW9uRGVsYXkgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIG1lZGlhIGZyb20gaHRtbCBlbGVtZW50cy4gKi9cbiAgcHJpdmF0ZSBjbGVhbnVwTWVkaWEoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5tZWRpYSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsLnZpZGVvKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsLnZpZGVvLnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsLnZpZGVvLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLmF1ZGlvKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpby5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUuYXVkaW8ucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS52aWRlbykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUudmlkZW8uc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLnZpZGVvLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogSGVscGVyIGZ1bmN0aW9uIHRvIGVuYWJsZS9kaXNhYmxlIG1lZGlhIHRyYWNrcy4gKi9cbiAgcHJpdmF0ZSBlbmFibGVTZW5kZXJUcmFja3MoZW5hYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSB0aGlzLnNlc3Npb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcjtcbiAgICBpZiAoIShzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIGluc3RhbmNlb2YgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24ncyBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgbm90IGluc3RhbmNlIG9mIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wZWVyQ29ubmVjdGlvbjtcbiAgICBwZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCkuZm9yRWFjaCgoc2VuZGVyKSA9PiB7XG4gICAgICBpZiAoc2VuZGVyLnRyYWNrKSB7XG4gICAgICAgIHNlbmRlci50cmFjay5lbmFibGVkID0gZW5hYmxlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqIFRoZSByZWNlaXZlciBtZWRpYSB0cmFjaywgaWYgYXZhaWxhYmxlLiAqL1xuICBwcml2YXRlIGdldFJlY2VpdmVyVHJhY2soa2luZDogXCJhdWRpb1wiIHwgXCJ2aWRlb1wiKTogTWVkaWFTdHJlYW1UcmFjayB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oYFske3RoaXMuaWR9XSBnZXRSZWNlaXZlclRyYWNrIC0gc2Vzc2lvbiB1bmRlZmluZWRgKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IHRoaXMuc2Vzc2lvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyO1xuICAgIGlmICghc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgWyR7dGhpcy5pZH1dIGdldFJlY2VpdmVyVHJhY2sgLSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgdW5kZWZpbmVkYCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICghKHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgaW5zdGFuY2VvZiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbidzIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBub3QgaW5zdGFuY2Ugb2YgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5cIik7XG4gICAgfVxuXG4gICAgY29uc3QgcGVlckNvbm5lY3Rpb24gPSBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnBlZXJDb25uZWN0aW9uO1xuICAgIGNvbnN0IHJ0cFJlY2VpdmVyID0gcGVlckNvbm5lY3Rpb24uZ2V0UmVjZWl2ZXJzKCkuZmluZCgocmVjZWl2ZXIpID0+IHtcbiAgICAgIHJldHVybiByZWNlaXZlci50cmFjay5raW5kID09PSBraW5kID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiBydHBSZWNlaXZlciA/IHJ0cFJlY2VpdmVyLnRyYWNrIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqIFRoZSBzZW5kZXIgbWVkaWEgdHJhY2ssIGlmIGF2YWlsYWJsZS4gKi9cbiAgcHJpdmF0ZSBnZXRTZW5kZXJUcmFjayhraW5kOiBcImF1ZGlvXCIgfCBcInZpZGVvXCIpOiBNZWRpYVN0cmVhbVRyYWNrIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgWyR7dGhpcy5pZH1dIGdldFNlbmRlclRyYWNrIC0gc2Vzc2lvbiB1bmRlZmluZWRgKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IHRoaXMuc2Vzc2lvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyO1xuICAgIGlmICghc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgWyR7dGhpcy5pZH1dIGdldFNlbmRlclRyYWNrIC0gc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIHVuZGVmaW5lZGApO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoIShzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIGluc3RhbmNlb2YgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24ncyBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgbm90IGluc3RhbmNlIG9mIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wZWVyQ29ubmVjdGlvbjtcbiAgICBjb25zdCBydHBTZW5kZXIgPSBwZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCkuZmluZCgoc2VuZGVyKSA9PiB7XG4gICAgICByZXR1cm4gc2VuZGVyLnRyYWNrICYmIHNlbmRlci50cmFjay5raW5kID09PSBraW5kID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiBydHBTZW5kZXIgJiYgcnRwU2VuZGVyLnRyYWNrID8gcnRwU2VuZGVyLnRyYWNrIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIHNlc3Npb24gZGVsZWdhdGUgYW5kIHN0YXRlIGNoYW5nZSBoYW5kbGVyLlxuICAgKiBAcGFyYW0gc2Vzc2lvbiAtIFNlc3Npb24gdG8gc2V0dXBcbiAgICogQHBhcmFtIHJlZmVycmFsSW52aXRlck9wdGlvbnMgLSBPcHRpb25zIGZvciBhbnkgSW52aXRlciBjcmVhdGVkIGFzIHJlc3VsdCBvZiBhIFJFRkVSLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0U2Vzc2lvbihcbiAgICBzZXNzaW9uOiBTZXNzaW9uLFxuICAgIHJlZmVycmFsSW52aXRlck9wdGlvbnM/OiBJbnZpdGVyT3B0aW9ucyxcbiAgKTogdm9pZCB7XG4gICAgLy8gU2V0IHNlc3Npb25cbiAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuXG4gICAgLy8gQ2FsbCBzZXNzaW9uIGNyZWF0ZWQgY2FsbGJhY2tcbiAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uQ2FsbENyZWF0ZWQpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUub25DYWxsQ3JlYXRlZCgpO1xuICAgIH1cblxuICAgIC8vIFNldHVwIHNlc3Npb24gc3RhdGUgY2hhbmdlIGhhbmRsZXJcbiAgICB0aGlzLnNlc3Npb24uc3RhdGVDaGFuZ2UuYWRkTGlzdGVuZXIoKHN0YXRlOiBTZXNzaW9uU3RhdGUpID0+IHtcbiAgICAgIGlmICh0aGlzLnNlc3Npb24gIT09IHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuOyAvLyBpZiBvdXIgc2Vzc2lvbiBoYXMgY2hhbmdlZCwganVzdCByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIHNlc3Npb24gc3RhdGUgY2hhbmdlZCB0byAke3N0YXRlfWApO1xuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIFNlc3Npb25TdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkOlxuICAgICAgICAgIHRoaXMuc2V0dXBMb2NhbE1lZGlhKCk7XG4gICAgICAgICAgdGhpcy5zZXR1cFJlbW90ZU1lZGlhKCk7XG4gICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkNhbGxBbnN3ZXJlZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkNhbGxBbnN3ZXJlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTZXNzaW9uU3RhdGUuVGVybWluYXRpbmc6XG4gICAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgdGhpcy5zZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMuY2xlYW51cE1lZGlhKCk7XG4gICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkNhbGxIYW5ndXApIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25DYWxsSGFuZ3VwKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc2Vzc2lvbiBzdGF0ZS5cIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTZXR1cCBkZWxlZ2F0ZVxuICAgIHRoaXMuc2Vzc2lvbi5kZWxlZ2F0ZSA9IHtcbiAgICAgIG9uUmVmZXI6IChyZWZlcnJhbDogUmVmZXJyYWwpID0+IHtcbiAgICAgICAgcmVmZXJyYWxcbiAgICAgICAgICAuYWNjZXB0KClcbiAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNlbmRJbnZpdGUocmVmZXJyYWwubWFrZUludml0ZXIocmVmZXJyYWxJbnZpdGVyT3B0aW9ucyksIHJlZmVycmFsSW52aXRlck9wdGlvbnMpKVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqIEhlbHBlciBmdW5jdGlvbiB0byBpbml0IHNlbmQgdGhlbiBzZW5kIGludml0ZS4gKi9cbiAgcHJpdmF0ZSBzZW5kSW52aXRlKFxuICAgIGludml0ZXI6IEludml0ZXIsXG4gICAgaW52aXRlck9wdGlvbnM/OiBJbnZpdGVyT3B0aW9ucyxcbiAgICBpbnZpdGVySW52aXRlT3B0aW9ucz86IEludml0ZXJJbnZpdGVPcHRpb25zXG4gICk6IFByb21pc2U8dm9pZD4ge1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBvdXIgc2Vzc2lvblxuICAgIHRoaXMuaW5pdFNlc3Npb24oaW52aXRlciwgaW52aXRlck9wdGlvbnMpO1xuXG4gICAgLy8gU2VuZCB0aGUgSU5WSVRFXG4gICAgcmV0dXJuIGludml0ZXIuaW52aXRlKGludml0ZXJJbnZpdGVPcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBbJHt0aGlzLmlkfV0gc2VudCBJTlZJVEVgKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1dHMgU2Vzc2lvbiBvbiBob2xkLlxuICAgKiBAcGFyYW0gaG9sZCAtIEhvbGQgb24gaWYgdHJ1ZSwgb2ZmIGlmIGZhbHNlLlxuICAgKi9cbiAgcHJpdmF0ZSBzZXRIb2xkKGhvbGQ6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlNlc3Npb24gZG9lcyBub3QgZXhpc3QuXCIpKTtcbiAgICB9XG5cbiAgICAvLyBKdXN0IHJlc29sdmUgaWYgd2UgYXJlIGFscmVhZHkgaW4gY29ycmVjdCBzdGF0ZVxuICAgIGlmICh0aGlzLmhlbGQgPT09IGhvbGQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gdGhpcy5zZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG4gICAgaWYgKCEoc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciBpbnN0YW5jZW9mIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uJ3Mgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIG5vdCBpbnN0YW5jZSBvZiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zOiBTZXNzaW9uSW52aXRlT3B0aW9ucyA9IHtcbiAgICAgIHJlcXVlc3REZWxlZ2F0ZToge1xuICAgICAgICBvbkFjY2VwdDogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGVsZCA9IGhvbGQ7XG4gICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkNhbGxIb2xkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uQ2FsbEhvbGQodGhpcy5oZWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVqZWN0OiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgWyR7dGhpcy5pZH1dIHJlLWludml0ZSByZXF1ZXN0IHdhcyByZWplY3RlZGApO1xuICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25DYWxsSG9sZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkNhbGxIb2xkKHRoaXMuaGVsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFVzZSBob2xkIG1vZGlmaWVyIHRvIHByb2R1Y2UgdGhlIGFwcHJvcHJpYXRlIFNEUCBvZmZlciB0byBwbGFjZSBjYWxsIG9uIGhvbGRcbiAgICBpZiAoaG9sZCkge1xuICAgICAgb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzID0gW3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuaG9sZE1vZGlmaWVyXTtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHJlLUlOVklURVxuICAgIHJldHVybiB0aGlzLnNlc3Npb24uaW52aXRlKG9wdGlvbnMpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuZW5hYmxlU2VuZGVyVHJhY2tzKCFob2xkKTsgLy8gbXV0ZS91bm11dGVcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSZXF1ZXN0UGVuZGluZ0Vycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYFske3RoaXMuaWR9XSBBIGhvbGQgcmVxdWVzdCBpcyBhbHJlYWR5IGluIHByb2dyZXNzLmApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHV0cyBTZXNzaW9uIG9uIG11dGUuXG4gICAqIEBwYXJhbSBtdXRlIC0gTXV0ZSBvbiBpZiB0cnVlLCBvZmYgaWYgZmFsc2UuXG4gICAqL1xuICBwcml2YXRlIHNldE11dGUobXV0ZTogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBbJHt0aGlzLmlkfV0gQSBzZXNzaW9uIGlzIHJlcXVpcmVkIHRvIGVuYWJsZWQvZGlzYWJsZSBtZWRpYSB0cmFja3NgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXNzaW9uLnN0YXRlICE9PSBTZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oYFske3RoaXMuaWR9XSBBbiBlc3RhYmxpc2hlZCBzZXNzaW9uIGlzIHJlcXVpcmVkIHRvIGVuYWJsZS9kaXNhYmxlIG1lZGlhIHRyYWNrc2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZW5hYmxlU2VuZGVyVHJhY2tzKCFtdXRlKTtcbiAgfVxuXG4gIC8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gYXR0YWNoIGxvY2FsIG1lZGlhIHRvIGh0bWwgZWxlbWVudHMuICovXG4gIHByaXZhdGUgc2V0dXBMb2NhbE1lZGlhKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm1lZGlhICYmIHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbCAmJiB0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwudmlkZW8pIHtcbiAgICAgIGNvbnN0IGxvY2FsVmlkZW9UcmFjayA9IHRoaXMubG9jYWxWaWRlb1RyYWNrO1xuICAgICAgaWYgKGxvY2FsVmlkZW9UcmFjaykge1xuICAgICAgICBjb25zdCBsb2NhbFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbbG9jYWxWaWRlb1RyYWNrXSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbC52aWRlby5zcmNPYmplY3QgPSBsb2NhbFN0cmVhbTtcbiAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsLnZpZGVvLnZvbHVtZSA9IDA7XG4gICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbC52aWRlby5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEhlbHBlciBmdW5jdGlvbiB0byBhdHRhY2ggcmVtb3RlIG1lZGlhIHRvIGh0bWwgZWxlbWVudHMuICovXG4gIHByaXZhdGUgc2V0dXBSZW1vdGVNZWRpYSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5tZWRpYSAmJiB0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlKSB7XG4gICAgICBjb25zdCByZW1vdGVBdWRpb1RyYWNrID0gdGhpcy5yZW1vdGVBdWRpb1RyYWNrO1xuICAgICAgY29uc3QgcmVtb3RlVmlkZW9UcmFjayA9IHRoaXMucmVtb3RlVmlkZW9UcmFjaztcbiAgICAgIGNvbnN0IHJlbW90ZVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHZpZGVvIGVsZW1lbnQsIGJvdGggYXVkaW8gYW5kIHZpZGVvIHdpbGwgYmUgYXR0YWNoZWQgdGhhdCBlbGVtZW50LlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUudmlkZW8pIHtcbiAgICAgICAgaWYgKHJlbW90ZUF1ZGlvVHJhY2spIHtcbiAgICAgICAgICByZW1vdGVTdHJlYW0uYWRkVHJhY2socmVtb3RlQXVkaW9UcmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW90ZVZpZGVvVHJhY2spIHtcbiAgICAgICAgICByZW1vdGVTdHJlYW0uYWRkVHJhY2socmVtb3RlVmlkZW9UcmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS52aWRlby5zcmNPYmplY3QgPSByZW1vdGVTdHJlYW07XG4gICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUudmlkZW8ucGxheSgpXG4gICAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBbJHt0aGlzLmlkfV0gRXJyb3IgcGxheWluZyB2aWRlb2ApO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUuYXVkaW8pIHtcbiAgICAgICAgaWYgKHJlbW90ZUF1ZGlvVHJhY2spIHtcbiAgICAgICAgICByZW1vdGVTdHJlYW0uYWRkVHJhY2socmVtb3RlQXVkaW9UcmFjayk7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpby5zcmNPYmplY3QgPSByZW1vdGVTdHJlYW07XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpby5wbGF5KClcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBbJHt0aGlzLmlkfV0gRXJyb3IgcGxheWluZyBhdWRpb2ApO1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5kIGEgc2Vzc2lvbi5cbiAgICogQHJlbWFya3NcbiAgICogU2VuZCBhIEJZRSByZXF1ZXN0LCBDQU5DRUwgcmVxdWVzdCBvciByZWplY3QgcmVzcG9uc2UgdG8gZW5kIHRoZSBjdXJyZW50IFNlc3Npb24uXG4gICAqIFJlc29sdmVzIHdoZW4gdGhlIHJlcXVlc3QvcmVzcG9uc2UgaXMgc2VudCwgb3RoZXJ3aXNlIHJlamVjdHMuXG4gICAqIFVzZSBgb25DYWxsVGVybWluYXRlZGAgZGVsZWdhdGUgbWV0aG9kIHRvIGRldGVybWluZSBpZiBhbmQgd2hlbiBTZXNzaW9uIGlzIHRlcm1pbmF0ZWQuXG4gICAqL1xuICBwcml2YXRlIHRlcm1pbmF0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBUZXJtaW5hdGluZy4uLmApO1xuXG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTZXNzaW9uIGRvZXMgbm90IGV4aXN0LlwiKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnNlc3Npb24uc3RhdGUpIHtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLkluaXRpYWw6XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24gaW5zdGFuY2VvZiBJbnZpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5jYW5jZWwoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBJbnZpdGVyIG5ldmVyIHNlbnQgSU5WSVRFIChjYW5jZWxlZClgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2Vzc2lvbiBpbnN0YW5jZW9mIEludml0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnJlamVjdCgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIEludml0YXRpb24gcmVqZWN0ZWQgKHNlbnQgNDgwKWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzZXNzaW9uIHR5cGUuXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmc6XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24gaW5zdGFuY2VvZiBJbnZpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5jYW5jZWwoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBJbnZpdGVyIGNhbmNlbGVkIChzZW50IENBTkNFTClgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2Vzc2lvbiBpbnN0YW5jZW9mIEludml0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnJlamVjdCgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhgWyR7dGhpcy5pZH1dIEludml0YXRpb24gcmVqZWN0ZWQgKHNlbnQgNDgwKWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzZXNzaW9uIHR5cGUuXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZDpcbiAgICAgICAgcmV0dXJuIG5ldyBCeWVyKHRoaXMuc2Vzc2lvbikuYnllKClcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBTZXNzaW9uIGVuZGVkIChzZW50IEJZRSlgKTtcbiAgICAgICAgICB9KTtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLlRlcm1pbmF0aW5nOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coYFske3RoaXMuaWR9XSBUZXJtaW5hdGluZyBpbiBzdGF0ZSAke3RoaXMuc2Vzc2lvbi5zdGF0ZX0sIG5vIGFjdGlvbiB0YWtlbmApO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50c1wiO1xuXG5pbXBvcnQgeyBfbWFrZUVtaXR0ZXIsIEVtaXR0ZXIgfSBmcm9tIFwiLi4vLi4vYXBpL2VtaXR0ZXJcIjtcbmltcG9ydCB7IFN0YXRlVHJhbnNpdGlvbkVycm9yIH0gZnJvbSBcIi4uLy4uL2FwaS9leGNlcHRpb25zXCI7XG5pbXBvcnQgeyBUcmFuc3BvcnQgYXMgVHJhbnNwb3J0RGVmaW5pdGlvbiB9IGZyb20gXCIuLi8uLi9hcGkvdHJhbnNwb3J0XCI7XG5pbXBvcnQgeyBUcmFuc3BvcnRTdGF0ZSB9IGZyb20gXCIuLi8uLi9hcGkvdHJhbnNwb3J0LXN0YXRlXCI7XG5pbXBvcnQgeyBHcmFtbWFyLCBMb2dnZXIgfSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBvcHRpb25zLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zcG9ydE9wdGlvbnMge1xuICAvKipcbiAgICogVVJMIG9mIFdlYlNvY2tldCBzZXJ2ZXIgdG8gY29ubmVjdCB3aXRoLiBGb3IgZXhhbXBsZSwgXCJ3c3M6Ly9sb2NhbGhvc3Q6ODA4MFwiLlxuICAgKi9cbiAgc2VydmVyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNlY29uZHMgdG8gd2FpdCBmb3IgV2ViU29ja2V0IHRvIGNvbm5lY3QgYmVmb3JlIGdpdmluZyB1cC5cbiAgICogQGRlZmF1bHRWYWx1ZSBgNWBcbiAgICovXG4gIGNvbm5lY3Rpb25UaW1lb3V0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBLZWVwIGFsaXZlIC0gbmVlZHMgcmV2aWV3LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGtlZXBBbGl2ZUludGVydmFsPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBLZWVwIGFsaXZlIC0gbmVlZHMgcmV2aWV3LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGtlZXBBbGl2ZURlYm91bmNlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBtZXNzc2FnZXMgc2VudCBhbmQgcmVjZWl2ZWQgYnkgdGhlIHRyYW5zcG9ydCBhcmUgbG9nZ2VkLlxuICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgKi9cbiAgdHJhY2VTaXA/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRyYW5zcG9ydCBmb3IgU0lQIG92ZXIgc2VjdXJlIFdlYlNvY2tldCAoV1NTKS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zcG9ydCBleHRlbmRzIEV2ZW50RW1pdHRlciBpbXBsZW1lbnRzIFRyYW5zcG9ydERlZmluaXRpb24ge1xuXG4gIHByaXZhdGUgc3RhdGljIGRlZmF1bHRPcHRpb25zOiBSZXF1aXJlZDxUcmFuc3BvcnRPcHRpb25zPiA9IHtcbiAgICBzZXJ2ZXI6IFwiXCIsXG4gICAgY29ubmVjdGlvblRpbWVvdXQ6IDUsXG4gICAga2VlcEFsaXZlSW50ZXJ2YWw6IDAsXG4gICAga2VlcEFsaXZlRGVib3VuY2U6IDEwLFxuICAgIHRyYWNlU2lwOiB0cnVlXG4gIH07XG5cbiAgcHVibGljIG9uQ29ubmVjdDogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgb25EaXNjb25uZWN0OiAoKGVycm9yPzogRXJyb3IpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgb25NZXNzYWdlOiAoKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBfcHJvdG9jb2w6IHN0cmluZztcbiAgcHJpdmF0ZSBfc3RhdGU6IFRyYW5zcG9ydFN0YXRlID0gVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGVkO1xuICBwcml2YXRlIF9zdGF0ZUV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgcHJpdmF0ZSBfd3M6IFdlYlNvY2tldCB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGNvbmZpZ3VyYXRpb246IFJlcXVpcmVkPFRyYW5zcG9ydE9wdGlvbnM+O1xuXG4gIHByaXZhdGUgY29ubmVjdFByb21pc2U6IFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgY29ubmVjdFJlc29sdmU6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBjb25uZWN0UmVqZWN0OiAoKGVycm9yOiBFcnJvcikgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgY29ubmVjdFRpbWVvdXQ6IGFueSB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGRpc2Nvbm5lY3RQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIGRpc2Nvbm5lY3RSZXNvbHZlOiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgZGlzY29ubmVjdFJlamVjdDogKChlcnJvcj86IEVycm9yKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGtlZXBBbGl2ZUludGVydmFsOiBhbnkgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUga2VlcEFsaXZlRGVib3VuY2VUaW1lb3V0OiBhbnkgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcbiAgcHJpdmF0ZSB0cmFuc2l0aW9uaW5nU3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihsb2dnZXI6IExvZ2dlciwgb3B0aW9ucz86IFRyYW5zcG9ydE9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gbG9nZ2VyXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG5cbiAgICAvLyBndWFyZCBkZXByZWNhdGVkIG9wdGlvbnMgKHJlbW92ZSB0aGlzIGluIHZlcnNpb24gMTYueClcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uc0RlcHJlY2F0ZWQ6IGFueSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCB3c1NlcnZlcnNEZXByZWNhdGVkOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgdW5kZWZpbmVkID0gb3B0aW9uc0RlcHJlY2F0ZWQud3NTZXJ2ZXJzO1xuICAgICAgY29uc3QgbWF4UmVjb25uZWN0aW9uQXR0ZW1wdHNEZXByZWNhdGVkOiBudW1iZXIgfCB1bmRlZmluZWQgPSBvcHRpb25zRGVwcmVjYXRlZC5tYXhSZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgICAgIGlmICh3c1NlcnZlcnNEZXByZWNhdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZGVwcmVjYXRlZE1lc3NhZ2UgPVxuICAgICAgICAgIGBUaGUgdHJhbnNwb3J0IG9wdGlvbiBcIndzU2VydmVyc1wiIGFzIGhhcyBhcHBhcmVudGx5IGJlZW4gc3BlY2lmaWVkIGFuZCBoYXMgYmVlbiBkZXByZWNhdGVkLiBgICtcbiAgICAgICAgICBcIkl0IHdpbGwgbm8gbG9uZ2VyIGJlIGF2YWlsYWJsZSBzdGFydGluZyB3aXRoIFNJUC5qcyByZWxlYXNlIDAuMTYuMC4gUGxlYXNlIHVwZGF0ZSBhY2NvcmRpbmdseS5cIjtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihkZXByZWNhdGVkTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4UmVjb25uZWN0aW9uQXR0ZW1wdHNEZXByZWNhdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZGVwcmVjYXRlZE1lc3NhZ2UgPVxuICAgICAgICAgIGBUaGUgdHJhbnNwb3J0IG9wdGlvbiBcIm1heFJlY29ubmVjdGlvbkF0dGVtcHRzXCIgYXMgaGFzIGFwcGFyZW50bHkgYmVlbiBzcGVjaWZpZWQgYW5kIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIGAgK1xuICAgICAgICAgIFwiSXQgd2lsbCBubyBsb25nZXIgYmUgYXZhaWxhYmxlIHN0YXJ0aW5nIHdpdGggU0lQLmpzIHJlbGVhc2UgMC4xNi4wLiBQbGVhc2UgdXBkYXRlIGFjY29yZGluZ2x5LlwiO1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGRlcHJlY2F0ZWRNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIC8vIGhhY2tcbiAgICAgIGlmICh3c1NlcnZlcnNEZXByZWNhdGVkICYmICFvcHRpb25zLnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIHdzU2VydmVyc0RlcHJlY2F0ZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBvcHRpb25zLnNlcnZlciA9IHdzU2VydmVyc0RlcHJlY2F0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdzU2VydmVyc0RlcHJlY2F0ZWQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIG9wdGlvbnMuc2VydmVyID0gd3NTZXJ2ZXJzRGVwcmVjYXRlZFswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgY29uZmlndXJhdGlvblxuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHtcbiAgICAgIC8vIHN0YXJ0IHdpdGggdGhlIGRlZmF1bHQgb3B0aW9uIHZhbHVlc1xuICAgICAgLi4uVHJhbnNwb3J0LmRlZmF1bHRPcHRpb25zLFxuICAgICAgLy8gYXBwbHkgYW55IG9wdGlvbnMgcGFzc2VkIGluIHZpYSB0aGUgY29uc3RydWN0b3JcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgLy8gdmFsaWRhdGUgc2VydmVyIFVSTFxuICAgIGNvbnN0IHVybCA9IHRoaXMuY29uZmlndXJhdGlvbi5zZXJ2ZXI7XG4gICAgY29uc3QgcGFyc2VkOiBhbnkgfCAtMSA9IEdyYW1tYXIucGFyc2UodXJsLCBcImFic29sdXRlVVJJXCIpO1xuICAgIGlmIChwYXJzZWQgPT09IC0xKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgSW52YWxpZCBXZWJTb2NrZXQgU2VydmVyIFVSTCBcIiR7dXJsfVwiYCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFdlYlNvY2tldCBTZXJ2ZXIgVVJMXCIpO1xuICAgIH1cbiAgICBpZiAoW1wid3NzXCIsIFwid3NcIiwgXCJ1ZHBcIl0uaW5kZXhPZihwYXJzZWQuc2NoZW1lKSA8IDApIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBJbnZhbGlkIHNjaGVtZSBpbiBXZWJTb2NrZXQgU2VydmVyIFVSTCBcIiR7dXJsfVwiYCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNjaGVtZSBpbiBXZWJTb2NrZXQgU2VydmVyIFVSTFwiKTtcbiAgICB9XG4gICAgdGhpcy5fcHJvdG9jb2wgPSBwYXJzZWQuc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5kaXNjb25uZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHByb3RvY29sLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBGb3JtYXR0ZWQgYXMgZGVmaW5lZCBmb3IgdGhlIFZpYSBoZWFkZXIgc2VudC1wcm90b2NvbCB0cmFuc3BvcnQuXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMjAuNDJcbiAgICovXG4gIHB1YmxpYyBnZXQgcHJvdG9jb2woKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFVSTCBvZiB0aGUgV2ViU29ja2V0IFNlcnZlci5cbiAgICovXG4gIHB1YmxpYyBnZXQgc2VydmVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5zZXJ2ZXI7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNwb3J0IHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGdldCBzdGF0ZSgpOiBUcmFuc3BvcnRTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zcG9ydCBzdGF0ZSBjaGFuZ2UgZW1pdHRlci5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGVDaGFuZ2UoKTogRW1pdHRlcjxUcmFuc3BvcnRTdGF0ZT4ge1xuICAgIHJldHVybiBfbWFrZUVtaXR0ZXIodGhpcy5fc3RhdGVFdmVudEVtaXR0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBXZWJTb2NrZXQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHdzKCk6IFdlYlNvY2tldCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3dzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gbmV0d29yay5cbiAgICogUmVzb2x2ZXMgb25jZSBjb25uZWN0ZWQuIE90aGVyd2lzZSByZWplY3RzIHdpdGggYW4gRXJyb3IuXG4gICAqL1xuICBwdWJsaWMgY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3QgZnJvbSBuZXR3b3JrLlxuICAgKiBSZXNvbHZlcyBvbmNlIGRpc2Nvbm5lY3RlZC4gT3RoZXJ3aXNlIHJlamVjdHMgd2l0aCBhbiBFcnJvci5cbiAgICovXG4gIHB1YmxpYyBkaXNjb25uZWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9kaXNjb25uZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBgc3RhdGVgIGVxdWFscyBcIkNvbm5lY3RlZFwiLlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYHN0YXRlID09PSBUcmFuc3BvcnRTdGF0ZS5Db25uZWN0ZWRgLlxuICAgKi9cbiAgcHVibGljIGlzQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBUcmFuc3BvcnRTdGF0ZS5Db25uZWN0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlLlxuICAgKiBSZXNvbHZlcyBvbmNlIG1lc3NhZ2UgaXMgc2VudC4gT3RoZXJ3aXNlIHJlamVjdHMgd2l0aCBhbiBFcnJvci5cbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIHNlbmQuXG4gICAqL1xuICBwdWJsaWMgc2VuZChtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBFcnJvciBoYW5kbGluZyBpcyBpbmRlcGVuZGVudCBvZiB3aGV0aGVyIHRoZSBtZXNzYWdlIHdhcyBhIHJlcXVlc3Qgb3JcbiAgICAvLyByZXNwb25zZS5cbiAgICAvL1xuICAgIC8vIElmIHRoZSB0cmFuc3BvcnQgdXNlciBhc2tzIGZvciBhIG1lc3NhZ2UgdG8gYmUgc2VudCBvdmVyIGFuXG4gICAgLy8gdW5yZWxpYWJsZSB0cmFuc3BvcnQsIGFuZCB0aGUgcmVzdWx0IGlzIGFuIElDTVAgZXJyb3IsIHRoZSBiZWhhdmlvclxuICAgIC8vIGRlcGVuZHMgb24gdGhlIHR5cGUgb2YgSUNNUCBlcnJvci4gIEhvc3QsIG5ldHdvcmssIHBvcnQgb3IgcHJvdG9jb2xcbiAgICAvLyB1bnJlYWNoYWJsZSBlcnJvcnMsIG9yIHBhcmFtZXRlciBwcm9ibGVtIGVycm9ycyBTSE9VTEQgY2F1c2UgdGhlXG4gICAgLy8gdHJhbnNwb3J0IGxheWVyIHRvIGluZm9ybSB0aGUgdHJhbnNwb3J0IHVzZXIgb2YgYSBmYWlsdXJlIGluIHNlbmRpbmcuXG4gICAgLy8gU291cmNlIHF1ZW5jaCBhbmQgVFRMIGV4Y2VlZGVkIElDTVAgZXJyb3JzIFNIT1VMRCBiZSBpZ25vcmVkLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlIHRyYW5zcG9ydCB1c2VyIGFza3MgZm9yIGEgcmVxdWVzdCB0byBiZSBzZW50IG92ZXIgYSByZWxpYWJsZVxuICAgIC8vIHRyYW5zcG9ydCwgYW5kIHRoZSByZXN1bHQgaXMgYSBjb25uZWN0aW9uIGZhaWx1cmUsIHRoZSB0cmFuc3BvcnRcbiAgICAvLyBsYXllciBTSE9VTEQgaW5mb3JtIHRoZSB0cmFuc3BvcnQgdXNlciBvZiBhIGZhaWx1cmUgaW4gc2VuZGluZy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE4LjRcbiAgICByZXR1cm4gdGhpcy5fc2VuZChtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbGlzdGVuZXIgZm9yIGNvbm5lY3Rpb24gZXZlbnRzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG9uQ29ubmVjdGVkYCwgYG9uRGlzY29ubmVjdGVkYCBhbmQvb3IgYHN0YXRlQ2hhbmdlYC5cbiAgICovXG4gIHB1YmxpYyBvbihldmVudDogXCJjb25uZWN0ZWRcIiB8IFwiY29ubmVjdGluZ1wiIHwgXCJkaXNjb25uZWN0aW5nXCIgfCBcImRpc2Nvbm5lY3RlZFwiLCBsaXN0ZW5lcjogKCkgPT4gdm9pZCk6IHRoaXM7XG5cbiAgLyoqXG4gICAqIEFkZCBsaXN0ZW5lciBmb3IgbWVzc2FnZSBldmVudC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBvbk1lc3NhZ2VgLlxuICAgKi9cbiAgcHVibGljIG9uKGV2ZW50OiBcIm1lc3NhZ2VcIiwgbGlzdGVuZXI6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpOiB0aGlzO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBvbihuYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQpOiB0aGlzIHtcbiAgICBjb25zdCBkZXByZWNhdGVkTWVzc2FnZSA9XG4gICAgICBgQSBsaXN0ZW5lciBoYXMgYmVlbiByZWdpc3RlcmVkIGZvciB0aGUgdHJhbnNwb3J0IGV2ZW50IFwiJHtuYW1lfVwiLiBgICtcbiAgICAgIFwiUmVnaXN0ZXJpbmcgbGlzdGVuZXJzIGZvciB0cmFuc3BvcnQgZXZlbnRzIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIGF2YWlsYWJsZSBzdGFydGluZyB3aXRoIFNJUC5qcyByZWxlYXNlIDAuMTYuMC4gXCIgK1xuICAgICAgXCJQbGVhc2UgdXNlIHRoZSBvbkNvbm5lY3RlZCwgb25EaXNjb25uZWN0ZWQsIG9uTWVzc2FnZSBjYWxsYmFja3MgYW5kL29yIHRoZSBzdGF0ZUNoYW5nZSBlbWl0dGVyIGluc3RlYWQuIFBsZWFzZSB1cGRhdGUgYWNjb3JkaW5nbHkuXCI7XG4gICAgdGhpcy5sb2dnZXIud2FybihkZXByZWNhdGVkTWVzc2FnZSk7XG4gICAgcmV0dXJuIHN1cGVyLm9uKG5hbWUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHByaXZhdGUgX2Nvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBDb25uZWN0aW5nICR7dGhpcy5zZXJ2ZXJ9YCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgVHJhbnNwb3J0U3RhdGUuQ29ubmVjdGluZzpcbiAgICAgICAgLy8gSWYgYHN0YXRlYCBpcyBcIkNvbm5lY3RpbmdcIiwgYHN0YXRlYCBNVVNUIE5PVCB0cmFuc2l0aW9uIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmdTdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLnRyYW5zaXRpb25Mb29wRGV0ZWN0ZWRFcnJvcihUcmFuc3BvcnRTdGF0ZS5Db25uZWN0aW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RQcm9taXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ubmVjdCBwcm9taXNlIG11c3QgYmUgZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdFByb21pc2U7IC8vIEFscmVhZHkgY29ubmVjdGluZ1xuICAgICAgY2FzZSBUcmFuc3BvcnRTdGF0ZS5Db25uZWN0ZWQ6XG4gICAgICAgIC8vIElmIGBzdGF0ZWAgaXMgXCJDb25uZWN0ZWRcIiwgYHN0YXRlYCBNVVNUIE5PVCB0cmFuc2l0aW9uIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmdTdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLnRyYW5zaXRpb25Mb29wRGV0ZWN0ZWRFcnJvcihUcmFuc3BvcnRTdGF0ZS5Db25uZWN0aW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdFByb21pc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25uZWN0IHByb21pc2UgbXVzdCBub3QgYmUgZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyAvLyBBbHJlYWR5IGNvbm5lY3RlZFxuICAgICAgY2FzZSBUcmFuc3BvcnRTdGF0ZS5EaXNjb25uZWN0aW5nOlxuICAgICAgICAvLyBJZiBgc3RhdGVgIGlzIFwiRGlzY29ubmVjdGluZ1wiLCBgc3RhdGVgIE1VU1QgdHJhbnNpdGlvbiB0byBcIkNvbm5lY3RpbmdcIiBiZWZvcmUgcmV0dXJuaW5nXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RQcm9taXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ubmVjdCBwcm9taXNlIG11c3Qgbm90IGJlIGRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RhdGUoVHJhbnNwb3J0U3RhdGUuQ29ubmVjdGluZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFN0YXRlVHJhbnNpdGlvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7IC8vIExvb3AgZGV0ZWN0ZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGVkOlxuICAgICAgICAvLyBJZiBgc3RhdGVgIGlzIFwiRGlzY29ubmVjdGVkXCIgYHN0YXRlYCBNVVNUIHRyYW5zaXRpb24gdG8gXCJDb25uZWN0aW5nXCIgYmVmb3JlIHJldHVybmluZ1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0UHJvbWlzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbm5lY3QgcHJvbWlzZSBtdXN0IG5vdCBiZSBkZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblN0YXRlKFRyYW5zcG9ydFN0YXRlLkNvbm5lY3RpbmcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTdGF0ZVRyYW5zaXRpb25FcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyAvLyBMb29wIGRldGVjdGVkXG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cblxuICAgIGxldCB3czogV2ViU29ja2V0O1xuICAgIHRyeSB7XG4gICAgICAvLyBXZWJTb2NrZXQoKVxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldC9XZWJTb2NrZXRcbiAgICAgIHdzID0gbmV3IFdlYlNvY2tldCh0aGlzLnNlcnZlciwgXCJzaXBcIik7XG4gICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKGV2OiBDbG9zZUV2ZW50KSA9PiB0aGlzLm9uV2ViU29ja2V0Q2xvc2UoZXYsIHdzKSk7XG4gICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGV2OiBFdmVudCkgPT4gdGhpcy5vbldlYlNvY2tldEVycm9yKGV2LCB3cykpO1xuICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKGV2OiBFdmVudCkgPT4gdGhpcy5vbldlYlNvY2tldE9wZW4oZXYsIHdzKSk7XG4gICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXY6IE1lc3NhZ2VFdmVudCkgPT4gdGhpcy5vbldlYlNvY2tldE1lc3NhZ2UoZXYsIHdzKSk7XG4gICAgICB0aGlzLl93cyA9IHdzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLl93cyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiV2ViU29ja2V0IGNvbnN0cnVjdGlvbiBmYWlsZWQuXCIpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAvLyBUaGUgYHN0YXRlYCBNVVNUIHRyYW5zaXRpb24gdG8gXCJEaXNjb25uZWN0aW5nXCIgb3IgXCJEaXNjb25uZWN0ZWRcIiBiZWZvcmUgcmVqZWN0aW5nXG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RhdGUoVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGVkLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3RSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuY29ubmVjdFJlamVjdCA9IHJlamVjdDtcblxuICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgIFwiQ29ubmVjdCB0aW1lZCBvdXQuIFwiICtcbiAgICAgICAgICBcIkV4Y2VlZGVkIHRpbWUgc2V0IGluIGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvblRpbWVvdXQ6IFwiICsgdGhpcy5jb25maWd1cmF0aW9uLmNvbm5lY3Rpb25UaW1lb3V0ICsgXCJzLlwiXG4gICAgICAgICk7XG4gICAgICAgIHdzLmNsb3NlKDEwMDApOyAvLyBjYXJlZnVsIGhlcmUgdG8gdXNlIGEgbG9jYWwgcmVmZXJlbmNlIGluc3RlYWQgb2YgdGhpcy5fd3NcbiAgICAgIH0sIHRoaXMuY29uZmlndXJhdGlvbi5jb25uZWN0aW9uVGltZW91dCAqIDEwMDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdFByb21pc2U7XG4gIH1cblxuICBwcml2YXRlIF9kaXNjb25uZWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgRGlzY29ubmVjdGluZyAke3RoaXMuc2VydmVyfWApO1xuXG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFRyYW5zcG9ydFN0YXRlLkNvbm5lY3Rpbmc6XG4gICAgICAgIC8vIElmIGBzdGF0ZWAgaXMgXCJDb25uZWN0aW5nXCIsIGBzdGF0ZWAgTVVTVCB0cmFuc2l0aW9uIHRvIFwiRGlzY29ubmVjdGluZ1wiIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RQcm9taXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzY29ubmVjdCBwcm9taXNlIG11c3Qgbm90IGJlIGRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RhdGUoVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGluZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFN0YXRlVHJhbnNpdGlvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7IC8vIExvb3AgZGV0ZWN0ZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNwb3J0U3RhdGUuQ29ubmVjdGVkOlxuICAgICAgICAvLyBJZiBgc3RhdGVgIGlzIFwiQ29ubmVjdGVkXCIsIGBzdGF0ZWAgTVVTVCB0cmFuc2l0aW9uIHRvIFwiRGlzY29ubmVjdGluZ1wiIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RQcm9taXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzY29ubmVjdCBwcm9taXNlIG11c3Qgbm90IGJlIGRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RhdGUoVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGluZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFN0YXRlVHJhbnNpdGlvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7IC8vIExvb3AgZGV0ZWN0ZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGluZzpcbiAgICAgICAgLy8gSWYgYHN0YXRlYCBpcyBcIkRpc2Nvbm5lY3RpbmdcIiwgYHN0YXRlYCBNVVNUIE5PVCB0cmFuc2l0aW9uIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmdTdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLnRyYW5zaXRpb25Mb29wRGV0ZWN0ZWRFcnJvcihUcmFuc3BvcnRTdGF0ZS5EaXNjb25uZWN0aW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRpc2Nvbm5lY3RQcm9taXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzY29ubmVjdCBwcm9taXNlIG11c3QgYmUgZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdFByb21pc2U7IC8vIEFscmVhZHkgZGlzY29ubmVjdGluZ1xuICAgICAgY2FzZSBUcmFuc3BvcnRTdGF0ZS5EaXNjb25uZWN0ZWQ6XG4gICAgICAgIC8vIElmIGBzdGF0ZWAgaXMgXCJEaXNjb25uZWN0ZWRcIiwgYHN0YXRlYCBNVVNUIE5PVCB0cmFuc2l0aW9uIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmdTdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLnRyYW5zaXRpb25Mb29wRGV0ZWN0ZWRFcnJvcihUcmFuc3BvcnRTdGF0ZS5EaXNjb25uZWN0aW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlzY29ubmVjdFByb21pc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNjb25uZWN0IHByb21pc2UgbXVzdCBub3QgYmUgZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyAvLyBBbHJlYWR5IGRpc2Nvbm5lY3RlZFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3dzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgbXVzdCBiZSBkZWZpbmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qgd3MgPSB0aGlzLl93cztcblxuICAgIHRoaXMuZGlzY29ubmVjdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdFJlamVjdCA9IHJlamVjdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2ViU29ja2V0LmNsb3NlKClcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldC9jbG9zZVxuICAgICAgICB3cy5jbG9zZSgxMDAwKTsgLy8gY2FyZWZ1bCBoZXJlIHRvIHVzZSBhIGxvY2FsIHJlZmVyZW5jZSBpbnN0ZWFkIG9mIHRoaXMuX3dzXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUcmVhdGluZyB0aGlzIGFzIGEgY29kaW5nIGVycm9yIGFzIGl0IGFwcGFyZW50bHkgY2FuIG9ubHkgaGFwcGVuXG4gICAgICAgIC8vIGlmIHlvdSBwYXNzIGNsb3NlKCkgaW52YWxpZCBwYXJhbWV0ZXJzIChzbyBpdCBzaG91bGQgbmV2ZXIgaGFwcGVuKVxuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIldlYlNvY2tldCBjbG9zZSBmYWlsZWQuXCIpO1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdFByb21pc2U7XG4gIH1cblxuICBwcml2YXRlIF9zZW5kKG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24udHJhY2VTaXAgPT09IHRydWUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlbmRpbmcgV2ViU29ja2V0IG1lc3NhZ2U6XFxuXFxuXCIgKyBtZXNzYWdlICsgXCJcXG5cIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBUcmFuc3BvcnRTdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkLlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl93cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IHVuZGVmaW5lZC5cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlYlNvY2tldC5zZW5kKClcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvc2VuZFxuICAgICAgdGhpcy5fd3Muc2VuZChtZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJXZWJTb2NrZXQgc2VuZCBmYWlsZWQuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvKipcbiAgICogV2ViU29ja2V0IFwib25jbG9zZVwiIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSBldiAtIEV2ZW50LlxuICAgKi9cbiAgcHJpdmF0ZSBvbldlYlNvY2tldENsb3NlKGV2OiBDbG9zZUV2ZW50LCB3czogV2ViU29ja2V0KTogdm9pZCB7XG4gICAgaWYgKHdzICE9PSB0aGlzLl93cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgV2ViU29ja2V0IGNsb3NlZCAke3RoaXMuc2VydmVyfSAoY29kZTogJHtldi5jb2RlfSlgO1xuICAgIGNvbnN0IGVycm9yID0gIXRoaXMuZGlzY29ubmVjdFByb21pc2UgPyBuZXcgRXJyb3IobWVzc2FnZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiV2ViU29ja2V0IGNsb3NlZCB1bmV4cGVjdGVkbHlcIik7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmxvZyhtZXNzYWdlKTtcblxuICAgIC8vIFdlIGFyZSBhYm91dCB0byB0cmFuc2l0aW9uIHRvIGRpc2Nvbm5lY3RlZCwgc28gY2xlYXIgb3VyIHdlYiBzb2NrZXRcbiAgICB0aGlzLl93cyA9IHVuZGVmaW5lZDtcblxuICAgIC8vIFRoZSBgc3RhdGVgIE1VU1QgdHJhbnNpdGlvbiB0byBcIkRpc2Nvbm5lY3RlZFwiIGJlZm9yZSByZXNvbHZpbmcgKGFzc3VtaW5nIGBzdGF0ZWAgaXMgbm90IGFscmVhZHkgXCJEaXNjb25uZWN0ZWRcIikuXG4gICAgdGhpcy50cmFuc2l0aW9uU3RhdGUoVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGVkLCBlcnJvcik7XG4gIH1cblxuICAvKipcbiAgICogV2ViU29ja2V0IFwib25lcnJvclwiIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSBldiAtIEV2ZW50LlxuICAgKi9cbiAgcHJpdmF0ZSBvbldlYlNvY2tldEVycm9yKGV2OiBFdmVudCwgd3M6IFdlYlNvY2tldCk6IHZvaWQge1xuICAgIGlmICh3cyAhPT0gdGhpcy5fd3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJXZWJTb2NrZXQgZXJyb3Igb2NjdXJyZWQuXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlYlNvY2tldCBcIm9ubWVzc2FnZVwiIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSBldiAtIEV2ZW50LlxuICAgKi9cbiAgcHJpdmF0ZSBvbldlYlNvY2tldE1lc3NhZ2UoZXY6IE1lc3NhZ2VFdmVudCwgd3M6IFdlYlNvY2tldCk6IHZvaWQge1xuICAgIGlmICh3cyAhPT0gdGhpcy5fd3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhOiBhbnkgPSBldi5kYXRhO1xuICAgIGxldCBmaW5pc2hlZERhdGE6IHN0cmluZztcblxuICAgIC8vIENSTEYgS2VlcCBBbGl2ZSByZXNwb25zZSBmcm9tIHNlcnZlci4gQ2xlYXIgb3VyIGtlZXAgYWxpdmUgdGltZW91dC5cbiAgICBpZiAoL14oXFxyXFxuKSskLy50ZXN0KGRhdGEpKSB7XG4gICAgICB0aGlzLmNsZWFyS2VlcEFsaXZlVGltZW91dCgpO1xuICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJSZWNlaXZlZCBXZWJTb2NrZXQgbWVzc2FnZSB3aXRoIENSTEYgS2VlcCBBbGl2ZSByZXNwb25zZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJSZWNlaXZlZCBlbXB0eSBtZXNzYWdlLCBkaXNjYXJkaW5nLi4uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikgeyAvLyBXZWJTb2NrZXQgYmluYXJ5IG1lc3NhZ2UuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUT0RPOiBVSW50OEFycmF5IGlzIG5vdCBhbiBBcnJheTxudW1iZXI+LCBzbyB0aGlzIHNob3VsZCBiZSBmaXhlZC4gKEl0IHdhcyBwb3J0ZWQgYXMgaXMuKVxuICAgICAgICBmaW5pc2hlZERhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIChuZXcgVWludDhBcnJheShkYXRhKSBhcyB1bmtub3duIGFzIEFycmF5PG51bWJlcj4pKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiUmVjZWl2ZWQgV2ViU29ja2V0IGJpbmFyeSBtZXNzYWdlIGZhaWxlZCB0byBiZSBjb252ZXJ0ZWQgaW50byBzdHJpbmcsIG1lc3NhZ2UgZGlzY2FyZGVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlJlY2VpdmVkIFdlYlNvY2tldCBiaW5hcnkgbWVzc2FnZTpcXG5cXG5cIiArIGRhdGEgKyBcIlxcblwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBXZWJTb2NrZXQgdGV4dCBtZXNzYWdlLlxuICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJSZWNlaXZlZCBXZWJTb2NrZXQgdGV4dCBtZXNzYWdlOlxcblxcblwiICsgZGF0YSArIFwiXFxuXCIpO1xuICAgICAgfVxuICAgICAgZmluaXNoZWREYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gVHJhbnNwb3J0U3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiUmVjZWl2ZWQgbWVzc2FnZSB3aGlsZSBub3QgY29ubmVjdGVkLCBkaXNjYXJkaW5nLi4uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9uTWVzc2FnZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UoZmluaXNoZWREYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiRXhjZXB0aW9uIHRocm93biBieSBvbk1lc3NhZ2UgY2FsbGJhY2tcIik7XG4gICAgICAgIHRocm93IGU7IC8vIHJldGhyb3cgdW5oYW5kbGVkIGV4Y2VwdGlvblxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIGZpbmlzaGVkRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogV2ViU29ja2V0IFwib25vcGVuXCIgZXZlbnQgaGFuZGxlci5cbiAgICogQHBhcmFtIGV2IC0gRXZlbnQuXG4gICAqL1xuICBwcml2YXRlIG9uV2ViU29ja2V0T3BlbihldjogRXZlbnQsIHdzOiBXZWJTb2NrZXQpOiB2b2lkIHtcbiAgICBpZiAod3MgIT09IHRoaXMuX3dzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gVHJhbnNwb3J0U3RhdGUuQ29ubmVjdGluZykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKGBXZWJTb2NrZXQgb3BlbmVkICR7dGhpcy5zZXJ2ZXJ9YCk7XG4gICAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZShUcmFuc3BvcnRTdGF0ZS5Db25uZWN0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYW4gRXJyb3IuXG4gICAqIEBwYXJhbSBzdGF0ZSBTdGF0ZSB0cmFuc2l0aW9uaW5nIHRvLlxuICAgKi9cbiAgcHJpdmF0ZSB0cmFuc2l0aW9uTG9vcERldGVjdGVkRXJyb3Ioc3RhdGU6IHN0cmluZyk6IFN0YXRlVHJhbnNpdGlvbkVycm9yIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBBIHN0YXRlIHRyYW5zaXRpb24gbG9vcCBoYXMgYmVlbiBkZXRlY3RlZC5gO1xuICAgIG1lc3NhZ2UgKz0gYCBBbiBhdHRlbXB0IHRvIHRyYW5zaXRpb24gZnJvbSAke3RoaXMuX3N0YXRlfSB0byAke3N0YXRlfSBiZWZvcmUgdGhlIHByaW9yIHRyYW5zaXRpb24gY29tcGxldGVkLmA7XG4gICAgbWVzc2FnZSArPSBgIFBlcmhhcHMgeW91IGFyZSBzeW5jaHJvbm91c2x5IGNhbGxpbmcgY29ubmVjdCgpIG9yIGRpc2Nvbm5lY3QoKSBmcm9tIGEgY2FsbGJhY2sgb3Igc3RhdGUgY2hhbmdlIGhhbmRsZXI/YDtcbiAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gbmV3IFN0YXRlVHJhbnNpdGlvbkVycm9yKFwiTG9vcCBkZXRlY3RlZC5cIik7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNpdGlvbiB0cmFuc3BvcnQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSB0cmFuc2l0aW9uU3RhdGUobmV3U3RhdGU6IFRyYW5zcG9ydFN0YXRlLCBlcnJvcj86IEVycm9yKTogdm9pZCB7XG4gICAgY29uc3QgaW52YWxpZFRyYW5zaXRpb24gPSAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGUgdHJhbnNpdGlvbiBmcm9tICR7dGhpcy5fc3RhdGV9IHRvICR7bmV3U3RhdGV9YCk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmdTdGF0ZSkge1xuICAgICAgdGhyb3cgdGhpcy50cmFuc2l0aW9uTG9vcERldGVjdGVkRXJyb3IobmV3U3RhdGUpO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zaXRpb25pbmdTdGF0ZSA9IHRydWU7XG5cbiAgICAvLyBWYWxpZGF0ZSBzdGF0ZSB0cmFuc2l0aW9uXG4gICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgY2FzZSBUcmFuc3BvcnRTdGF0ZS5Db25uZWN0aW5nOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgbmV3U3RhdGUgIT09IFRyYW5zcG9ydFN0YXRlLkNvbm5lY3RlZCAmJlxuICAgICAgICAgIG5ld1N0YXRlICE9PSBUcmFuc3BvcnRTdGF0ZS5EaXNjb25uZWN0aW5nICYmXG4gICAgICAgICAgbmV3U3RhdGUgIT09IFRyYW5zcG9ydFN0YXRlLkRpc2Nvbm5lY3RlZFxuICAgICAgICApIHtcbiAgICAgICAgICBpbnZhbGlkVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc3BvcnRTdGF0ZS5Db25uZWN0ZWQ6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXdTdGF0ZSAhPT0gVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGluZyAmJlxuICAgICAgICAgIG5ld1N0YXRlICE9PSBUcmFuc3BvcnRTdGF0ZS5EaXNjb25uZWN0ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW52YWxpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGluZzpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5ld1N0YXRlICE9PSBUcmFuc3BvcnRTdGF0ZS5Db25uZWN0aW5nICYmXG4gICAgICAgICAgbmV3U3RhdGUgIT09IFRyYW5zcG9ydFN0YXRlLkRpc2Nvbm5lY3RlZFxuICAgICAgICApIHtcbiAgICAgICAgICBpbnZhbGlkVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc3BvcnRTdGF0ZS5EaXNjb25uZWN0ZWQ6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXdTdGF0ZSAhPT0gVHJhbnNwb3J0U3RhdGUuQ29ubmVjdGluZ1xuICAgICAgICApIHtcbiAgICAgICAgICBpbnZhbGlkVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdGF0ZS5cIik7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gICAgLy8gTG9jYWwgY29waWVzIG9mIGNvbm5lY3QgcHJvbWlzZXMgKGd1YXJkaW5nIGFnYWluc3QgY2FsbGJhY2tzIGNoYW5naW5nIHRoZW0gaW5kaXJlY3RseSlcbiAgICBjb25zdCBjb25uZWN0UHJvbWlzZSA9IHRoaXMuY29ubmVjdFByb21pc2U7XG4gICAgY29uc3QgY29ubmVjdFJlc29sdmUgPSB0aGlzLmNvbm5lY3RSZXNvbHZlO1xuICAgIGNvbnN0IGNvbm5lY3RSZWplY3QgPSB0aGlzLmNvbm5lY3RSZWplY3Q7XG5cbiAgICAvLyBSZXNldCBjb25uZWN0IHByb21pc2VzIGlmIG5vIGxvbmdlciBjb25uZWN0aW5nXG4gICAgaWYgKG9sZFN0YXRlID09PSBUcmFuc3BvcnRTdGF0ZS5Db25uZWN0aW5nKSB7XG4gICAgICB0aGlzLmNvbm5lY3RQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jb25uZWN0UmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY29ubmVjdFJlamVjdCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBMb2NhbCBjb3BpZXMgb2YgZGlzY29ubmVjdCBwcm9taXNlcyAoZ3VhcmRpbmcgYWdhaW5zdCBjYWxsYmFja3MgY2hhbmdpbmcgdGhlbSBpbmRpcmVjdGx5KVxuICAgIGNvbnN0IGRpc2Nvbm5lY3RQcm9taXNlID0gdGhpcy5kaXNjb25uZWN0UHJvbWlzZTtcbiAgICBjb25zdCBkaXNjb25uZWN0UmVzb2x2ZSA9IHRoaXMuZGlzY29ubmVjdFJlc29sdmU7XG4gICAgY29uc3QgZGlzY29ubmVjdFJlamVjdCA9IHRoaXMuZGlzY29ubmVjdFJlamVjdDtcblxuICAgIC8vIFJlc2V0IGRpc2Nvbm5lY3QgcHJvbWlzZXMgaWYgbm8gbG9uZ2VyIGRpc2Nvbm5lY3RpbmdcbiAgICBpZiAob2xkU3RhdGUgPT09IFRyYW5zcG9ydFN0YXRlLkRpc2Nvbm5lY3RpbmcpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RSZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kaXNjb25uZWN0UmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGFueSBvdXRzdGFuZGluZyBjb25uZWN0IHRpbWVvdXRcbiAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXQpO1xuICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coYFRyYW5zaXRpb25lZCBmcm9tICR7b2xkU3RhdGV9IHRvICR7dGhpcy5fc3RhdGV9YCk7XG4gICAgdGhpcy5fc3RhdGVFdmVudEVtaXR0ZXIuZW1pdChcImV2ZW50XCIsIHRoaXMuX3N0YXRlKTtcblxuICAgIC8vICBUcmFuc2l0aW9uIHRvIENvbm5lY3RlZFxuICAgIGlmIChuZXdTdGF0ZSA9PT0gVHJhbnNwb3J0U3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0U2VuZGluZ0tlZXBBbGl2ZXMoKTtcbiAgICAgIGlmICh0aGlzLm9uQ29ubmVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMub25Db25uZWN0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkV4Y2VwdGlvbiB0aHJvd24gYnkgb25Db25uZWN0IGNhbGxiYWNrXCIpO1xuICAgICAgICAgIHRocm93IGU7IC8vIHJldGhyb3cgdW5oYW5kbGVkIGV4Y2VwdGlvblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gIFRyYW5zaXRpb24gZnJvbSBDb25uZWN0ZWRcbiAgICBpZiAob2xkU3RhdGUgPT09IFRyYW5zcG9ydFN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgdGhpcy5zdG9wU2VuZGluZ0tlZXBBbGl2ZXMoKTtcbiAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiRXhjZXB0aW9uIHRocm93biBieSBvbkRpc2Nvbm5lY3QgY2FsbGJhY2tcIik7XG4gICAgICAgICAgdGhyb3cgZTsgLy8gcmV0aHJvdyB1bmhhbmRsZWQgZXhjZXB0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgdHJhbnNwb3J0IGJlaGF2aW9yIChvciBhdCBsZWFzdCB3aGF0IEkgYmVsaWV2ZSB0aGUgbGVnYWN5IHRyYW5zcG9ydCB3YXMgc2hvb3RpbmcgZm9yKVxuICAgIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICAgIGNhc2UgVHJhbnNwb3J0U3RhdGUuQ29ubmVjdGluZzpcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGluZ1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zcG9ydFN0YXRlLkNvbm5lY3RlZDpcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGVkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGluZzpcbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdGluZ1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zcG9ydFN0YXRlLkRpc2Nvbm5lY3RlZDpcbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdGVkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc3RhdGUuXCIpO1xuICAgIH1cblxuICAgIC8vIENvbXBsZXRlIGNvbm5lY3QgcHJvbWlzZVxuICAgIGlmIChvbGRTdGF0ZSA9PT0gVHJhbnNwb3J0U3RhdGUuQ29ubmVjdGluZykge1xuICAgICAgaWYgKCFjb25uZWN0UmVzb2x2ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25uZWN0IHJlc29sdmUgdW5kZWZpbmVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghY29ubmVjdFJlamVjdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25uZWN0IHJlamVjdCB1bmRlZmluZWQuXCIpO1xuICAgICAgfVxuICAgICAgbmV3U3RhdGUgPT09IFRyYW5zcG9ydFN0YXRlLkNvbm5lY3RlZCA/IGNvbm5lY3RSZXNvbHZlKCkgOiBjb25uZWN0UmVqZWN0KGVycm9yIHx8IG5ldyBFcnJvcihcIkNvbm5lY3QgYWJvcnRlZC5cIikpO1xuICAgIH1cblxuICAgIC8vIENvbXBsZXRlIGRpc2Nvbm5lY3QgcHJvbWlzZVxuICAgIGlmIChvbGRTdGF0ZSA9PT0gVHJhbnNwb3J0U3RhdGUuRGlzY29ubmVjdGluZykge1xuICAgICAgaWYgKCFkaXNjb25uZWN0UmVzb2x2ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNjb25uZWN0IHJlc29sdmUgdW5kZWZpbmVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlzY29ubmVjdFJlamVjdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNjb25uZWN0IHJlamVjdCB1bmRlZmluZWQuXCIpO1xuICAgICAgfVxuICAgICAgbmV3U3RhdGUgPT09IFRyYW5zcG9ydFN0YXRlLkRpc2Nvbm5lY3RlZCA/IGRpc2Nvbm5lY3RSZXNvbHZlKCkgOiBkaXNjb25uZWN0UmVqZWN0KGVycm9yIHx8IG5ldyBFcnJvcihcIkRpc2Nvbm5lY3QgYWJvcnRlZC5cIikpO1xuICAgIH1cblxuICAgIHRoaXMudHJhbnNpdGlvbmluZ1N0YXRlID0gZmFsc2U7XG4gIH1cblxuICAvLyBUT0RPOiBSZXZpZXcgXCJLZWVwQWxpdmUgU3R1ZmZcIi5cbiAgLy8gSXQgaXMgbm90IGNsZWFyIGlmIGl0IHdvcmtzIGFuZCB0aGVyZSBhcmUgbm8gdGVzdHMgZm9yIGl0LlxuICAvLyBJdCB3YXMgYmxpbmRseSBsaWZ0ZWQgdGhlIGtlZXAgYWxpdmUgY29kZSB1bmNoYW5nZWQgZnJvbSBlYXJsaWVyIHRyYW5zcG9ydCBjb2RlLlxuICAvL1xuICAvLyBGcm9tIHRoZSBSRkMuLi5cbiAgLy9cbiAgLy8gU0lQIFdlYlNvY2tldCBDbGllbnRzIGFuZCBTZXJ2ZXJzIG1heSBrZWVwIHRoZWlyIFdlYlNvY2tldFxuICAvLyBjb25uZWN0aW9ucyBvcGVuIGJ5IHNlbmRpbmcgcGVyaW9kaWMgV2ViU29ja2V0IFwiUGluZ1wiIGZyYW1lcyBhc1xuICAvLyBkZXNjcmliZWQgaW4gW1JGQzY0NTVdLCBTZWN0aW9uIDUuNS4yLlxuICAvLyAuLi5cbiAgLy8gVGhlIGluZGljYXRpb24gYW5kIHVzZSBvZiB0aGUgQ1JMRiBOQVQga2VlcC1hbGl2ZSBtZWNoYW5pc20gZGVmaW5lZFxuICAvLyBmb3IgU0lQIGNvbm5lY3Rpb24tb3JpZW50ZWQgdHJhbnNwb3J0cyBpbiBbUkZDNTYyNl0sIFNlY3Rpb24gMy41LjEgb3JcbiAgLy8gW1JGQzYyMjNdIGFyZSwgb2YgY291cnNlLCB1c2FibGUgb3ZlciB0aGUgdHJhbnNwb3J0IGRlZmluZWQgaW4gdGhpc1xuICAvLyBzcGVjaWZpY2F0aW9uLlxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzExOCNzZWN0aW9uLTZcbiAgLy9cbiAgLy8gYW5kLi4uXG4gIC8vXG4gIC8vIFRoZSBQaW5nIGZyYW1lIGNvbnRhaW5zIGFuIG9wY29kZSBvZiAweDkuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNS41LjJcbiAgLy9cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEtlZXBBbGl2ZSBTdHVmZlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBwcml2YXRlIGNsZWFyS2VlcEFsaXZlVGltZW91dCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5rZWVwQWxpdmVEZWJvdW5jZVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBBbGl2ZURlYm91bmNlVGltZW91dCk7XG4gICAgfVxuICAgIHRoaXMua2VlcEFsaXZlRGVib3VuY2VUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBrZWVwLWFsaXZlIChhIGRvdWJsZS1DUkxGIHNlcXVlbmNlKS5cbiAgICovXG4gIHByaXZhdGUgc2VuZEtlZXBBbGl2ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5rZWVwQWxpdmVEZWJvdW5jZVRpbWVvdXQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBvdXRzdGFuZGluZyBrZWVwIGFsaXZlLCBkbyBub3Qgc2VuZCBhbm90aGVyLlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHRoaXMua2VlcEFsaXZlRGVib3VuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmNsZWFyS2VlcEFsaXZlVGltZW91dCgpO1xuICAgIH0sIHRoaXMuY29uZmlndXJhdGlvbi5rZWVwQWxpdmVEZWJvdW5jZSAqIDEwMDApO1xuXG4gICAgcmV0dXJuIHRoaXMuc2VuZChcIlxcclxcblxcclxcblwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBzZW5kaW5nIGtlZXAtYWxpdmVzLlxuICAgKi9cbiAgcHJpdmF0ZSBzdGFydFNlbmRpbmdLZWVwQWxpdmVzKCk6IHZvaWQge1xuICAgIC8vIENvbXB1dGUgYW4gYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBzZW5kaW5nIGFub3RoZXIga2VlcC1hbGl2ZS5cbiAgICBjb25zdCBjb21wdXRlS2VlcEFsaXZlVGltZW91dCA9ICh1cHBlckJvdW5kOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IHVwcGVyQm91bmQgKiAwLjg7XG4gICAgICByZXR1cm4gMTAwMCAqIChNYXRoLnJhbmRvbSgpICogKHVwcGVyQm91bmQgLSBsb3dlckJvdW5kKSArIGxvd2VyQm91bmQpO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmtlZXBBbGl2ZUludGVydmFsICYmICF0aGlzLmtlZXBBbGl2ZUludGVydmFsKSB7XG4gICAgICB0aGlzLmtlZXBBbGl2ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICB0aGlzLnNlbmRLZWVwQWxpdmUoKTtcbiAgICAgICAgdGhpcy5zdGFydFNlbmRpbmdLZWVwQWxpdmVzKCk7XG4gICAgICB9LCBjb21wdXRlS2VlcEFsaXZlVGltZW91dCh0aGlzLmNvbmZpZ3VyYXRpb24ua2VlcEFsaXZlSW50ZXJ2YWwpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBzZW5kaW5nIGtlZXAtYWxpdmVzLlxuICAgKi9cbiAgcHJpdmF0ZSBzdG9wU2VuZGluZ0tlZXBBbGl2ZXMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwQWxpdmVJbnRlcnZhbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmtlZXBBbGl2ZURlYm91bmNlVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcEFsaXZlRGVib3VuY2VUaW1lb3V0KTtcbiAgICB9XG4gICAgdGhpcy5rZWVwQWxpdmVJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtlZXBBbGl2ZURlYm91bmNlVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IExJQlJBUllfVkVSU0lPTiA9IFwiMC4xNS4xMFwiO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==